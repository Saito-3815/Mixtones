var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys2 = Object.keys(expected);
      for (const key of keys2) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName))
        return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace)
        return {
          internal: false,
          trace: ""
        };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression2;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral2;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration2;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement2;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration;
    exports.isFunctionExpression = isFunctionExpression;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier2;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportExpression = isImportExpression;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement2;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer2;
    exports.isJSXFragment = isJSXFragment2;
    exports.isJSXIdentifier = isJSXIdentifier2;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern;
    exports.isObjectProperty = isObjectProperty;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral2;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration;
    exports.isVariableDeclarator = isVariableDeclarator;
    exports.isVariance = isVariance;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isAssignmentExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AssignmentExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBinaryExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BinaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isInterpreterDirective(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterpreterDirective")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDirective(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Directive")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDirectiveLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DirectiveLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBlockStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BlockStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBreakStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BreakStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isCallExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "CallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isCatchClause(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "CatchClause")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isConditionalExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ConditionalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isContinueStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ContinueStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDebuggerStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DebuggerStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDoWhileStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DoWhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEmptyStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EmptyStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExpressionStatement2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExpressionStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFile(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "File")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isForInStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForInStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isForStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunctionDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunctionExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isIdentifier2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Identifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isIfStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isLabeledStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "LabeledStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStringLiteral2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNumericLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumericLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNullLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBooleanLiteral2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isRegExpLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RegExpLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isLogicalExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "LogicalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNewExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NewExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isProgram(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Program")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isRestElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RestElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isReturnStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ReturnStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSequenceExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SequenceExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isParenthesizedExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ParenthesizedExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSwitchCase(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SwitchCase")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSwitchStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SwitchStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isThisExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThisExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isThrowStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThrowStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTryStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TryStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isUnaryExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UnaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isUpdateExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UpdateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isVariableDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VariableDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isVariableDeclarator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VariableDeclarator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isWhileStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "WhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isWithStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "WithStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isAssignmentPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AssignmentPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isArrayPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isArrowFunctionExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrowFunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportAllDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportDefaultDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportDefaultDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportNamedDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportNamedDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isForOfStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForOfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportDefaultSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportNamespaceSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isMetaProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MetaProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSpreadElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SpreadElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSuper(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Super")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTaggedTemplateExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TaggedTemplateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTemplateElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TemplateElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTemplateLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TemplateLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isYieldExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "YieldExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isAwaitExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AwaitExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImport(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Import")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBigIntLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BigIntLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportNamespaceSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isOptionalMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isOptionalCallExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalCallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassAccessorProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassAccessorProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassPrivateProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassPrivateProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassPrivateMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassPrivateMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPrivateName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PrivateName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStaticBlock(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StaticBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isAnyTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AnyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isArrayTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBooleanTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBooleanLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNullLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClassImplements(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassImplements")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareClass(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareClass")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareInterface(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareInterface")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareModule(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareModule")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareModuleExports(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareModuleExports")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareTypeAlias(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareTypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareOpaqueType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareOpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareVariable(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareVariable")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclareExportAllDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclaredPredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclaredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExistsTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExistsTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunctionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunctionTypeParam(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionTypeParam")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isGenericTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "GenericTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isInferredPredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InferredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isInterfaceExtends(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceExtends")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isInterfaceDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isInterfaceTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isIntersectionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IntersectionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isMixedTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MixedTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEmptyTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EmptyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNullableTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullableTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNumberLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumberLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNumberTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumberTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeInternalSlot(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeInternalSlot")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeCallProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeCallProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeIndexer(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeIndexer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectTypeSpreadProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeSpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isOpaqueType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isQualifiedTypeIdentifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "QualifiedTypeIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStringLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStringTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSymbolTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SymbolTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isThisTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThisTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTupleTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TupleTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeofTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeofTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeAlias(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeCastExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeCastExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeParameter(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeParameterDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeParameterInstantiation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isUnionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UnionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isVariance(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Variance")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isVoidTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VoidTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumBooleanBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumBooleanBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumNumberBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumNumberBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumStringBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumStringBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumSymbolBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumSymbolBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumBooleanMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumBooleanMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumNumberMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumNumberMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumStringMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumStringMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumDefaultedMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumDefaultedMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isOptionalIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXClosingElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXClosingElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXElement2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXEmptyExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXEmptyExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXExpressionContainer2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXExpressionContainer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXSpreadChild(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXSpreadChild")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXIdentifier2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXNamespacedName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXNamespacedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXOpeningElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXOpeningElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXSpreadAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXSpreadAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXText(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXText")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXFragment2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXOpeningFragment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXOpeningFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSXClosingFragment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXClosingFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNoop(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Noop")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPlaceholder(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Placeholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isV8IntrinsicIdentifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "V8IntrinsicIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isArgumentPlaceholder(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArgumentPlaceholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBindExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BindExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDecorator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Decorator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDoExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DoExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportDefaultSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isRecordExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RecordExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTupleExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TupleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDecimalLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DecimalLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isModuleExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ModuleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTopicReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPipelineTopicExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelineTopicExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPipelineBareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelineBareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPipelinePrimaryTopicReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelinePrimaryTopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSParameterProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSParameterProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSDeclareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSDeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSDeclareMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSDeclareMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSQualifiedName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSQualifiedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSCallSignatureDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSCallSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSConstructSignatureDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConstructSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSPropertySignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSPropertySignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSMethodSignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSMethodSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSIndexSignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIndexSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSAnyKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSAnyKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSBooleanKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSBooleanKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSBigIntKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSBigIntKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSIntrinsicKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIntrinsicKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNeverKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNeverKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNullKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNullKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNumberKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNumberKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSObjectKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSObjectKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSStringKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSStringKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSSymbolKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSSymbolKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSUndefinedKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUndefinedKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSUnknownKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUnknownKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSVoidKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSVoidKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSThisType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSThisType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSFunctionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSFunctionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSConstructorType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConstructorType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypePredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypePredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeQuery(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeQuery")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSArrayType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSArrayType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTupleType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTupleType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSOptionalType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSOptionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSRestType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSRestType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNamedTupleMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNamedTupleMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSUnionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUnionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSIntersectionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIntersectionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSConditionalType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConditionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSInferType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInferType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSParenthesizedType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSParenthesizedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeOperator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeOperator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSMappedType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSMappedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSLiteralType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSLiteralType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSExpressionWithTypeArguments(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExpressionWithTypeArguments")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSInterfaceDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSInterfaceBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInterfaceBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeAliasDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAliasDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSInstantiationExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInstantiationExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSAsExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSAsExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSSatisfiesExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSSatisfiesExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeAssertion(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAssertion")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSEnumDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSEnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSEnumMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSEnumMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSModuleDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSModuleDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSModuleBlock(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSModuleBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSImportType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSImportType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSImportEqualsDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSImportEqualsDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSExternalModuleReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExternalModuleReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNonNullExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNonNullExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSExportAssignment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExportAssignment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSNamespaceExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNamespaceExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeParameterInstantiation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeParameterDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeParameter(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStandardized(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExpression(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBinary(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isScopable(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBlockParent(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isBlock(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTerminatorless(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isCompletionStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isConditional(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isLoop(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isWhile(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExpressionWrapper(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFor(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isForXStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunction(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFunctionParent(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPureish(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node2.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isDeclaration2(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Declaration")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPatternLike(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isLVal(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSEntityName(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Identifier")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isLiteral(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node2.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImmutable(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node2.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isUserWhitespacable(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isMethod(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isObjectMember(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isProperty(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isUnaryLike(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPattern(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Pattern")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isClass(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isImportOrExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isModuleSpecifier(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isAccessor(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isPrivate(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFlow(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFlowType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFlowBaseAnnotation(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFlowDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isFlowPredicate(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumBody(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isEnumMember(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isJSX(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isMiscellaneous(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTypeScript(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSTypeElement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isTSBaseType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isNumberLiteral(node2, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node2)
        return false;
      if (node2.type !== "NumberLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isRegexLiteral(node2, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node2)
        return false;
      if (node2.type !== "RegexLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isRestProperty(node2, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node2)
        return false;
      if (node2.type !== "RestProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isSpreadProperty(node2, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node2)
        return false;
      if (node2.type !== "SpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node2, opts);
    }
    function isModuleDeclaration(node2, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node2, opts);
    }
  }
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matchesPattern;
    var _index = require_generated();
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _index.isMemberExpression)(member))
        return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node2;
      for (node2 = member; (0, _index.isMemberExpression)(node2); node2 = node2.object) {
        nodes.push(node2.property);
      }
      nodes.push(node2);
      if (nodes.length < parts.length)
        return false;
      if (!allowPartial && nodes.length > parts.length)
        return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node3 = nodes[j];
        let value;
        if ((0, _index.isIdentifier)(node3)) {
          value = node3.name;
        } else if ((0, _index.isStringLiteral)(node3)) {
          value = node3.value;
        } else if ((0, _index.isThisExpression)(node3)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i] !== value)
          return false;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = exports.default = isReactComponent;
  }
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "node_modules/to-fast-properties/index.js"(exports, module2) {
    "use strict";
    var fastProto = null;
    function FastObject(o) {
      if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }
      fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o;
      return new FastObject();
    }
    FastObject();
    module2.exports = function toFastproperties(o) {
      return FastObject(o);
    };
  }
});

// node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isType;
    var _index = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (nodeType == null)
        return false;
      if (_index.ALIAS_KEYS[targetType])
        return false;
      const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (const alias of aliases) {
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = is2;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _index = require_definitions();
    function is2(type, node2, opts) {
      if (!node2)
        return false;
      const matches = (0, _isType.default)(node2.type, type);
      if (!matches) {
        if (!opts && node2.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node2.expectedNode, type);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node2, opts);
      }
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar2;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart2;
    var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
    var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
    nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
    var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet2(code2, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code2)
          return false;
        pos += set[i + 1];
        if (pos >= code2)
          return true;
      }
      return false;
    }
    function isIdentifierStart2(code2) {
      if (code2 < 65)
        return code2 === 36;
      if (code2 <= 90)
        return true;
      if (code2 < 97)
        return code2 === 95;
      if (code2 <= 122)
        return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code2));
      }
      return isInAstralSet2(code2, astralIdentifierStartCodes2);
    }
    function isIdentifierChar2(code2) {
      if (code2 < 48)
        return code2 === 36;
      if (code2 < 58)
        return true;
      if (code2 < 65)
        return false;
      if (code2 <= 90)
        return true;
      if (code2 < 97)
        return code2 === 95;
      if (code2 <= 122)
        return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code2));
      }
      return isInAstralSet2(code2, astralIdentifierStartCodes2) || isInAstralSet2(code2, astralIdentifierCodes2);
    }
    function isIdentifierName(name2) {
      let isFirst = true;
      for (let i = 0; i < name2.length; i++) {
        let cp = name2.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name2.length) {
          const trail = name2.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart2(cp)) {
            return false;
          }
        } else if (!isIdentifierChar2(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords2 = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords2.keyword);
    var reservedWordsStrictSet = new Set(reservedWords2.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords2.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib();
    function isValidIdentifier(name2, reserved = true) {
      if (typeof name2 !== "string")
        return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name2) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name2, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name2);
    }
  }
});

// node_modules/@babel/helper-string-parser/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start2 = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid2 = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid2 = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start2 || len != null && pos - start2 !== len || invalid2) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
  }
});

// node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
    var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    var INHERIT_KEYS = exports.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.typeIs = typeIs;
    exports.validate = validate;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = exports.VISITOR_KEYS = {};
    var ALIAS_KEYS = exports.ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = exports.NODE_FIELDS = {};
    var BUILDER_KEYS = exports.BUILDER_KEYS = {};
    var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    }
    function validateType(typeName) {
      return validate(typeIs(typeName));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node2, key, val) {
        if (!Array.isArray(val))
          return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node2, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING)
            (0, _validate.validateChild)(node2, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node2, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    function assertNodeType(...types2) {
      function validate2(node2, key, val) {
        for (const type of types2) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node2, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types2;
      return validate2;
    }
    function assertNodeOrValueType(...types2) {
      function validate2(node2, key, val) {
        for (const type of types2) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node2, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types2;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node2, key, val) {
        const valid2 = getType(val) === type;
        if (!valid2) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node2, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node2, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node2.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node2) {
        var _current;
        let current2 = node2;
        while (node2) {
          const {
            type
          } = current2;
          if (type === "OptionalCallExpression") {
            if (current2.optional)
              return;
            current2 = current2.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current2.optional)
              return;
            current2 = current2.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node2.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current2) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "deprecated", "validate"];
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits)
            defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined) != null ? _defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys2 = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys2) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (validFieldKeys.indexOf(k) === -1) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
  }
});

// node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    var _helperStringParser = require_lib2();
    var _index = require_constants();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)("string");
            }
            const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node2, key, val) {
              const validator = (0, _is.default)("Pattern", node2.left) ? pattern : identifier;
              validator(node2, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node2, key, val) {
              const validator2 = node2.operator === "in" ? inOp : expression;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
      },
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return () => {
          };
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node2) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node2, "id", node2.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          }))
        }
      }),
      validate(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /\.(\w+)$/.exec(key);
        if (!match)
          return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp))
            return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
            return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp))
            return;
          if ((0, _is.default)("Method", parent, nonComp))
            return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent))
            return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node2
          }))
            return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node2
          }))
            return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node2.name) || (0, _helperValidatorIdentifier.isReservedWord)(node2.name, false)) && node2.name !== "this") {
          throw new TypeError(`"${node2.name}" is not a valid identifier`);
        }
      }
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node2, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
              {
              }
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const invalid2 = /[^gimsuy]/.exec(val);
            if (invalid2) {
              throw new TypeError(`"${invalid2[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node2, key, val) {
              const validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node2, key, val) {
              const validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node2, key, val) {
              const validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !(0, _is.default)("Identifier", node2.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node2) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node2, "value", node2.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match)
          throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index2] = match;
        if (parent[listKey].length > +index2 + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node2) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node2.handler && !node2.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          }))
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
      },
      validate(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ForXStatement", parent, {
          left: node2
        }))
          return;
        if (node2.declarations.length !== 1) {
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      }
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("LVal");
            }
            const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
            const without = (0, _utils.assertNodeType)("Identifier");
            return function(node2, key, val) {
              const validator = node2.init ? normal : without;
              validator(node2, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node2) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node2, "id", node2.id);
          }
        };
      }()
    });
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
      }
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          }), function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node2, key, val) {
              const validator = node2.source ? sourced : sourceless;
              validator(node2, key, val);
            };
          }()))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return function(node2, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node2, key, val);
              } else {
                lval(node2, key, val);
              }
            };
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: {
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node2.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          }))
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node2, key, val) {
            const validator = node2.computed ? computed : normal;
            validator(node2, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node2) {
            const raw = node2.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled)
              throw new Error("Invalid raw");
            node2.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node2, key, val) {
            if (node2.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node2.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node2, key, val) {
              const validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node2, key, val) {
              const validator = node2.computed ? computed : normal;
              validator(node2, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name2) => {
      const isDeclareClass = name2 === "DeclareClass";
      defineType(name2, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils();
    var PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length)
        PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils();
    var _core = require_core();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation", "nameType"],
      fields: {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal2 = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node2) {
              if ((0, _is.default)("UnaryExpression", node2)) {
                unaryOperator(node2, "operator", node2.operator);
                unaryExpression(node2, "argument", node2.argument);
              } else {
                literal2(parent, key, node2);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
  }
});

// node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    var _toFastProperties = require_to_fast_properties();
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  }
});

// node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validate;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    var _index = require_definitions();
    function validate(node2, key, val) {
      if (!node2)
        return;
      const fields = _index.NODE_FIELDS[node2.type];
      if (!fields)
        return;
      const field = fields[key];
      validateField(node2, key, val, field);
      validateChild(node2, key, val);
    }
    function validateField(node2, key, val, field) {
      if (!(field != null && field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node2, key, val);
    }
    function validateChild(node2, key, val) {
      if (val == null)
        return;
      const validate2 = _index.NODE_PARENT_VALIDATIONS[val.type];
      if (!validate2)
        return;
      validate2(node2, key, val);
    }
  }
});

// node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS({
  "node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validateNode;
    var _validate = require_validate();
    var _index = require_lib3();
    function validateNode(node2) {
      const keys2 = _index.BUILDER_KEYS[node2.type];
      for (const key of keys2) {
        (0, _validate.default)(node2, key, node2[key]);
      }
      return node2;
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importExpression = importExpression;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute2;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement2;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment2;
    exports.jSXElement = exports.jsxElement = jsxElement2;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression2;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer2;
    exports.jSXFragment = exports.jsxFragment = jsxFragment2;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier2;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression2;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName2;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement2;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment2;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute2;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText3;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validateNode = require_validateNode();
    var _deprecationWarning = require_deprecationWarning();
    function arrayExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "ArrayExpression",
        elements
      });
    }
    function assignmentExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentExpression",
        operator,
        left,
        right
      });
    }
    function binaryExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "BinaryExpression",
        operator,
        left,
        right
      });
    }
    function interpreterDirective(value) {
      return (0, _validateNode.default)({
        type: "InterpreterDirective",
        value
      });
    }
    function directive(value) {
      return (0, _validateNode.default)({
        type: "Directive",
        value
      });
    }
    function directiveLiteral(value) {
      return (0, _validateNode.default)({
        type: "DirectiveLiteral",
        value
      });
    }
    function blockStatement(body, directives = []) {
      return (0, _validateNode.default)({
        type: "BlockStatement",
        body,
        directives
      });
    }
    function breakStatement(label = null) {
      return (0, _validateNode.default)({
        type: "BreakStatement",
        label
      });
    }
    function callExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "CallExpression",
        callee,
        arguments: _arguments
      });
    }
    function catchClause(param = null, body) {
      return (0, _validateNode.default)({
        type: "CatchClause",
        param,
        body
      });
    }
    function conditionalExpression(test, consequent, alternate) {
      return (0, _validateNode.default)({
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      });
    }
    function continueStatement(label = null) {
      return (0, _validateNode.default)({
        type: "ContinueStatement",
        label
      });
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "DoWhileStatement",
        test,
        body
      });
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      return (0, _validateNode.default)({
        type: "ExpressionStatement",
        expression
      });
    }
    function file(program2, comments = null, tokens = null) {
      return (0, _validateNode.default)({
        type: "File",
        program: program2,
        comments,
        tokens
      });
    }
    function forInStatement(left, right, body) {
      return (0, _validateNode.default)({
        type: "ForInStatement",
        left,
        right,
        body
      });
    }
    function forStatement(init = null, test = null, update = null, body) {
      return (0, _validateNode.default)({
        type: "ForStatement",
        init,
        test,
        update,
        body
      });
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function identifier(name2) {
      return (0, _validateNode.default)({
        type: "Identifier",
        name: name2
      });
    }
    function ifStatement(test, consequent, alternate = null) {
      return (0, _validateNode.default)({
        type: "IfStatement",
        test,
        consequent,
        alternate
      });
    }
    function labeledStatement(label, body) {
      return (0, _validateNode.default)({
        type: "LabeledStatement",
        label,
        body
      });
    }
    function stringLiteral(value) {
      return (0, _validateNode.default)({
        type: "StringLiteral",
        value
      });
    }
    function numericLiteral(value) {
      return (0, _validateNode.default)({
        type: "NumericLiteral",
        value
      });
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteral",
        value
      });
    }
    function regExpLiteral(pattern, flags = "") {
      return (0, _validateNode.default)({
        type: "RegExpLiteral",
        pattern,
        flags
      });
    }
    function logicalExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "LogicalExpression",
        operator,
        left,
        right
      });
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return (0, _validateNode.default)({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function newExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "NewExpression",
        callee,
        arguments: _arguments
      });
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      return (0, _validateNode.default)({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
      });
    }
    function objectExpression(properties) {
      return (0, _validateNode.default)({
        type: "ObjectExpression",
        properties
      });
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      });
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      return (0, _validateNode.default)({
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      });
    }
    function restElement(argument) {
      return (0, _validateNode.default)({
        type: "RestElement",
        argument
      });
    }
    function returnStatement(argument = null) {
      return (0, _validateNode.default)({
        type: "ReturnStatement",
        argument
      });
    }
    function sequenceExpression(expressions) {
      return (0, _validateNode.default)({
        type: "SequenceExpression",
        expressions
      });
    }
    function parenthesizedExpression(expression) {
      return (0, _validateNode.default)({
        type: "ParenthesizedExpression",
        expression
      });
    }
    function switchCase(test = null, consequent) {
      return (0, _validateNode.default)({
        type: "SwitchCase",
        test,
        consequent
      });
    }
    function switchStatement(discriminant, cases) {
      return (0, _validateNode.default)({
        type: "SwitchStatement",
        discriminant,
        cases
      });
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      return (0, _validateNode.default)({
        type: "ThrowStatement",
        argument
      });
    }
    function tryStatement(block, handler = null, finalizer = null) {
      return (0, _validateNode.default)({
        type: "TryStatement",
        block,
        handler,
        finalizer
      });
    }
    function unaryExpression(operator, argument, prefix = true) {
      return (0, _validateNode.default)({
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      });
    }
    function updateExpression(operator, argument, prefix = false) {
      return (0, _validateNode.default)({
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      });
    }
    function variableDeclaration(kind, declarations) {
      return (0, _validateNode.default)({
        type: "VariableDeclaration",
        kind,
        declarations
      });
    }
    function variableDeclarator(id, init = null) {
      return (0, _validateNode.default)({
        type: "VariableDeclarator",
        id,
        init
      });
    }
    function whileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "WhileStatement",
        test,
        body
      });
    }
    function withStatement(object, body) {
      return (0, _validateNode.default)({
        type: "WithStatement",
        object,
        body
      });
    }
    function assignmentPattern(left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentPattern",
        left,
        right
      });
    }
    function arrayPattern(elements) {
      return (0, _validateNode.default)({
        type: "ArrayPattern",
        elements
      });
    }
    function arrowFunctionExpression(params, body, async = false) {
      return (0, _validateNode.default)({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      });
    }
    function classBody(body) {
      return (0, _validateNode.default)({
        type: "ClassBody",
        body
      });
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      });
    }
    function classDeclaration(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      });
    }
    function exportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "ExportAllDeclaration",
        source
      });
    }
    function exportDefaultDeclaration(declaration) {
      return (0, _validateNode.default)({
        type: "ExportDefaultDeclaration",
        declaration
      });
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      return (0, _validateNode.default)({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function exportSpecifier(local, exported) {
      return (0, _validateNode.default)({
        type: "ExportSpecifier",
        local,
        exported
      });
    }
    function forOfStatement(left, right, body, _await = false) {
      return (0, _validateNode.default)({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      });
    }
    function importDeclaration(specifiers, source) {
      return (0, _validateNode.default)({
        type: "ImportDeclaration",
        specifiers,
        source
      });
    }
    function importDefaultSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportDefaultSpecifier",
        local
      });
    }
    function importNamespaceSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportNamespaceSpecifier",
        local
      });
    }
    function importSpecifier(local, imported) {
      return (0, _validateNode.default)({
        type: "ImportSpecifier",
        local,
        imported
      });
    }
    function importExpression(source, options = null) {
      return (0, _validateNode.default)({
        type: "ImportExpression",
        source,
        options
      });
    }
    function metaProperty(meta, property) {
      return (0, _validateNode.default)({
        type: "MetaProperty",
        meta,
        property
      });
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      });
    }
    function objectPattern(properties) {
      return (0, _validateNode.default)({
        type: "ObjectPattern",
        properties
      });
    }
    function spreadElement(argument) {
      return (0, _validateNode.default)({
        type: "SpreadElement",
        argument
      });
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      return (0, _validateNode.default)({
        type: "TaggedTemplateExpression",
        tag,
        quasi
      });
    }
    function templateElement(value, tail = false) {
      return (0, _validateNode.default)({
        type: "TemplateElement",
        value,
        tail
      });
    }
    function templateLiteral(quasis, expressions) {
      return (0, _validateNode.default)({
        type: "TemplateLiteral",
        quasis,
        expressions
      });
    }
    function yieldExpression(argument = null, delegate = false) {
      return (0, _validateNode.default)({
        type: "YieldExpression",
        argument,
        delegate
      });
    }
    function awaitExpression(argument) {
      return (0, _validateNode.default)({
        type: "AwaitExpression",
        argument
      });
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value) {
      return (0, _validateNode.default)({
        type: "BigIntLiteral",
        value
      });
    }
    function exportNamespaceSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportNamespaceSpecifier",
        exported
      });
    }
    function optionalMemberExpression(object, property, computed = false, optional) {
      return (0, _validateNode.default)({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _validateNode.default)({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      });
    }
    function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classPrivateProperty(key, value = null, decorators = null, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
      });
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      });
    }
    function privateName(id) {
      return (0, _validateNode.default)({
        type: "PrivateName",
        id
      });
    }
    function staticBlock(body) {
      return (0, _validateNode.default)({
        type: "StaticBlock",
        body
      });
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      return (0, _validateNode.default)({
        type: "ArrayTypeAnnotation",
        elementType
      });
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteralTypeAnnotation",
        value
      });
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "ClassImplements",
        id,
        typeParameters
      });
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareFunction(id) {
      return (0, _validateNode.default)({
        type: "DeclareFunction",
        id
      });
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareModule(id, body, kind = null) {
      return (0, _validateNode.default)({
        type: "DeclareModule",
        id,
        body,
        kind
      });
    }
    function declareModuleExports(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      });
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      return (0, _validateNode.default)({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      });
    }
    function declareVariable(id) {
      return (0, _validateNode.default)({
        type: "DeclareVariable",
        id
      });
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
      return (0, _validateNode.default)({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function declareExportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "DeclareExportAllDeclaration",
        source
      });
    }
    function declaredPredicate(value) {
      return (0, _validateNode.default)({
        type: "DeclaredPredicate",
        value
      });
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      return (0, _validateNode.default)({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      });
    }
    function functionTypeParam(name2 = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "FunctionTypeParam",
        name: name2,
        typeAnnotation: typeAnnotation2
      });
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      });
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "InterfaceExtends",
        id,
        typeParameters
      });
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      });
    }
    function intersectionTypeAnnotation(types2) {
      return (0, _validateNode.default)({
        type: "IntersectionTypeAnnotation",
        types: types2
      });
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function numberLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "NumberLiteralTypeAnnotation",
        value
      });
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      return (0, _validateNode.default)({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      });
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      return (0, _validateNode.default)({
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
      });
    }
    function objectTypeCallProperty(value) {
      return (0, _validateNode.default)({
        type: "ObjectTypeCallProperty",
        value,
        static: null
      });
    }
    function objectTypeIndexer(id = null, key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance: variance2,
        static: null
      });
    }
    function objectTypeProperty(key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeProperty",
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      });
    }
    function objectTypeSpreadProperty(argument) {
      return (0, _validateNode.default)({
        type: "ObjectTypeSpreadProperty",
        argument
      });
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      return (0, _validateNode.default)({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      });
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _validateNode.default)({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      });
    }
    function stringLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "StringLiteralTypeAnnotation",
        value
      });
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types2) {
      return (0, _validateNode.default)({
        type: "TupleTypeAnnotation",
        types: types2
      });
    }
    function typeofTypeAnnotation(argument) {
      return (0, _validateNode.default)({
        type: "TypeofTypeAnnotation",
        argument
      });
    }
    function typeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "TypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function typeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function typeCastExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      return (0, _validateNode.default)({
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      });
    }
    function typeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterDeclaration",
        params
      });
    }
    function typeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterInstantiation",
        params
      });
    }
    function unionTypeAnnotation(types2) {
      return (0, _validateNode.default)({
        type: "UnionTypeAnnotation",
        types: types2
      });
    }
    function variance(kind) {
      return (0, _validateNode.default)({
        type: "Variance",
        kind
      });
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "EnumDeclaration",
        id,
        body
      });
    }
    function enumBooleanBody(members) {
      return (0, _validateNode.default)({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumNumberBody(members) {
      return (0, _validateNode.default)({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumStringBody(members) {
      return (0, _validateNode.default)({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumSymbolBody(members) {
      return (0, _validateNode.default)({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      });
    }
    function enumBooleanMember(id) {
      return (0, _validateNode.default)({
        type: "EnumBooleanMember",
        id,
        init: null
      });
    }
    function enumNumberMember(id, init) {
      return (0, _validateNode.default)({
        type: "EnumNumberMember",
        id,
        init
      });
    }
    function enumStringMember(id, init) {
      return (0, _validateNode.default)({
        type: "EnumStringMember",
        id,
        init
      });
    }
    function enumDefaultedMember(id) {
      return (0, _validateNode.default)({
        type: "EnumDefaultedMember",
        id
      });
    }
    function indexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "IndexedAccessType",
        objectType,
        indexType
      });
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      });
    }
    function jsxAttribute2(name2, value = null) {
      return (0, _validateNode.default)({
        type: "JSXAttribute",
        name: name2,
        value
      });
    }
    function jsxClosingElement2(name2) {
      return (0, _validateNode.default)({
        type: "JSXClosingElement",
        name: name2
      });
    }
    function jsxElement2(openingElement, closingElement = null, children, selfClosing = null) {
      return (0, _validateNode.default)({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      });
    }
    function jsxEmptyExpression2() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer2(expression) {
      return (0, _validateNode.default)({
        type: "JSXExpressionContainer",
        expression
      });
    }
    function jsxSpreadChild(expression) {
      return (0, _validateNode.default)({
        type: "JSXSpreadChild",
        expression
      });
    }
    function jsxIdentifier2(name2) {
      return (0, _validateNode.default)({
        type: "JSXIdentifier",
        name: name2
      });
    }
    function jsxMemberExpression2(object, property) {
      return (0, _validateNode.default)({
        type: "JSXMemberExpression",
        object,
        property
      });
    }
    function jsxNamespacedName2(namespace, name2) {
      return (0, _validateNode.default)({
        type: "JSXNamespacedName",
        namespace,
        name: name2
      });
    }
    function jsxOpeningElement2(name2, attributes, selfClosing = false) {
      return (0, _validateNode.default)({
        type: "JSXOpeningElement",
        name: name2,
        attributes,
        selfClosing
      });
    }
    function jsxSpreadAttribute2(argument) {
      return (0, _validateNode.default)({
        type: "JSXSpreadAttribute",
        argument
      });
    }
    function jsxText3(value) {
      return (0, _validateNode.default)({
        type: "JSXText",
        value
      });
    }
    function jsxFragment2(openingFragment, closingFragment, children) {
      return (0, _validateNode.default)({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      });
    }
    function jsxOpeningFragment2() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment2() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name2) {
      return (0, _validateNode.default)({
        type: "Placeholder",
        expectedNode,
        name: name2
      });
    }
    function v8IntrinsicIdentifier(name2) {
      return (0, _validateNode.default)({
        type: "V8IntrinsicIdentifier",
        name: name2
      });
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      return (0, _validateNode.default)({
        type: "BindExpression",
        object,
        callee
      });
    }
    function importAttribute(key, value) {
      return (0, _validateNode.default)({
        type: "ImportAttribute",
        key,
        value
      });
    }
    function decorator(expression) {
      return (0, _validateNode.default)({
        type: "Decorator",
        expression
      });
    }
    function doExpression(body, async = false) {
      return (0, _validateNode.default)({
        type: "DoExpression",
        body,
        async
      });
    }
    function exportDefaultSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportDefaultSpecifier",
        exported
      });
    }
    function recordExpression(properties) {
      return (0, _validateNode.default)({
        type: "RecordExpression",
        properties
      });
    }
    function tupleExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "TupleExpression",
        elements
      });
    }
    function decimalLiteral(value) {
      return (0, _validateNode.default)({
        type: "DecimalLiteral",
        value
      });
    }
    function moduleExpression(body) {
      return (0, _validateNode.default)({
        type: "ModuleExpression",
        body
      });
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      return (0, _validateNode.default)({
        type: "PipelineTopicExpression",
        expression
      });
    }
    function pipelineBareFunction(callee) {
      return (0, _validateNode.default)({
        type: "PipelineBareFunction",
        callee
      });
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      return (0, _validateNode.default)({
        type: "TSParameterProperty",
        parameter
      });
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      });
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      });
    }
    function tsQualifiedName(left, right) {
      return (0, _validateNode.default)({
        type: "TSQualifiedName",
        left,
        right
      });
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsPropertySignature(key, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeReference(typeName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeReference",
        typeName,
        typeParameters
      });
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      return (0, _validateNode.default)({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      });
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeQuery",
        exprName,
        typeParameters
      });
    }
    function tsTypeLiteral(members) {
      return (0, _validateNode.default)({
        type: "TSTypeLiteral",
        members
      });
    }
    function tsArrayType(elementType) {
      return (0, _validateNode.default)({
        type: "TSArrayType",
        elementType
      });
    }
    function tsTupleType(elementTypes) {
      return (0, _validateNode.default)({
        type: "TSTupleType",
        elementTypes
      });
    }
    function tsOptionalType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsRestType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      return (0, _validateNode.default)({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      });
    }
    function tsUnionType(types2) {
      return (0, _validateNode.default)({
        type: "TSUnionType",
        types: types2
      });
    }
    function tsIntersectionType(types2) {
      return (0, _validateNode.default)({
        type: "TSIntersectionType",
        types: types2
      });
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _validateNode.default)({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      });
    }
    function tsInferType(typeParameter2) {
      return (0, _validateNode.default)({
        type: "TSInferType",
        typeParameter: typeParameter2
      });
    }
    function tsParenthesizedType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeOperator(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      });
    }
    function tsIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "TSIndexedAccessType",
        objectType,
        indexType
      });
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      return (0, _validateNode.default)({
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      });
    }
    function tsLiteralType(literal2) {
      return (0, _validateNode.default)({
        type: "TSLiteralType",
        literal: literal2
      });
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      });
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function tsInterfaceBody(body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceBody",
        body
      });
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      });
    }
    function tsAsExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      return (0, _validateNode.default)({
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      });
    }
    function tsEnumDeclaration(id, members) {
      return (0, _validateNode.default)({
        type: "TSEnumDeclaration",
        id,
        members
      });
    }
    function tsEnumMember(id, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSEnumMember",
        id,
        initializer
      });
    }
    function tsModuleDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "TSModuleDeclaration",
        id,
        body
      });
    }
    function tsModuleBlock(body) {
      return (0, _validateNode.default)({
        type: "TSModuleBlock",
        body
      });
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      });
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _validateNode.default)({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      });
    }
    function tsExternalModuleReference(expression) {
      return (0, _validateNode.default)({
        type: "TSExternalModuleReference",
        expression
      });
    }
    function tsNonNullExpression(expression) {
      return (0, _validateNode.default)({
        type: "TSNonNullExpression",
        expression
      });
    }
    function tsExportAssignment(expression) {
      return (0, _validateNode.default)({
        type: "TSExportAssignment",
        expression
      });
    }
    function tsNamespaceExportDeclaration(id) {
      return (0, _validateNode.default)({
        type: "TSNamespaceExportDeclaration",
        id
      });
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterInstantiation",
        params
      });
    }
    function tsTypeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterDeclaration",
        params
      });
    }
    function tsTypeParameter(constraint = null, _default = null, name2) {
      return (0, _validateNode.default)({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name: name2
      });
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cleanJSXElementLiteralChild;
    var _index = require_generated2();
    var _index2 = require_lib3();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    }
  }
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildChildren;
    var _index = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node2) {
      const elements = [];
      for (let i = 0; i < node2.children.length; i++) {
        let child = node2.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _index.isJSXExpressionContainer)(child))
          child = child.expression;
        if ((0, _index.isJSXEmptyExpression)(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNode2;
    var _index = require_definitions();
    function isNode2(node2) {
      return !!(node2 && _index.VISITOR_KEYS[node2.type]);
    }
  }
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertNode2;
    var _isNode = require_isNode();
    function assertNode2(node2) {
      if (!(0, _isNode.default)(node2)) {
        var _node$type;
        const type = (_node$type = node2 == null ? void 0 : node2.type) != null ? _node$type : JSON.stringify(node2);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportExpression = assertImportExpression;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type, node2, opts) {
      if (!(0, _is.default)(type, node2, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node2.type}".`);
      }
    }
    function assertArrayExpression(node2, opts) {
      assert("ArrayExpression", node2, opts);
    }
    function assertAssignmentExpression(node2, opts) {
      assert("AssignmentExpression", node2, opts);
    }
    function assertBinaryExpression(node2, opts) {
      assert("BinaryExpression", node2, opts);
    }
    function assertInterpreterDirective(node2, opts) {
      assert("InterpreterDirective", node2, opts);
    }
    function assertDirective(node2, opts) {
      assert("Directive", node2, opts);
    }
    function assertDirectiveLiteral(node2, opts) {
      assert("DirectiveLiteral", node2, opts);
    }
    function assertBlockStatement(node2, opts) {
      assert("BlockStatement", node2, opts);
    }
    function assertBreakStatement(node2, opts) {
      assert("BreakStatement", node2, opts);
    }
    function assertCallExpression(node2, opts) {
      assert("CallExpression", node2, opts);
    }
    function assertCatchClause(node2, opts) {
      assert("CatchClause", node2, opts);
    }
    function assertConditionalExpression(node2, opts) {
      assert("ConditionalExpression", node2, opts);
    }
    function assertContinueStatement(node2, opts) {
      assert("ContinueStatement", node2, opts);
    }
    function assertDebuggerStatement(node2, opts) {
      assert("DebuggerStatement", node2, opts);
    }
    function assertDoWhileStatement(node2, opts) {
      assert("DoWhileStatement", node2, opts);
    }
    function assertEmptyStatement(node2, opts) {
      assert("EmptyStatement", node2, opts);
    }
    function assertExpressionStatement(node2, opts) {
      assert("ExpressionStatement", node2, opts);
    }
    function assertFile(node2, opts) {
      assert("File", node2, opts);
    }
    function assertForInStatement(node2, opts) {
      assert("ForInStatement", node2, opts);
    }
    function assertForStatement(node2, opts) {
      assert("ForStatement", node2, opts);
    }
    function assertFunctionDeclaration(node2, opts) {
      assert("FunctionDeclaration", node2, opts);
    }
    function assertFunctionExpression(node2, opts) {
      assert("FunctionExpression", node2, opts);
    }
    function assertIdentifier(node2, opts) {
      assert("Identifier", node2, opts);
    }
    function assertIfStatement(node2, opts) {
      assert("IfStatement", node2, opts);
    }
    function assertLabeledStatement(node2, opts) {
      assert("LabeledStatement", node2, opts);
    }
    function assertStringLiteral(node2, opts) {
      assert("StringLiteral", node2, opts);
    }
    function assertNumericLiteral(node2, opts) {
      assert("NumericLiteral", node2, opts);
    }
    function assertNullLiteral(node2, opts) {
      assert("NullLiteral", node2, opts);
    }
    function assertBooleanLiteral(node2, opts) {
      assert("BooleanLiteral", node2, opts);
    }
    function assertRegExpLiteral(node2, opts) {
      assert("RegExpLiteral", node2, opts);
    }
    function assertLogicalExpression(node2, opts) {
      assert("LogicalExpression", node2, opts);
    }
    function assertMemberExpression(node2, opts) {
      assert("MemberExpression", node2, opts);
    }
    function assertNewExpression(node2, opts) {
      assert("NewExpression", node2, opts);
    }
    function assertProgram(node2, opts) {
      assert("Program", node2, opts);
    }
    function assertObjectExpression(node2, opts) {
      assert("ObjectExpression", node2, opts);
    }
    function assertObjectMethod(node2, opts) {
      assert("ObjectMethod", node2, opts);
    }
    function assertObjectProperty(node2, opts) {
      assert("ObjectProperty", node2, opts);
    }
    function assertRestElement(node2, opts) {
      assert("RestElement", node2, opts);
    }
    function assertReturnStatement(node2, opts) {
      assert("ReturnStatement", node2, opts);
    }
    function assertSequenceExpression(node2, opts) {
      assert("SequenceExpression", node2, opts);
    }
    function assertParenthesizedExpression(node2, opts) {
      assert("ParenthesizedExpression", node2, opts);
    }
    function assertSwitchCase(node2, opts) {
      assert("SwitchCase", node2, opts);
    }
    function assertSwitchStatement(node2, opts) {
      assert("SwitchStatement", node2, opts);
    }
    function assertThisExpression(node2, opts) {
      assert("ThisExpression", node2, opts);
    }
    function assertThrowStatement(node2, opts) {
      assert("ThrowStatement", node2, opts);
    }
    function assertTryStatement(node2, opts) {
      assert("TryStatement", node2, opts);
    }
    function assertUnaryExpression(node2, opts) {
      assert("UnaryExpression", node2, opts);
    }
    function assertUpdateExpression(node2, opts) {
      assert("UpdateExpression", node2, opts);
    }
    function assertVariableDeclaration(node2, opts) {
      assert("VariableDeclaration", node2, opts);
    }
    function assertVariableDeclarator(node2, opts) {
      assert("VariableDeclarator", node2, opts);
    }
    function assertWhileStatement(node2, opts) {
      assert("WhileStatement", node2, opts);
    }
    function assertWithStatement(node2, opts) {
      assert("WithStatement", node2, opts);
    }
    function assertAssignmentPattern(node2, opts) {
      assert("AssignmentPattern", node2, opts);
    }
    function assertArrayPattern(node2, opts) {
      assert("ArrayPattern", node2, opts);
    }
    function assertArrowFunctionExpression(node2, opts) {
      assert("ArrowFunctionExpression", node2, opts);
    }
    function assertClassBody(node2, opts) {
      assert("ClassBody", node2, opts);
    }
    function assertClassExpression(node2, opts) {
      assert("ClassExpression", node2, opts);
    }
    function assertClassDeclaration(node2, opts) {
      assert("ClassDeclaration", node2, opts);
    }
    function assertExportAllDeclaration(node2, opts) {
      assert("ExportAllDeclaration", node2, opts);
    }
    function assertExportDefaultDeclaration(node2, opts) {
      assert("ExportDefaultDeclaration", node2, opts);
    }
    function assertExportNamedDeclaration(node2, opts) {
      assert("ExportNamedDeclaration", node2, opts);
    }
    function assertExportSpecifier(node2, opts) {
      assert("ExportSpecifier", node2, opts);
    }
    function assertForOfStatement(node2, opts) {
      assert("ForOfStatement", node2, opts);
    }
    function assertImportDeclaration(node2, opts) {
      assert("ImportDeclaration", node2, opts);
    }
    function assertImportDefaultSpecifier(node2, opts) {
      assert("ImportDefaultSpecifier", node2, opts);
    }
    function assertImportNamespaceSpecifier(node2, opts) {
      assert("ImportNamespaceSpecifier", node2, opts);
    }
    function assertImportSpecifier(node2, opts) {
      assert("ImportSpecifier", node2, opts);
    }
    function assertImportExpression(node2, opts) {
      assert("ImportExpression", node2, opts);
    }
    function assertMetaProperty(node2, opts) {
      assert("MetaProperty", node2, opts);
    }
    function assertClassMethod(node2, opts) {
      assert("ClassMethod", node2, opts);
    }
    function assertObjectPattern(node2, opts) {
      assert("ObjectPattern", node2, opts);
    }
    function assertSpreadElement(node2, opts) {
      assert("SpreadElement", node2, opts);
    }
    function assertSuper(node2, opts) {
      assert("Super", node2, opts);
    }
    function assertTaggedTemplateExpression(node2, opts) {
      assert("TaggedTemplateExpression", node2, opts);
    }
    function assertTemplateElement(node2, opts) {
      assert("TemplateElement", node2, opts);
    }
    function assertTemplateLiteral(node2, opts) {
      assert("TemplateLiteral", node2, opts);
    }
    function assertYieldExpression(node2, opts) {
      assert("YieldExpression", node2, opts);
    }
    function assertAwaitExpression(node2, opts) {
      assert("AwaitExpression", node2, opts);
    }
    function assertImport(node2, opts) {
      assert("Import", node2, opts);
    }
    function assertBigIntLiteral(node2, opts) {
      assert("BigIntLiteral", node2, opts);
    }
    function assertExportNamespaceSpecifier(node2, opts) {
      assert("ExportNamespaceSpecifier", node2, opts);
    }
    function assertOptionalMemberExpression(node2, opts) {
      assert("OptionalMemberExpression", node2, opts);
    }
    function assertOptionalCallExpression(node2, opts) {
      assert("OptionalCallExpression", node2, opts);
    }
    function assertClassProperty(node2, opts) {
      assert("ClassProperty", node2, opts);
    }
    function assertClassAccessorProperty(node2, opts) {
      assert("ClassAccessorProperty", node2, opts);
    }
    function assertClassPrivateProperty(node2, opts) {
      assert("ClassPrivateProperty", node2, opts);
    }
    function assertClassPrivateMethod(node2, opts) {
      assert("ClassPrivateMethod", node2, opts);
    }
    function assertPrivateName(node2, opts) {
      assert("PrivateName", node2, opts);
    }
    function assertStaticBlock(node2, opts) {
      assert("StaticBlock", node2, opts);
    }
    function assertAnyTypeAnnotation(node2, opts) {
      assert("AnyTypeAnnotation", node2, opts);
    }
    function assertArrayTypeAnnotation(node2, opts) {
      assert("ArrayTypeAnnotation", node2, opts);
    }
    function assertBooleanTypeAnnotation(node2, opts) {
      assert("BooleanTypeAnnotation", node2, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node2, opts) {
      assert("BooleanLiteralTypeAnnotation", node2, opts);
    }
    function assertNullLiteralTypeAnnotation(node2, opts) {
      assert("NullLiteralTypeAnnotation", node2, opts);
    }
    function assertClassImplements(node2, opts) {
      assert("ClassImplements", node2, opts);
    }
    function assertDeclareClass(node2, opts) {
      assert("DeclareClass", node2, opts);
    }
    function assertDeclareFunction(node2, opts) {
      assert("DeclareFunction", node2, opts);
    }
    function assertDeclareInterface(node2, opts) {
      assert("DeclareInterface", node2, opts);
    }
    function assertDeclareModule(node2, opts) {
      assert("DeclareModule", node2, opts);
    }
    function assertDeclareModuleExports(node2, opts) {
      assert("DeclareModuleExports", node2, opts);
    }
    function assertDeclareTypeAlias(node2, opts) {
      assert("DeclareTypeAlias", node2, opts);
    }
    function assertDeclareOpaqueType(node2, opts) {
      assert("DeclareOpaqueType", node2, opts);
    }
    function assertDeclareVariable(node2, opts) {
      assert("DeclareVariable", node2, opts);
    }
    function assertDeclareExportDeclaration(node2, opts) {
      assert("DeclareExportDeclaration", node2, opts);
    }
    function assertDeclareExportAllDeclaration(node2, opts) {
      assert("DeclareExportAllDeclaration", node2, opts);
    }
    function assertDeclaredPredicate(node2, opts) {
      assert("DeclaredPredicate", node2, opts);
    }
    function assertExistsTypeAnnotation(node2, opts) {
      assert("ExistsTypeAnnotation", node2, opts);
    }
    function assertFunctionTypeAnnotation(node2, opts) {
      assert("FunctionTypeAnnotation", node2, opts);
    }
    function assertFunctionTypeParam(node2, opts) {
      assert("FunctionTypeParam", node2, opts);
    }
    function assertGenericTypeAnnotation(node2, opts) {
      assert("GenericTypeAnnotation", node2, opts);
    }
    function assertInferredPredicate(node2, opts) {
      assert("InferredPredicate", node2, opts);
    }
    function assertInterfaceExtends(node2, opts) {
      assert("InterfaceExtends", node2, opts);
    }
    function assertInterfaceDeclaration(node2, opts) {
      assert("InterfaceDeclaration", node2, opts);
    }
    function assertInterfaceTypeAnnotation(node2, opts) {
      assert("InterfaceTypeAnnotation", node2, opts);
    }
    function assertIntersectionTypeAnnotation(node2, opts) {
      assert("IntersectionTypeAnnotation", node2, opts);
    }
    function assertMixedTypeAnnotation(node2, opts) {
      assert("MixedTypeAnnotation", node2, opts);
    }
    function assertEmptyTypeAnnotation(node2, opts) {
      assert("EmptyTypeAnnotation", node2, opts);
    }
    function assertNullableTypeAnnotation(node2, opts) {
      assert("NullableTypeAnnotation", node2, opts);
    }
    function assertNumberLiteralTypeAnnotation(node2, opts) {
      assert("NumberLiteralTypeAnnotation", node2, opts);
    }
    function assertNumberTypeAnnotation(node2, opts) {
      assert("NumberTypeAnnotation", node2, opts);
    }
    function assertObjectTypeAnnotation(node2, opts) {
      assert("ObjectTypeAnnotation", node2, opts);
    }
    function assertObjectTypeInternalSlot(node2, opts) {
      assert("ObjectTypeInternalSlot", node2, opts);
    }
    function assertObjectTypeCallProperty(node2, opts) {
      assert("ObjectTypeCallProperty", node2, opts);
    }
    function assertObjectTypeIndexer(node2, opts) {
      assert("ObjectTypeIndexer", node2, opts);
    }
    function assertObjectTypeProperty(node2, opts) {
      assert("ObjectTypeProperty", node2, opts);
    }
    function assertObjectTypeSpreadProperty(node2, opts) {
      assert("ObjectTypeSpreadProperty", node2, opts);
    }
    function assertOpaqueType(node2, opts) {
      assert("OpaqueType", node2, opts);
    }
    function assertQualifiedTypeIdentifier(node2, opts) {
      assert("QualifiedTypeIdentifier", node2, opts);
    }
    function assertStringLiteralTypeAnnotation(node2, opts) {
      assert("StringLiteralTypeAnnotation", node2, opts);
    }
    function assertStringTypeAnnotation(node2, opts) {
      assert("StringTypeAnnotation", node2, opts);
    }
    function assertSymbolTypeAnnotation(node2, opts) {
      assert("SymbolTypeAnnotation", node2, opts);
    }
    function assertThisTypeAnnotation(node2, opts) {
      assert("ThisTypeAnnotation", node2, opts);
    }
    function assertTupleTypeAnnotation(node2, opts) {
      assert("TupleTypeAnnotation", node2, opts);
    }
    function assertTypeofTypeAnnotation(node2, opts) {
      assert("TypeofTypeAnnotation", node2, opts);
    }
    function assertTypeAlias(node2, opts) {
      assert("TypeAlias", node2, opts);
    }
    function assertTypeAnnotation(node2, opts) {
      assert("TypeAnnotation", node2, opts);
    }
    function assertTypeCastExpression(node2, opts) {
      assert("TypeCastExpression", node2, opts);
    }
    function assertTypeParameter(node2, opts) {
      assert("TypeParameter", node2, opts);
    }
    function assertTypeParameterDeclaration(node2, opts) {
      assert("TypeParameterDeclaration", node2, opts);
    }
    function assertTypeParameterInstantiation(node2, opts) {
      assert("TypeParameterInstantiation", node2, opts);
    }
    function assertUnionTypeAnnotation(node2, opts) {
      assert("UnionTypeAnnotation", node2, opts);
    }
    function assertVariance(node2, opts) {
      assert("Variance", node2, opts);
    }
    function assertVoidTypeAnnotation(node2, opts) {
      assert("VoidTypeAnnotation", node2, opts);
    }
    function assertEnumDeclaration(node2, opts) {
      assert("EnumDeclaration", node2, opts);
    }
    function assertEnumBooleanBody(node2, opts) {
      assert("EnumBooleanBody", node2, opts);
    }
    function assertEnumNumberBody(node2, opts) {
      assert("EnumNumberBody", node2, opts);
    }
    function assertEnumStringBody(node2, opts) {
      assert("EnumStringBody", node2, opts);
    }
    function assertEnumSymbolBody(node2, opts) {
      assert("EnumSymbolBody", node2, opts);
    }
    function assertEnumBooleanMember(node2, opts) {
      assert("EnumBooleanMember", node2, opts);
    }
    function assertEnumNumberMember(node2, opts) {
      assert("EnumNumberMember", node2, opts);
    }
    function assertEnumStringMember(node2, opts) {
      assert("EnumStringMember", node2, opts);
    }
    function assertEnumDefaultedMember(node2, opts) {
      assert("EnumDefaultedMember", node2, opts);
    }
    function assertIndexedAccessType(node2, opts) {
      assert("IndexedAccessType", node2, opts);
    }
    function assertOptionalIndexedAccessType(node2, opts) {
      assert("OptionalIndexedAccessType", node2, opts);
    }
    function assertJSXAttribute(node2, opts) {
      assert("JSXAttribute", node2, opts);
    }
    function assertJSXClosingElement(node2, opts) {
      assert("JSXClosingElement", node2, opts);
    }
    function assertJSXElement(node2, opts) {
      assert("JSXElement", node2, opts);
    }
    function assertJSXEmptyExpression(node2, opts) {
      assert("JSXEmptyExpression", node2, opts);
    }
    function assertJSXExpressionContainer(node2, opts) {
      assert("JSXExpressionContainer", node2, opts);
    }
    function assertJSXSpreadChild(node2, opts) {
      assert("JSXSpreadChild", node2, opts);
    }
    function assertJSXIdentifier(node2, opts) {
      assert("JSXIdentifier", node2, opts);
    }
    function assertJSXMemberExpression(node2, opts) {
      assert("JSXMemberExpression", node2, opts);
    }
    function assertJSXNamespacedName(node2, opts) {
      assert("JSXNamespacedName", node2, opts);
    }
    function assertJSXOpeningElement(node2, opts) {
      assert("JSXOpeningElement", node2, opts);
    }
    function assertJSXSpreadAttribute(node2, opts) {
      assert("JSXSpreadAttribute", node2, opts);
    }
    function assertJSXText(node2, opts) {
      assert("JSXText", node2, opts);
    }
    function assertJSXFragment(node2, opts) {
      assert("JSXFragment", node2, opts);
    }
    function assertJSXOpeningFragment(node2, opts) {
      assert("JSXOpeningFragment", node2, opts);
    }
    function assertJSXClosingFragment(node2, opts) {
      assert("JSXClosingFragment", node2, opts);
    }
    function assertNoop(node2, opts) {
      assert("Noop", node2, opts);
    }
    function assertPlaceholder(node2, opts) {
      assert("Placeholder", node2, opts);
    }
    function assertV8IntrinsicIdentifier(node2, opts) {
      assert("V8IntrinsicIdentifier", node2, opts);
    }
    function assertArgumentPlaceholder(node2, opts) {
      assert("ArgumentPlaceholder", node2, opts);
    }
    function assertBindExpression(node2, opts) {
      assert("BindExpression", node2, opts);
    }
    function assertImportAttribute(node2, opts) {
      assert("ImportAttribute", node2, opts);
    }
    function assertDecorator(node2, opts) {
      assert("Decorator", node2, opts);
    }
    function assertDoExpression(node2, opts) {
      assert("DoExpression", node2, opts);
    }
    function assertExportDefaultSpecifier(node2, opts) {
      assert("ExportDefaultSpecifier", node2, opts);
    }
    function assertRecordExpression(node2, opts) {
      assert("RecordExpression", node2, opts);
    }
    function assertTupleExpression(node2, opts) {
      assert("TupleExpression", node2, opts);
    }
    function assertDecimalLiteral(node2, opts) {
      assert("DecimalLiteral", node2, opts);
    }
    function assertModuleExpression(node2, opts) {
      assert("ModuleExpression", node2, opts);
    }
    function assertTopicReference(node2, opts) {
      assert("TopicReference", node2, opts);
    }
    function assertPipelineTopicExpression(node2, opts) {
      assert("PipelineTopicExpression", node2, opts);
    }
    function assertPipelineBareFunction(node2, opts) {
      assert("PipelineBareFunction", node2, opts);
    }
    function assertPipelinePrimaryTopicReference(node2, opts) {
      assert("PipelinePrimaryTopicReference", node2, opts);
    }
    function assertTSParameterProperty(node2, opts) {
      assert("TSParameterProperty", node2, opts);
    }
    function assertTSDeclareFunction(node2, opts) {
      assert("TSDeclareFunction", node2, opts);
    }
    function assertTSDeclareMethod(node2, opts) {
      assert("TSDeclareMethod", node2, opts);
    }
    function assertTSQualifiedName(node2, opts) {
      assert("TSQualifiedName", node2, opts);
    }
    function assertTSCallSignatureDeclaration(node2, opts) {
      assert("TSCallSignatureDeclaration", node2, opts);
    }
    function assertTSConstructSignatureDeclaration(node2, opts) {
      assert("TSConstructSignatureDeclaration", node2, opts);
    }
    function assertTSPropertySignature(node2, opts) {
      assert("TSPropertySignature", node2, opts);
    }
    function assertTSMethodSignature(node2, opts) {
      assert("TSMethodSignature", node2, opts);
    }
    function assertTSIndexSignature(node2, opts) {
      assert("TSIndexSignature", node2, opts);
    }
    function assertTSAnyKeyword(node2, opts) {
      assert("TSAnyKeyword", node2, opts);
    }
    function assertTSBooleanKeyword(node2, opts) {
      assert("TSBooleanKeyword", node2, opts);
    }
    function assertTSBigIntKeyword(node2, opts) {
      assert("TSBigIntKeyword", node2, opts);
    }
    function assertTSIntrinsicKeyword(node2, opts) {
      assert("TSIntrinsicKeyword", node2, opts);
    }
    function assertTSNeverKeyword(node2, opts) {
      assert("TSNeverKeyword", node2, opts);
    }
    function assertTSNullKeyword(node2, opts) {
      assert("TSNullKeyword", node2, opts);
    }
    function assertTSNumberKeyword(node2, opts) {
      assert("TSNumberKeyword", node2, opts);
    }
    function assertTSObjectKeyword(node2, opts) {
      assert("TSObjectKeyword", node2, opts);
    }
    function assertTSStringKeyword(node2, opts) {
      assert("TSStringKeyword", node2, opts);
    }
    function assertTSSymbolKeyword(node2, opts) {
      assert("TSSymbolKeyword", node2, opts);
    }
    function assertTSUndefinedKeyword(node2, opts) {
      assert("TSUndefinedKeyword", node2, opts);
    }
    function assertTSUnknownKeyword(node2, opts) {
      assert("TSUnknownKeyword", node2, opts);
    }
    function assertTSVoidKeyword(node2, opts) {
      assert("TSVoidKeyword", node2, opts);
    }
    function assertTSThisType(node2, opts) {
      assert("TSThisType", node2, opts);
    }
    function assertTSFunctionType(node2, opts) {
      assert("TSFunctionType", node2, opts);
    }
    function assertTSConstructorType(node2, opts) {
      assert("TSConstructorType", node2, opts);
    }
    function assertTSTypeReference(node2, opts) {
      assert("TSTypeReference", node2, opts);
    }
    function assertTSTypePredicate(node2, opts) {
      assert("TSTypePredicate", node2, opts);
    }
    function assertTSTypeQuery(node2, opts) {
      assert("TSTypeQuery", node2, opts);
    }
    function assertTSTypeLiteral(node2, opts) {
      assert("TSTypeLiteral", node2, opts);
    }
    function assertTSArrayType(node2, opts) {
      assert("TSArrayType", node2, opts);
    }
    function assertTSTupleType(node2, opts) {
      assert("TSTupleType", node2, opts);
    }
    function assertTSOptionalType(node2, opts) {
      assert("TSOptionalType", node2, opts);
    }
    function assertTSRestType(node2, opts) {
      assert("TSRestType", node2, opts);
    }
    function assertTSNamedTupleMember(node2, opts) {
      assert("TSNamedTupleMember", node2, opts);
    }
    function assertTSUnionType(node2, opts) {
      assert("TSUnionType", node2, opts);
    }
    function assertTSIntersectionType(node2, opts) {
      assert("TSIntersectionType", node2, opts);
    }
    function assertTSConditionalType(node2, opts) {
      assert("TSConditionalType", node2, opts);
    }
    function assertTSInferType(node2, opts) {
      assert("TSInferType", node2, opts);
    }
    function assertTSParenthesizedType(node2, opts) {
      assert("TSParenthesizedType", node2, opts);
    }
    function assertTSTypeOperator(node2, opts) {
      assert("TSTypeOperator", node2, opts);
    }
    function assertTSIndexedAccessType(node2, opts) {
      assert("TSIndexedAccessType", node2, opts);
    }
    function assertTSMappedType(node2, opts) {
      assert("TSMappedType", node2, opts);
    }
    function assertTSLiteralType(node2, opts) {
      assert("TSLiteralType", node2, opts);
    }
    function assertTSExpressionWithTypeArguments(node2, opts) {
      assert("TSExpressionWithTypeArguments", node2, opts);
    }
    function assertTSInterfaceDeclaration(node2, opts) {
      assert("TSInterfaceDeclaration", node2, opts);
    }
    function assertTSInterfaceBody(node2, opts) {
      assert("TSInterfaceBody", node2, opts);
    }
    function assertTSTypeAliasDeclaration(node2, opts) {
      assert("TSTypeAliasDeclaration", node2, opts);
    }
    function assertTSInstantiationExpression(node2, opts) {
      assert("TSInstantiationExpression", node2, opts);
    }
    function assertTSAsExpression(node2, opts) {
      assert("TSAsExpression", node2, opts);
    }
    function assertTSSatisfiesExpression(node2, opts) {
      assert("TSSatisfiesExpression", node2, opts);
    }
    function assertTSTypeAssertion(node2, opts) {
      assert("TSTypeAssertion", node2, opts);
    }
    function assertTSEnumDeclaration(node2, opts) {
      assert("TSEnumDeclaration", node2, opts);
    }
    function assertTSEnumMember(node2, opts) {
      assert("TSEnumMember", node2, opts);
    }
    function assertTSModuleDeclaration(node2, opts) {
      assert("TSModuleDeclaration", node2, opts);
    }
    function assertTSModuleBlock(node2, opts) {
      assert("TSModuleBlock", node2, opts);
    }
    function assertTSImportType(node2, opts) {
      assert("TSImportType", node2, opts);
    }
    function assertTSImportEqualsDeclaration(node2, opts) {
      assert("TSImportEqualsDeclaration", node2, opts);
    }
    function assertTSExternalModuleReference(node2, opts) {
      assert("TSExternalModuleReference", node2, opts);
    }
    function assertTSNonNullExpression(node2, opts) {
      assert("TSNonNullExpression", node2, opts);
    }
    function assertTSExportAssignment(node2, opts) {
      assert("TSExportAssignment", node2, opts);
    }
    function assertTSNamespaceExportDeclaration(node2, opts) {
      assert("TSNamespaceExportDeclaration", node2, opts);
    }
    function assertTSTypeAnnotation(node2, opts) {
      assert("TSTypeAnnotation", node2, opts);
    }
    function assertTSTypeParameterInstantiation(node2, opts) {
      assert("TSTypeParameterInstantiation", node2, opts);
    }
    function assertTSTypeParameterDeclaration(node2, opts) {
      assert("TSTypeParameterDeclaration", node2, opts);
    }
    function assertTSTypeParameter(node2, opts) {
      assert("TSTypeParameter", node2, opts);
    }
    function assertStandardized(node2, opts) {
      assert("Standardized", node2, opts);
    }
    function assertExpression(node2, opts) {
      assert("Expression", node2, opts);
    }
    function assertBinary(node2, opts) {
      assert("Binary", node2, opts);
    }
    function assertScopable(node2, opts) {
      assert("Scopable", node2, opts);
    }
    function assertBlockParent(node2, opts) {
      assert("BlockParent", node2, opts);
    }
    function assertBlock(node2, opts) {
      assert("Block", node2, opts);
    }
    function assertStatement(node2, opts) {
      assert("Statement", node2, opts);
    }
    function assertTerminatorless(node2, opts) {
      assert("Terminatorless", node2, opts);
    }
    function assertCompletionStatement(node2, opts) {
      assert("CompletionStatement", node2, opts);
    }
    function assertConditional(node2, opts) {
      assert("Conditional", node2, opts);
    }
    function assertLoop(node2, opts) {
      assert("Loop", node2, opts);
    }
    function assertWhile(node2, opts) {
      assert("While", node2, opts);
    }
    function assertExpressionWrapper(node2, opts) {
      assert("ExpressionWrapper", node2, opts);
    }
    function assertFor(node2, opts) {
      assert("For", node2, opts);
    }
    function assertForXStatement(node2, opts) {
      assert("ForXStatement", node2, opts);
    }
    function assertFunction(node2, opts) {
      assert("Function", node2, opts);
    }
    function assertFunctionParent(node2, opts) {
      assert("FunctionParent", node2, opts);
    }
    function assertPureish(node2, opts) {
      assert("Pureish", node2, opts);
    }
    function assertDeclaration(node2, opts) {
      assert("Declaration", node2, opts);
    }
    function assertPatternLike(node2, opts) {
      assert("PatternLike", node2, opts);
    }
    function assertLVal(node2, opts) {
      assert("LVal", node2, opts);
    }
    function assertTSEntityName(node2, opts) {
      assert("TSEntityName", node2, opts);
    }
    function assertLiteral(node2, opts) {
      assert("Literal", node2, opts);
    }
    function assertImmutable(node2, opts) {
      assert("Immutable", node2, opts);
    }
    function assertUserWhitespacable(node2, opts) {
      assert("UserWhitespacable", node2, opts);
    }
    function assertMethod(node2, opts) {
      assert("Method", node2, opts);
    }
    function assertObjectMember(node2, opts) {
      assert("ObjectMember", node2, opts);
    }
    function assertProperty(node2, opts) {
      assert("Property", node2, opts);
    }
    function assertUnaryLike(node2, opts) {
      assert("UnaryLike", node2, opts);
    }
    function assertPattern(node2, opts) {
      assert("Pattern", node2, opts);
    }
    function assertClass(node2, opts) {
      assert("Class", node2, opts);
    }
    function assertImportOrExportDeclaration(node2, opts) {
      assert("ImportOrExportDeclaration", node2, opts);
    }
    function assertExportDeclaration(node2, opts) {
      assert("ExportDeclaration", node2, opts);
    }
    function assertModuleSpecifier(node2, opts) {
      assert("ModuleSpecifier", node2, opts);
    }
    function assertAccessor(node2, opts) {
      assert("Accessor", node2, opts);
    }
    function assertPrivate(node2, opts) {
      assert("Private", node2, opts);
    }
    function assertFlow(node2, opts) {
      assert("Flow", node2, opts);
    }
    function assertFlowType(node2, opts) {
      assert("FlowType", node2, opts);
    }
    function assertFlowBaseAnnotation(node2, opts) {
      assert("FlowBaseAnnotation", node2, opts);
    }
    function assertFlowDeclaration(node2, opts) {
      assert("FlowDeclaration", node2, opts);
    }
    function assertFlowPredicate(node2, opts) {
      assert("FlowPredicate", node2, opts);
    }
    function assertEnumBody(node2, opts) {
      assert("EnumBody", node2, opts);
    }
    function assertEnumMember(node2, opts) {
      assert("EnumMember", node2, opts);
    }
    function assertJSX(node2, opts) {
      assert("JSX", node2, opts);
    }
    function assertMiscellaneous(node2, opts) {
      assert("Miscellaneous", node2, opts);
    }
    function assertTypeScript(node2, opts) {
      assert("TypeScript", node2, opts);
    }
    function assertTSTypeElement(node2, opts) {
      assert("TSTypeElement", node2, opts);
    }
    function assertTSType(node2, opts) {
      assert("TSType", node2, opts);
    }
    function assertTSBaseType(node2, opts) {
      assert("TSBaseType", node2, opts);
    }
    function assertNumberLiteral(node2, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node2, opts);
    }
    function assertRegexLiteral(node2, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node2, opts);
    }
    function assertRestProperty(node2, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node2, opts);
    }
    function assertSpreadProperty(node2, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node2, opts);
    }
    function assertModuleDeclaration(node2, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node2, opts);
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated2();
    var _default = exports.default = createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node2) {
      return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.id.name}.${getQualifiedName(node2.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types2 = [];
      for (let i = 0; i < nodes.length; i++) {
        const node2 = nodes[i];
        if (!node2)
          continue;
        if (types2.indexOf(node2) >= 0) {
          continue;
        }
        if ((0, _index.isAnyTypeAnnotation)(node2)) {
          return [node2];
        }
        if ((0, _index.isFlowBaseAnnotation)(node2)) {
          bases.set(node2.type, node2);
          continue;
        }
        if ((0, _index.isUnionTypeAnnotation)(node2)) {
          if (!typeGroups.has(node2.types)) {
            nodes.push(...node2.types);
            typeGroups.add(node2.types);
          }
          continue;
        }
        if ((0, _index.isGenericTypeAnnotation)(node2)) {
          const name2 = getQualifiedName(node2.id);
          if (generics.has(name2)) {
            let existing = generics.get(name2);
            if (existing.typeParameters) {
              if (node2.typeParameters) {
                existing.typeParameters.params.push(...node2.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node2.typeParameters;
            }
          } else {
            generics.set(name2, node2);
          }
          continue;
        }
        types2.push(node2);
      }
      for (const [, baseType] of bases) {
        types2.push(baseType);
      }
      for (const [, genericName] of generics) {
        types2.push(genericName);
      }
      return types2;
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createFlowUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types2) {
      const flattened = (0, _removeTypeDuplicates.default)(types2);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node2) {
      return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.right.name}.${getQualifiedName(node2.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types2 = [];
      for (let i = 0; i < nodes.length; i++) {
        const node2 = nodes[i];
        if (!node2)
          continue;
        if (types2.indexOf(node2) >= 0) {
          continue;
        }
        if ((0, _index.isTSAnyKeyword)(node2)) {
          return [node2];
        }
        if ((0, _index.isTSBaseType)(node2)) {
          bases.set(node2.type, node2);
          continue;
        }
        if ((0, _index.isTSUnionType)(node2)) {
          if (!typeGroups.has(node2.types)) {
            nodes.push(...node2.types);
            typeGroups.add(node2.types);
          }
          continue;
        }
        if ((0, _index.isTSTypeReference)(node2) && node2.typeParameters) {
          const name2 = getQualifiedName(node2.typeName);
          if (generics.has(name2)) {
            let existing = generics.get(name2);
            if (existing.typeParameters) {
              if (node2.typeParameters) {
                existing.typeParameters.params.push(...node2.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node2.typeParameters;
            }
          } else {
            generics.set(name2, node2);
          }
          continue;
        }
        types2.push(node2);
      }
      for (const [, baseType] of bases) {
        types2.push(baseType);
      }
      for (const [, genericName] of generics) {
        types2.push(genericName);
      }
      return types2;
    }
  }
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTSUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types2 = typeAnnotations.map((type) => {
        return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types2);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _index.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _index.arrayExpression;
      }
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _index.arrayPattern;
      }
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _index.assignmentExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _index.assignmentPattern;
      }
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _index.awaitExpression;
      }
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _index.bigIntLiteral;
      }
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _index.binaryExpression;
      }
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function() {
        return _index.bindExpression;
      }
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _index.blockStatement;
      }
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteral;
      }
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _index.breakStatement;
      }
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function() {
        return _index.callExpression;
      }
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function() {
        return _index.catchClause;
      }
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _index.classAccessorProperty;
      }
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function() {
        return _index.classBody;
      }
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _index.classDeclaration;
      }
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _index.classExpression;
      }
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _index.classImplements;
      }
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _index.classMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _index.classPrivateMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _index.classPrivateProperty;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _index.classProperty;
      }
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _index.conditionalExpression;
      }
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _index.continueStatement;
      }
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _index.debuggerStatement;
      }
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _index.decimalLiteral;
      }
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _index.declareClass;
      }
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.declareFunction;
      }
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _index.declareInterface;
      }
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _index.declareModule;
      }
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _index.declareModuleExports;
      }
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _index.declareOpaqueType;
      }
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _index.declareTypeAlias;
      }
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _index.declareVariable;
      }
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _index.declaredPredicate;
      }
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function() {
        return _index.decorator;
      }
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function() {
        return _index.directive;
      }
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _index.directiveLiteral;
      }
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function() {
        return _index.doExpression;
      }
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _index.doWhileStatement;
      }
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _index.emptyStatement;
      }
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanBody;
      }
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanMember;
      }
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.enumDeclaration;
      }
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _index.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _index.enumNumberBody;
      }
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _index.enumNumberMember;
      }
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _index.enumStringBody;
      }
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _index.enumStringMember;
      }
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _index.enumSymbolBody;
      }
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportSpecifier;
      }
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _index.expressionStatement;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function() {
        return _index.file;
      }
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _index.forInStatement;
      }
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _index.forOfStatement;
      }
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function() {
        return _index.forStatement;
      }
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _index.functionDeclaration;
      }
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.functionExpression;
      }
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _index.functionTypeParam;
      }
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _index.identifier;
      }
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function() {
        return _index.ifStatement;
      }
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function() {
        return _index.import;
      }
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _index.importAttribute;
      }
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.importDeclaration;
      }
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportExpression", {
      enumerable: true,
      get: function() {
        return _index.importExpression;
      }
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importSpecifier;
      }
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.indexedAccessType;
      }
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _index.inferredPredicate;
      }
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _index.interfaceExtends;
      }
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _index.interpreterDirective;
      }
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxAttribute;
      }
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingElement;
      }
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function() {
        return _index.jsxElement;
      }
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _index.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxFragment;
      }
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _index.jsxIdentifier;
      }
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _index.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function() {
        return _index.jsxText;
      }
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _index.labeledStatement;
      }
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _index.logicalExpression;
      }
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _index.memberExpression;
      }
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _index.metaProperty;
      }
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _index.moduleExpression;
      }
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function() {
        return _index.newExpression;
      }
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function() {
        return _index.noop;
      }
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _index.nullLiteral;
      }
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _index.numberLiteral;
      }
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _index.numericLiteral;
      }
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _index.objectExpression;
      }
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _index.objectMethod;
      }
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _index.objectPattern;
      }
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _index.objectProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _index.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _index.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _index.opaqueType;
      }
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalCallExpression;
      }
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _index.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _index.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _index.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _index.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function() {
        return _index.placeholder;
      }
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function() {
        return _index.privateName;
      }
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function() {
        return _index.program;
      }
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _index.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _index.recordExpression;
      }
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _index.regExpLiteral;
      }
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _index.regexLiteral;
      }
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function() {
        return _index.restElement;
      }
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function() {
        return _index.restProperty;
      }
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _index.returnStatement;
      }
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _index.sequenceExpression;
      }
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _index.spreadElement;
      }
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.spreadProperty;
      }
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _index.staticBlock;
      }
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _index.stringLiteral;
      }
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function() {
        return _index.super;
      }
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _index.switchCase;
      }
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _index.switchStatement;
      }
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _index.tsArrayType;
      }
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _index.tsAsExpression;
      }
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _index.tsConditionalType;
      }
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _index.tsConstructorType;
      }
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _index.tsEnumMember;
      }
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _index.tsExportAssignment;
      }
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _index.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _index.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _index.tsFunctionType;
      }
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function() {
        return _index.tsImportType;
      }
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _index.tsIndexSignature;
      }
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function() {
        return _index.tsInferType;
      }
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _index.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _index.tsIntersectionType;
      }
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _index.tsLiteralType;
      }
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _index.tsMappedType;
      }
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _index.tsMethodSignature;
      }
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _index.tsModuleBlock;
      }
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _index.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _index.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNullKeyword;
      }
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _index.tsOptionalType;
      }
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _index.tsParameterProperty;
      }
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _index.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _index.tsPropertySignature;
      }
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _index.tsQualifiedName;
      }
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function() {
        return _index.tsRestType;
      }
    });
    Object.defineProperty(exports, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _index.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsStringKeyword;
      }
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function() {
        return _index.tsThisType;
      }
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _index.tsTupleType;
      }
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _index.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _index.tsTypeOperator;
      }
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameter;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _index.tsTypePredicate;
      }
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _index.tsTypeQuery;
      }
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _index.tsTypeReference;
      }
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _index.tsUnionType;
      }
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _index.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _index.templateElement;
      }
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _index.templateLiteral;
      }
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _index.thisExpression;
      }
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _index.throwStatement;
      }
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function() {
        return _index.topicReference;
      }
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function() {
        return _index.tryStatement;
      }
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _index.tupleExpression;
      }
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _index.typeAlias;
      }
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _index.typeCastExpression;
      }
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _index.typeParameter;
      }
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _index.unaryExpression;
      }
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _index.updateExpression;
      }
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _index.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _index.variableDeclaration;
      }
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _index.variableDeclarator;
      }
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function() {
        return _index.variance;
      }
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _index.whileStatement;
      }
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function() {
        return _index.withStatement;
      }
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _index.yieldExpression;
      }
    });
    var _index = require_generated2();
  }
});

// node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "node_modules/@babel/types/lib/builders/productions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneNode;
    var _index = require_definitions();
    var _index2 = require_generated();
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node2) => cloneIfNode(node2, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node2, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node2, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node2, deep = true, withoutLoc = false, commentsCache) {
      if (!node2)
        return node2;
      const {
        type
      } = node2;
      const newNode = {
        type: node2.type
      };
      if ((0, _index2.isIdentifier)(node2)) {
        newNode.name = node2.name;
        if (has(node2, "optional") && typeof node2.optional === "boolean") {
          newNode.optional = node2.optional;
        }
        if (has(node2, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache) : node2.typeAnnotation;
        }
      } else if (!has(_index.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_index.NODE_FIELDS[type])) {
          if (has(node2, field)) {
            if (deep) {
              newNode[field] = (0, _index2.isFile)(node2) && field === "comments" ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node2[field];
            }
          }
        }
      }
      if (has(node2, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node2.loc;
        }
      }
      if (has(node2, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "extra")) {
        newNode.extra = Object.assign({}, node2.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment2) => {
        const cache = commentsCache.get(comment2);
        if (cache)
          return cache;
        const {
          type,
          value,
          loc
        } = comment2;
        const ret = {
          type,
          value,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment2, ret);
        return ret;
      });
    }
  }
});

// node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node2) {
      return (0, _cloneNode.default)(node2, false);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeep2;
    var _cloneNode = require_cloneNode();
    function cloneDeep2(node2) {
      return (0, _cloneNode.default)(node2);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node2) {
      return (0, _cloneNode.default)(node2, true, true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node2) {
      return (0, _cloneNode.default)(node2, false, true);
    }
  }
});

// node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComments;
    function addComments(node2, type, comments) {
      if (!comments || !node2)
        return node2;
      const key = `${type}Comments`;
      if (node2[key]) {
        if (type === "leading") {
          node2[key] = comments.concat(node2[key]);
        } else {
          node2[key].push(...comments);
        }
      } else {
        node2[key] = comments;
      }
      return node2;
    }
  }
});

// node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComment;
    var _addComments = require_addComments();
    function addComment(node2, type, content3, line) {
      return (0, _addComments.default)(node2, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content3
      }]);
    }
  }
});

// node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherit2;
    function inherit2(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeComments;
    var _index = require_constants();
    function removeComments(node2) {
      _index.COMMENT_KEYS.forEach((key) => {
        node2[key] = null;
      });
      return node2;
    }
  }
});

// node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _index = require_definitions();
    var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  }
});

// node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBlock;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toBlock(node2, parent) {
      if ((0, _index.isBlockStatement)(node2)) {
        return node2;
      }
      let blockNodes = [];
      if ((0, _index.isEmptyStatement)(node2)) {
        blockNodes = [];
      } else {
        if (!(0, _index.isStatement)(node2)) {
          if ((0, _index.isFunction)(parent)) {
            node2 = (0, _index2.returnStatement)(node2);
          } else {
            node2 = (0, _index2.expressionStatement)(node2);
          }
        }
        blockNodes = [node2];
      }
      return (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node2, key = "body") {
      const result = (0, _toBlock.default)(node2[key], node2);
      node2[key] = result;
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toIdentifier2;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    function toIdentifier2(input) {
      input = input + "";
      let name2 = "";
      for (const c of input) {
        name2 += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name2 = name2.replace(/^[-0-9]+/, "");
      name2 = name2.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name2)) {
        name2 = `_${name2}`;
      }
      return name2 || "_";
    }
  }
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name2) {
      name2 = (0, _toIdentifier.default)(name2);
      if (name2 === "eval" || name2 === "arguments")
        name2 = "_" + name2;
      return name2;
    }
  }
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toComputedKey;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toComputedKey(node2, key = node2.key || node2.property) {
      if (!node2.computed && (0, _index.isIdentifier)(key))
        key = (0, _index2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _default = exports.default = toExpression;
    function toExpression(node2) {
      if ((0, _index.isExpressionStatement)(node2)) {
        node2 = node2.expression;
      }
      if ((0, _index.isExpression)(node2)) {
        return node2;
      }
      if ((0, _index.isClass)(node2)) {
        node2.type = "ClassExpression";
      } else if ((0, _index.isFunction)(node2)) {
        node2.type = "FunctionExpression";
      }
      if (!(0, _index.isExpression)(node2)) {
        throw new Error(`cannot turn ${node2.type} to an expression`);
      }
      return node2;
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverseFast;
    var _index = require_definitions();
    function traverseFast(node2, enter, opts) {
      if (!node2)
        return;
      const keys2 = _index.VISITOR_KEYS[node2.type];
      if (!keys2)
        return;
      opts = opts || {};
      enter(node2, opts);
      for (const key of keys2) {
        const subNode = node2[key];
        if (Array.isArray(subNode)) {
          for (const node3 of subNode) {
            traverseFast(node3, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeProperties;
    var _index = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node2, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node2[key] != null)
          node2[key] = void 0;
      }
      for (const key of Object.keys(node2)) {
        if (key[0] === "_" && node2[key] != null)
          node2[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node2);
      for (const sym of symbols) {
        node2[sym] = null;
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toKeyAlias;
    var _index = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node2, key = node2.key) {
      let alias;
      if (node2.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node2.computed) {
        alias = `[${alias}]`;
      }
      if (node2.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _index2 = require_generated2();
    var _default = exports.default = toStatement;
    function toStatement(node2, ignore3) {
      if ((0, _index.isStatement)(node2)) {
        return node2;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _index.isClass)(node2)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index.isFunction)(node2)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index.isAssignmentExpression)(node2)) {
        return (0, _index2.expressionStatement)(node2);
      }
      if (mustHaveId && !node2.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore3) {
          return false;
        } else {
          throw new Error(`cannot turn ${node2.type} to a statement`);
        }
      }
      node2.type = newType;
      return node2;
    }
  }
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _index = require_generated2();
    var _default = exports.default = valueToNode;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject2(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _index.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _index.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _index.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _index.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _index.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _index.numericLiteral)(0);
          } else {
            numerator = (0, _index.numericLiteral)(1);
          }
          result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _index.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _index.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _index.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject2(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _index.identifier)(key);
          } else {
            nodeKey = (0, _index.stringLiteral)(key);
          }
          props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _index.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherits;
    var _index = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      for (const key of _index.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _index.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prependToMemberExpression;
    var _index = require_generated2();
    var _index2 = require_lib3();
    function prependToMemberExpression(member, prepend) {
      if ((0, _index2.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _index.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node2, duplicates, outerOnly, newBindingsOnly) {
      const search2 = [].concat(node2);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search2.length) {
        const id = search2.shift();
        if (!id)
          continue;
        if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id))) {
          continue;
        }
        const keys2 = getBindingIdentifiers.keys[id.type];
        if ((0, _index.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
          if ((0, _index.isDeclaration)(id.declaration)) {
            search2.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id)) {
            search2.push(id.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id)) {
            continue;
          }
        }
        if (keys2) {
          for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const nodes = id[key];
            if (nodes) {
              Array.isArray(nodes) ? search2.push(...nodes) : search2.push(nodes);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
  }
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = exports.default = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node2, duplicates) {
      return (0, _getBindingIdentifiers.default)(node2, duplicates, true);
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverse;
    var _index = require_definitions();
    function traverse(node2, handlers3, state) {
      if (typeof handlers3 === "function") {
        handlers3 = {
          enter: handlers3
        };
      }
      const {
        enter,
        exit: exit2
      } = handlers3;
      traverseSimpleImpl(node2, enter, exit2, state, []);
    }
    function traverseSimpleImpl(node2, enter, exit2, state, ancestors) {
      const keys2 = _index.VISITOR_KEYS[node2.type];
      if (!keys2)
        return;
      if (enter)
        enter(node2, ancestors, state);
      for (const key of keys2) {
        const subNode = node2[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child)
              continue;
            ancestors.push({
              node: node2,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit2, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node: node2,
            key
          });
          traverseSimpleImpl(subNode, enter, exit2, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit2)
        exit2(node2, ancestors, state);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node2, parent, grandparent) {
      if (grandparent && node2.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys2 = _getBindingIdentifiers.default.keys[parent.type];
      if (keys2) {
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node2) >= 0)
              return true;
          } else {
            if (val === node2)
              return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLet;
    var _index = require_generated();
    var _index2 = require_constants();
    function isLet(node2) {
      return (0, _index.isVariableDeclaration)(node2) && (node2.kind !== "var" || node2[_index2.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBlockScoped;
    var _index = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node2) {
      return (0, _index.isFunctionDeclaration)(node2) || (0, _index.isClassDeclaration)(node2) || (0, _isLet.default)(node2);
    }
  }
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isImmutable;
    var _isType = require_isType();
    var _index = require_generated();
    function isImmutable(node2) {
      if ((0, _isType.default)(node2.type, "Immutable"))
        return true;
      if ((0, _index.isIdentifier)(node2)) {
        if (node2.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _index.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isReferenced;
    function isReferenced(node2, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node2) {
            return !!parent.computed;
          }
          return parent.object === node2;
        case "JSXMemberExpression":
          return parent.object === node2;
        case "VariableDeclarator":
          return parent.init === node2;
        case "ArrowFunctionExpression":
          return parent.body === node2;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node2;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node2;
        case "AssignmentExpression":
          return parent.right === node2;
        case "AssignmentPattern":
          return parent.right === node2;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node2;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node2;
        case "TSEnumMember":
          return parent.id !== node2;
        case "TSPropertySignature":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isScope;
    var _index = require_generated();
    function isScope(node2, parent) {
      if ((0, _index.isBlockStatement)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _index.isPattern)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return true;
      }
      return (0, _index.isScopable)(node2);
    }
  }
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name2) {
      return (0, _isValidIdentifier.default)(name2) && !RESERVED_WORDS_ES3_ONLY.has(name2);
    }
  }
});

// node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVar;
    var _index = require_generated();
    var _index2 = require_constants();
    function isVar(node2) {
      return (0, _index.isVariableDeclaration)(node2, {
        kind: "var"
      }) && !node2[_index2.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _index = require_generated();
    var _index2 = require_generated2();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, scope, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node2 of nodes) {
        if (!(0, _index.isEmptyStatement)(node2)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node2)) {
          exprs.push(node2);
        } else if ((0, _index.isExpressionStatement)(node2)) {
          exprs.push(node2.expression);
        } else if ((0, _index.isVariableDeclaration)(node2)) {
          if (node2.kind !== "var")
            return;
          for (const declar of node2.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node2.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node2)) {
          const consequent = node2.consequent ? gatherSequenceExpressions([node2.consequent], scope, declars) : scope.buildUndefinedNode();
          const alternate = node2.alternate ? gatherSequenceExpressions([node2.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push((0, _index2.conditionalExpression)(node2.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node2)) {
          const body = gatherSequenceExpressions(node2.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node2)) {
          if (nodes.indexOf(node2) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length))
        return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
      if (!result)
        return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/@babel/types/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index2[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _uppercase[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
    var _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _productions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index3[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index4[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index5[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _traverse[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index6[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var react = exports.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    {
      exports.toSequenceExpression = require_toSequenceExpression().default;
    }
  }
});

// node_modules/@putout/babel/bundle/index.js
var require_bundle = __commonJS({
  "node_modules/@putout/babel/bundle/index.js"(exports, module2) {
    function _array_like_to_array(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _array_with_holes(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _array_without_holes(arr) {
      if (Array.isArray(arr))
        return _array_like_to_array(arr);
    }
    function _assert_this_initialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _class_call_check(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _create_class(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _define_property(obj, key, value1) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value1,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value1;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function get3(target2, property2, receiver2) {
          var base = _super_prop_base(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2 || target2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _get_prototype_of(o) {
      _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _get_prototype_of(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _set_prototype_of(subClass, superClass);
    }
    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }
    function _iterable_to_array(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _iterable_to_array_limit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _non_iterable_rest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _non_iterable_spread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _object_spread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _possible_constructor_return(self2, call2) {
      if (call2 && (_type_of(call2) === "object" || typeof call2 === "function")) {
        return call2;
      }
      return _assert_this_initialized(self2);
    }
    function _set_prototype_of(o, p) {
      _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _set_prototype_of(o, p);
    }
    function _sliced_to_array(arr, i2) {
      return _array_with_holes(arr) || _iterable_to_array_limit(arr, i2) || _unsupported_iterable_to_array(arr, i2) || _non_iterable_rest();
    }
    function _super_prop_base(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _get_prototype_of(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _tagged_template_literal(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _to_consumable_array(arr) {
      return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
    }
    function _type_of(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }
    function _unsupported_iterable_to_array(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _array_like_to_array(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _array_like_to_array(o, minLen);
    }
    function _is_native_reflect_construct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _create_super(Derived) {
      var hasNativeReflectConstruct = _is_native_reflect_construct();
      return function _createSuperInternal() {
        var Super2 = _get_prototype_of(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _get_prototype_of(this).constructor;
          result = Reflect.construct(Super2, arguments, NewTarget);
        } else {
          result = Super2.apply(this, arguments);
        }
        return _possible_constructor_return(this, result);
      };
    }
    function _ts_generator(thisArg, body) {
      var f, y, t2, g, _ = {
        label: 0,
        sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        },
        trys: [],
        ops: []
      };
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([
            n2,
            v
          ]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
              return t2;
            if (y = 0, t2)
              op = [
                op[0] & 2,
                t2.value
              ];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [
                  0
                ];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [
              6,
              e
            ];
            y = 0;
          } finally {
            f = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }
    function _templateObject() {
      var data2 = _tagged_template_literal([
        "pipelineOperator"
      ]);
      _templateObject = function _templateObject5() {
        return data2;
      };
      return data2;
    }
    function _templateObject1() {
      var data2 = _tagged_template_literal([
        "flow"
      ]);
      _templateObject1 = function _templateObject5() {
        return data2;
      };
      return data2;
    }
    function _templateObject2() {
      var data2 = _tagged_template_literal([
        "jsx"
      ]);
      _templateObject2 = function _templateObject5() {
        return data2;
      };
      return data2;
    }
    function _templateObject3() {
      var data2 = _tagged_template_literal([
        "typescript"
      ]);
      _templateObject3 = function _templateObject5() {
        return data2;
      };
      return data2;
    }
    function _templateObject4() {
      var data2 = _tagged_template_literal([
        "placeholders"
      ]);
      _templateObject4 = function _templateObject5() {
        return data2;
      };
      return data2;
    }
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __defNormalProp = function(obj, key, value1) {
      return key in obj ? __defProp2(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value1
      }) : obj[key] = value1;
    };
    var __commonJS2 = function(cb, mod) {
      return function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {
          exports: {}
        }).exports, mod), mod.exports;
      };
    };
    var __export2 = function(target, all3) {
      for (var name2 in all3)
        __defProp2(target, name2, {
          get: all3[name2],
          enumerable: true
        });
    };
    var __copyProps2 = function(to, from, except, desc) {
      if (from && typeof from === "object" || typeof from === "function") {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          var _loop5 = function() {
            var key = _step8.value;
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, {
                get: function() {
                  return from[key];
                },
                enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
              });
          };
          for (var _iterator8 = __getOwnPropNames2(from)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true)
            _loop5();
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      return to;
    };
    var __toESM2 = function(mod, isNodeMode, target) {
      return target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
          value: mod,
          enumerable: true
        }) : target,
        mod
      );
    };
    var __toCommonJS2 = function(mod) {
      return __copyProps2(__defProp2({}, "__esModule", {
        value: true
      }), mod);
    };
    var __publicField = function(obj, key, value1) {
      __defNormalProp(obj, (typeof key === "undefined" ? "undefined" : _type_of(key)) !== "symbol" ? key + "" : key, value1);
      return value1;
    };
    var require_to_fast_properties2 = __commonJS2({
      "node_modules/to-fast-properties/index.js": function(exports2, module22) {
        "use strict";
        var fastProto = null;
        function FastObject(o) {
          if (fastProto !== null && _type_of(fastProto.property)) {
            var result = fastProto;
            fastProto = FastObject.prototype = null;
            return result;
          }
          fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o;
          return new FastObject();
        }
        var inlineCacheCutoff = 10;
        for (var i2 = 0; i2 <= inlineCacheCutoff; i2++) {
          FastObject();
        }
        module22.exports = function toFastproperties(o) {
          return FastObject(o);
        };
      }
    });
    var require_js_tokens2 = __commonJS2({
      "node_modules/@babel/highlight/node_modules/js-tokens/index.js": function(exports2, module22) {
        var Identifier2;
        var JSXIdentifier2;
        var JSXPunctuator;
        var JSXString;
        var JSXText2;
        var KeywordsWithExpressionAfter;
        var KeywordsWithNoLineTerminatorAfter;
        var LineTerminatorSequence;
        var MultiLineComment;
        var Newline;
        var NumericLiteral3;
        var Punctuator;
        var RegularExpressionLiteral;
        var SingleLineComment;
        var StringLiteral3;
        var Template;
        var TokensNotPrecedingObjectLiteral;
        var TokensPrecedingExpression;
        var WhiteSpace;
        var jsTokens2;
        RegularExpressionLiteral = RegExp("\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?", "yu");
        Punctuator = RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
        Identifier2 = RegExp("(\\x23?)(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+", "yu");
        StringLiteral3 = RegExp(`(['"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?`, "y");
        NumericLiteral3 = RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
        Template = RegExp("[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
        WhiteSpace = RegExp("[\\t\\v\\f\\ufeff\\p{Zs}]+", "yu");
        LineTerminatorSequence = RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
        MultiLineComment = RegExp("\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?", "y");
        SingleLineComment = RegExp("\\/\\/.*", "y");
        JSXPunctuator = RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
        JSXIdentifier2 = RegExp("[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*", "yu");
        JSXString = RegExp(`(['"])(?:(?!\\1)[^])*(\\1)?`, "y");
        JSXText2 = RegExp("[^<>{}]+", "y");
        TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
        TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
        KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
        KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
        Newline = RegExp(LineTerminatorSequence.source);
        module22.exports = jsTokens2 = function jsTokens22(input) {
          var _ref, tmp, jsx22, braces, firstCodePoint, isExpression3, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack, _, _1, _2;
          var _arguments = arguments;
          return _ts_generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                _ref = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, tmp = _ref.jsx, jsx22 = tmp === void 0 ? false : tmp;
                length = input.length;
                lastIndex = 0;
                lastSignificantToken = "";
                stack = [
                  {
                    tag: "JS"
                  }
                ];
                braces = [];
                parenNesting = 0;
                postfixIncDec = false;
                _state.label = 1;
              case 1:
                if (!(lastIndex < length))
                  return [
                    3,
                    62
                  ];
                mode = stack[stack.length - 1];
                _ = mode.tag;
                switch (_) {
                  case "JS":
                    return [
                      3,
                      2
                    ];
                  case "JSNonExpressionParen":
                    return [
                      3,
                      2
                    ];
                  case "InterpolationInTemplate":
                    return [
                      3,
                      2
                    ];
                  case "InterpolationInJSX":
                    return [
                      3,
                      2
                    ];
                  case "JSXTag":
                    return [
                      3,
                      38
                    ];
                  case "JSXTagEnd":
                    return [
                      3,
                      38
                    ];
                  case "JSXChildren":
                    return [
                      3,
                      45
                    ];
                }
                return [
                  3,
                  52
                ];
              case 2:
                if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))))
                  return [
                    3,
                    4
                  ];
                RegularExpressionLiteral.lastIndex = lastIndex;
                if (!(match = RegularExpressionLiteral.exec(input)))
                  return [
                    3,
                    4
                  ];
                lastIndex = RegularExpressionLiteral.lastIndex;
                lastSignificantToken = match[0];
                postfixIncDec = true;
                return [
                  4,
                  {
                    type: "RegularExpressionLiteral",
                    value: match[0],
                    closed: match[1] !== void 0 && match[1] !== "\\"
                  }
                ];
              case 3:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 4:
                Punctuator.lastIndex = lastIndex;
                if (!(match = Punctuator.exec(input)))
                  return [
                    3,
                    26
                  ];
                punctuator = match[0];
                nextLastIndex = Punctuator.lastIndex;
                nextLastSignificantToken = punctuator;
                switch (punctuator) {
                  case "(":
                    return [
                      3,
                      5
                    ];
                  case ")":
                    return [
                      3,
                      6
                    ];
                  case "{":
                    return [
                      3,
                      7
                    ];
                  case "}":
                    return [
                      3,
                      8
                    ];
                  case "]":
                    return [
                      3,
                      18
                    ];
                  case "++":
                    return [
                      3,
                      19
                    ];
                  case "--":
                    return [
                      3,
                      19
                    ];
                  case "<":
                    return [
                      3,
                      20
                    ];
                }
                return [
                  3,
                  23
                ];
              case 5:
                if (lastSignificantToken === "?NonExpressionParenKeyword") {
                  stack.push({
                    tag: "JSNonExpressionParen",
                    nesting: parenNesting
                  });
                }
                parenNesting++;
                postfixIncDec = false;
                return [
                  3,
                  24
                ];
              case 6:
                parenNesting--;
                postfixIncDec = true;
                if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
                  stack.pop();
                  nextLastSignificantToken = "?NonExpressionParenEnd";
                  postfixIncDec = false;
                }
                return [
                  3,
                  24
                ];
              case 7:
                Punctuator.lastIndex = 0;
                isExpression3 = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                braces.push(isExpression3);
                postfixIncDec = false;
                return [
                  3,
                  24
                ];
              case 8:
                _1 = mode.tag;
                switch (_1) {
                  case "InterpolationInTemplate":
                    return [
                      3,
                      9
                    ];
                  case "InterpolationInJSX":
                    return [
                      3,
                      15
                    ];
                }
                return [
                  3,
                  17
                ];
              case 9:
                if (!(braces.length === mode.nesting))
                  return [
                    3,
                    14
                  ];
                Template.lastIndex = lastIndex;
                match = Template.exec(input);
                lastIndex = Template.lastIndex;
                lastSignificantToken = match[0];
                if (!(match[1] === "${"))
                  return [
                    3,
                    11
                  ];
                lastSignificantToken = "?InterpolationInTemplate";
                postfixIncDec = false;
                return [
                  4,
                  {
                    type: "TemplateMiddle",
                    value: match[0]
                  }
                ];
              case 10:
                _state.sent();
                return [
                  3,
                  13
                ];
              case 11:
                stack.pop();
                postfixIncDec = true;
                return [
                  4,
                  {
                    type: "TemplateTail",
                    value: match[0],
                    closed: match[1] === "`"
                  }
                ];
              case 12:
                _state.sent();
                _state.label = 13;
              case 13:
                return [
                  3,
                  1
                ];
              case 14:
                return [
                  3,
                  17
                ];
              case 15:
                if (!(braces.length === mode.nesting))
                  return [
                    3,
                    17
                  ];
                stack.pop();
                lastIndex += 1;
                lastSignificantToken = "}";
                return [
                  4,
                  {
                    type: "JSXPunctuator",
                    value: "}"
                  }
                ];
              case 16:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 17:
                postfixIncDec = braces.pop();
                nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                return [
                  3,
                  24
                ];
              case 18:
                postfixIncDec = true;
                return [
                  3,
                  24
                ];
              case 19:
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                return [
                  3,
                  24
                ];
              case 20:
                if (!(jsx22 && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))))
                  return [
                    3,
                    22
                  ];
                stack.push({
                  tag: "JSXTag"
                });
                lastIndex += 1;
                lastSignificantToken = "<";
                return [
                  4,
                  {
                    type: "JSXPunctuator",
                    value: punctuator
                  }
                ];
              case 21:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 22:
                postfixIncDec = false;
                return [
                  3,
                  24
                ];
              case 23:
                postfixIncDec = false;
                _state.label = 24;
              case 24:
                lastIndex = nextLastIndex;
                lastSignificantToken = nextLastSignificantToken;
                return [
                  4,
                  {
                    type: "Punctuator",
                    value: punctuator
                  }
                ];
              case 25:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 26:
                Identifier2.lastIndex = lastIndex;
                if (!(match = Identifier2.exec(input)))
                  return [
                    3,
                    28
                  ];
                lastIndex = Identifier2.lastIndex;
                nextLastSignificantToken = match[0];
                switch (match[0]) {
                  case "for":
                  case "if":
                  case "while":
                  case "with":
                    if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                      nextLastSignificantToken = "?NonExpressionParenKeyword";
                    }
                }
                lastSignificantToken = nextLastSignificantToken;
                postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
                return [
                  4,
                  {
                    type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
                    value: match[0]
                  }
                ];
              case 27:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 28:
                StringLiteral3.lastIndex = lastIndex;
                if (!(match = StringLiteral3.exec(input)))
                  return [
                    3,
                    30
                  ];
                lastIndex = StringLiteral3.lastIndex;
                lastSignificantToken = match[0];
                postfixIncDec = true;
                return [
                  4,
                  {
                    type: "StringLiteral",
                    value: match[0],
                    closed: match[2] !== void 0
                  }
                ];
              case 29:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 30:
                NumericLiteral3.lastIndex = lastIndex;
                if (!(match = NumericLiteral3.exec(input)))
                  return [
                    3,
                    32
                  ];
                lastIndex = NumericLiteral3.lastIndex;
                lastSignificantToken = match[0];
                postfixIncDec = true;
                return [
                  4,
                  {
                    type: "NumericLiteral",
                    value: match[0]
                  }
                ];
              case 31:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 32:
                Template.lastIndex = lastIndex;
                if (!(match = Template.exec(input)))
                  return [
                    3,
                    37
                  ];
                lastIndex = Template.lastIndex;
                lastSignificantToken = match[0];
                if (!(match[1] === "${"))
                  return [
                    3,
                    34
                  ];
                lastSignificantToken = "?InterpolationInTemplate";
                stack.push({
                  tag: "InterpolationInTemplate",
                  nesting: braces.length
                });
                postfixIncDec = false;
                return [
                  4,
                  {
                    type: "TemplateHead",
                    value: match[0]
                  }
                ];
              case 33:
                _state.sent();
                return [
                  3,
                  36
                ];
              case 34:
                postfixIncDec = true;
                return [
                  4,
                  {
                    type: "NoSubstitutionTemplate",
                    value: match[0],
                    closed: match[1] === "`"
                  }
                ];
              case 35:
                _state.sent();
                _state.label = 36;
              case 36:
                return [
                  3,
                  1
                ];
              case 37:
                return [
                  3,
                  52
                ];
              case 38:
                JSXPunctuator.lastIndex = lastIndex;
                if (!(match = JSXPunctuator.exec(input)))
                  return [
                    3,
                    40
                  ];
                lastIndex = JSXPunctuator.lastIndex;
                nextLastSignificantToken = match[0];
                switch (match[0]) {
                  case "<":
                    stack.push({
                      tag: "JSXTag"
                    });
                    break;
                  case ">":
                    stack.pop();
                    if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
                      nextLastSignificantToken = "?JSX";
                      postfixIncDec = true;
                    } else {
                      stack.push({
                        tag: "JSXChildren"
                      });
                    }
                    break;
                  case "{":
                    stack.push({
                      tag: "InterpolationInJSX",
                      nesting: braces.length
                    });
                    nextLastSignificantToken = "?InterpolationInJSX";
                    postfixIncDec = false;
                    break;
                  case "/":
                    if (lastSignificantToken === "<") {
                      stack.pop();
                      if (stack[stack.length - 1].tag === "JSXChildren") {
                        stack.pop();
                      }
                      stack.push({
                        tag: "JSXTagEnd"
                      });
                    }
                }
                lastSignificantToken = nextLastSignificantToken;
                return [
                  4,
                  {
                    type: "JSXPunctuator",
                    value: match[0]
                  }
                ];
              case 39:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 40:
                JSXIdentifier2.lastIndex = lastIndex;
                if (!(match = JSXIdentifier2.exec(input)))
                  return [
                    3,
                    42
                  ];
                lastIndex = JSXIdentifier2.lastIndex;
                lastSignificantToken = match[0];
                return [
                  4,
                  {
                    type: "JSXIdentifier",
                    value: match[0]
                  }
                ];
              case 41:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 42:
                JSXString.lastIndex = lastIndex;
                if (!(match = JSXString.exec(input)))
                  return [
                    3,
                    44
                  ];
                lastIndex = JSXString.lastIndex;
                lastSignificantToken = match[0];
                return [
                  4,
                  {
                    type: "JSXString",
                    value: match[0],
                    closed: match[2] !== void 0
                  }
                ];
              case 43:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 44:
                return [
                  3,
                  52
                ];
              case 45:
                JSXText2.lastIndex = lastIndex;
                if (!(match = JSXText2.exec(input)))
                  return [
                    3,
                    47
                  ];
                lastIndex = JSXText2.lastIndex;
                lastSignificantToken = match[0];
                return [
                  4,
                  {
                    type: "JSXText",
                    value: match[0]
                  }
                ];
              case 46:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 47:
                _2 = input[lastIndex];
                switch (_2) {
                  case "<":
                    return [
                      3,
                      48
                    ];
                  case "{":
                    return [
                      3,
                      50
                    ];
                }
                return [
                  3,
                  52
                ];
              case 48:
                stack.push({
                  tag: "JSXTag"
                });
                lastIndex++;
                lastSignificantToken = "<";
                return [
                  4,
                  {
                    type: "JSXPunctuator",
                    value: "<"
                  }
                ];
              case 49:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 50:
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                });
                lastIndex++;
                lastSignificantToken = "?InterpolationInJSX";
                postfixIncDec = false;
                return [
                  4,
                  {
                    type: "JSXPunctuator",
                    value: "{"
                  }
                ];
              case 51:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 52:
                WhiteSpace.lastIndex = lastIndex;
                if (!(match = WhiteSpace.exec(input)))
                  return [
                    3,
                    54
                  ];
                lastIndex = WhiteSpace.lastIndex;
                return [
                  4,
                  {
                    type: "WhiteSpace",
                    value: match[0]
                  }
                ];
              case 53:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 54:
                LineTerminatorSequence.lastIndex = lastIndex;
                if (!(match = LineTerminatorSequence.exec(input)))
                  return [
                    3,
                    56
                  ];
                lastIndex = LineTerminatorSequence.lastIndex;
                postfixIncDec = false;
                if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                  lastSignificantToken = "?NoLineTerminatorHere";
                }
                return [
                  4,
                  {
                    type: "LineTerminatorSequence",
                    value: match[0]
                  }
                ];
              case 55:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 56:
                MultiLineComment.lastIndex = lastIndex;
                if (!(match = MultiLineComment.exec(input)))
                  return [
                    3,
                    58
                  ];
                lastIndex = MultiLineComment.lastIndex;
                if (Newline.test(match[0])) {
                  postfixIncDec = false;
                  if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                    lastSignificantToken = "?NoLineTerminatorHere";
                  }
                }
                return [
                  4,
                  {
                    type: "MultiLineComment",
                    value: match[0],
                    closed: match[1] !== void 0
                  }
                ];
              case 57:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 58:
                SingleLineComment.lastIndex = lastIndex;
                if (!(match = SingleLineComment.exec(input)))
                  return [
                    3,
                    60
                  ];
                lastIndex = SingleLineComment.lastIndex;
                postfixIncDec = false;
                return [
                  4,
                  {
                    type: "SingleLineComment",
                    value: match[0]
                  }
                ];
              case 59:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 60:
                firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
                lastIndex += firstCodePoint.length;
                lastSignificantToken = firstCodePoint;
                postfixIncDec = false;
                return [
                  4,
                  {
                    type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
                    value: firstCodePoint
                  }
                ];
              case 61:
                _state.sent();
                return [
                  3,
                  1
                ];
              case 62:
                return [
                  2,
                  void 0
                ];
            }
          });
        };
      }
    });
    var require_jsesc2 = __commonJS2({
      "node_modules/jsesc/jsesc.js": function(exports2, module22) {
        "use strict";
        var object = {};
        var hasOwnProperty3 = object.hasOwnProperty;
        var forOwn = function(object2, callback) {
          for (var key in object2) {
            if (hasOwnProperty3.call(object2, key)) {
              callback(key, object2[key]);
            }
          }
        };
        var extend3 = function(destination, source) {
          if (!source) {
            return destination;
          }
          forOwn(source, function(key, value1) {
            destination[key] = value1;
          });
          return destination;
        };
        var forEach = function(array, callback) {
          var length = array.length;
          var index3 = -1;
          while (++index3 < length) {
            callback(array[index3]);
          }
        };
        var fourHexEscape = function(hex) {
          return "\\u" + ("0000" + hex).slice(-4);
        };
        var hexadecimal = function(code22, lowercase) {
          var hexadecimal2 = code22.toString(16);
          if (lowercase)
            return hexadecimal2;
          return hexadecimal2.toUpperCase();
        };
        var toString4 = object.toString;
        var isArray2 = Array.isArray;
        var isBuffer = function(value1) {
          return typeof Buffer === "function" && Buffer.isBuffer(value1);
        };
        var isObject = function(value1) {
          return toString4.call(value1) == "[object Object]";
        };
        var isString = function(value1) {
          return typeof value1 == "string" || toString4.call(value1) == "[object String]";
        };
        var isNumber2 = function(value1) {
          return typeof value1 == "number" || toString4.call(value1) == "[object Number]";
        };
        var isFunction5 = function(value1) {
          return typeof value1 == "function";
        };
        var isMap = function(value1) {
          return toString4.call(value1) == "[object Map]";
        };
        var isSet = function(value1) {
          return toString4.call(value1) == "[object Set]";
        };
        var singleEscapes = {
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t"
        };
        var regexSingleEscape = /[\\\b\f\n\r\t]/;
        var regexDigit = /[0-9]/;
        var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
        var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
        var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
        var jsesc2 = function(argument, options) {
          var increaseIndentation = function() {
            oldIndent = indent2;
            ++options.indentLevel;
            indent2 = options.indent.repeat(options.indentLevel);
          };
          var defaults = {
            "escapeEverything": false,
            "minimal": false,
            "isScriptContext": false,
            "quotes": "single",
            "wrap": false,
            "es6": false,
            "json": false,
            "compact": true,
            "lowercaseHex": false,
            "numbers": "decimal",
            "indent": "	",
            "indentLevel": 0,
            "__inline1__": false,
            "__inline2__": false
          };
          var json = options && options.json;
          if (json) {
            defaults.quotes = "double";
            defaults.wrap = true;
          }
          options = extend3(defaults, options);
          if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
            options.quotes = "single";
          }
          var quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
          var compact = options.compact;
          var lowercaseHex = options.lowercaseHex;
          var indent2 = options.indent.repeat(options.indentLevel);
          var oldIndent = "";
          var inline1 = options.__inline1__;
          var inline2 = options.__inline2__;
          var newLine = compact ? "" : "\n";
          var result;
          var isEmpty = true;
          var useBinNumbers = options.numbers == "binary";
          var useOctNumbers = options.numbers == "octal";
          var useDecNumbers = options.numbers == "decimal";
          var useHexNumbers = options.numbers == "hexadecimal";
          if (json && argument && isFunction5(argument.toJSON)) {
            argument = argument.toJSON();
          }
          if (!isString(argument)) {
            if (isMap(argument)) {
              if (argument.size == 0) {
                return "new Map()";
              }
              if (!compact) {
                options.__inline1__ = true;
                options.__inline2__ = false;
              }
              return "new Map(" + jsesc2(Array.from(argument), options) + ")";
            }
            if (isSet(argument)) {
              if (argument.size == 0) {
                return "new Set()";
              }
              return "new Set(" + jsesc2(Array.from(argument), options) + ")";
            }
            if (isBuffer(argument)) {
              if (argument.length == 0) {
                return "Buffer.from([])";
              }
              return "Buffer.from(" + jsesc2(Array.from(argument), options) + ")";
            }
            if (isArray2(argument)) {
              result = [];
              options.wrap = true;
              if (inline1) {
                options.__inline1__ = false;
                options.__inline2__ = true;
              }
              if (!inline2) {
                increaseIndentation();
              }
              forEach(argument, function(value1) {
                isEmpty = false;
                if (inline2) {
                  options.__inline2__ = false;
                }
                result.push((compact || inline2 ? "" : indent2) + jsesc2(value1, options));
              });
              if (isEmpty) {
                return "[]";
              }
              if (inline2) {
                return "[" + result.join(", ") + "]";
              }
              return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
            } else if (isNumber2(argument)) {
              if (json) {
                return JSON.stringify(argument);
              }
              if (useDecNumbers) {
                return String(argument);
              }
              if (useHexNumbers) {
                var hexadecimal2 = argument.toString(16);
                if (!lowercaseHex) {
                  hexadecimal2 = hexadecimal2.toUpperCase();
                }
                return "0x" + hexadecimal2;
              }
              if (useBinNumbers) {
                return "0b" + argument.toString(2);
              }
              if (useOctNumbers) {
                return "0o" + argument.toString(8);
              }
            } else if (!isObject(argument)) {
              if (json) {
                return JSON.stringify(argument) || "null";
              }
              return String(argument);
            } else {
              result = [];
              options.wrap = true;
              increaseIndentation();
              forOwn(argument, function(key, value1) {
                isEmpty = false;
                result.push((compact ? "" : indent2) + jsesc2(key, options) + ":" + (compact ? "" : " ") + jsesc2(value1, options));
              });
              if (isEmpty) {
                return "{}";
              }
              return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
            }
          }
          var regex2 = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
          result = argument.replace(regex2, function(char, pair, lone, quoteChar, index3, string3) {
            if (pair) {
              if (options.minimal)
                return pair;
              var first = pair.charCodeAt(0);
              var second = pair.charCodeAt(1);
              if (options.es6) {
                var codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                var hex2 = hexadecimal(codePoint, lowercaseHex);
                return "\\u{" + hex2 + "}";
              }
              return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
            }
            if (lone) {
              return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
            }
            if (char == "\0" && !json && !regexDigit.test(string3.charAt(index3 + 1))) {
              return "\\0";
            }
            if (quoteChar) {
              if (quoteChar == quote || options.escapeEverything) {
                return "\\" + quoteChar;
              }
              return quoteChar;
            }
            if (regexSingleEscape.test(char)) {
              return singleEscapes[char];
            }
            if (options.minimal && !regexWhitespace.test(char)) {
              return char;
            }
            var hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
            if (json || hex.length > 2) {
              return fourHexEscape(hex);
            }
            return "\\x" + ("00" + hex).slice(-2);
          });
          if (quote == "`") {
            result = result.replace(/\$\{/g, "\\${");
          }
          if (options.isScriptContext) {
            result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
          }
          if (options.wrap) {
            result = quote + result + quote;
          }
          return result;
        };
        jsesc2.version = "3.0.2";
        module22.exports = jsesc2;
      }
    });
    var require_ms2 = __commonJS2({
      "node_modules/ms/index.js": function(exports2, module22) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module22.exports = function(val, options) {
          options = options || {};
          var type3 = typeof val === "undefined" ? "undefined" : _type_of(val);
          if (type3 === "string" && val.length > 0) {
            return parse22(val);
          } else if (type3 === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse22(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) {
            return;
          }
          var n2 = parseFloat(match[1]);
          var type3 = (match[2] || "ms").toLowerCase();
          switch (type3) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n2 * y;
            case "weeks":
            case "week":
            case "w":
              return n2 * w;
            case "days":
            case "day":
            case "d":
              return n2 * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n2 * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n2 * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n2 * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n2;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n2, name2) {
          var isPlural = msAbs >= n2 * 1.5;
          return Math.round(ms / n2) + " " + name2 + (isPlural ? "s" : "");
        }
      }
    });
    var require_common2 = __commonJS2({
      "node_modules/debug/src/common.js": function(exports2, module22) {
        function setup2(env3) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable2;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require_ms2();
          createDebug.destroy = destroy;
          Object.keys(env3).forEach(function(key) {
            createDebug[key] = env3[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            var hash = 0;
            for (var i2 = 0; i2 < namespace.length; i2++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i2);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            var prevTime;
            var enableOverride = null;
            var namespacesCache;
            var enabledCache;
            function debug2() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (!debug2.enabled) {
                return;
              }
              var self2 = debug2;
              var curr = Number(/* @__PURE__ */ new Date());
              var ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              var index3 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                if (match === "%%") {
                  return "%";
                }
                index3++;
                var formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  var val = args[index3];
                  match = formatter.call(self2, val);
                  args.splice(index3, 1);
                  index3--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              var logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug2.namespace = namespace;
            debug2.useColors = createDebug.useColors();
            debug2.color = createDebug.selectColor(namespace);
            debug2.extend = extend3;
            debug2.destroy = createDebug.destroy;
            Object.defineProperty(debug2, "enabled", {
              enumerable: true,
              configurable: false,
              get: function() {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: function(v) {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug2);
            }
            return debug2;
          }
          function extend3(namespace, delimiter) {
            var newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            var i2;
            var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            var len = split.length;
            for (i2 = 0; i2 < len; i2++) {
              if (!split[i2]) {
                continue;
              }
              namespaces = split[i2].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          function disable2() {
            var namespaces = _to_consumable_array(createDebug.names.map(toNamespace)).concat(_to_consumable_array(createDebug.skips.map(toNamespace).map(function(namespace) {
              return "-" + namespace;
            }))).join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            if (name2[name2.length - 1] === "*") {
              return true;
            }
            var i2;
            var len;
            for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
              if (createDebug.skips[i2].test(name2)) {
                return false;
              }
            }
            for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
              if (createDebug.names[i2].test(name2)) {
                return true;
              }
            }
            return false;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function coerce(val) {
            if (_instanceof(val, Error)) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        module22.exports = setup2;
      }
    });
    var require_browser2 = __commonJS2({
      "node_modules/debug/src/browser.js": function(exports2, module22) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = /* @__PURE__ */ function() {
          var warned2 = false;
          return function() {
            if (!warned2) {
              warned2 = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        }();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
          typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module22.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          var c2 = "color: " + this.color;
          args.splice(1, 0, c2, "color: inherit");
          var index3 = 0;
          var lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, function(match) {
            if (match === "%%") {
              return;
            }
            index3++;
            if (match === "%c") {
              lastC = index3;
            }
          });
          args.splice(lastC, 0, c2);
        }
        exports2.log = console.debug || console.log || function() {
        };
        function save(namespaces) {
          try {
            if (namespaces) {
              exports2.storage.setItem("debug", namespaces);
            } else {
              exports2.storage.removeItem("debug");
            }
          } catch (error) {
          }
        }
        function load() {
          var r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = process.env.DEBUG;
          }
          return r;
        }
        function localstorage() {
          try {
            return localStorage;
          } catch (error) {
          }
        }
        module22.exports = require_common2()(exports2);
        var formatters = module22.exports.formatters;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
          }
        };
      }
    });
    var require_has_flag3 = __commonJS2({
      "node_modules/has-flag/index.js": function(exports2, module22) {
        "use strict";
        module22.exports = function(flag) {
          var argv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : process.argv;
          var prefix2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
          var position3 = argv.indexOf(prefix2 + flag);
          var terminatorPosition = argv.indexOf("--");
          return position3 !== -1 && (terminatorPosition === -1 || position3 < terminatorPosition);
        };
      }
    });
    var require_supports_color3 = __commonJS2({
      "node_modules/supports-color/index.js": function(exports2, module22) {
        "use strict";
        var os3 = require("os");
        var tty3 = require("tty");
        var hasFlag3 = require_has_flag3();
        var env3 = process.env;
        var forceColor;
        if (hasFlag3("no-color") || hasFlag3("no-colors") || hasFlag3("color=false") || hasFlag3("color=never")) {
          forceColor = 0;
        } else if (hasFlag3("color") || hasFlag3("colors") || hasFlag3("color=true") || hasFlag3("color=always")) {
          forceColor = 1;
        }
        if ("FORCE_COLOR" in env3) {
          if (env3.FORCE_COLOR === "true") {
            forceColor = 1;
          } else if (env3.FORCE_COLOR === "false") {
            forceColor = 0;
          } else {
            forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3);
          }
        }
        function translateLevel3(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        }
        function supportsColor3(haveStream, streamIsTTY) {
          if (forceColor === 0) {
            return 0;
          }
          if (hasFlag3("color=16m") || hasFlag3("color=full") || hasFlag3("color=truecolor")) {
            return 3;
          }
          if (hasFlag3("color=256")) {
            return 2;
          }
          if (haveStream && !streamIsTTY && forceColor === void 0) {
            return 0;
          }
          var min = forceColor || 0;
          if (env3.TERM === "dumb") {
            return min;
          }
          if (process.platform === "win32") {
            var osRelease = os3.release().split(".");
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
              return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
          }
          if ("CI" in env3) {
            if ([
              "TRAVIS",
              "CIRCLECI",
              "APPVEYOR",
              "GITLAB_CI",
              "GITHUB_ACTIONS",
              "BUILDKITE"
            ].some(function(sign) {
              return sign in env3;
            }) || env3.CI_NAME === "codeship") {
              return 1;
            }
            return min;
          }
          if ("TEAMCITY_VERSION" in env3) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
          }
          if (env3.COLORTERM === "truecolor") {
            return 3;
          }
          if ("TERM_PROGRAM" in env3) {
            var version2 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env3.TERM_PROGRAM) {
              case "iTerm.app":
                return version2 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          if (/-256(color)?$/i.test(env3.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
            return 1;
          }
          if ("COLORTERM" in env3) {
            return 1;
          }
          return min;
        }
        function getSupportLevel(stream) {
          var level = supportsColor3(stream, stream && stream.isTTY);
          return translateLevel3(level);
        }
        module22.exports = {
          supportsColor: getSupportLevel,
          stdout: translateLevel3(supportsColor3(true, tty3.isatty(1))),
          stderr: translateLevel3(supportsColor3(true, tty3.isatty(2)))
        };
      }
    });
    var require_node3 = __commonJS2({
      "node_modules/debug/src/node.js": function(exports2, module22) {
        var tty3 = require("tty");
        var util = require("util");
        exports2.init = init;
        exports2.log = log;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.destroy = util.deprecate(function() {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        exports2.colors = [
          6,
          2,
          3,
          4,
          5,
          1
        ];
        try {
          var supportsColor3 = require_supports_color3();
          if (supportsColor3 && (supportsColor3.stderr || supportsColor3).level >= 2) {
            exports2.colors = [
              20,
              21,
              26,
              27,
              32,
              33,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              56,
              57,
              62,
              63,
              68,
              69,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              92,
              93,
              98,
              99,
              112,
              113,
              128,
              129,
              134,
              135,
              148,
              149,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              178,
              179,
              184,
              185,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              214,
              215,
              220,
              221
            ];
          }
        } catch (error) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
          return /^debug_/i.test(key);
        }).reduce(function(obj, key) {
          var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
            return k.toUpperCase();
          });
          var val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
        function useColors() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty3.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
          var _this = this, name2 = _this.namespace, useColors2 = _this.useColors;
          if (useColors2) {
            var c2 = this.color;
            var colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
            var prefix2 = "  ".concat(colorCode, ";1m").concat(name2, " \x1B[0m");
            args[0] = prefix2 + args[0].split("\n").join("\n" + prefix2);
            args.push(colorCode + "m+" + module22.exports.humanize(this.diff) + "\x1B[0m");
          } else {
            args[0] = getDate() + name2 + " " + args[0];
          }
        }
        function getDate() {
          if (exports2.inspectOpts.hideDate) {
            return "";
          }
          return /* @__PURE__ */ (/* @__PURE__ */ new Date()).toISOString() + " ";
        }
        function log() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var _util;
          return process.stderr.write((_util = util).format.apply(_util, _to_consumable_array(args)) + "\n");
        }
        function save(namespaces) {
          if (namespaces) {
            process.env.DEBUG = namespaces;
          } else {
            delete process.env.DEBUG;
          }
        }
        function load() {
          return process.env.DEBUG;
        }
        function init(debug2) {
          debug2.inspectOpts = {};
          var keys2 = Object.keys(exports2.inspectOpts);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            debug2.inspectOpts[keys2[i2]] = exports2.inspectOpts[keys2[i2]];
          }
        }
        module22.exports = require_common2()(exports2);
        var formatters = module22.exports.formatters;
        formatters.o = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
            return str.trim();
          }).join(" ");
        };
        formatters.O = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v, this.inspectOpts);
        };
      }
    });
    var require_src2 = __commonJS2({
      "node_modules/debug/src/index.js": function(exports2, module22) {
        if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
          module22.exports = require_browser2();
        } else {
          module22.exports = require_node3();
        }
      }
    });
    var require_globals3 = __commonJS2({
      "node_modules/globals/globals.json": function(exports2, module22) {
        module22.exports = {
          builtin: {
            AggregateError: false,
            Array: false,
            ArrayBuffer: false,
            Atomics: false,
            BigInt: false,
            BigInt64Array: false,
            BigUint64Array: false,
            Boolean: false,
            constructor: false,
            DataView: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            FinalizationRegistry: false,
            Float32Array: false,
            Float64Array: false,
            Function: false,
            globalThis: false,
            hasOwnProperty: false,
            Infinity: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Map: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            Promise: false,
            propertyIsEnumerable: false,
            Proxy: false,
            RangeError: false,
            ReferenceError: false,
            Reflect: false,
            RegExp: false,
            Set: false,
            SharedArrayBuffer: false,
            String: false,
            Symbol: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false,
            WeakMap: false,
            WeakRef: false,
            WeakSet: false
          },
          es5: {
            Array: false,
            Boolean: false,
            constructor: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            Function: false,
            hasOwnProperty: false,
            Infinity: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            propertyIsEnumerable: false,
            RangeError: false,
            ReferenceError: false,
            RegExp: false,
            String: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false
          },
          es2015: {
            Array: false,
            ArrayBuffer: false,
            Boolean: false,
            constructor: false,
            DataView: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            Float32Array: false,
            Float64Array: false,
            Function: false,
            hasOwnProperty: false,
            Infinity: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Map: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            Promise: false,
            propertyIsEnumerable: false,
            Proxy: false,
            RangeError: false,
            ReferenceError: false,
            Reflect: false,
            RegExp: false,
            Set: false,
            String: false,
            Symbol: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false,
            WeakMap: false,
            WeakSet: false
          },
          es2017: {
            Array: false,
            ArrayBuffer: false,
            Atomics: false,
            Boolean: false,
            constructor: false,
            DataView: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            Float32Array: false,
            Float64Array: false,
            Function: false,
            hasOwnProperty: false,
            Infinity: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Map: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            Promise: false,
            propertyIsEnumerable: false,
            Proxy: false,
            RangeError: false,
            ReferenceError: false,
            Reflect: false,
            RegExp: false,
            Set: false,
            SharedArrayBuffer: false,
            String: false,
            Symbol: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false,
            WeakMap: false,
            WeakSet: false
          },
          es2020: {
            Array: false,
            ArrayBuffer: false,
            Atomics: false,
            BigInt: false,
            BigInt64Array: false,
            BigUint64Array: false,
            Boolean: false,
            constructor: false,
            DataView: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            Float32Array: false,
            Float64Array: false,
            Function: false,
            globalThis: false,
            hasOwnProperty: false,
            Infinity: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Map: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            Promise: false,
            propertyIsEnumerable: false,
            Proxy: false,
            RangeError: false,
            ReferenceError: false,
            Reflect: false,
            RegExp: false,
            Set: false,
            SharedArrayBuffer: false,
            String: false,
            Symbol: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false,
            WeakMap: false,
            WeakSet: false
          },
          es2021: {
            AggregateError: false,
            Array: false,
            ArrayBuffer: false,
            Atomics: false,
            BigInt: false,
            BigInt64Array: false,
            BigUint64Array: false,
            Boolean: false,
            constructor: false,
            DataView: false,
            Date: false,
            decodeURI: false,
            decodeURIComponent: false,
            encodeURI: false,
            encodeURIComponent: false,
            Error: false,
            escape: false,
            eval: false,
            EvalError: false,
            FinalizationRegistry: false,
            Float32Array: false,
            Float64Array: false,
            Function: false,
            globalThis: false,
            hasOwnProperty: false,
            Infinity: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            isFinite: false,
            isNaN: false,
            isPrototypeOf: false,
            JSON: false,
            Map: false,
            Math: false,
            NaN: false,
            Number: false,
            Object: false,
            parseFloat: false,
            parseInt: false,
            Promise: false,
            propertyIsEnumerable: false,
            Proxy: false,
            RangeError: false,
            ReferenceError: false,
            Reflect: false,
            RegExp: false,
            Set: false,
            SharedArrayBuffer: false,
            String: false,
            Symbol: false,
            SyntaxError: false,
            toLocaleString: false,
            toString: false,
            TypeError: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false,
            undefined: false,
            unescape: false,
            URIError: false,
            valueOf: false,
            WeakMap: false,
            WeakRef: false,
            WeakSet: false
          },
          browser: {
            AbortController: false,
            AbortSignal: false,
            addEventListener: false,
            alert: false,
            AnalyserNode: false,
            Animation: false,
            AnimationEffectReadOnly: false,
            AnimationEffectTiming: false,
            AnimationEffectTimingReadOnly: false,
            AnimationEvent: false,
            AnimationPlaybackEvent: false,
            AnimationTimeline: false,
            applicationCache: false,
            ApplicationCache: false,
            ApplicationCacheErrorEvent: false,
            atob: false,
            Attr: false,
            Audio: false,
            AudioBuffer: false,
            AudioBufferSourceNode: false,
            AudioContext: false,
            AudioDestinationNode: false,
            AudioListener: false,
            AudioNode: false,
            AudioParam: false,
            AudioProcessingEvent: false,
            AudioScheduledSourceNode: false,
            AudioWorkletGlobalScope: false,
            AudioWorkletNode: false,
            AudioWorkletProcessor: false,
            BarProp: false,
            BaseAudioContext: false,
            BatteryManager: false,
            BeforeUnloadEvent: false,
            BiquadFilterNode: false,
            Blob: false,
            BlobEvent: false,
            blur: false,
            BroadcastChannel: false,
            btoa: false,
            BudgetService: false,
            ByteLengthQueuingStrategy: false,
            Cache: false,
            caches: false,
            CacheStorage: false,
            cancelAnimationFrame: false,
            cancelIdleCallback: false,
            CanvasCaptureMediaStreamTrack: false,
            CanvasGradient: false,
            CanvasPattern: false,
            CanvasRenderingContext2D: false,
            ChannelMergerNode: false,
            ChannelSplitterNode: false,
            CharacterData: false,
            clearInterval: false,
            clearTimeout: false,
            clientInformation: false,
            ClipboardEvent: false,
            ClipboardItem: false,
            close: false,
            closed: false,
            CloseEvent: false,
            Comment: false,
            CompositionEvent: false,
            CompressionStream: false,
            confirm: false,
            console: false,
            ConstantSourceNode: false,
            ConvolverNode: false,
            CountQueuingStrategy: false,
            createImageBitmap: false,
            Credential: false,
            CredentialsContainer: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CSS: false,
            CSSConditionRule: false,
            CSSFontFaceRule: false,
            CSSGroupingRule: false,
            CSSImportRule: false,
            CSSKeyframeRule: false,
            CSSKeyframesRule: false,
            CSSMatrixComponent: false,
            CSSMediaRule: false,
            CSSNamespaceRule: false,
            CSSPageRule: false,
            CSSPerspective: false,
            CSSRotate: false,
            CSSRule: false,
            CSSRuleList: false,
            CSSScale: false,
            CSSSkew: false,
            CSSSkewX: false,
            CSSSkewY: false,
            CSSStyleDeclaration: false,
            CSSStyleRule: false,
            CSSStyleSheet: false,
            CSSSupportsRule: false,
            CSSTransformValue: false,
            CSSTranslate: false,
            CustomElementRegistry: false,
            customElements: false,
            CustomEvent: false,
            DataTransfer: false,
            DataTransferItem: false,
            DataTransferItemList: false,
            DecompressionStream: false,
            defaultstatus: false,
            defaultStatus: false,
            DelayNode: false,
            DeviceMotionEvent: false,
            DeviceOrientationEvent: false,
            devicePixelRatio: false,
            dispatchEvent: false,
            document: false,
            Document: false,
            DocumentFragment: false,
            DocumentType: false,
            DOMError: false,
            DOMException: false,
            DOMImplementation: false,
            DOMMatrix: false,
            DOMMatrixReadOnly: false,
            DOMParser: false,
            DOMPoint: false,
            DOMPointReadOnly: false,
            DOMQuad: false,
            DOMRect: false,
            DOMRectList: false,
            DOMRectReadOnly: false,
            DOMStringList: false,
            DOMStringMap: false,
            DOMTokenList: false,
            DragEvent: false,
            DynamicsCompressorNode: false,
            Element: false,
            ErrorEvent: false,
            event: false,
            Event: false,
            EventSource: false,
            EventTarget: false,
            external: false,
            fetch: false,
            File: false,
            FileList: false,
            FileReader: false,
            find: false,
            focus: false,
            FocusEvent: false,
            FontFace: false,
            FontFaceSetLoadEvent: false,
            FormData: false,
            FormDataEvent: false,
            frameElement: false,
            frames: false,
            GainNode: false,
            Gamepad: false,
            GamepadButton: false,
            GamepadEvent: false,
            getComputedStyle: false,
            getSelection: false,
            HashChangeEvent: false,
            Headers: false,
            history: false,
            History: false,
            HTMLAllCollection: false,
            HTMLAnchorElement: false,
            HTMLAreaElement: false,
            HTMLAudioElement: false,
            HTMLBaseElement: false,
            HTMLBodyElement: false,
            HTMLBRElement: false,
            HTMLButtonElement: false,
            HTMLCanvasElement: false,
            HTMLCollection: false,
            HTMLContentElement: false,
            HTMLDataElement: false,
            HTMLDataListElement: false,
            HTMLDetailsElement: false,
            HTMLDialogElement: false,
            HTMLDirectoryElement: false,
            HTMLDivElement: false,
            HTMLDListElement: false,
            HTMLDocument: false,
            HTMLElement: false,
            HTMLEmbedElement: false,
            HTMLFieldSetElement: false,
            HTMLFontElement: false,
            HTMLFormControlsCollection: false,
            HTMLFormElement: false,
            HTMLFrameElement: false,
            HTMLFrameSetElement: false,
            HTMLHeadElement: false,
            HTMLHeadingElement: false,
            HTMLHRElement: false,
            HTMLHtmlElement: false,
            HTMLIFrameElement: false,
            HTMLImageElement: false,
            HTMLInputElement: false,
            HTMLLabelElement: false,
            HTMLLegendElement: false,
            HTMLLIElement: false,
            HTMLLinkElement: false,
            HTMLMapElement: false,
            HTMLMarqueeElement: false,
            HTMLMediaElement: false,
            HTMLMenuElement: false,
            HTMLMetaElement: false,
            HTMLMeterElement: false,
            HTMLModElement: false,
            HTMLObjectElement: false,
            HTMLOListElement: false,
            HTMLOptGroupElement: false,
            HTMLOptionElement: false,
            HTMLOptionsCollection: false,
            HTMLOutputElement: false,
            HTMLParagraphElement: false,
            HTMLParamElement: false,
            HTMLPictureElement: false,
            HTMLPreElement: false,
            HTMLProgressElement: false,
            HTMLQuoteElement: false,
            HTMLScriptElement: false,
            HTMLSelectElement: false,
            HTMLShadowElement: false,
            HTMLSlotElement: false,
            HTMLSourceElement: false,
            HTMLSpanElement: false,
            HTMLStyleElement: false,
            HTMLTableCaptionElement: false,
            HTMLTableCellElement: false,
            HTMLTableColElement: false,
            HTMLTableElement: false,
            HTMLTableRowElement: false,
            HTMLTableSectionElement: false,
            HTMLTemplateElement: false,
            HTMLTextAreaElement: false,
            HTMLTimeElement: false,
            HTMLTitleElement: false,
            HTMLTrackElement: false,
            HTMLUListElement: false,
            HTMLUnknownElement: false,
            HTMLVideoElement: false,
            IDBCursor: false,
            IDBCursorWithValue: false,
            IDBDatabase: false,
            IDBFactory: false,
            IDBIndex: false,
            IDBKeyRange: false,
            IDBObjectStore: false,
            IDBOpenDBRequest: false,
            IDBRequest: false,
            IDBTransaction: false,
            IDBVersionChangeEvent: false,
            IdleDeadline: false,
            IIRFilterNode: false,
            Image: false,
            ImageBitmap: false,
            ImageBitmapRenderingContext: false,
            ImageCapture: false,
            ImageData: false,
            indexedDB: false,
            innerHeight: false,
            innerWidth: false,
            InputEvent: false,
            IntersectionObserver: false,
            IntersectionObserverEntry: false,
            Intl: false,
            isSecureContext: false,
            KeyboardEvent: false,
            KeyframeEffect: false,
            KeyframeEffectReadOnly: false,
            length: false,
            localStorage: false,
            location: true,
            Location: false,
            locationbar: false,
            matchMedia: false,
            MediaDeviceInfo: false,
            MediaDevices: false,
            MediaElementAudioSourceNode: false,
            MediaEncryptedEvent: false,
            MediaError: false,
            MediaKeyMessageEvent: false,
            MediaKeySession: false,
            MediaKeyStatusMap: false,
            MediaKeySystemAccess: false,
            MediaList: false,
            MediaMetadata: false,
            MediaQueryList: false,
            MediaQueryListEvent: false,
            MediaRecorder: false,
            MediaSettingsRange: false,
            MediaSource: false,
            MediaStream: false,
            MediaStreamAudioDestinationNode: false,
            MediaStreamAudioSourceNode: false,
            MediaStreamConstraints: false,
            MediaStreamEvent: false,
            MediaStreamTrack: false,
            MediaStreamTrackEvent: false,
            menubar: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            MIDIAccess: false,
            MIDIConnectionEvent: false,
            MIDIInput: false,
            MIDIInputMap: false,
            MIDIMessageEvent: false,
            MIDIOutput: false,
            MIDIOutputMap: false,
            MIDIPort: false,
            MimeType: false,
            MimeTypeArray: false,
            MouseEvent: false,
            moveBy: false,
            moveTo: false,
            MutationEvent: false,
            MutationObserver: false,
            MutationRecord: false,
            name: false,
            NamedNodeMap: false,
            NavigationPreloadManager: false,
            navigator: false,
            Navigator: false,
            NavigatorUAData: false,
            NetworkInformation: false,
            Node: false,
            NodeFilter: false,
            NodeIterator: false,
            NodeList: false,
            Notification: false,
            OfflineAudioCompletionEvent: false,
            OfflineAudioContext: false,
            offscreenBuffering: false,
            OffscreenCanvas: true,
            OffscreenCanvasRenderingContext2D: false,
            onabort: true,
            onafterprint: true,
            onanimationend: true,
            onanimationiteration: true,
            onanimationstart: true,
            onappinstalled: true,
            onauxclick: true,
            onbeforeinstallprompt: true,
            onbeforeprint: true,
            onbeforeunload: true,
            onblur: true,
            oncancel: true,
            oncanplay: true,
            oncanplaythrough: true,
            onchange: true,
            onclick: true,
            onclose: true,
            oncontextmenu: true,
            oncuechange: true,
            ondblclick: true,
            ondevicemotion: true,
            ondeviceorientation: true,
            ondeviceorientationabsolute: true,
            ondrag: true,
            ondragend: true,
            ondragenter: true,
            ondragleave: true,
            ondragover: true,
            ondragstart: true,
            ondrop: true,
            ondurationchange: true,
            onemptied: true,
            onended: true,
            onerror: true,
            onfocus: true,
            ongotpointercapture: true,
            onhashchange: true,
            oninput: true,
            oninvalid: true,
            onkeydown: true,
            onkeypress: true,
            onkeyup: true,
            onlanguagechange: true,
            onload: true,
            onloadeddata: true,
            onloadedmetadata: true,
            onloadstart: true,
            onlostpointercapture: true,
            onmessage: true,
            onmessageerror: true,
            onmousedown: true,
            onmouseenter: true,
            onmouseleave: true,
            onmousemove: true,
            onmouseout: true,
            onmouseover: true,
            onmouseup: true,
            onmousewheel: true,
            onoffline: true,
            ononline: true,
            onpagehide: true,
            onpageshow: true,
            onpause: true,
            onplay: true,
            onplaying: true,
            onpointercancel: true,
            onpointerdown: true,
            onpointerenter: true,
            onpointerleave: true,
            onpointermove: true,
            onpointerout: true,
            onpointerover: true,
            onpointerup: true,
            onpopstate: true,
            onprogress: true,
            onratechange: true,
            onrejectionhandled: true,
            onreset: true,
            onresize: true,
            onscroll: true,
            onsearch: true,
            onseeked: true,
            onseeking: true,
            onselect: true,
            onstalled: true,
            onstorage: true,
            onsubmit: true,
            onsuspend: true,
            ontimeupdate: true,
            ontoggle: true,
            ontransitionend: true,
            onunhandledrejection: true,
            onunload: true,
            onvolumechange: true,
            onwaiting: true,
            onwheel: true,
            open: false,
            openDatabase: false,
            opener: false,
            Option: false,
            origin: false,
            OscillatorNode: false,
            outerHeight: false,
            outerWidth: false,
            OverconstrainedError: false,
            PageTransitionEvent: false,
            pageXOffset: false,
            pageYOffset: false,
            PannerNode: false,
            parent: false,
            Path2D: false,
            PaymentAddress: false,
            PaymentRequest: false,
            PaymentRequestUpdateEvent: false,
            PaymentResponse: false,
            performance: false,
            Performance: false,
            PerformanceEntry: false,
            PerformanceLongTaskTiming: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceNavigation: false,
            PerformanceNavigationTiming: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformancePaintTiming: false,
            PerformanceResourceTiming: false,
            PerformanceTiming: false,
            PeriodicWave: false,
            Permissions: false,
            PermissionStatus: false,
            personalbar: false,
            PhotoCapabilities: false,
            Plugin: false,
            PluginArray: false,
            PointerEvent: false,
            PopStateEvent: false,
            postMessage: false,
            Presentation: false,
            PresentationAvailability: false,
            PresentationConnection: false,
            PresentationConnectionAvailableEvent: false,
            PresentationConnectionCloseEvent: false,
            PresentationConnectionList: false,
            PresentationReceiver: false,
            PresentationRequest: false,
            print: false,
            ProcessingInstruction: false,
            ProgressEvent: false,
            PromiseRejectionEvent: false,
            prompt: false,
            PushManager: false,
            PushSubscription: false,
            PushSubscriptionOptions: false,
            queueMicrotask: false,
            RadioNodeList: false,
            Range: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            registerProcessor: false,
            RemotePlayback: false,
            removeEventListener: false,
            reportError: false,
            Request: false,
            requestAnimationFrame: false,
            requestIdleCallback: false,
            resizeBy: false,
            ResizeObserver: false,
            ResizeObserverEntry: false,
            resizeTo: false,
            Response: false,
            RTCCertificate: false,
            RTCDataChannel: false,
            RTCDataChannelEvent: false,
            RTCDtlsTransport: false,
            RTCIceCandidate: false,
            RTCIceGatherer: false,
            RTCIceTransport: false,
            RTCPeerConnection: false,
            RTCPeerConnectionIceEvent: false,
            RTCRtpContributingSource: false,
            RTCRtpReceiver: false,
            RTCRtpSender: false,
            RTCSctpTransport: false,
            RTCSessionDescription: false,
            RTCStatsReport: false,
            RTCTrackEvent: false,
            screen: false,
            Screen: false,
            screenLeft: false,
            ScreenOrientation: false,
            screenTop: false,
            screenX: false,
            screenY: false,
            ScriptProcessorNode: false,
            scroll: false,
            scrollbars: false,
            scrollBy: false,
            scrollTo: false,
            scrollX: false,
            scrollY: false,
            SecurityPolicyViolationEvent: false,
            Selection: false,
            self: false,
            ServiceWorker: false,
            ServiceWorkerContainer: false,
            ServiceWorkerRegistration: false,
            sessionStorage: false,
            setInterval: false,
            setTimeout: false,
            ShadowRoot: false,
            SharedWorker: false,
            SourceBuffer: false,
            SourceBufferList: false,
            speechSynthesis: false,
            SpeechSynthesisEvent: false,
            SpeechSynthesisUtterance: false,
            StaticRange: false,
            status: false,
            statusbar: false,
            StereoPannerNode: false,
            stop: false,
            Storage: false,
            StorageEvent: false,
            StorageManager: false,
            structuredClone: false,
            styleMedia: false,
            StyleSheet: false,
            StyleSheetList: false,
            SubmitEvent: false,
            SubtleCrypto: false,
            SVGAElement: false,
            SVGAngle: false,
            SVGAnimatedAngle: false,
            SVGAnimatedBoolean: false,
            SVGAnimatedEnumeration: false,
            SVGAnimatedInteger: false,
            SVGAnimatedLength: false,
            SVGAnimatedLengthList: false,
            SVGAnimatedNumber: false,
            SVGAnimatedNumberList: false,
            SVGAnimatedPreserveAspectRatio: false,
            SVGAnimatedRect: false,
            SVGAnimatedString: false,
            SVGAnimatedTransformList: false,
            SVGAnimateElement: false,
            SVGAnimateMotionElement: false,
            SVGAnimateTransformElement: false,
            SVGAnimationElement: false,
            SVGCircleElement: false,
            SVGClipPathElement: false,
            SVGComponentTransferFunctionElement: false,
            SVGDefsElement: false,
            SVGDescElement: false,
            SVGDiscardElement: false,
            SVGElement: false,
            SVGEllipseElement: false,
            SVGFEBlendElement: false,
            SVGFEColorMatrixElement: false,
            SVGFEComponentTransferElement: false,
            SVGFECompositeElement: false,
            SVGFEConvolveMatrixElement: false,
            SVGFEDiffuseLightingElement: false,
            SVGFEDisplacementMapElement: false,
            SVGFEDistantLightElement: false,
            SVGFEDropShadowElement: false,
            SVGFEFloodElement: false,
            SVGFEFuncAElement: false,
            SVGFEFuncBElement: false,
            SVGFEFuncGElement: false,
            SVGFEFuncRElement: false,
            SVGFEGaussianBlurElement: false,
            SVGFEImageElement: false,
            SVGFEMergeElement: false,
            SVGFEMergeNodeElement: false,
            SVGFEMorphologyElement: false,
            SVGFEOffsetElement: false,
            SVGFEPointLightElement: false,
            SVGFESpecularLightingElement: false,
            SVGFESpotLightElement: false,
            SVGFETileElement: false,
            SVGFETurbulenceElement: false,
            SVGFilterElement: false,
            SVGForeignObjectElement: false,
            SVGGElement: false,
            SVGGeometryElement: false,
            SVGGradientElement: false,
            SVGGraphicsElement: false,
            SVGImageElement: false,
            SVGLength: false,
            SVGLengthList: false,
            SVGLinearGradientElement: false,
            SVGLineElement: false,
            SVGMarkerElement: false,
            SVGMaskElement: false,
            SVGMatrix: false,
            SVGMetadataElement: false,
            SVGMPathElement: false,
            SVGNumber: false,
            SVGNumberList: false,
            SVGPathElement: false,
            SVGPatternElement: false,
            SVGPoint: false,
            SVGPointList: false,
            SVGPolygonElement: false,
            SVGPolylineElement: false,
            SVGPreserveAspectRatio: false,
            SVGRadialGradientElement: false,
            SVGRect: false,
            SVGRectElement: false,
            SVGScriptElement: false,
            SVGSetElement: false,
            SVGStopElement: false,
            SVGStringList: false,
            SVGStyleElement: false,
            SVGSVGElement: false,
            SVGSwitchElement: false,
            SVGSymbolElement: false,
            SVGTextContentElement: false,
            SVGTextElement: false,
            SVGTextPathElement: false,
            SVGTextPositioningElement: false,
            SVGTitleElement: false,
            SVGTransform: false,
            SVGTransformList: false,
            SVGTSpanElement: false,
            SVGUnitTypes: false,
            SVGUseElement: false,
            SVGViewElement: false,
            TaskAttributionTiming: false,
            Text: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TextEvent: false,
            TextMetrics: false,
            TextTrack: false,
            TextTrackCue: false,
            TextTrackCueList: false,
            TextTrackList: false,
            TimeRanges: false,
            ToggleEvent: false,
            toolbar: false,
            top: false,
            Touch: false,
            TouchEvent: false,
            TouchList: false,
            TrackEvent: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            TransitionEvent: false,
            TreeWalker: false,
            UIEvent: false,
            URL: false,
            URLSearchParams: false,
            ValidityState: false,
            visualViewport: false,
            VisualViewport: false,
            VTTCue: false,
            WaveShaperNode: false,
            WebAssembly: false,
            WebGL2RenderingContext: false,
            WebGLActiveInfo: false,
            WebGLBuffer: false,
            WebGLContextEvent: false,
            WebGLFramebuffer: false,
            WebGLProgram: false,
            WebGLQuery: false,
            WebGLRenderbuffer: false,
            WebGLRenderingContext: false,
            WebGLSampler: false,
            WebGLShader: false,
            WebGLShaderPrecisionFormat: false,
            WebGLSync: false,
            WebGLTexture: false,
            WebGLTransformFeedback: false,
            WebGLUniformLocation: false,
            WebGLVertexArrayObject: false,
            WebSocket: false,
            WheelEvent: false,
            window: false,
            Window: false,
            Worker: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false,
            XMLDocument: false,
            XMLHttpRequest: false,
            XMLHttpRequestEventTarget: false,
            XMLHttpRequestUpload: false,
            XMLSerializer: false,
            XPathEvaluator: false,
            XPathExpression: false,
            XPathResult: false,
            XRAnchor: false,
            XRBoundedReferenceSpace: false,
            XRCPUDepthInformation: false,
            XRDepthInformation: false,
            XRFrame: false,
            XRInputSource: false,
            XRInputSourceArray: false,
            XRInputSourceEvent: false,
            XRInputSourcesChangeEvent: false,
            XRPose: false,
            XRReferenceSpace: false,
            XRReferenceSpaceEvent: false,
            XRRenderState: false,
            XRRigidTransform: false,
            XRSession: false,
            XRSessionEvent: false,
            XRSpace: false,
            XRSystem: false,
            XRView: false,
            XRViewerPose: false,
            XRViewport: false,
            XRWebGLBinding: false,
            XRWebGLDepthInformation: false,
            XRWebGLLayer: false,
            XSLTProcessor: false
          },
          worker: {
            addEventListener: false,
            applicationCache: false,
            atob: false,
            Blob: false,
            BroadcastChannel: false,
            btoa: false,
            ByteLengthQueuingStrategy: false,
            Cache: false,
            caches: false,
            clearInterval: false,
            clearTimeout: false,
            close: true,
            CompressionStream: false,
            console: false,
            CountQueuingStrategy: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CustomEvent: false,
            DecompressionStream: false,
            ErrorEvent: false,
            Event: false,
            fetch: false,
            File: false,
            FileReaderSync: false,
            FormData: false,
            Headers: false,
            IDBCursor: false,
            IDBCursorWithValue: false,
            IDBDatabase: false,
            IDBFactory: false,
            IDBIndex: false,
            IDBKeyRange: false,
            IDBObjectStore: false,
            IDBOpenDBRequest: false,
            IDBRequest: false,
            IDBTransaction: false,
            IDBVersionChangeEvent: false,
            ImageData: false,
            importScripts: true,
            indexedDB: false,
            location: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            name: false,
            navigator: false,
            Notification: false,
            onclose: true,
            onconnect: true,
            onerror: true,
            onlanguagechange: true,
            onmessage: true,
            onoffline: true,
            ononline: true,
            onrejectionhandled: true,
            onunhandledrejection: true,
            performance: false,
            Performance: false,
            PerformanceEntry: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceNavigation: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformanceResourceTiming: false,
            PerformanceTiming: false,
            postMessage: true,
            Promise: false,
            queueMicrotask: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            removeEventListener: false,
            reportError: false,
            Request: false,
            Response: false,
            self: true,
            ServiceWorkerRegistration: false,
            setInterval: false,
            setTimeout: false,
            SubtleCrypto: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            URL: false,
            URLSearchParams: false,
            WebAssembly: false,
            WebSocket: false,
            Worker: false,
            WorkerGlobalScope: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false,
            XMLHttpRequest: false
          },
          node: {
            __dirname: false,
            __filename: false,
            AbortController: false,
            AbortSignal: false,
            atob: false,
            Blob: false,
            BroadcastChannel: false,
            btoa: false,
            Buffer: false,
            ByteLengthQueuingStrategy: false,
            clearImmediate: false,
            clearInterval: false,
            clearTimeout: false,
            CompressionStream: false,
            console: false,
            CountQueuingStrategy: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CustomEvent: false,
            DecompressionStream: false,
            DOMException: false,
            Event: false,
            EventTarget: false,
            exports: true,
            fetch: false,
            File: false,
            FormData: false,
            global: false,
            Headers: false,
            Intl: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            module: false,
            performance: false,
            PerformanceEntry: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformanceResourceTiming: false,
            process: false,
            queueMicrotask: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            Request: false,
            require: false,
            Response: false,
            setImmediate: false,
            setInterval: false,
            setTimeout: false,
            structuredClone: false,
            SubtleCrypto: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            URL: false,
            URLSearchParams: false,
            WebAssembly: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false
          },
          nodeBuiltin: {
            AbortController: false,
            AbortSignal: false,
            atob: false,
            Blob: false,
            BroadcastChannel: false,
            btoa: false,
            Buffer: false,
            ByteLengthQueuingStrategy: false,
            clearImmediate: false,
            clearInterval: false,
            clearTimeout: false,
            CompressionStream: false,
            console: false,
            CountQueuingStrategy: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CustomEvent: false,
            DecompressionStream: false,
            DOMException: false,
            Event: false,
            EventTarget: false,
            fetch: false,
            File: false,
            FormData: false,
            global: false,
            Headers: false,
            Intl: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            performance: false,
            PerformanceEntry: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformanceResourceTiming: false,
            process: false,
            queueMicrotask: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            Request: false,
            Response: false,
            setImmediate: false,
            setInterval: false,
            setTimeout: false,
            structuredClone: false,
            SubtleCrypto: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            URL: false,
            URLSearchParams: false,
            WebAssembly: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false
          },
          commonjs: {
            exports: true,
            global: false,
            module: false,
            require: false
          },
          amd: {
            define: false,
            require: false
          },
          mocha: {
            after: false,
            afterEach: false,
            before: false,
            beforeEach: false,
            context: false,
            describe: false,
            it: false,
            mocha: false,
            run: false,
            setup: false,
            specify: false,
            suite: false,
            suiteSetup: false,
            suiteTeardown: false,
            teardown: false,
            test: false,
            xcontext: false,
            xdescribe: false,
            xit: false,
            xspecify: false
          },
          jasmine: {
            afterAll: false,
            afterEach: false,
            beforeAll: false,
            beforeEach: false,
            describe: false,
            expect: false,
            expectAsync: false,
            fail: false,
            fdescribe: false,
            fit: false,
            it: false,
            jasmine: false,
            pending: false,
            runs: false,
            spyOn: false,
            spyOnAllFunctions: false,
            spyOnProperty: false,
            waits: false,
            waitsFor: false,
            xdescribe: false,
            xit: false
          },
          jest: {
            afterAll: false,
            afterEach: false,
            beforeAll: false,
            beforeEach: false,
            describe: false,
            expect: false,
            fdescribe: false,
            fit: false,
            it: false,
            jest: false,
            pit: false,
            require: false,
            test: false,
            xdescribe: false,
            xit: false,
            xtest: false
          },
          qunit: {
            asyncTest: false,
            deepEqual: false,
            equal: false,
            expect: false,
            module: false,
            notDeepEqual: false,
            notEqual: false,
            notOk: false,
            notPropEqual: false,
            notStrictEqual: false,
            ok: false,
            propEqual: false,
            QUnit: false,
            raises: false,
            start: false,
            stop: false,
            strictEqual: false,
            test: false,
            throws: false
          },
          phantomjs: {
            console: true,
            exports: true,
            phantom: true,
            require: true,
            WebPage: true
          },
          couch: {
            emit: false,
            exports: false,
            getRow: false,
            log: false,
            module: false,
            provides: false,
            require: false,
            respond: false,
            send: false,
            start: false,
            sum: false
          },
          rhino: {
            defineClass: false,
            deserialize: false,
            gc: false,
            help: false,
            importClass: false,
            importPackage: false,
            java: false,
            load: false,
            loadClass: false,
            Packages: false,
            print: false,
            quit: false,
            readFile: false,
            readUrl: false,
            runCommand: false,
            seal: false,
            serialize: false,
            spawn: false,
            sync: false,
            toint32: false,
            version: false
          },
          nashorn: {
            __DIR__: false,
            __FILE__: false,
            __LINE__: false,
            com: false,
            edu: false,
            exit: false,
            java: false,
            Java: false,
            javafx: false,
            JavaImporter: false,
            javax: false,
            JSAdapter: false,
            load: false,
            loadWithNewGlobal: false,
            org: false,
            Packages: false,
            print: false,
            quit: false
          },
          wsh: {
            ActiveXObject: false,
            CollectGarbage: false,
            Debug: false,
            Enumerator: false,
            GetObject: false,
            RuntimeObject: false,
            ScriptEngine: false,
            ScriptEngineBuildVersion: false,
            ScriptEngineMajorVersion: false,
            ScriptEngineMinorVersion: false,
            VBArray: false,
            WScript: false,
            WSH: false
          },
          jquery: {
            $: false,
            jQuery: false
          },
          yui: {
            YAHOO: false,
            YAHOO_config: false,
            YUI: false,
            YUI_config: false
          },
          shelljs: {
            cat: false,
            cd: false,
            chmod: false,
            config: false,
            cp: false,
            dirs: false,
            echo: false,
            env: false,
            error: false,
            exec: false,
            exit: false,
            find: false,
            grep: false,
            ln: false,
            ls: false,
            mkdir: false,
            mv: false,
            popd: false,
            pushd: false,
            pwd: false,
            rm: false,
            sed: false,
            set: false,
            target: false,
            tempdir: false,
            test: false,
            touch: false,
            which: false
          },
          prototypejs: {
            $: false,
            $$: false,
            $A: false,
            $break: false,
            $continue: false,
            $F: false,
            $H: false,
            $R: false,
            $w: false,
            Abstract: false,
            Ajax: false,
            Autocompleter: false,
            Builder: false,
            Class: false,
            Control: false,
            Draggable: false,
            Draggables: false,
            Droppables: false,
            Effect: false,
            Element: false,
            Enumerable: false,
            Event: false,
            Field: false,
            Form: false,
            Hash: false,
            Insertion: false,
            ObjectRange: false,
            PeriodicalExecuter: false,
            Position: false,
            Prototype: false,
            Scriptaculous: false,
            Selector: false,
            Sortable: false,
            SortableObserver: false,
            Sound: false,
            Template: false,
            Toggle: false,
            Try: false
          },
          meteor: {
            $: false,
            Accounts: false,
            AccountsClient: false,
            AccountsCommon: false,
            AccountsServer: false,
            App: false,
            Assets: false,
            Blaze: false,
            check: false,
            Cordova: false,
            DDP: false,
            DDPRateLimiter: false,
            DDPServer: false,
            Deps: false,
            EJSON: false,
            Email: false,
            HTTP: false,
            Log: false,
            Match: false,
            Meteor: false,
            Mongo: false,
            MongoInternals: false,
            Npm: false,
            Package: false,
            Plugin: false,
            process: false,
            Random: false,
            ReactiveDict: false,
            ReactiveVar: false,
            Router: false,
            ServiceConfiguration: false,
            Session: false,
            share: false,
            Spacebars: false,
            Template: false,
            Tinytest: false,
            Tracker: false,
            UI: false,
            Utils: false,
            WebApp: false,
            WebAppInternals: false
          },
          mongo: {
            _isWindows: false,
            _rand: false,
            BulkWriteResult: false,
            cat: false,
            cd: false,
            connect: false,
            db: false,
            getHostName: false,
            getMemInfo: false,
            hostname: false,
            ISODate: false,
            listFiles: false,
            load: false,
            ls: false,
            md5sumFile: false,
            mkdir: false,
            Mongo: false,
            NumberInt: false,
            NumberLong: false,
            ObjectId: false,
            PlanCache: false,
            print: false,
            printjson: false,
            pwd: false,
            quit: false,
            removeFile: false,
            rs: false,
            sh: false,
            UUID: false,
            version: false,
            WriteResult: false
          },
          applescript: {
            $: false,
            Application: false,
            Automation: false,
            console: false,
            delay: false,
            Library: false,
            ObjC: false,
            ObjectSpecifier: false,
            Path: false,
            Progress: false,
            Ref: false
          },
          serviceworker: {
            addEventListener: false,
            applicationCache: false,
            atob: false,
            Blob: false,
            BroadcastChannel: false,
            btoa: false,
            ByteLengthQueuingStrategy: false,
            Cache: false,
            caches: false,
            CacheStorage: false,
            clearInterval: false,
            clearTimeout: false,
            Client: false,
            clients: false,
            Clients: false,
            close: true,
            CompressionStream: false,
            console: false,
            CountQueuingStrategy: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CustomEvent: false,
            DecompressionStream: false,
            ErrorEvent: false,
            Event: false,
            ExtendableEvent: false,
            ExtendableMessageEvent: false,
            fetch: false,
            FetchEvent: false,
            File: false,
            FileReaderSync: false,
            FormData: false,
            Headers: false,
            IDBCursor: false,
            IDBCursorWithValue: false,
            IDBDatabase: false,
            IDBFactory: false,
            IDBIndex: false,
            IDBKeyRange: false,
            IDBObjectStore: false,
            IDBOpenDBRequest: false,
            IDBRequest: false,
            IDBTransaction: false,
            IDBVersionChangeEvent: false,
            ImageData: false,
            importScripts: false,
            indexedDB: false,
            location: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            name: false,
            navigator: false,
            Notification: false,
            onclose: true,
            onconnect: true,
            onerror: true,
            onfetch: true,
            oninstall: true,
            onlanguagechange: true,
            onmessage: true,
            onmessageerror: true,
            onnotificationclick: true,
            onnotificationclose: true,
            onoffline: true,
            ononline: true,
            onpush: true,
            onpushsubscriptionchange: true,
            onrejectionhandled: true,
            onsync: true,
            onunhandledrejection: true,
            performance: false,
            Performance: false,
            PerformanceEntry: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceNavigation: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformanceResourceTiming: false,
            PerformanceTiming: false,
            postMessage: true,
            Promise: false,
            queueMicrotask: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            registration: false,
            removeEventListener: false,
            Request: false,
            Response: false,
            self: false,
            ServiceWorker: false,
            ServiceWorkerContainer: false,
            ServiceWorkerGlobalScope: false,
            ServiceWorkerMessageEvent: false,
            ServiceWorkerRegistration: false,
            setInterval: false,
            setTimeout: false,
            skipWaiting: false,
            SubtleCrypto: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            URL: false,
            URLSearchParams: false,
            WebAssembly: false,
            WebSocket: false,
            WindowClient: false,
            Worker: false,
            WorkerGlobalScope: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false,
            XMLHttpRequest: false
          },
          atomtest: {
            advanceClock: false,
            atom: false,
            fakeClearInterval: false,
            fakeClearTimeout: false,
            fakeSetInterval: false,
            fakeSetTimeout: false,
            resetTimeouts: false,
            waitsForPromise: false
          },
          embertest: {
            andThen: false,
            click: false,
            currentPath: false,
            currentRouteName: false,
            currentURL: false,
            fillIn: false,
            find: false,
            findAll: false,
            findWithAssert: false,
            keyEvent: false,
            pauseTest: false,
            resumeTest: false,
            triggerEvent: false,
            visit: false,
            wait: false
          },
          protractor: {
            $: false,
            $$: false,
            browser: false,
            by: false,
            By: false,
            DartObject: false,
            element: false,
            protractor: false
          },
          "shared-node-browser": {
            AbortController: false,
            AbortSignal: false,
            atob: false,
            Blob: false,
            BroadcastChannel: false,
            btoa: false,
            ByteLengthQueuingStrategy: false,
            clearInterval: false,
            clearTimeout: false,
            CompressionStream: false,
            console: false,
            CountQueuingStrategy: false,
            crypto: false,
            Crypto: false,
            CryptoKey: false,
            CustomEvent: false,
            DecompressionStream: false,
            DOMException: false,
            Event: false,
            EventTarget: false,
            fetch: false,
            File: false,
            FormData: false,
            Headers: false,
            Intl: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            performance: false,
            PerformanceEntry: false,
            PerformanceMark: false,
            PerformanceMeasure: false,
            PerformanceObserver: false,
            PerformanceObserverEntryList: false,
            PerformanceResourceTiming: false,
            queueMicrotask: false,
            ReadableByteStreamController: false,
            ReadableStream: false,
            ReadableStreamBYOBReader: false,
            ReadableStreamBYOBRequest: false,
            ReadableStreamDefaultController: false,
            ReadableStreamDefaultReader: false,
            Request: false,
            Response: false,
            setInterval: false,
            setTimeout: false,
            structuredClone: false,
            SubtleCrypto: false,
            TextDecoder: false,
            TextDecoderStream: false,
            TextEncoder: false,
            TextEncoderStream: false,
            TransformStream: false,
            TransformStreamDefaultController: false,
            URL: false,
            URLSearchParams: false,
            WebAssembly: false,
            WritableStream: false,
            WritableStreamDefaultController: false,
            WritableStreamDefaultWriter: false
          },
          webextensions: {
            browser: false,
            chrome: false,
            opr: false
          },
          greasemonkey: {
            cloneInto: false,
            createObjectIn: false,
            exportFunction: false,
            GM: false,
            GM_addElement: false,
            GM_addStyle: false,
            GM_addValueChangeListener: false,
            GM_deleteValue: false,
            GM_download: false,
            GM_getResourceText: false,
            GM_getResourceURL: false,
            GM_getTab: false,
            GM_getTabs: false,
            GM_getValue: false,
            GM_info: false,
            GM_listValues: false,
            GM_log: false,
            GM_notification: false,
            GM_openInTab: false,
            GM_registerMenuCommand: false,
            GM_removeValueChangeListener: false,
            GM_saveTab: false,
            GM_setClipboard: false,
            GM_setValue: false,
            GM_unregisterMenuCommand: false,
            GM_xmlhttpRequest: false,
            unsafeWindow: false
          },
          devtools: {
            $: false,
            $_: false,
            $$: false,
            $0: false,
            $1: false,
            $2: false,
            $3: false,
            $4: false,
            $x: false,
            chrome: false,
            clear: false,
            copy: false,
            debug: false,
            dir: false,
            dirxml: false,
            getEventListeners: false,
            inspect: false,
            keys: false,
            monitor: false,
            monitorEvents: false,
            profile: false,
            profileEnd: false,
            queryObjects: false,
            table: false,
            undebug: false,
            unmonitor: false,
            unmonitorEvents: false,
            values: false
          }
        };
      }
    });
    var require_globals22 = __commonJS2({
      "node_modules/globals/index.js": function(exports2, module22) {
        "use strict";
        module22.exports = require_globals3();
      }
    });
    var lib_exports2 = {};
    __export2(lib_exports2, {
      codeFrameColumns: function() {
        return codeFrameColumns;
      },
      generate: function() {
        return generate2;
      },
      parse: function() {
        return parse4;
      },
      parseExpression: function() {
        return parseExpression;
      },
      template: function() {
        return index2;
      },
      tokTypes: function() {
        return tokTypes;
      },
      traverse: function() {
        return traverse3;
      },
      types: function() {
        return lib_exports;
      }
    });
    module2.exports = __toCommonJS2(lib_exports2);
    var lib_exports = {};
    __export2(lib_exports, {
      ACCESSOR_TYPES: function() {
        return ACCESSOR_TYPES;
      },
      ALIAS_KEYS: function() {
        return ALIAS_KEYS;
      },
      ASSIGNMENT_OPERATORS: function() {
        return ASSIGNMENT_OPERATORS;
      },
      AnyTypeAnnotation: function() {
        return anyTypeAnnotation;
      },
      ArgumentPlaceholder: function() {
        return argumentPlaceholder;
      },
      ArrayExpression: function() {
        return arrayExpression;
      },
      ArrayPattern: function() {
        return arrayPattern;
      },
      ArrayTypeAnnotation: function() {
        return arrayTypeAnnotation;
      },
      ArrowFunctionExpression: function() {
        return arrowFunctionExpression;
      },
      AssignmentExpression: function() {
        return assignmentExpression;
      },
      AssignmentPattern: function() {
        return assignmentPattern;
      },
      AwaitExpression: function() {
        return awaitExpression;
      },
      BINARY_OPERATORS: function() {
        return BINARY_OPERATORS;
      },
      BINARY_TYPES: function() {
        return BINARY_TYPES;
      },
      BLOCKPARENT_TYPES: function() {
        return BLOCKPARENT_TYPES;
      },
      BLOCK_SCOPED_SYMBOL: function() {
        return BLOCK_SCOPED_SYMBOL;
      },
      BLOCK_TYPES: function() {
        return BLOCK_TYPES;
      },
      BOOLEAN_BINARY_OPERATORS: function() {
        return BOOLEAN_BINARY_OPERATORS;
      },
      BOOLEAN_NUMBER_BINARY_OPERATORS: function() {
        return BOOLEAN_NUMBER_BINARY_OPERATORS;
      },
      BOOLEAN_UNARY_OPERATORS: function() {
        return BOOLEAN_UNARY_OPERATORS;
      },
      BUILDER_KEYS: function() {
        return BUILDER_KEYS;
      },
      BigIntLiteral: function() {
        return bigIntLiteral;
      },
      BinaryExpression: function() {
        return binaryExpression;
      },
      BindExpression: function() {
        return bindExpression;
      },
      BlockStatement: function() {
        return blockStatement;
      },
      BooleanLiteral: function() {
        return booleanLiteral;
      },
      BooleanLiteralTypeAnnotation: function() {
        return booleanLiteralTypeAnnotation;
      },
      BooleanTypeAnnotation: function() {
        return booleanTypeAnnotation;
      },
      BreakStatement: function() {
        return breakStatement;
      },
      CLASS_TYPES: function() {
        return CLASS_TYPES;
      },
      COMMENT_KEYS: function() {
        return COMMENT_KEYS;
      },
      COMPARISON_BINARY_OPERATORS: function() {
        return COMPARISON_BINARY_OPERATORS;
      },
      COMPLETIONSTATEMENT_TYPES: function() {
        return COMPLETIONSTATEMENT_TYPES;
      },
      CONDITIONAL_TYPES: function() {
        return CONDITIONAL_TYPES;
      },
      CallExpression: function() {
        return callExpression;
      },
      CatchClause: function() {
        return catchClause;
      },
      ClassAccessorProperty: function() {
        return classAccessorProperty;
      },
      ClassBody: function() {
        return classBody;
      },
      ClassDeclaration: function() {
        return classDeclaration;
      },
      ClassExpression: function() {
        return classExpression;
      },
      ClassImplements: function() {
        return classImplements;
      },
      ClassMethod: function() {
        return classMethod;
      },
      ClassPrivateMethod: function() {
        return classPrivateMethod;
      },
      ClassPrivateProperty: function() {
        return classPrivateProperty;
      },
      ClassProperty: function() {
        return classProperty;
      },
      ConditionalExpression: function() {
        return conditionalExpression;
      },
      ContinueStatement: function() {
        return continueStatement;
      },
      DECLARATION_TYPES: function() {
        return DECLARATION_TYPES;
      },
      DEPRECATED_ALIASES: function() {
        return DEPRECATED_ALIASES;
      },
      DEPRECATED_KEYS: function() {
        return DEPRECATED_KEYS;
      },
      DebuggerStatement: function() {
        return debuggerStatement;
      },
      DecimalLiteral: function() {
        return decimalLiteral;
      },
      DeclareClass: function() {
        return declareClass;
      },
      DeclareExportAllDeclaration: function() {
        return declareExportAllDeclaration;
      },
      DeclareExportDeclaration: function() {
        return declareExportDeclaration;
      },
      DeclareFunction: function() {
        return declareFunction;
      },
      DeclareInterface: function() {
        return declareInterface;
      },
      DeclareModule: function() {
        return declareModule;
      },
      DeclareModuleExports: function() {
        return declareModuleExports;
      },
      DeclareOpaqueType: function() {
        return declareOpaqueType;
      },
      DeclareTypeAlias: function() {
        return declareTypeAlias;
      },
      DeclareVariable: function() {
        return declareVariable;
      },
      DeclaredPredicate: function() {
        return declaredPredicate;
      },
      Decorator: function() {
        return decorator;
      },
      Directive: function() {
        return directive;
      },
      DirectiveLiteral: function() {
        return directiveLiteral;
      },
      DoExpression: function() {
        return doExpression;
      },
      DoWhileStatement: function() {
        return doWhileStatement;
      },
      ENUMBODY_TYPES: function() {
        return ENUMBODY_TYPES;
      },
      ENUMMEMBER_TYPES: function() {
        return ENUMMEMBER_TYPES;
      },
      EQUALITY_BINARY_OPERATORS: function() {
        return EQUALITY_BINARY_OPERATORS;
      },
      EXPORTDECLARATION_TYPES: function() {
        return EXPORTDECLARATION_TYPES;
      },
      EXPRESSIONWRAPPER_TYPES: function() {
        return EXPRESSIONWRAPPER_TYPES;
      },
      EXPRESSION_TYPES: function() {
        return EXPRESSION_TYPES;
      },
      EmptyStatement: function() {
        return emptyStatement;
      },
      EmptyTypeAnnotation: function() {
        return emptyTypeAnnotation;
      },
      EnumBooleanBody: function() {
        return enumBooleanBody;
      },
      EnumBooleanMember: function() {
        return enumBooleanMember;
      },
      EnumDeclaration: function() {
        return enumDeclaration;
      },
      EnumDefaultedMember: function() {
        return enumDefaultedMember;
      },
      EnumNumberBody: function() {
        return enumNumberBody;
      },
      EnumNumberMember: function() {
        return enumNumberMember;
      },
      EnumStringBody: function() {
        return enumStringBody;
      },
      EnumStringMember: function() {
        return enumStringMember;
      },
      EnumSymbolBody: function() {
        return enumSymbolBody;
      },
      ExistsTypeAnnotation: function() {
        return existsTypeAnnotation;
      },
      ExportAllDeclaration: function() {
        return exportAllDeclaration;
      },
      ExportDefaultDeclaration: function() {
        return exportDefaultDeclaration;
      },
      ExportDefaultSpecifier: function() {
        return exportDefaultSpecifier;
      },
      ExportNamedDeclaration: function() {
        return exportNamedDeclaration;
      },
      ExportNamespaceSpecifier: function() {
        return exportNamespaceSpecifier;
      },
      ExportSpecifier: function() {
        return exportSpecifier;
      },
      ExpressionStatement: function() {
        return expressionStatement;
      },
      FLATTENABLE_KEYS: function() {
        return FLATTENABLE_KEYS;
      },
      FLIPPED_ALIAS_KEYS: function() {
        return FLIPPED_ALIAS_KEYS;
      },
      FLOWBASEANNOTATION_TYPES: function() {
        return FLOWBASEANNOTATION_TYPES;
      },
      FLOWDECLARATION_TYPES: function() {
        return FLOWDECLARATION_TYPES;
      },
      FLOWPREDICATE_TYPES: function() {
        return FLOWPREDICATE_TYPES;
      },
      FLOWTYPE_TYPES: function() {
        return FLOWTYPE_TYPES;
      },
      FLOW_TYPES: function() {
        return FLOW_TYPES;
      },
      FORXSTATEMENT_TYPES: function() {
        return FORXSTATEMENT_TYPES;
      },
      FOR_INIT_KEYS: function() {
        return FOR_INIT_KEYS;
      },
      FOR_TYPES: function() {
        return FOR_TYPES;
      },
      FUNCTIONPARENT_TYPES: function() {
        return FUNCTIONPARENT_TYPES;
      },
      FUNCTION_TYPES: function() {
        return FUNCTION_TYPES;
      },
      File: function() {
        return file;
      },
      ForInStatement: function() {
        return forInStatement;
      },
      ForOfStatement: function() {
        return forOfStatement;
      },
      ForStatement: function() {
        return forStatement;
      },
      FunctionDeclaration: function() {
        return functionDeclaration;
      },
      FunctionExpression: function() {
        return functionExpression;
      },
      FunctionTypeAnnotation: function() {
        return functionTypeAnnotation;
      },
      FunctionTypeParam: function() {
        return functionTypeParam;
      },
      GenericTypeAnnotation: function() {
        return genericTypeAnnotation;
      },
      IMMUTABLE_TYPES: function() {
        return IMMUTABLE_TYPES;
      },
      IMPORTOREXPORTDECLARATION_TYPES: function() {
        return IMPORTOREXPORTDECLARATION_TYPES;
      },
      INHERIT_KEYS: function() {
        return INHERIT_KEYS;
      },
      Identifier: function() {
        return identifier;
      },
      IfStatement: function() {
        return ifStatement;
      },
      Import: function() {
        return _import;
      },
      ImportAttribute: function() {
        return importAttribute;
      },
      ImportDeclaration: function() {
        return importDeclaration;
      },
      ImportDefaultSpecifier: function() {
        return importDefaultSpecifier;
      },
      ImportExpression: function() {
        return importExpression;
      },
      ImportNamespaceSpecifier: function() {
        return importNamespaceSpecifier;
      },
      ImportSpecifier: function() {
        return importSpecifier;
      },
      IndexedAccessType: function() {
        return indexedAccessType;
      },
      InferredPredicate: function() {
        return inferredPredicate;
      },
      InterfaceDeclaration: function() {
        return interfaceDeclaration;
      },
      InterfaceExtends: function() {
        return interfaceExtends;
      },
      InterfaceTypeAnnotation: function() {
        return interfaceTypeAnnotation;
      },
      InterpreterDirective: function() {
        return interpreterDirective;
      },
      IntersectionTypeAnnotation: function() {
        return intersectionTypeAnnotation;
      },
      JSXAttribute: function() {
        return jsxAttribute2;
      },
      JSXClosingElement: function() {
        return jsxClosingElement2;
      },
      JSXClosingFragment: function() {
        return jsxClosingFragment2;
      },
      JSXElement: function() {
        return jsxElement2;
      },
      JSXEmptyExpression: function() {
        return jsxEmptyExpression2;
      },
      JSXExpressionContainer: function() {
        return jsxExpressionContainer2;
      },
      JSXFragment: function() {
        return jsxFragment2;
      },
      JSXIdentifier: function() {
        return jsxIdentifier2;
      },
      JSXMemberExpression: function() {
        return jsxMemberExpression2;
      },
      JSXNamespacedName: function() {
        return jsxNamespacedName2;
      },
      JSXOpeningElement: function() {
        return jsxOpeningElement2;
      },
      JSXOpeningFragment: function() {
        return jsxOpeningFragment2;
      },
      JSXSpreadAttribute: function() {
        return jsxSpreadAttribute2;
      },
      JSXSpreadChild: function() {
        return jsxSpreadChild;
      },
      JSXText: function() {
        return jsxText3;
      },
      JSX_TYPES: function() {
        return JSX_TYPES;
      },
      LITERAL_TYPES: function() {
        return LITERAL_TYPES;
      },
      LOGICAL_OPERATORS: function() {
        return LOGICAL_OPERATORS;
      },
      LOOP_TYPES: function() {
        return LOOP_TYPES;
      },
      LVAL_TYPES: function() {
        return LVAL_TYPES;
      },
      LabeledStatement: function() {
        return labeledStatement;
      },
      LogicalExpression: function() {
        return logicalExpression;
      },
      METHOD_TYPES: function() {
        return METHOD_TYPES;
      },
      MISCELLANEOUS_TYPES: function() {
        return MISCELLANEOUS_TYPES;
      },
      MODULEDECLARATION_TYPES: function() {
        return MODULEDECLARATION_TYPES;
      },
      MODULESPECIFIER_TYPES: function() {
        return MODULESPECIFIER_TYPES;
      },
      MemberExpression: function() {
        return memberExpression;
      },
      MetaProperty: function() {
        return metaProperty;
      },
      MixedTypeAnnotation: function() {
        return mixedTypeAnnotation;
      },
      ModuleExpression: function() {
        return moduleExpression;
      },
      NODE_FIELDS: function() {
        return NODE_FIELDS;
      },
      NODE_PARENT_VALIDATIONS: function() {
        return NODE_PARENT_VALIDATIONS;
      },
      NOT_LOCAL_BINDING: function() {
        return NOT_LOCAL_BINDING;
      },
      NUMBER_BINARY_OPERATORS: function() {
        return NUMBER_BINARY_OPERATORS;
      },
      NUMBER_UNARY_OPERATORS: function() {
        return NUMBER_UNARY_OPERATORS;
      },
      NewExpression: function() {
        return newExpression;
      },
      Noop: function() {
        return noop;
      },
      NullLiteral: function() {
        return nullLiteral;
      },
      NullLiteralTypeAnnotation: function() {
        return nullLiteralTypeAnnotation;
      },
      NullableTypeAnnotation: function() {
        return nullableTypeAnnotation;
      },
      NumberLiteral: function() {
        return NumberLiteral;
      },
      NumberLiteralTypeAnnotation: function() {
        return numberLiteralTypeAnnotation;
      },
      NumberTypeAnnotation: function() {
        return numberTypeAnnotation;
      },
      NumericLiteral: function() {
        return numericLiteral;
      },
      OBJECTMEMBER_TYPES: function() {
        return OBJECTMEMBER_TYPES;
      },
      ObjectExpression: function() {
        return objectExpression;
      },
      ObjectMethod: function() {
        return objectMethod;
      },
      ObjectPattern: function() {
        return objectPattern;
      },
      ObjectProperty: function() {
        return objectProperty;
      },
      ObjectTypeAnnotation: function() {
        return objectTypeAnnotation;
      },
      ObjectTypeCallProperty: function() {
        return objectTypeCallProperty;
      },
      ObjectTypeIndexer: function() {
        return objectTypeIndexer;
      },
      ObjectTypeInternalSlot: function() {
        return objectTypeInternalSlot;
      },
      ObjectTypeProperty: function() {
        return objectTypeProperty;
      },
      ObjectTypeSpreadProperty: function() {
        return objectTypeSpreadProperty;
      },
      OpaqueType: function() {
        return opaqueType;
      },
      OptionalCallExpression: function() {
        return optionalCallExpression;
      },
      OptionalIndexedAccessType: function() {
        return optionalIndexedAccessType;
      },
      OptionalMemberExpression: function() {
        return optionalMemberExpression;
      },
      PATTERNLIKE_TYPES: function() {
        return PATTERNLIKE_TYPES;
      },
      PATTERN_TYPES: function() {
        return PATTERN_TYPES;
      },
      PLACEHOLDERS: function() {
        return PLACEHOLDERS;
      },
      PLACEHOLDERS_ALIAS: function() {
        return PLACEHOLDERS_ALIAS;
      },
      PLACEHOLDERS_FLIPPED_ALIAS: function() {
        return PLACEHOLDERS_FLIPPED_ALIAS;
      },
      PRIVATE_TYPES: function() {
        return PRIVATE_TYPES;
      },
      PROPERTY_TYPES: function() {
        return PROPERTY_TYPES;
      },
      PUREISH_TYPES: function() {
        return PUREISH_TYPES;
      },
      ParenthesizedExpression: function() {
        return parenthesizedExpression;
      },
      PipelineBareFunction: function() {
        return pipelineBareFunction;
      },
      PipelinePrimaryTopicReference: function() {
        return pipelinePrimaryTopicReference;
      },
      PipelineTopicExpression: function() {
        return pipelineTopicExpression;
      },
      Placeholder: function() {
        return placeholder;
      },
      PrivateName: function() {
        return privateName;
      },
      Program: function() {
        return program;
      },
      QualifiedTypeIdentifier: function() {
        return qualifiedTypeIdentifier;
      },
      RecordExpression: function() {
        return recordExpression;
      },
      RegExpLiteral: function() {
        return regExpLiteral;
      },
      RegexLiteral: function() {
        return RegexLiteral;
      },
      RestElement: function() {
        return restElement;
      },
      RestProperty: function() {
        return RestProperty;
      },
      ReturnStatement: function() {
        return returnStatement;
      },
      SCOPABLE_TYPES: function() {
        return SCOPABLE_TYPES;
      },
      STANDARDIZED_TYPES: function() {
        return STANDARDIZED_TYPES;
      },
      STATEMENT_OR_BLOCK_KEYS: function() {
        return STATEMENT_OR_BLOCK_KEYS;
      },
      STATEMENT_TYPES: function() {
        return STATEMENT_TYPES;
      },
      STRING_UNARY_OPERATORS: function() {
        return STRING_UNARY_OPERATORS;
      },
      SequenceExpression: function() {
        return sequenceExpression;
      },
      SpreadElement: function() {
        return spreadElement;
      },
      SpreadProperty: function() {
        return SpreadProperty;
      },
      StaticBlock: function() {
        return staticBlock;
      },
      StringLiteral: function() {
        return stringLiteral;
      },
      StringLiteralTypeAnnotation: function() {
        return stringLiteralTypeAnnotation;
      },
      StringTypeAnnotation: function() {
        return stringTypeAnnotation;
      },
      Super: function() {
        return _super;
      },
      SwitchCase: function() {
        return switchCase;
      },
      SwitchStatement: function() {
        return switchStatement;
      },
      SymbolTypeAnnotation: function() {
        return symbolTypeAnnotation;
      },
      TERMINATORLESS_TYPES: function() {
        return TERMINATORLESS_TYPES;
      },
      TSAnyKeyword: function() {
        return tsAnyKeyword;
      },
      TSArrayType: function() {
        return tsArrayType;
      },
      TSAsExpression: function() {
        return tsAsExpression;
      },
      TSBASETYPE_TYPES: function() {
        return TSBASETYPE_TYPES;
      },
      TSBigIntKeyword: function() {
        return tsBigIntKeyword;
      },
      TSBooleanKeyword: function() {
        return tsBooleanKeyword;
      },
      TSCallSignatureDeclaration: function() {
        return tsCallSignatureDeclaration;
      },
      TSConditionalType: function() {
        return tsConditionalType;
      },
      TSConstructSignatureDeclaration: function() {
        return tsConstructSignatureDeclaration;
      },
      TSConstructorType: function() {
        return tsConstructorType;
      },
      TSDeclareFunction: function() {
        return tsDeclareFunction;
      },
      TSDeclareMethod: function() {
        return tsDeclareMethod;
      },
      TSENTITYNAME_TYPES: function() {
        return TSENTITYNAME_TYPES;
      },
      TSEnumDeclaration: function() {
        return tsEnumDeclaration;
      },
      TSEnumMember: function() {
        return tsEnumMember;
      },
      TSExportAssignment: function() {
        return tsExportAssignment;
      },
      TSExpressionWithTypeArguments: function() {
        return tsExpressionWithTypeArguments;
      },
      TSExternalModuleReference: function() {
        return tsExternalModuleReference;
      },
      TSFunctionType: function() {
        return tsFunctionType;
      },
      TSImportEqualsDeclaration: function() {
        return tsImportEqualsDeclaration;
      },
      TSImportType: function() {
        return tsImportType;
      },
      TSIndexSignature: function() {
        return tsIndexSignature;
      },
      TSIndexedAccessType: function() {
        return tsIndexedAccessType;
      },
      TSInferType: function() {
        return tsInferType;
      },
      TSInstantiationExpression: function() {
        return tsInstantiationExpression;
      },
      TSInterfaceBody: function() {
        return tsInterfaceBody;
      },
      TSInterfaceDeclaration: function() {
        return tsInterfaceDeclaration;
      },
      TSIntersectionType: function() {
        return tsIntersectionType;
      },
      TSIntrinsicKeyword: function() {
        return tsIntrinsicKeyword;
      },
      TSLiteralType: function() {
        return tsLiteralType;
      },
      TSMappedType: function() {
        return tsMappedType;
      },
      TSMethodSignature: function() {
        return tsMethodSignature;
      },
      TSModuleBlock: function() {
        return tsModuleBlock;
      },
      TSModuleDeclaration: function() {
        return tsModuleDeclaration;
      },
      TSNamedTupleMember: function() {
        return tsNamedTupleMember;
      },
      TSNamespaceExportDeclaration: function() {
        return tsNamespaceExportDeclaration;
      },
      TSNeverKeyword: function() {
        return tsNeverKeyword;
      },
      TSNonNullExpression: function() {
        return tsNonNullExpression;
      },
      TSNullKeyword: function() {
        return tsNullKeyword;
      },
      TSNumberKeyword: function() {
        return tsNumberKeyword;
      },
      TSObjectKeyword: function() {
        return tsObjectKeyword;
      },
      TSOptionalType: function() {
        return tsOptionalType;
      },
      TSParameterProperty: function() {
        return tsParameterProperty;
      },
      TSParenthesizedType: function() {
        return tsParenthesizedType;
      },
      TSPropertySignature: function() {
        return tsPropertySignature;
      },
      TSQualifiedName: function() {
        return tsQualifiedName;
      },
      TSRestType: function() {
        return tsRestType;
      },
      TSSatisfiesExpression: function() {
        return tsSatisfiesExpression;
      },
      TSStringKeyword: function() {
        return tsStringKeyword;
      },
      TSSymbolKeyword: function() {
        return tsSymbolKeyword;
      },
      TSTYPEELEMENT_TYPES: function() {
        return TSTYPEELEMENT_TYPES;
      },
      TSTYPE_TYPES: function() {
        return TSTYPE_TYPES;
      },
      TSThisType: function() {
        return tsThisType;
      },
      TSTupleType: function() {
        return tsTupleType;
      },
      TSTypeAliasDeclaration: function() {
        return tsTypeAliasDeclaration;
      },
      TSTypeAnnotation: function() {
        return tsTypeAnnotation;
      },
      TSTypeAssertion: function() {
        return tsTypeAssertion;
      },
      TSTypeLiteral: function() {
        return tsTypeLiteral;
      },
      TSTypeOperator: function() {
        return tsTypeOperator;
      },
      TSTypeParameter: function() {
        return tsTypeParameter;
      },
      TSTypeParameterDeclaration: function() {
        return tsTypeParameterDeclaration;
      },
      TSTypeParameterInstantiation: function() {
        return tsTypeParameterInstantiation;
      },
      TSTypePredicate: function() {
        return tsTypePredicate;
      },
      TSTypeQuery: function() {
        return tsTypeQuery;
      },
      TSTypeReference: function() {
        return tsTypeReference;
      },
      TSUndefinedKeyword: function() {
        return tsUndefinedKeyword;
      },
      TSUnionType: function() {
        return tsUnionType;
      },
      TSUnknownKeyword: function() {
        return tsUnknownKeyword;
      },
      TSVoidKeyword: function() {
        return tsVoidKeyword;
      },
      TYPES: function() {
        return TYPES;
      },
      TYPESCRIPT_TYPES: function() {
        return TYPESCRIPT_TYPES;
      },
      TaggedTemplateExpression: function() {
        return taggedTemplateExpression;
      },
      TemplateElement: function() {
        return templateElement;
      },
      TemplateLiteral: function() {
        return templateLiteral;
      },
      ThisExpression: function() {
        return thisExpression;
      },
      ThisTypeAnnotation: function() {
        return thisTypeAnnotation;
      },
      ThrowStatement: function() {
        return throwStatement;
      },
      TopicReference: function() {
        return topicReference;
      },
      TryStatement: function() {
        return tryStatement;
      },
      TupleExpression: function() {
        return tupleExpression;
      },
      TupleTypeAnnotation: function() {
        return tupleTypeAnnotation;
      },
      TypeAlias: function() {
        return typeAlias;
      },
      TypeAnnotation: function() {
        return typeAnnotation;
      },
      TypeCastExpression: function() {
        return typeCastExpression;
      },
      TypeParameter: function() {
        return typeParameter;
      },
      TypeParameterDeclaration: function() {
        return typeParameterDeclaration;
      },
      TypeParameterInstantiation: function() {
        return typeParameterInstantiation;
      },
      TypeofTypeAnnotation: function() {
        return typeofTypeAnnotation;
      },
      UNARYLIKE_TYPES: function() {
        return UNARYLIKE_TYPES;
      },
      UNARY_OPERATORS: function() {
        return UNARY_OPERATORS;
      },
      UPDATE_OPERATORS: function() {
        return UPDATE_OPERATORS;
      },
      USERWHITESPACABLE_TYPES: function() {
        return USERWHITESPACABLE_TYPES;
      },
      UnaryExpression: function() {
        return unaryExpression;
      },
      UnionTypeAnnotation: function() {
        return unionTypeAnnotation;
      },
      UpdateExpression: function() {
        return updateExpression;
      },
      V8IntrinsicIdentifier: function() {
        return v8IntrinsicIdentifier;
      },
      VISITOR_KEYS: function() {
        return VISITOR_KEYS;
      },
      VariableDeclaration: function() {
        return variableDeclaration;
      },
      VariableDeclarator: function() {
        return variableDeclarator;
      },
      Variance: function() {
        return variance;
      },
      VoidTypeAnnotation: function() {
        return voidTypeAnnotation;
      },
      WHILE_TYPES: function() {
        return WHILE_TYPES;
      },
      WhileStatement: function() {
        return whileStatement;
      },
      WithStatement: function() {
        return withStatement;
      },
      YieldExpression: function() {
        return yieldExpression;
      },
      __internal__deprecationWarning: function() {
        return deprecationWarning;
      },
      addComment: function() {
        return addComment;
      },
      addComments: function() {
        return addComments;
      },
      anyTypeAnnotation: function() {
        return anyTypeAnnotation;
      },
      appendToMemberExpression: function() {
        return appendToMemberExpression;
      },
      argumentPlaceholder: function() {
        return argumentPlaceholder;
      },
      arrayExpression: function() {
        return arrayExpression;
      },
      arrayPattern: function() {
        return arrayPattern;
      },
      arrayTypeAnnotation: function() {
        return arrayTypeAnnotation;
      },
      arrowFunctionExpression: function() {
        return arrowFunctionExpression;
      },
      assertAccessor: function() {
        return assertAccessor;
      },
      assertAnyTypeAnnotation: function() {
        return assertAnyTypeAnnotation;
      },
      assertArgumentPlaceholder: function() {
        return assertArgumentPlaceholder;
      },
      assertArrayExpression: function() {
        return assertArrayExpression;
      },
      assertArrayPattern: function() {
        return assertArrayPattern;
      },
      assertArrayTypeAnnotation: function() {
        return assertArrayTypeAnnotation;
      },
      assertArrowFunctionExpression: function() {
        return assertArrowFunctionExpression;
      },
      assertAssignmentExpression: function() {
        return assertAssignmentExpression;
      },
      assertAssignmentPattern: function() {
        return assertAssignmentPattern;
      },
      assertAwaitExpression: function() {
        return assertAwaitExpression;
      },
      assertBigIntLiteral: function() {
        return assertBigIntLiteral;
      },
      assertBinary: function() {
        return assertBinary;
      },
      assertBinaryExpression: function() {
        return assertBinaryExpression;
      },
      assertBindExpression: function() {
        return assertBindExpression;
      },
      assertBlock: function() {
        return assertBlock;
      },
      assertBlockParent: function() {
        return assertBlockParent;
      },
      assertBlockStatement: function() {
        return assertBlockStatement;
      },
      assertBooleanLiteral: function() {
        return assertBooleanLiteral;
      },
      assertBooleanLiteralTypeAnnotation: function() {
        return assertBooleanLiteralTypeAnnotation;
      },
      assertBooleanTypeAnnotation: function() {
        return assertBooleanTypeAnnotation;
      },
      assertBreakStatement: function() {
        return assertBreakStatement;
      },
      assertCallExpression: function() {
        return assertCallExpression;
      },
      assertCatchClause: function() {
        return assertCatchClause;
      },
      assertClass: function() {
        return assertClass;
      },
      assertClassAccessorProperty: function() {
        return assertClassAccessorProperty;
      },
      assertClassBody: function() {
        return assertClassBody;
      },
      assertClassDeclaration: function() {
        return assertClassDeclaration;
      },
      assertClassExpression: function() {
        return assertClassExpression;
      },
      assertClassImplements: function() {
        return assertClassImplements;
      },
      assertClassMethod: function() {
        return assertClassMethod;
      },
      assertClassPrivateMethod: function() {
        return assertClassPrivateMethod;
      },
      assertClassPrivateProperty: function() {
        return assertClassPrivateProperty;
      },
      assertClassProperty: function() {
        return assertClassProperty;
      },
      assertCompletionStatement: function() {
        return assertCompletionStatement;
      },
      assertConditional: function() {
        return assertConditional;
      },
      assertConditionalExpression: function() {
        return assertConditionalExpression;
      },
      assertContinueStatement: function() {
        return assertContinueStatement;
      },
      assertDebuggerStatement: function() {
        return assertDebuggerStatement;
      },
      assertDecimalLiteral: function() {
        return assertDecimalLiteral;
      },
      assertDeclaration: function() {
        return assertDeclaration;
      },
      assertDeclareClass: function() {
        return assertDeclareClass;
      },
      assertDeclareExportAllDeclaration: function() {
        return assertDeclareExportAllDeclaration;
      },
      assertDeclareExportDeclaration: function() {
        return assertDeclareExportDeclaration;
      },
      assertDeclareFunction: function() {
        return assertDeclareFunction;
      },
      assertDeclareInterface: function() {
        return assertDeclareInterface;
      },
      assertDeclareModule: function() {
        return assertDeclareModule;
      },
      assertDeclareModuleExports: function() {
        return assertDeclareModuleExports;
      },
      assertDeclareOpaqueType: function() {
        return assertDeclareOpaqueType;
      },
      assertDeclareTypeAlias: function() {
        return assertDeclareTypeAlias;
      },
      assertDeclareVariable: function() {
        return assertDeclareVariable;
      },
      assertDeclaredPredicate: function() {
        return assertDeclaredPredicate;
      },
      assertDecorator: function() {
        return assertDecorator;
      },
      assertDirective: function() {
        return assertDirective;
      },
      assertDirectiveLiteral: function() {
        return assertDirectiveLiteral;
      },
      assertDoExpression: function() {
        return assertDoExpression;
      },
      assertDoWhileStatement: function() {
        return assertDoWhileStatement;
      },
      assertEmptyStatement: function() {
        return assertEmptyStatement;
      },
      assertEmptyTypeAnnotation: function() {
        return assertEmptyTypeAnnotation;
      },
      assertEnumBody: function() {
        return assertEnumBody;
      },
      assertEnumBooleanBody: function() {
        return assertEnumBooleanBody;
      },
      assertEnumBooleanMember: function() {
        return assertEnumBooleanMember;
      },
      assertEnumDeclaration: function() {
        return assertEnumDeclaration;
      },
      assertEnumDefaultedMember: function() {
        return assertEnumDefaultedMember;
      },
      assertEnumMember: function() {
        return assertEnumMember;
      },
      assertEnumNumberBody: function() {
        return assertEnumNumberBody;
      },
      assertEnumNumberMember: function() {
        return assertEnumNumberMember;
      },
      assertEnumStringBody: function() {
        return assertEnumStringBody;
      },
      assertEnumStringMember: function() {
        return assertEnumStringMember;
      },
      assertEnumSymbolBody: function() {
        return assertEnumSymbolBody;
      },
      assertExistsTypeAnnotation: function() {
        return assertExistsTypeAnnotation;
      },
      assertExportAllDeclaration: function() {
        return assertExportAllDeclaration;
      },
      assertExportDeclaration: function() {
        return assertExportDeclaration;
      },
      assertExportDefaultDeclaration: function() {
        return assertExportDefaultDeclaration;
      },
      assertExportDefaultSpecifier: function() {
        return assertExportDefaultSpecifier;
      },
      assertExportNamedDeclaration: function() {
        return assertExportNamedDeclaration;
      },
      assertExportNamespaceSpecifier: function() {
        return assertExportNamespaceSpecifier;
      },
      assertExportSpecifier: function() {
        return assertExportSpecifier;
      },
      assertExpression: function() {
        return assertExpression;
      },
      assertExpressionStatement: function() {
        return assertExpressionStatement;
      },
      assertExpressionWrapper: function() {
        return assertExpressionWrapper;
      },
      assertFile: function() {
        return assertFile;
      },
      assertFlow: function() {
        return assertFlow;
      },
      assertFlowBaseAnnotation: function() {
        return assertFlowBaseAnnotation;
      },
      assertFlowDeclaration: function() {
        return assertFlowDeclaration;
      },
      assertFlowPredicate: function() {
        return assertFlowPredicate;
      },
      assertFlowType: function() {
        return assertFlowType;
      },
      assertFor: function() {
        return assertFor;
      },
      assertForInStatement: function() {
        return assertForInStatement;
      },
      assertForOfStatement: function() {
        return assertForOfStatement;
      },
      assertForStatement: function() {
        return assertForStatement;
      },
      assertForXStatement: function() {
        return assertForXStatement;
      },
      assertFunction: function() {
        return assertFunction;
      },
      assertFunctionDeclaration: function() {
        return assertFunctionDeclaration;
      },
      assertFunctionExpression: function() {
        return assertFunctionExpression;
      },
      assertFunctionParent: function() {
        return assertFunctionParent;
      },
      assertFunctionTypeAnnotation: function() {
        return assertFunctionTypeAnnotation;
      },
      assertFunctionTypeParam: function() {
        return assertFunctionTypeParam;
      },
      assertGenericTypeAnnotation: function() {
        return assertGenericTypeAnnotation;
      },
      assertIdentifier: function() {
        return assertIdentifier;
      },
      assertIfStatement: function() {
        return assertIfStatement;
      },
      assertImmutable: function() {
        return assertImmutable;
      },
      assertImport: function() {
        return assertImport;
      },
      assertImportAttribute: function() {
        return assertImportAttribute;
      },
      assertImportDeclaration: function() {
        return assertImportDeclaration;
      },
      assertImportDefaultSpecifier: function() {
        return assertImportDefaultSpecifier;
      },
      assertImportExpression: function() {
        return assertImportExpression;
      },
      assertImportNamespaceSpecifier: function() {
        return assertImportNamespaceSpecifier;
      },
      assertImportOrExportDeclaration: function() {
        return assertImportOrExportDeclaration;
      },
      assertImportSpecifier: function() {
        return assertImportSpecifier;
      },
      assertIndexedAccessType: function() {
        return assertIndexedAccessType;
      },
      assertInferredPredicate: function() {
        return assertInferredPredicate;
      },
      assertInterfaceDeclaration: function() {
        return assertInterfaceDeclaration;
      },
      assertInterfaceExtends: function() {
        return assertInterfaceExtends;
      },
      assertInterfaceTypeAnnotation: function() {
        return assertInterfaceTypeAnnotation;
      },
      assertInterpreterDirective: function() {
        return assertInterpreterDirective;
      },
      assertIntersectionTypeAnnotation: function() {
        return assertIntersectionTypeAnnotation;
      },
      assertJSX: function() {
        return assertJSX;
      },
      assertJSXAttribute: function() {
        return assertJSXAttribute;
      },
      assertJSXClosingElement: function() {
        return assertJSXClosingElement;
      },
      assertJSXClosingFragment: function() {
        return assertJSXClosingFragment;
      },
      assertJSXElement: function() {
        return assertJSXElement;
      },
      assertJSXEmptyExpression: function() {
        return assertJSXEmptyExpression;
      },
      assertJSXExpressionContainer: function() {
        return assertJSXExpressionContainer;
      },
      assertJSXFragment: function() {
        return assertJSXFragment;
      },
      assertJSXIdentifier: function() {
        return assertJSXIdentifier;
      },
      assertJSXMemberExpression: function() {
        return assertJSXMemberExpression;
      },
      assertJSXNamespacedName: function() {
        return assertJSXNamespacedName;
      },
      assertJSXOpeningElement: function() {
        return assertJSXOpeningElement;
      },
      assertJSXOpeningFragment: function() {
        return assertJSXOpeningFragment;
      },
      assertJSXSpreadAttribute: function() {
        return assertJSXSpreadAttribute;
      },
      assertJSXSpreadChild: function() {
        return assertJSXSpreadChild;
      },
      assertJSXText: function() {
        return assertJSXText;
      },
      assertLVal: function() {
        return assertLVal;
      },
      assertLabeledStatement: function() {
        return assertLabeledStatement;
      },
      assertLiteral: function() {
        return assertLiteral;
      },
      assertLogicalExpression: function() {
        return assertLogicalExpression;
      },
      assertLoop: function() {
        return assertLoop;
      },
      assertMemberExpression: function() {
        return assertMemberExpression;
      },
      assertMetaProperty: function() {
        return assertMetaProperty;
      },
      assertMethod: function() {
        return assertMethod;
      },
      assertMiscellaneous: function() {
        return assertMiscellaneous;
      },
      assertMixedTypeAnnotation: function() {
        return assertMixedTypeAnnotation;
      },
      assertModuleDeclaration: function() {
        return assertModuleDeclaration;
      },
      assertModuleExpression: function() {
        return assertModuleExpression;
      },
      assertModuleSpecifier: function() {
        return assertModuleSpecifier;
      },
      assertNewExpression: function() {
        return assertNewExpression;
      },
      assertNode: function() {
        return assertNode2;
      },
      assertNoop: function() {
        return assertNoop;
      },
      assertNullLiteral: function() {
        return assertNullLiteral;
      },
      assertNullLiteralTypeAnnotation: function() {
        return assertNullLiteralTypeAnnotation;
      },
      assertNullableTypeAnnotation: function() {
        return assertNullableTypeAnnotation;
      },
      assertNumberLiteral: function() {
        return assertNumberLiteral;
      },
      assertNumberLiteralTypeAnnotation: function() {
        return assertNumberLiteralTypeAnnotation;
      },
      assertNumberTypeAnnotation: function() {
        return assertNumberTypeAnnotation;
      },
      assertNumericLiteral: function() {
        return assertNumericLiteral;
      },
      assertObjectExpression: function() {
        return assertObjectExpression;
      },
      assertObjectMember: function() {
        return assertObjectMember;
      },
      assertObjectMethod: function() {
        return assertObjectMethod;
      },
      assertObjectPattern: function() {
        return assertObjectPattern;
      },
      assertObjectProperty: function() {
        return assertObjectProperty;
      },
      assertObjectTypeAnnotation: function() {
        return assertObjectTypeAnnotation;
      },
      assertObjectTypeCallProperty: function() {
        return assertObjectTypeCallProperty;
      },
      assertObjectTypeIndexer: function() {
        return assertObjectTypeIndexer;
      },
      assertObjectTypeInternalSlot: function() {
        return assertObjectTypeInternalSlot;
      },
      assertObjectTypeProperty: function() {
        return assertObjectTypeProperty;
      },
      assertObjectTypeSpreadProperty: function() {
        return assertObjectTypeSpreadProperty;
      },
      assertOpaqueType: function() {
        return assertOpaqueType;
      },
      assertOptionalCallExpression: function() {
        return assertOptionalCallExpression;
      },
      assertOptionalIndexedAccessType: function() {
        return assertOptionalIndexedAccessType;
      },
      assertOptionalMemberExpression: function() {
        return assertOptionalMemberExpression;
      },
      assertParenthesizedExpression: function() {
        return assertParenthesizedExpression;
      },
      assertPattern: function() {
        return assertPattern;
      },
      assertPatternLike: function() {
        return assertPatternLike;
      },
      assertPipelineBareFunction: function() {
        return assertPipelineBareFunction;
      },
      assertPipelinePrimaryTopicReference: function() {
        return assertPipelinePrimaryTopicReference;
      },
      assertPipelineTopicExpression: function() {
        return assertPipelineTopicExpression;
      },
      assertPlaceholder: function() {
        return assertPlaceholder;
      },
      assertPrivate: function() {
        return assertPrivate;
      },
      assertPrivateName: function() {
        return assertPrivateName;
      },
      assertProgram: function() {
        return assertProgram;
      },
      assertProperty: function() {
        return assertProperty;
      },
      assertPureish: function() {
        return assertPureish;
      },
      assertQualifiedTypeIdentifier: function() {
        return assertQualifiedTypeIdentifier;
      },
      assertRecordExpression: function() {
        return assertRecordExpression;
      },
      assertRegExpLiteral: function() {
        return assertRegExpLiteral;
      },
      assertRegexLiteral: function() {
        return assertRegexLiteral;
      },
      assertRestElement: function() {
        return assertRestElement;
      },
      assertRestProperty: function() {
        return assertRestProperty;
      },
      assertReturnStatement: function() {
        return assertReturnStatement;
      },
      assertScopable: function() {
        return assertScopable;
      },
      assertSequenceExpression: function() {
        return assertSequenceExpression;
      },
      assertSpreadElement: function() {
        return assertSpreadElement;
      },
      assertSpreadProperty: function() {
        return assertSpreadProperty;
      },
      assertStandardized: function() {
        return assertStandardized;
      },
      assertStatement: function() {
        return assertStatement;
      },
      assertStaticBlock: function() {
        return assertStaticBlock;
      },
      assertStringLiteral: function() {
        return assertStringLiteral;
      },
      assertStringLiteralTypeAnnotation: function() {
        return assertStringLiteralTypeAnnotation;
      },
      assertStringTypeAnnotation: function() {
        return assertStringTypeAnnotation;
      },
      assertSuper: function() {
        return assertSuper;
      },
      assertSwitchCase: function() {
        return assertSwitchCase;
      },
      assertSwitchStatement: function() {
        return assertSwitchStatement;
      },
      assertSymbolTypeAnnotation: function() {
        return assertSymbolTypeAnnotation;
      },
      assertTSAnyKeyword: function() {
        return assertTSAnyKeyword;
      },
      assertTSArrayType: function() {
        return assertTSArrayType;
      },
      assertTSAsExpression: function() {
        return assertTSAsExpression;
      },
      assertTSBaseType: function() {
        return assertTSBaseType;
      },
      assertTSBigIntKeyword: function() {
        return assertTSBigIntKeyword;
      },
      assertTSBooleanKeyword: function() {
        return assertTSBooleanKeyword;
      },
      assertTSCallSignatureDeclaration: function() {
        return assertTSCallSignatureDeclaration;
      },
      assertTSConditionalType: function() {
        return assertTSConditionalType;
      },
      assertTSConstructSignatureDeclaration: function() {
        return assertTSConstructSignatureDeclaration;
      },
      assertTSConstructorType: function() {
        return assertTSConstructorType;
      },
      assertTSDeclareFunction: function() {
        return assertTSDeclareFunction;
      },
      assertTSDeclareMethod: function() {
        return assertTSDeclareMethod;
      },
      assertTSEntityName: function() {
        return assertTSEntityName;
      },
      assertTSEnumDeclaration: function() {
        return assertTSEnumDeclaration;
      },
      assertTSEnumMember: function() {
        return assertTSEnumMember;
      },
      assertTSExportAssignment: function() {
        return assertTSExportAssignment;
      },
      assertTSExpressionWithTypeArguments: function() {
        return assertTSExpressionWithTypeArguments;
      },
      assertTSExternalModuleReference: function() {
        return assertTSExternalModuleReference;
      },
      assertTSFunctionType: function() {
        return assertTSFunctionType;
      },
      assertTSImportEqualsDeclaration: function() {
        return assertTSImportEqualsDeclaration;
      },
      assertTSImportType: function() {
        return assertTSImportType;
      },
      assertTSIndexSignature: function() {
        return assertTSIndexSignature;
      },
      assertTSIndexedAccessType: function() {
        return assertTSIndexedAccessType;
      },
      assertTSInferType: function() {
        return assertTSInferType;
      },
      assertTSInstantiationExpression: function() {
        return assertTSInstantiationExpression;
      },
      assertTSInterfaceBody: function() {
        return assertTSInterfaceBody;
      },
      assertTSInterfaceDeclaration: function() {
        return assertTSInterfaceDeclaration;
      },
      assertTSIntersectionType: function() {
        return assertTSIntersectionType;
      },
      assertTSIntrinsicKeyword: function() {
        return assertTSIntrinsicKeyword;
      },
      assertTSLiteralType: function() {
        return assertTSLiteralType;
      },
      assertTSMappedType: function() {
        return assertTSMappedType;
      },
      assertTSMethodSignature: function() {
        return assertTSMethodSignature;
      },
      assertTSModuleBlock: function() {
        return assertTSModuleBlock;
      },
      assertTSModuleDeclaration: function() {
        return assertTSModuleDeclaration;
      },
      assertTSNamedTupleMember: function() {
        return assertTSNamedTupleMember;
      },
      assertTSNamespaceExportDeclaration: function() {
        return assertTSNamespaceExportDeclaration;
      },
      assertTSNeverKeyword: function() {
        return assertTSNeverKeyword;
      },
      assertTSNonNullExpression: function() {
        return assertTSNonNullExpression;
      },
      assertTSNullKeyword: function() {
        return assertTSNullKeyword;
      },
      assertTSNumberKeyword: function() {
        return assertTSNumberKeyword;
      },
      assertTSObjectKeyword: function() {
        return assertTSObjectKeyword;
      },
      assertTSOptionalType: function() {
        return assertTSOptionalType;
      },
      assertTSParameterProperty: function() {
        return assertTSParameterProperty;
      },
      assertTSParenthesizedType: function() {
        return assertTSParenthesizedType;
      },
      assertTSPropertySignature: function() {
        return assertTSPropertySignature;
      },
      assertTSQualifiedName: function() {
        return assertTSQualifiedName;
      },
      assertTSRestType: function() {
        return assertTSRestType;
      },
      assertTSSatisfiesExpression: function() {
        return assertTSSatisfiesExpression;
      },
      assertTSStringKeyword: function() {
        return assertTSStringKeyword;
      },
      assertTSSymbolKeyword: function() {
        return assertTSSymbolKeyword;
      },
      assertTSThisType: function() {
        return assertTSThisType;
      },
      assertTSTupleType: function() {
        return assertTSTupleType;
      },
      assertTSType: function() {
        return assertTSType;
      },
      assertTSTypeAliasDeclaration: function() {
        return assertTSTypeAliasDeclaration;
      },
      assertTSTypeAnnotation: function() {
        return assertTSTypeAnnotation;
      },
      assertTSTypeAssertion: function() {
        return assertTSTypeAssertion;
      },
      assertTSTypeElement: function() {
        return assertTSTypeElement;
      },
      assertTSTypeLiteral: function() {
        return assertTSTypeLiteral;
      },
      assertTSTypeOperator: function() {
        return assertTSTypeOperator;
      },
      assertTSTypeParameter: function() {
        return assertTSTypeParameter;
      },
      assertTSTypeParameterDeclaration: function() {
        return assertTSTypeParameterDeclaration;
      },
      assertTSTypeParameterInstantiation: function() {
        return assertTSTypeParameterInstantiation;
      },
      assertTSTypePredicate: function() {
        return assertTSTypePredicate;
      },
      assertTSTypeQuery: function() {
        return assertTSTypeQuery;
      },
      assertTSTypeReference: function() {
        return assertTSTypeReference;
      },
      assertTSUndefinedKeyword: function() {
        return assertTSUndefinedKeyword;
      },
      assertTSUnionType: function() {
        return assertTSUnionType;
      },
      assertTSUnknownKeyword: function() {
        return assertTSUnknownKeyword;
      },
      assertTSVoidKeyword: function() {
        return assertTSVoidKeyword;
      },
      assertTaggedTemplateExpression: function() {
        return assertTaggedTemplateExpression;
      },
      assertTemplateElement: function() {
        return assertTemplateElement;
      },
      assertTemplateLiteral: function() {
        return assertTemplateLiteral;
      },
      assertTerminatorless: function() {
        return assertTerminatorless;
      },
      assertThisExpression: function() {
        return assertThisExpression;
      },
      assertThisTypeAnnotation: function() {
        return assertThisTypeAnnotation;
      },
      assertThrowStatement: function() {
        return assertThrowStatement;
      },
      assertTopicReference: function() {
        return assertTopicReference;
      },
      assertTryStatement: function() {
        return assertTryStatement;
      },
      assertTupleExpression: function() {
        return assertTupleExpression;
      },
      assertTupleTypeAnnotation: function() {
        return assertTupleTypeAnnotation;
      },
      assertTypeAlias: function() {
        return assertTypeAlias;
      },
      assertTypeAnnotation: function() {
        return assertTypeAnnotation;
      },
      assertTypeCastExpression: function() {
        return assertTypeCastExpression;
      },
      assertTypeParameter: function() {
        return assertTypeParameter;
      },
      assertTypeParameterDeclaration: function() {
        return assertTypeParameterDeclaration;
      },
      assertTypeParameterInstantiation: function() {
        return assertTypeParameterInstantiation;
      },
      assertTypeScript: function() {
        return assertTypeScript;
      },
      assertTypeofTypeAnnotation: function() {
        return assertTypeofTypeAnnotation;
      },
      assertUnaryExpression: function() {
        return assertUnaryExpression;
      },
      assertUnaryLike: function() {
        return assertUnaryLike;
      },
      assertUnionTypeAnnotation: function() {
        return assertUnionTypeAnnotation;
      },
      assertUpdateExpression: function() {
        return assertUpdateExpression;
      },
      assertUserWhitespacable: function() {
        return assertUserWhitespacable;
      },
      assertV8IntrinsicIdentifier: function() {
        return assertV8IntrinsicIdentifier;
      },
      assertVariableDeclaration: function() {
        return assertVariableDeclaration;
      },
      assertVariableDeclarator: function() {
        return assertVariableDeclarator;
      },
      assertVariance: function() {
        return assertVariance;
      },
      assertVoidTypeAnnotation: function() {
        return assertVoidTypeAnnotation;
      },
      assertWhile: function() {
        return assertWhile;
      },
      assertWhileStatement: function() {
        return assertWhileStatement;
      },
      assertWithStatement: function() {
        return assertWithStatement;
      },
      assertYieldExpression: function() {
        return assertYieldExpression;
      },
      assignmentExpression: function() {
        return assignmentExpression;
      },
      assignmentPattern: function() {
        return assignmentPattern;
      },
      awaitExpression: function() {
        return awaitExpression;
      },
      bigIntLiteral: function() {
        return bigIntLiteral;
      },
      binaryExpression: function() {
        return binaryExpression;
      },
      bindExpression: function() {
        return bindExpression;
      },
      blockStatement: function() {
        return blockStatement;
      },
      booleanLiteral: function() {
        return booleanLiteral;
      },
      booleanLiteralTypeAnnotation: function() {
        return booleanLiteralTypeAnnotation;
      },
      booleanTypeAnnotation: function() {
        return booleanTypeAnnotation;
      },
      breakStatement: function() {
        return breakStatement;
      },
      buildMatchMemberExpression: function() {
        return buildMatchMemberExpression;
      },
      buildUndefinedNode: function() {
        return buildUndefinedNode;
      },
      callExpression: function() {
        return callExpression;
      },
      catchClause: function() {
        return catchClause;
      },
      classAccessorProperty: function() {
        return classAccessorProperty;
      },
      classBody: function() {
        return classBody;
      },
      classDeclaration: function() {
        return classDeclaration;
      },
      classExpression: function() {
        return classExpression;
      },
      classImplements: function() {
        return classImplements;
      },
      classMethod: function() {
        return classMethod;
      },
      classPrivateMethod: function() {
        return classPrivateMethod;
      },
      classPrivateProperty: function() {
        return classPrivateProperty;
      },
      classProperty: function() {
        return classProperty;
      },
      clone: function() {
        return clone;
      },
      cloneDeep: function() {
        return cloneDeep2;
      },
      cloneDeepWithoutLoc: function() {
        return cloneDeepWithoutLoc;
      },
      cloneNode: function() {
        return cloneNode;
      },
      cloneWithoutLoc: function() {
        return cloneWithoutLoc;
      },
      conditionalExpression: function() {
        return conditionalExpression;
      },
      continueStatement: function() {
        return continueStatement;
      },
      createFlowUnionType: function() {
        return createFlowUnionType;
      },
      createTSUnionType: function() {
        return createTSUnionType;
      },
      createTypeAnnotationBasedOnTypeof: function() {
        return createTypeAnnotationBasedOnTypeof;
      },
      createUnionTypeAnnotation: function() {
        return createFlowUnionType;
      },
      debuggerStatement: function() {
        return debuggerStatement;
      },
      decimalLiteral: function() {
        return decimalLiteral;
      },
      declareClass: function() {
        return declareClass;
      },
      declareExportAllDeclaration: function() {
        return declareExportAllDeclaration;
      },
      declareExportDeclaration: function() {
        return declareExportDeclaration;
      },
      declareFunction: function() {
        return declareFunction;
      },
      declareInterface: function() {
        return declareInterface;
      },
      declareModule: function() {
        return declareModule;
      },
      declareModuleExports: function() {
        return declareModuleExports;
      },
      declareOpaqueType: function() {
        return declareOpaqueType;
      },
      declareTypeAlias: function() {
        return declareTypeAlias;
      },
      declareVariable: function() {
        return declareVariable;
      },
      declaredPredicate: function() {
        return declaredPredicate;
      },
      decorator: function() {
        return decorator;
      },
      directive: function() {
        return directive;
      },
      directiveLiteral: function() {
        return directiveLiteral;
      },
      doExpression: function() {
        return doExpression;
      },
      doWhileStatement: function() {
        return doWhileStatement;
      },
      emptyStatement: function() {
        return emptyStatement;
      },
      emptyTypeAnnotation: function() {
        return emptyTypeAnnotation;
      },
      ensureBlock: function() {
        return ensureBlock;
      },
      enumBooleanBody: function() {
        return enumBooleanBody;
      },
      enumBooleanMember: function() {
        return enumBooleanMember;
      },
      enumDeclaration: function() {
        return enumDeclaration;
      },
      enumDefaultedMember: function() {
        return enumDefaultedMember;
      },
      enumNumberBody: function() {
        return enumNumberBody;
      },
      enumNumberMember: function() {
        return enumNumberMember;
      },
      enumStringBody: function() {
        return enumStringBody;
      },
      enumStringMember: function() {
        return enumStringMember;
      },
      enumSymbolBody: function() {
        return enumSymbolBody;
      },
      existsTypeAnnotation: function() {
        return existsTypeAnnotation;
      },
      exportAllDeclaration: function() {
        return exportAllDeclaration;
      },
      exportDefaultDeclaration: function() {
        return exportDefaultDeclaration;
      },
      exportDefaultSpecifier: function() {
        return exportDefaultSpecifier;
      },
      exportNamedDeclaration: function() {
        return exportNamedDeclaration;
      },
      exportNamespaceSpecifier: function() {
        return exportNamespaceSpecifier;
      },
      exportSpecifier: function() {
        return exportSpecifier;
      },
      expressionStatement: function() {
        return expressionStatement;
      },
      file: function() {
        return file;
      },
      forInStatement: function() {
        return forInStatement;
      },
      forOfStatement: function() {
        return forOfStatement;
      },
      forStatement: function() {
        return forStatement;
      },
      functionDeclaration: function() {
        return functionDeclaration;
      },
      functionExpression: function() {
        return functionExpression;
      },
      functionTypeAnnotation: function() {
        return functionTypeAnnotation;
      },
      functionTypeParam: function() {
        return functionTypeParam;
      },
      genericTypeAnnotation: function() {
        return genericTypeAnnotation;
      },
      getBindingIdentifiers: function() {
        return getBindingIdentifiers;
      },
      getOuterBindingIdentifiers: function() {
        return getOuterBindingIdentifiers;
      },
      identifier: function() {
        return identifier;
      },
      ifStatement: function() {
        return ifStatement;
      },
      import: function() {
        return _import;
      },
      importAttribute: function() {
        return importAttribute;
      },
      importDeclaration: function() {
        return importDeclaration;
      },
      importDefaultSpecifier: function() {
        return importDefaultSpecifier;
      },
      importExpression: function() {
        return importExpression;
      },
      importNamespaceSpecifier: function() {
        return importNamespaceSpecifier;
      },
      importSpecifier: function() {
        return importSpecifier;
      },
      indexedAccessType: function() {
        return indexedAccessType;
      },
      inferredPredicate: function() {
        return inferredPredicate;
      },
      inheritInnerComments: function() {
        return inheritInnerComments;
      },
      inheritLeadingComments: function() {
        return inheritLeadingComments;
      },
      inheritTrailingComments: function() {
        return inheritTrailingComments;
      },
      inherits: function() {
        return inherits;
      },
      inheritsComments: function() {
        return inheritsComments;
      },
      interfaceDeclaration: function() {
        return interfaceDeclaration;
      },
      interfaceExtends: function() {
        return interfaceExtends;
      },
      interfaceTypeAnnotation: function() {
        return interfaceTypeAnnotation;
      },
      interpreterDirective: function() {
        return interpreterDirective;
      },
      intersectionTypeAnnotation: function() {
        return intersectionTypeAnnotation;
      },
      is: function() {
        return is2;
      },
      isAccessor: function() {
        return isAccessor;
      },
      isAnyTypeAnnotation: function() {
        return isAnyTypeAnnotation;
      },
      isArgumentPlaceholder: function() {
        return isArgumentPlaceholder;
      },
      isArrayExpression: function() {
        return isArrayExpression2;
      },
      isArrayPattern: function() {
        return isArrayPattern;
      },
      isArrayTypeAnnotation: function() {
        return isArrayTypeAnnotation;
      },
      isArrowFunctionExpression: function() {
        return isArrowFunctionExpression;
      },
      isAssignmentExpression: function() {
        return isAssignmentExpression;
      },
      isAssignmentPattern: function() {
        return isAssignmentPattern;
      },
      isAwaitExpression: function() {
        return isAwaitExpression;
      },
      isBigIntLiteral: function() {
        return isBigIntLiteral;
      },
      isBinary: function() {
        return isBinary;
      },
      isBinaryExpression: function() {
        return isBinaryExpression;
      },
      isBindExpression: function() {
        return isBindExpression;
      },
      isBinding: function() {
        return isBinding;
      },
      isBlock: function() {
        return isBlock;
      },
      isBlockParent: function() {
        return isBlockParent;
      },
      isBlockScoped: function() {
        return isBlockScoped;
      },
      isBlockStatement: function() {
        return isBlockStatement;
      },
      isBooleanLiteral: function() {
        return isBooleanLiteral2;
      },
      isBooleanLiteralTypeAnnotation: function() {
        return isBooleanLiteralTypeAnnotation;
      },
      isBooleanTypeAnnotation: function() {
        return isBooleanTypeAnnotation;
      },
      isBreakStatement: function() {
        return isBreakStatement;
      },
      isCallExpression: function() {
        return isCallExpression;
      },
      isCatchClause: function() {
        return isCatchClause;
      },
      isClass: function() {
        return isClass;
      },
      isClassAccessorProperty: function() {
        return isClassAccessorProperty;
      },
      isClassBody: function() {
        return isClassBody;
      },
      isClassDeclaration: function() {
        return isClassDeclaration;
      },
      isClassExpression: function() {
        return isClassExpression;
      },
      isClassImplements: function() {
        return isClassImplements;
      },
      isClassMethod: function() {
        return isClassMethod;
      },
      isClassPrivateMethod: function() {
        return isClassPrivateMethod;
      },
      isClassPrivateProperty: function() {
        return isClassPrivateProperty;
      },
      isClassProperty: function() {
        return isClassProperty;
      },
      isCompletionStatement: function() {
        return isCompletionStatement;
      },
      isConditional: function() {
        return isConditional;
      },
      isConditionalExpression: function() {
        return isConditionalExpression;
      },
      isContinueStatement: function() {
        return isContinueStatement;
      },
      isDebuggerStatement: function() {
        return isDebuggerStatement;
      },
      isDecimalLiteral: function() {
        return isDecimalLiteral;
      },
      isDeclaration: function() {
        return isDeclaration2;
      },
      isDeclareClass: function() {
        return isDeclareClass;
      },
      isDeclareExportAllDeclaration: function() {
        return isDeclareExportAllDeclaration;
      },
      isDeclareExportDeclaration: function() {
        return isDeclareExportDeclaration;
      },
      isDeclareFunction: function() {
        return isDeclareFunction;
      },
      isDeclareInterface: function() {
        return isDeclareInterface;
      },
      isDeclareModule: function() {
        return isDeclareModule;
      },
      isDeclareModuleExports: function() {
        return isDeclareModuleExports;
      },
      isDeclareOpaqueType: function() {
        return isDeclareOpaqueType;
      },
      isDeclareTypeAlias: function() {
        return isDeclareTypeAlias;
      },
      isDeclareVariable: function() {
        return isDeclareVariable;
      },
      isDeclaredPredicate: function() {
        return isDeclaredPredicate;
      },
      isDecorator: function() {
        return isDecorator;
      },
      isDirective: function() {
        return isDirective;
      },
      isDirectiveLiteral: function() {
        return isDirectiveLiteral;
      },
      isDoExpression: function() {
        return isDoExpression;
      },
      isDoWhileStatement: function() {
        return isDoWhileStatement;
      },
      isEmptyStatement: function() {
        return isEmptyStatement;
      },
      isEmptyTypeAnnotation: function() {
        return isEmptyTypeAnnotation;
      },
      isEnumBody: function() {
        return isEnumBody;
      },
      isEnumBooleanBody: function() {
        return isEnumBooleanBody;
      },
      isEnumBooleanMember: function() {
        return isEnumBooleanMember;
      },
      isEnumDeclaration: function() {
        return isEnumDeclaration;
      },
      isEnumDefaultedMember: function() {
        return isEnumDefaultedMember;
      },
      isEnumMember: function() {
        return isEnumMember;
      },
      isEnumNumberBody: function() {
        return isEnumNumberBody;
      },
      isEnumNumberMember: function() {
        return isEnumNumberMember;
      },
      isEnumStringBody: function() {
        return isEnumStringBody;
      },
      isEnumStringMember: function() {
        return isEnumStringMember;
      },
      isEnumSymbolBody: function() {
        return isEnumSymbolBody;
      },
      isExistsTypeAnnotation: function() {
        return isExistsTypeAnnotation;
      },
      isExportAllDeclaration: function() {
        return isExportAllDeclaration;
      },
      isExportDeclaration: function() {
        return isExportDeclaration;
      },
      isExportDefaultDeclaration: function() {
        return isExportDefaultDeclaration;
      },
      isExportDefaultSpecifier: function() {
        return isExportDefaultSpecifier;
      },
      isExportNamedDeclaration: function() {
        return isExportNamedDeclaration;
      },
      isExportNamespaceSpecifier: function() {
        return isExportNamespaceSpecifier;
      },
      isExportSpecifier: function() {
        return isExportSpecifier;
      },
      isExpression: function() {
        return isExpression;
      },
      isExpressionStatement: function() {
        return isExpressionStatement2;
      },
      isExpressionWrapper: function() {
        return isExpressionWrapper;
      },
      isFile: function() {
        return isFile;
      },
      isFlow: function() {
        return isFlow;
      },
      isFlowBaseAnnotation: function() {
        return isFlowBaseAnnotation;
      },
      isFlowDeclaration: function() {
        return isFlowDeclaration;
      },
      isFlowPredicate: function() {
        return isFlowPredicate;
      },
      isFlowType: function() {
        return isFlowType;
      },
      isFor: function() {
        return isFor;
      },
      isForInStatement: function() {
        return isForInStatement;
      },
      isForOfStatement: function() {
        return isForOfStatement;
      },
      isForStatement: function() {
        return isForStatement;
      },
      isForXStatement: function() {
        return isForXStatement;
      },
      isFunction: function() {
        return isFunction;
      },
      isFunctionDeclaration: function() {
        return isFunctionDeclaration;
      },
      isFunctionExpression: function() {
        return isFunctionExpression;
      },
      isFunctionParent: function() {
        return isFunctionParent;
      },
      isFunctionTypeAnnotation: function() {
        return isFunctionTypeAnnotation;
      },
      isFunctionTypeParam: function() {
        return isFunctionTypeParam;
      },
      isGenericTypeAnnotation: function() {
        return isGenericTypeAnnotation;
      },
      isIdentifier: function() {
        return isIdentifier2;
      },
      isIfStatement: function() {
        return isIfStatement;
      },
      isImmutable: function() {
        return isImmutable;
      },
      isImport: function() {
        return isImport;
      },
      isImportAttribute: function() {
        return isImportAttribute;
      },
      isImportDeclaration: function() {
        return isImportDeclaration;
      },
      isImportDefaultSpecifier: function() {
        return isImportDefaultSpecifier;
      },
      isImportExpression: function() {
        return isImportExpression;
      },
      isImportNamespaceSpecifier: function() {
        return isImportNamespaceSpecifier;
      },
      isImportOrExportDeclaration: function() {
        return isImportOrExportDeclaration;
      },
      isImportSpecifier: function() {
        return isImportSpecifier;
      },
      isIndexedAccessType: function() {
        return isIndexedAccessType;
      },
      isInferredPredicate: function() {
        return isInferredPredicate;
      },
      isInterfaceDeclaration: function() {
        return isInterfaceDeclaration;
      },
      isInterfaceExtends: function() {
        return isInterfaceExtends;
      },
      isInterfaceTypeAnnotation: function() {
        return isInterfaceTypeAnnotation;
      },
      isInterpreterDirective: function() {
        return isInterpreterDirective;
      },
      isIntersectionTypeAnnotation: function() {
        return isIntersectionTypeAnnotation;
      },
      isJSX: function() {
        return isJSX;
      },
      isJSXAttribute: function() {
        return isJSXAttribute;
      },
      isJSXClosingElement: function() {
        return isJSXClosingElement;
      },
      isJSXClosingFragment: function() {
        return isJSXClosingFragment;
      },
      isJSXElement: function() {
        return isJSXElement2;
      },
      isJSXEmptyExpression: function() {
        return isJSXEmptyExpression;
      },
      isJSXExpressionContainer: function() {
        return isJSXExpressionContainer2;
      },
      isJSXFragment: function() {
        return isJSXFragment2;
      },
      isJSXIdentifier: function() {
        return isJSXIdentifier2;
      },
      isJSXMemberExpression: function() {
        return isJSXMemberExpression;
      },
      isJSXNamespacedName: function() {
        return isJSXNamespacedName;
      },
      isJSXOpeningElement: function() {
        return isJSXOpeningElement;
      },
      isJSXOpeningFragment: function() {
        return isJSXOpeningFragment;
      },
      isJSXSpreadAttribute: function() {
        return isJSXSpreadAttribute;
      },
      isJSXSpreadChild: function() {
        return isJSXSpreadChild;
      },
      isJSXText: function() {
        return isJSXText;
      },
      isLVal: function() {
        return isLVal;
      },
      isLabeledStatement: function() {
        return isLabeledStatement;
      },
      isLet: function() {
        return isLet;
      },
      isLiteral: function() {
        return isLiteral;
      },
      isLogicalExpression: function() {
        return isLogicalExpression;
      },
      isLoop: function() {
        return isLoop;
      },
      isMemberExpression: function() {
        return isMemberExpression;
      },
      isMetaProperty: function() {
        return isMetaProperty;
      },
      isMethod: function() {
        return isMethod;
      },
      isMiscellaneous: function() {
        return isMiscellaneous;
      },
      isMixedTypeAnnotation: function() {
        return isMixedTypeAnnotation;
      },
      isModuleDeclaration: function() {
        return isModuleDeclaration;
      },
      isModuleExpression: function() {
        return isModuleExpression;
      },
      isModuleSpecifier: function() {
        return isModuleSpecifier;
      },
      isNewExpression: function() {
        return isNewExpression;
      },
      isNode: function() {
        return isNode2;
      },
      isNodesEquivalent: function() {
        return isNodesEquivalent;
      },
      isNoop: function() {
        return isNoop;
      },
      isNullLiteral: function() {
        return isNullLiteral;
      },
      isNullLiteralTypeAnnotation: function() {
        return isNullLiteralTypeAnnotation;
      },
      isNullableTypeAnnotation: function() {
        return isNullableTypeAnnotation;
      },
      isNumberLiteral: function() {
        return isNumberLiteral;
      },
      isNumberLiteralTypeAnnotation: function() {
        return isNumberLiteralTypeAnnotation;
      },
      isNumberTypeAnnotation: function() {
        return isNumberTypeAnnotation;
      },
      isNumericLiteral: function() {
        return isNumericLiteral;
      },
      isObjectExpression: function() {
        return isObjectExpression;
      },
      isObjectMember: function() {
        return isObjectMember;
      },
      isObjectMethod: function() {
        return isObjectMethod;
      },
      isObjectPattern: function() {
        return isObjectPattern;
      },
      isObjectProperty: function() {
        return isObjectProperty;
      },
      isObjectTypeAnnotation: function() {
        return isObjectTypeAnnotation;
      },
      isObjectTypeCallProperty: function() {
        return isObjectTypeCallProperty;
      },
      isObjectTypeIndexer: function() {
        return isObjectTypeIndexer;
      },
      isObjectTypeInternalSlot: function() {
        return isObjectTypeInternalSlot;
      },
      isObjectTypeProperty: function() {
        return isObjectTypeProperty;
      },
      isObjectTypeSpreadProperty: function() {
        return isObjectTypeSpreadProperty;
      },
      isOpaqueType: function() {
        return isOpaqueType;
      },
      isOptionalCallExpression: function() {
        return isOptionalCallExpression;
      },
      isOptionalIndexedAccessType: function() {
        return isOptionalIndexedAccessType;
      },
      isOptionalMemberExpression: function() {
        return isOptionalMemberExpression;
      },
      isParenthesizedExpression: function() {
        return isParenthesizedExpression;
      },
      isPattern: function() {
        return isPattern;
      },
      isPatternLike: function() {
        return isPatternLike;
      },
      isPipelineBareFunction: function() {
        return isPipelineBareFunction;
      },
      isPipelinePrimaryTopicReference: function() {
        return isPipelinePrimaryTopicReference;
      },
      isPipelineTopicExpression: function() {
        return isPipelineTopicExpression;
      },
      isPlaceholder: function() {
        return isPlaceholder;
      },
      isPlaceholderType: function() {
        return isPlaceholderType;
      },
      isPrivate: function() {
        return isPrivate;
      },
      isPrivateName: function() {
        return isPrivateName;
      },
      isProgram: function() {
        return isProgram;
      },
      isProperty: function() {
        return isProperty;
      },
      isPureish: function() {
        return isPureish;
      },
      isQualifiedTypeIdentifier: function() {
        return isQualifiedTypeIdentifier;
      },
      isRecordExpression: function() {
        return isRecordExpression;
      },
      isReferenced: function() {
        return isReferenced;
      },
      isRegExpLiteral: function() {
        return isRegExpLiteral;
      },
      isRegexLiteral: function() {
        return isRegexLiteral;
      },
      isRestElement: function() {
        return isRestElement;
      },
      isRestProperty: function() {
        return isRestProperty;
      },
      isReturnStatement: function() {
        return isReturnStatement;
      },
      isScopable: function() {
        return isScopable;
      },
      isScope: function() {
        return isScope;
      },
      isSequenceExpression: function() {
        return isSequenceExpression;
      },
      isSpecifierDefault: function() {
        return isSpecifierDefault;
      },
      isSpreadElement: function() {
        return isSpreadElement;
      },
      isSpreadProperty: function() {
        return isSpreadProperty;
      },
      isStandardized: function() {
        return isStandardized;
      },
      isStatement: function() {
        return isStatement;
      },
      isStaticBlock: function() {
        return isStaticBlock;
      },
      isStringLiteral: function() {
        return isStringLiteral2;
      },
      isStringLiteralTypeAnnotation: function() {
        return isStringLiteralTypeAnnotation;
      },
      isStringTypeAnnotation: function() {
        return isStringTypeAnnotation;
      },
      isSuper: function() {
        return isSuper;
      },
      isSwitchCase: function() {
        return isSwitchCase;
      },
      isSwitchStatement: function() {
        return isSwitchStatement;
      },
      isSymbolTypeAnnotation: function() {
        return isSymbolTypeAnnotation;
      },
      isTSAnyKeyword: function() {
        return isTSAnyKeyword;
      },
      isTSArrayType: function() {
        return isTSArrayType;
      },
      isTSAsExpression: function() {
        return isTSAsExpression;
      },
      isTSBaseType: function() {
        return isTSBaseType;
      },
      isTSBigIntKeyword: function() {
        return isTSBigIntKeyword;
      },
      isTSBooleanKeyword: function() {
        return isTSBooleanKeyword;
      },
      isTSCallSignatureDeclaration: function() {
        return isTSCallSignatureDeclaration;
      },
      isTSConditionalType: function() {
        return isTSConditionalType;
      },
      isTSConstructSignatureDeclaration: function() {
        return isTSConstructSignatureDeclaration;
      },
      isTSConstructorType: function() {
        return isTSConstructorType;
      },
      isTSDeclareFunction: function() {
        return isTSDeclareFunction;
      },
      isTSDeclareMethod: function() {
        return isTSDeclareMethod;
      },
      isTSEntityName: function() {
        return isTSEntityName;
      },
      isTSEnumDeclaration: function() {
        return isTSEnumDeclaration;
      },
      isTSEnumMember: function() {
        return isTSEnumMember;
      },
      isTSExportAssignment: function() {
        return isTSExportAssignment;
      },
      isTSExpressionWithTypeArguments: function() {
        return isTSExpressionWithTypeArguments;
      },
      isTSExternalModuleReference: function() {
        return isTSExternalModuleReference;
      },
      isTSFunctionType: function() {
        return isTSFunctionType;
      },
      isTSImportEqualsDeclaration: function() {
        return isTSImportEqualsDeclaration;
      },
      isTSImportType: function() {
        return isTSImportType;
      },
      isTSIndexSignature: function() {
        return isTSIndexSignature;
      },
      isTSIndexedAccessType: function() {
        return isTSIndexedAccessType;
      },
      isTSInferType: function() {
        return isTSInferType;
      },
      isTSInstantiationExpression: function() {
        return isTSInstantiationExpression;
      },
      isTSInterfaceBody: function() {
        return isTSInterfaceBody;
      },
      isTSInterfaceDeclaration: function() {
        return isTSInterfaceDeclaration;
      },
      isTSIntersectionType: function() {
        return isTSIntersectionType;
      },
      isTSIntrinsicKeyword: function() {
        return isTSIntrinsicKeyword;
      },
      isTSLiteralType: function() {
        return isTSLiteralType;
      },
      isTSMappedType: function() {
        return isTSMappedType;
      },
      isTSMethodSignature: function() {
        return isTSMethodSignature;
      },
      isTSModuleBlock: function() {
        return isTSModuleBlock;
      },
      isTSModuleDeclaration: function() {
        return isTSModuleDeclaration;
      },
      isTSNamedTupleMember: function() {
        return isTSNamedTupleMember;
      },
      isTSNamespaceExportDeclaration: function() {
        return isTSNamespaceExportDeclaration;
      },
      isTSNeverKeyword: function() {
        return isTSNeverKeyword;
      },
      isTSNonNullExpression: function() {
        return isTSNonNullExpression;
      },
      isTSNullKeyword: function() {
        return isTSNullKeyword;
      },
      isTSNumberKeyword: function() {
        return isTSNumberKeyword;
      },
      isTSObjectKeyword: function() {
        return isTSObjectKeyword;
      },
      isTSOptionalType: function() {
        return isTSOptionalType;
      },
      isTSParameterProperty: function() {
        return isTSParameterProperty;
      },
      isTSParenthesizedType: function() {
        return isTSParenthesizedType;
      },
      isTSPropertySignature: function() {
        return isTSPropertySignature;
      },
      isTSQualifiedName: function() {
        return isTSQualifiedName;
      },
      isTSRestType: function() {
        return isTSRestType;
      },
      isTSSatisfiesExpression: function() {
        return isTSSatisfiesExpression;
      },
      isTSStringKeyword: function() {
        return isTSStringKeyword;
      },
      isTSSymbolKeyword: function() {
        return isTSSymbolKeyword;
      },
      isTSThisType: function() {
        return isTSThisType;
      },
      isTSTupleType: function() {
        return isTSTupleType;
      },
      isTSType: function() {
        return isTSType;
      },
      isTSTypeAliasDeclaration: function() {
        return isTSTypeAliasDeclaration;
      },
      isTSTypeAnnotation: function() {
        return isTSTypeAnnotation;
      },
      isTSTypeAssertion: function() {
        return isTSTypeAssertion;
      },
      isTSTypeElement: function() {
        return isTSTypeElement;
      },
      isTSTypeLiteral: function() {
        return isTSTypeLiteral;
      },
      isTSTypeOperator: function() {
        return isTSTypeOperator;
      },
      isTSTypeParameter: function() {
        return isTSTypeParameter;
      },
      isTSTypeParameterDeclaration: function() {
        return isTSTypeParameterDeclaration;
      },
      isTSTypeParameterInstantiation: function() {
        return isTSTypeParameterInstantiation;
      },
      isTSTypePredicate: function() {
        return isTSTypePredicate;
      },
      isTSTypeQuery: function() {
        return isTSTypeQuery;
      },
      isTSTypeReference: function() {
        return isTSTypeReference;
      },
      isTSUndefinedKeyword: function() {
        return isTSUndefinedKeyword;
      },
      isTSUnionType: function() {
        return isTSUnionType;
      },
      isTSUnknownKeyword: function() {
        return isTSUnknownKeyword;
      },
      isTSVoidKeyword: function() {
        return isTSVoidKeyword;
      },
      isTaggedTemplateExpression: function() {
        return isTaggedTemplateExpression;
      },
      isTemplateElement: function() {
        return isTemplateElement;
      },
      isTemplateLiteral: function() {
        return isTemplateLiteral;
      },
      isTerminatorless: function() {
        return isTerminatorless;
      },
      isThisExpression: function() {
        return isThisExpression;
      },
      isThisTypeAnnotation: function() {
        return isThisTypeAnnotation;
      },
      isThrowStatement: function() {
        return isThrowStatement;
      },
      isTopicReference: function() {
        return isTopicReference;
      },
      isTryStatement: function() {
        return isTryStatement;
      },
      isTupleExpression: function() {
        return isTupleExpression;
      },
      isTupleTypeAnnotation: function() {
        return isTupleTypeAnnotation;
      },
      isType: function() {
        return isType;
      },
      isTypeAlias: function() {
        return isTypeAlias;
      },
      isTypeAnnotation: function() {
        return isTypeAnnotation;
      },
      isTypeCastExpression: function() {
        return isTypeCastExpression;
      },
      isTypeParameter: function() {
        return isTypeParameter;
      },
      isTypeParameterDeclaration: function() {
        return isTypeParameterDeclaration;
      },
      isTypeParameterInstantiation: function() {
        return isTypeParameterInstantiation;
      },
      isTypeScript: function() {
        return isTypeScript;
      },
      isTypeofTypeAnnotation: function() {
        return isTypeofTypeAnnotation;
      },
      isUnaryExpression: function() {
        return isUnaryExpression;
      },
      isUnaryLike: function() {
        return isUnaryLike;
      },
      isUnionTypeAnnotation: function() {
        return isUnionTypeAnnotation;
      },
      isUpdateExpression: function() {
        return isUpdateExpression;
      },
      isUserWhitespacable: function() {
        return isUserWhitespacable;
      },
      isV8IntrinsicIdentifier: function() {
        return isV8IntrinsicIdentifier;
      },
      isValidES3Identifier: function() {
        return isValidES3Identifier;
      },
      isValidIdentifier: function() {
        return isValidIdentifier;
      },
      isVar: function() {
        return isVar;
      },
      isVariableDeclaration: function() {
        return isVariableDeclaration;
      },
      isVariableDeclarator: function() {
        return isVariableDeclarator;
      },
      isVariance: function() {
        return isVariance;
      },
      isVoidTypeAnnotation: function() {
        return isVoidTypeAnnotation;
      },
      isWhile: function() {
        return isWhile;
      },
      isWhileStatement: function() {
        return isWhileStatement;
      },
      isWithStatement: function() {
        return isWithStatement;
      },
      isYieldExpression: function() {
        return isYieldExpression;
      },
      jSXAttribute: function() {
        return jsxAttribute2;
      },
      jSXClosingElement: function() {
        return jsxClosingElement2;
      },
      jSXClosingFragment: function() {
        return jsxClosingFragment2;
      },
      jSXElement: function() {
        return jsxElement2;
      },
      jSXEmptyExpression: function() {
        return jsxEmptyExpression2;
      },
      jSXExpressionContainer: function() {
        return jsxExpressionContainer2;
      },
      jSXFragment: function() {
        return jsxFragment2;
      },
      jSXIdentifier: function() {
        return jsxIdentifier2;
      },
      jSXMemberExpression: function() {
        return jsxMemberExpression2;
      },
      jSXNamespacedName: function() {
        return jsxNamespacedName2;
      },
      jSXOpeningElement: function() {
        return jsxOpeningElement2;
      },
      jSXOpeningFragment: function() {
        return jsxOpeningFragment2;
      },
      jSXSpreadAttribute: function() {
        return jsxSpreadAttribute2;
      },
      jSXSpreadChild: function() {
        return jsxSpreadChild;
      },
      jSXText: function() {
        return jsxText3;
      },
      jsxAttribute: function() {
        return jsxAttribute2;
      },
      jsxClosingElement: function() {
        return jsxClosingElement2;
      },
      jsxClosingFragment: function() {
        return jsxClosingFragment2;
      },
      jsxElement: function() {
        return jsxElement2;
      },
      jsxEmptyExpression: function() {
        return jsxEmptyExpression2;
      },
      jsxExpressionContainer: function() {
        return jsxExpressionContainer2;
      },
      jsxFragment: function() {
        return jsxFragment2;
      },
      jsxIdentifier: function() {
        return jsxIdentifier2;
      },
      jsxMemberExpression: function() {
        return jsxMemberExpression2;
      },
      jsxNamespacedName: function() {
        return jsxNamespacedName2;
      },
      jsxOpeningElement: function() {
        return jsxOpeningElement2;
      },
      jsxOpeningFragment: function() {
        return jsxOpeningFragment2;
      },
      jsxSpreadAttribute: function() {
        return jsxSpreadAttribute2;
      },
      jsxSpreadChild: function() {
        return jsxSpreadChild;
      },
      jsxText: function() {
        return jsxText3;
      },
      labeledStatement: function() {
        return labeledStatement;
      },
      logicalExpression: function() {
        return logicalExpression;
      },
      matchesPattern: function() {
        return matchesPattern;
      },
      memberExpression: function() {
        return memberExpression;
      },
      metaProperty: function() {
        return metaProperty;
      },
      mixedTypeAnnotation: function() {
        return mixedTypeAnnotation;
      },
      moduleExpression: function() {
        return moduleExpression;
      },
      newExpression: function() {
        return newExpression;
      },
      noop: function() {
        return noop;
      },
      nullLiteral: function() {
        return nullLiteral;
      },
      nullLiteralTypeAnnotation: function() {
        return nullLiteralTypeAnnotation;
      },
      nullableTypeAnnotation: function() {
        return nullableTypeAnnotation;
      },
      numberLiteral: function() {
        return NumberLiteral;
      },
      numberLiteralTypeAnnotation: function() {
        return numberLiteralTypeAnnotation;
      },
      numberTypeAnnotation: function() {
        return numberTypeAnnotation;
      },
      numericLiteral: function() {
        return numericLiteral;
      },
      objectExpression: function() {
        return objectExpression;
      },
      objectMethod: function() {
        return objectMethod;
      },
      objectPattern: function() {
        return objectPattern;
      },
      objectProperty: function() {
        return objectProperty;
      },
      objectTypeAnnotation: function() {
        return objectTypeAnnotation;
      },
      objectTypeCallProperty: function() {
        return objectTypeCallProperty;
      },
      objectTypeIndexer: function() {
        return objectTypeIndexer;
      },
      objectTypeInternalSlot: function() {
        return objectTypeInternalSlot;
      },
      objectTypeProperty: function() {
        return objectTypeProperty;
      },
      objectTypeSpreadProperty: function() {
        return objectTypeSpreadProperty;
      },
      opaqueType: function() {
        return opaqueType;
      },
      optionalCallExpression: function() {
        return optionalCallExpression;
      },
      optionalIndexedAccessType: function() {
        return optionalIndexedAccessType;
      },
      optionalMemberExpression: function() {
        return optionalMemberExpression;
      },
      parenthesizedExpression: function() {
        return parenthesizedExpression;
      },
      pipelineBareFunction: function() {
        return pipelineBareFunction;
      },
      pipelinePrimaryTopicReference: function() {
        return pipelinePrimaryTopicReference;
      },
      pipelineTopicExpression: function() {
        return pipelineTopicExpression;
      },
      placeholder: function() {
        return placeholder;
      },
      prependToMemberExpression: function() {
        return prependToMemberExpression;
      },
      privateName: function() {
        return privateName;
      },
      program: function() {
        return program;
      },
      qualifiedTypeIdentifier: function() {
        return qualifiedTypeIdentifier;
      },
      react: function() {
        return react;
      },
      recordExpression: function() {
        return recordExpression;
      },
      regExpLiteral: function() {
        return regExpLiteral;
      },
      regexLiteral: function() {
        return RegexLiteral;
      },
      removeComments: function() {
        return removeComments;
      },
      removeProperties: function() {
        return removeProperties;
      },
      removePropertiesDeep: function() {
        return removePropertiesDeep;
      },
      removeTypeDuplicates: function() {
        return removeTypeDuplicates$1;
      },
      restElement: function() {
        return restElement;
      },
      restProperty: function() {
        return RestProperty;
      },
      returnStatement: function() {
        return returnStatement;
      },
      sequenceExpression: function() {
        return sequenceExpression;
      },
      shallowEqual: function() {
        return shallowEqual;
      },
      spreadElement: function() {
        return spreadElement;
      },
      spreadProperty: function() {
        return SpreadProperty;
      },
      staticBlock: function() {
        return staticBlock;
      },
      stringLiteral: function() {
        return stringLiteral;
      },
      stringLiteralTypeAnnotation: function() {
        return stringLiteralTypeAnnotation;
      },
      stringTypeAnnotation: function() {
        return stringTypeAnnotation;
      },
      super: function() {
        return _super;
      },
      switchCase: function() {
        return switchCase;
      },
      switchStatement: function() {
        return switchStatement;
      },
      symbolTypeAnnotation: function() {
        return symbolTypeAnnotation;
      },
      tSAnyKeyword: function() {
        return tsAnyKeyword;
      },
      tSArrayType: function() {
        return tsArrayType;
      },
      tSAsExpression: function() {
        return tsAsExpression;
      },
      tSBigIntKeyword: function() {
        return tsBigIntKeyword;
      },
      tSBooleanKeyword: function() {
        return tsBooleanKeyword;
      },
      tSCallSignatureDeclaration: function() {
        return tsCallSignatureDeclaration;
      },
      tSConditionalType: function() {
        return tsConditionalType;
      },
      tSConstructSignatureDeclaration: function() {
        return tsConstructSignatureDeclaration;
      },
      tSConstructorType: function() {
        return tsConstructorType;
      },
      tSDeclareFunction: function() {
        return tsDeclareFunction;
      },
      tSDeclareMethod: function() {
        return tsDeclareMethod;
      },
      tSEnumDeclaration: function() {
        return tsEnumDeclaration;
      },
      tSEnumMember: function() {
        return tsEnumMember;
      },
      tSExportAssignment: function() {
        return tsExportAssignment;
      },
      tSExpressionWithTypeArguments: function() {
        return tsExpressionWithTypeArguments;
      },
      tSExternalModuleReference: function() {
        return tsExternalModuleReference;
      },
      tSFunctionType: function() {
        return tsFunctionType;
      },
      tSImportEqualsDeclaration: function() {
        return tsImportEqualsDeclaration;
      },
      tSImportType: function() {
        return tsImportType;
      },
      tSIndexSignature: function() {
        return tsIndexSignature;
      },
      tSIndexedAccessType: function() {
        return tsIndexedAccessType;
      },
      tSInferType: function() {
        return tsInferType;
      },
      tSInstantiationExpression: function() {
        return tsInstantiationExpression;
      },
      tSInterfaceBody: function() {
        return tsInterfaceBody;
      },
      tSInterfaceDeclaration: function() {
        return tsInterfaceDeclaration;
      },
      tSIntersectionType: function() {
        return tsIntersectionType;
      },
      tSIntrinsicKeyword: function() {
        return tsIntrinsicKeyword;
      },
      tSLiteralType: function() {
        return tsLiteralType;
      },
      tSMappedType: function() {
        return tsMappedType;
      },
      tSMethodSignature: function() {
        return tsMethodSignature;
      },
      tSModuleBlock: function() {
        return tsModuleBlock;
      },
      tSModuleDeclaration: function() {
        return tsModuleDeclaration;
      },
      tSNamedTupleMember: function() {
        return tsNamedTupleMember;
      },
      tSNamespaceExportDeclaration: function() {
        return tsNamespaceExportDeclaration;
      },
      tSNeverKeyword: function() {
        return tsNeverKeyword;
      },
      tSNonNullExpression: function() {
        return tsNonNullExpression;
      },
      tSNullKeyword: function() {
        return tsNullKeyword;
      },
      tSNumberKeyword: function() {
        return tsNumberKeyword;
      },
      tSObjectKeyword: function() {
        return tsObjectKeyword;
      },
      tSOptionalType: function() {
        return tsOptionalType;
      },
      tSParameterProperty: function() {
        return tsParameterProperty;
      },
      tSParenthesizedType: function() {
        return tsParenthesizedType;
      },
      tSPropertySignature: function() {
        return tsPropertySignature;
      },
      tSQualifiedName: function() {
        return tsQualifiedName;
      },
      tSRestType: function() {
        return tsRestType;
      },
      tSSatisfiesExpression: function() {
        return tsSatisfiesExpression;
      },
      tSStringKeyword: function() {
        return tsStringKeyword;
      },
      tSSymbolKeyword: function() {
        return tsSymbolKeyword;
      },
      tSThisType: function() {
        return tsThisType;
      },
      tSTupleType: function() {
        return tsTupleType;
      },
      tSTypeAliasDeclaration: function() {
        return tsTypeAliasDeclaration;
      },
      tSTypeAnnotation: function() {
        return tsTypeAnnotation;
      },
      tSTypeAssertion: function() {
        return tsTypeAssertion;
      },
      tSTypeLiteral: function() {
        return tsTypeLiteral;
      },
      tSTypeOperator: function() {
        return tsTypeOperator;
      },
      tSTypeParameter: function() {
        return tsTypeParameter;
      },
      tSTypeParameterDeclaration: function() {
        return tsTypeParameterDeclaration;
      },
      tSTypeParameterInstantiation: function() {
        return tsTypeParameterInstantiation;
      },
      tSTypePredicate: function() {
        return tsTypePredicate;
      },
      tSTypeQuery: function() {
        return tsTypeQuery;
      },
      tSTypeReference: function() {
        return tsTypeReference;
      },
      tSUndefinedKeyword: function() {
        return tsUndefinedKeyword;
      },
      tSUnionType: function() {
        return tsUnionType;
      },
      tSUnknownKeyword: function() {
        return tsUnknownKeyword;
      },
      tSVoidKeyword: function() {
        return tsVoidKeyword;
      },
      taggedTemplateExpression: function() {
        return taggedTemplateExpression;
      },
      templateElement: function() {
        return templateElement;
      },
      templateLiteral: function() {
        return templateLiteral;
      },
      thisExpression: function() {
        return thisExpression;
      },
      thisTypeAnnotation: function() {
        return thisTypeAnnotation;
      },
      throwStatement: function() {
        return throwStatement;
      },
      toBindingIdentifierName: function() {
        return toBindingIdentifierName;
      },
      toBlock: function() {
        return toBlock;
      },
      toComputedKey: function() {
        return toComputedKey;
      },
      toExpression: function() {
        return toExpression;
      },
      toIdentifier: function() {
        return toIdentifier2;
      },
      toKeyAlias: function() {
        return toKeyAlias;
      },
      toStatement: function() {
        return toStatement;
      },
      topicReference: function() {
        return topicReference;
      },
      traverse: function() {
        return traverse;
      },
      traverseFast: function() {
        return traverseFast;
      },
      tryStatement: function() {
        return tryStatement;
      },
      tsAnyKeyword: function() {
        return tsAnyKeyword;
      },
      tsArrayType: function() {
        return tsArrayType;
      },
      tsAsExpression: function() {
        return tsAsExpression;
      },
      tsBigIntKeyword: function() {
        return tsBigIntKeyword;
      },
      tsBooleanKeyword: function() {
        return tsBooleanKeyword;
      },
      tsCallSignatureDeclaration: function() {
        return tsCallSignatureDeclaration;
      },
      tsConditionalType: function() {
        return tsConditionalType;
      },
      tsConstructSignatureDeclaration: function() {
        return tsConstructSignatureDeclaration;
      },
      tsConstructorType: function() {
        return tsConstructorType;
      },
      tsDeclareFunction: function() {
        return tsDeclareFunction;
      },
      tsDeclareMethod: function() {
        return tsDeclareMethod;
      },
      tsEnumDeclaration: function() {
        return tsEnumDeclaration;
      },
      tsEnumMember: function() {
        return tsEnumMember;
      },
      tsExportAssignment: function() {
        return tsExportAssignment;
      },
      tsExpressionWithTypeArguments: function() {
        return tsExpressionWithTypeArguments;
      },
      tsExternalModuleReference: function() {
        return tsExternalModuleReference;
      },
      tsFunctionType: function() {
        return tsFunctionType;
      },
      tsImportEqualsDeclaration: function() {
        return tsImportEqualsDeclaration;
      },
      tsImportType: function() {
        return tsImportType;
      },
      tsIndexSignature: function() {
        return tsIndexSignature;
      },
      tsIndexedAccessType: function() {
        return tsIndexedAccessType;
      },
      tsInferType: function() {
        return tsInferType;
      },
      tsInstantiationExpression: function() {
        return tsInstantiationExpression;
      },
      tsInterfaceBody: function() {
        return tsInterfaceBody;
      },
      tsInterfaceDeclaration: function() {
        return tsInterfaceDeclaration;
      },
      tsIntersectionType: function() {
        return tsIntersectionType;
      },
      tsIntrinsicKeyword: function() {
        return tsIntrinsicKeyword;
      },
      tsLiteralType: function() {
        return tsLiteralType;
      },
      tsMappedType: function() {
        return tsMappedType;
      },
      tsMethodSignature: function() {
        return tsMethodSignature;
      },
      tsModuleBlock: function() {
        return tsModuleBlock;
      },
      tsModuleDeclaration: function() {
        return tsModuleDeclaration;
      },
      tsNamedTupleMember: function() {
        return tsNamedTupleMember;
      },
      tsNamespaceExportDeclaration: function() {
        return tsNamespaceExportDeclaration;
      },
      tsNeverKeyword: function() {
        return tsNeverKeyword;
      },
      tsNonNullExpression: function() {
        return tsNonNullExpression;
      },
      tsNullKeyword: function() {
        return tsNullKeyword;
      },
      tsNumberKeyword: function() {
        return tsNumberKeyword;
      },
      tsObjectKeyword: function() {
        return tsObjectKeyword;
      },
      tsOptionalType: function() {
        return tsOptionalType;
      },
      tsParameterProperty: function() {
        return tsParameterProperty;
      },
      tsParenthesizedType: function() {
        return tsParenthesizedType;
      },
      tsPropertySignature: function() {
        return tsPropertySignature;
      },
      tsQualifiedName: function() {
        return tsQualifiedName;
      },
      tsRestType: function() {
        return tsRestType;
      },
      tsSatisfiesExpression: function() {
        return tsSatisfiesExpression;
      },
      tsStringKeyword: function() {
        return tsStringKeyword;
      },
      tsSymbolKeyword: function() {
        return tsSymbolKeyword;
      },
      tsThisType: function() {
        return tsThisType;
      },
      tsTupleType: function() {
        return tsTupleType;
      },
      tsTypeAliasDeclaration: function() {
        return tsTypeAliasDeclaration;
      },
      tsTypeAnnotation: function() {
        return tsTypeAnnotation;
      },
      tsTypeAssertion: function() {
        return tsTypeAssertion;
      },
      tsTypeLiteral: function() {
        return tsTypeLiteral;
      },
      tsTypeOperator: function() {
        return tsTypeOperator;
      },
      tsTypeParameter: function() {
        return tsTypeParameter;
      },
      tsTypeParameterDeclaration: function() {
        return tsTypeParameterDeclaration;
      },
      tsTypeParameterInstantiation: function() {
        return tsTypeParameterInstantiation;
      },
      tsTypePredicate: function() {
        return tsTypePredicate;
      },
      tsTypeQuery: function() {
        return tsTypeQuery;
      },
      tsTypeReference: function() {
        return tsTypeReference;
      },
      tsUndefinedKeyword: function() {
        return tsUndefinedKeyword;
      },
      tsUnionType: function() {
        return tsUnionType;
      },
      tsUnknownKeyword: function() {
        return tsUnknownKeyword;
      },
      tsVoidKeyword: function() {
        return tsVoidKeyword;
      },
      tupleExpression: function() {
        return tupleExpression;
      },
      tupleTypeAnnotation: function() {
        return tupleTypeAnnotation;
      },
      typeAlias: function() {
        return typeAlias;
      },
      typeAnnotation: function() {
        return typeAnnotation;
      },
      typeCastExpression: function() {
        return typeCastExpression;
      },
      typeParameter: function() {
        return typeParameter;
      },
      typeParameterDeclaration: function() {
        return typeParameterDeclaration;
      },
      typeParameterInstantiation: function() {
        return typeParameterInstantiation;
      },
      typeofTypeAnnotation: function() {
        return typeofTypeAnnotation;
      },
      unaryExpression: function() {
        return unaryExpression;
      },
      unionTypeAnnotation: function() {
        return unionTypeAnnotation;
      },
      updateExpression: function() {
        return updateExpression;
      },
      v8IntrinsicIdentifier: function() {
        return v8IntrinsicIdentifier;
      },
      validate: function() {
        return validate;
      },
      valueToNode: function() {
        return valueToNode;
      },
      variableDeclaration: function() {
        return variableDeclaration;
      },
      variableDeclarator: function() {
        return variableDeclarator;
      },
      variance: function() {
        return variance;
      },
      voidTypeAnnotation: function() {
        return voidTypeAnnotation;
      },
      whileStatement: function() {
        return whileStatement;
      },
      withStatement: function() {
        return withStatement;
      },
      yieldExpression: function() {
        return yieldExpression;
      }
    });
    var import_to_fast_properties = __toESM2(require_to_fast_properties2(), 1);
    var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
    var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
    nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
    var astralIdentifierStartCodes2 = [
      0,
      11,
      2,
      25,
      2,
      18,
      2,
      1,
      2,
      14,
      3,
      13,
      35,
      122,
      70,
      52,
      268,
      28,
      4,
      48,
      48,
      31,
      14,
      29,
      6,
      37,
      11,
      29,
      3,
      35,
      5,
      7,
      2,
      4,
      43,
      157,
      19,
      35,
      5,
      35,
      5,
      39,
      9,
      51,
      13,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      2,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      68,
      310,
      10,
      21,
      11,
      7,
      25,
      5,
      2,
      41,
      2,
      8,
      70,
      5,
      3,
      0,
      2,
      43,
      2,
      1,
      4,
      0,
      3,
      22,
      11,
      22,
      10,
      30,
      66,
      18,
      2,
      1,
      11,
      21,
      11,
      25,
      71,
      55,
      7,
      1,
      65,
      0,
      16,
      3,
      2,
      2,
      2,
      28,
      43,
      28,
      4,
      28,
      36,
      7,
      2,
      27,
      28,
      53,
      11,
      21,
      11,
      18,
      14,
      17,
      111,
      72,
      56,
      50,
      14,
      50,
      14,
      35,
      349,
      41,
      7,
      1,
      79,
      28,
      11,
      0,
      9,
      21,
      43,
      17,
      47,
      20,
      28,
      22,
      13,
      52,
      58,
      1,
      3,
      0,
      14,
      44,
      33,
      24,
      27,
      35,
      30,
      0,
      3,
      0,
      9,
      34,
      4,
      0,
      13,
      47,
      15,
      3,
      22,
      0,
      2,
      0,
      36,
      17,
      2,
      24,
      20,
      1,
      64,
      6,
      2,
      0,
      2,
      3,
      2,
      14,
      2,
      9,
      8,
      46,
      39,
      7,
      3,
      1,
      3,
      21,
      2,
      6,
      2,
      1,
      2,
      4,
      4,
      0,
      19,
      0,
      13,
      4,
      159,
      52,
      19,
      3,
      21,
      2,
      31,
      47,
      21,
      1,
      2,
      0,
      185,
      46,
      42,
      3,
      37,
      47,
      21,
      0,
      60,
      42,
      14,
      0,
      72,
      26,
      38,
      6,
      186,
      43,
      117,
      63,
      32,
      7,
      3,
      0,
      3,
      7,
      2,
      1,
      2,
      23,
      16,
      0,
      2,
      0,
      95,
      7,
      3,
      38,
      17,
      0,
      2,
      0,
      29,
      0,
      11,
      39,
      8,
      0,
      22,
      0,
      12,
      45,
      20,
      0,
      19,
      72,
      264,
      8,
      2,
      36,
      18,
      0,
      50,
      29,
      113,
      6,
      2,
      1,
      2,
      37,
      22,
      0,
      26,
      5,
      2,
      1,
      2,
      31,
      15,
      0,
      328,
      18,
      16,
      0,
      2,
      12,
      2,
      33,
      125,
      0,
      80,
      921,
      103,
      110,
      18,
      195,
      2637,
      96,
      16,
      1071,
      18,
      5,
      4026,
      582,
      8634,
      568,
      8,
      30,
      18,
      78,
      18,
      29,
      19,
      47,
      17,
      3,
      32,
      20,
      6,
      18,
      689,
      63,
      129,
      74,
      6,
      0,
      67,
      12,
      65,
      1,
      2,
      0,
      29,
      6135,
      9,
      1237,
      43,
      8,
      8936,
      3,
      2,
      6,
      2,
      1,
      2,
      290,
      16,
      0,
      30,
      2,
      3,
      0,
      15,
      3,
      9,
      395,
      2309,
      106,
      6,
      12,
      4,
      8,
      8,
      9,
      5991,
      84,
      2,
      70,
      2,
      1,
      3,
      0,
      3,
      1,
      3,
      3,
      2,
      11,
      2,
      0,
      2,
      6,
      2,
      64,
      2,
      3,
      3,
      7,
      2,
      6,
      2,
      27,
      2,
      3,
      2,
      4,
      2,
      0,
      4,
      6,
      2,
      339,
      3,
      24,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      7,
      1845,
      30,
      7,
      5,
      262,
      61,
      147,
      44,
      11,
      6,
      17,
      0,
      322,
      29,
      19,
      43,
      485,
      27,
      757,
      6,
      2,
      3,
      2,
      1,
      2,
      14,
      2,
      196,
      60,
      67,
      8,
      0,
      1205,
      3,
      2,
      26,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      9,
      2,
      3,
      2,
      0,
      2,
      0,
      7,
      0,
      5,
      0,
      2,
      0,
      2,
      0,
      2,
      2,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      1,
      2,
      0,
      3,
      3,
      2,
      6,
      2,
      3,
      2,
      3,
      2,
      0,
      2,
      9,
      2,
      16,
      6,
      2,
      2,
      4,
      2,
      16,
      4421,
      42719,
      33,
      4153,
      7,
      221,
      3,
      5761,
      15,
      7472,
      16,
      621,
      2467,
      541,
      1507,
      4938,
      6,
      4191
    ];
    var astralIdentifierCodes2 = [
      509,
      0,
      227,
      0,
      150,
      4,
      294,
      9,
      1368,
      2,
      2,
      1,
      6,
      3,
      41,
      2,
      5,
      0,
      166,
      1,
      574,
      3,
      9,
      9,
      370,
      1,
      81,
      2,
      71,
      10,
      50,
      3,
      123,
      2,
      54,
      14,
      32,
      10,
      3,
      1,
      11,
      3,
      46,
      10,
      8,
      0,
      46,
      9,
      7,
      2,
      37,
      13,
      2,
      9,
      6,
      1,
      45,
      0,
      13,
      2,
      49,
      13,
      9,
      3,
      2,
      11,
      83,
      11,
      7,
      0,
      3,
      0,
      158,
      11,
      6,
      9,
      7,
      3,
      56,
      1,
      2,
      6,
      3,
      1,
      3,
      2,
      10,
      0,
      11,
      1,
      3,
      6,
      4,
      4,
      193,
      17,
      10,
      9,
      5,
      0,
      82,
      19,
      13,
      9,
      214,
      6,
      3,
      8,
      28,
      1,
      83,
      16,
      16,
      9,
      82,
      12,
      9,
      9,
      84,
      14,
      5,
      9,
      243,
      14,
      166,
      9,
      71,
      5,
      2,
      1,
      3,
      3,
      2,
      0,
      2,
      1,
      13,
      9,
      120,
      6,
      3,
      6,
      4,
      0,
      29,
      9,
      41,
      6,
      2,
      3,
      9,
      0,
      10,
      10,
      47,
      15,
      406,
      7,
      2,
      7,
      17,
      9,
      57,
      21,
      2,
      13,
      123,
      5,
      4,
      0,
      2,
      1,
      2,
      6,
      2,
      0,
      9,
      9,
      49,
      4,
      2,
      1,
      2,
      4,
      9,
      9,
      330,
      3,
      10,
      1,
      2,
      0,
      49,
      6,
      4,
      4,
      14,
      9,
      5351,
      0,
      7,
      14,
      13835,
      9,
      87,
      9,
      39,
      4,
      60,
      6,
      26,
      9,
      1014,
      0,
      2,
      54,
      8,
      3,
      82,
      0,
      12,
      1,
      19628,
      1,
      4706,
      45,
      3,
      22,
      543,
      4,
      4,
      5,
      9,
      7,
      3,
      6,
      31,
      3,
      149,
      2,
      1418,
      49,
      513,
      54,
      5,
      49,
      9,
      0,
      15,
      0,
      23,
      4,
      2,
      14,
      1361,
      6,
      2,
      16,
      3,
      6,
      2,
      1,
      2,
      4,
      101,
      0,
      161,
      6,
      10,
      9,
      357,
      0,
      62,
      13,
      499,
      13,
      983,
      6,
      110,
      6,
      6,
      9,
      4759,
      9,
      787719,
      239
    ];
    function isInAstralSet2(code22, set) {
      var pos = 65536;
      for (var i2 = 0, length = set.length; i2 < length; i2 += 2) {
        pos += set[i2];
        if (pos > code22)
          return false;
        pos += set[i2 + 1];
        if (pos >= code22)
          return true;
      }
      return false;
    }
    function isIdentifierStart2(code22) {
      if (code22 < 65)
        return code22 === 36;
      if (code22 <= 90)
        return true;
      if (code22 < 97)
        return code22 === 95;
      if (code22 <= 122)
        return true;
      if (code22 <= 65535) {
        return code22 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code22));
      }
      return isInAstralSet2(code22, astralIdentifierStartCodes2);
    }
    function isIdentifierChar2(code22) {
      if (code22 < 48)
        return code22 === 36;
      if (code22 < 58)
        return true;
      if (code22 < 65)
        return false;
      if (code22 <= 90)
        return true;
      if (code22 < 97)
        return code22 === 95;
      if (code22 <= 122)
        return true;
      if (code22 <= 65535) {
        return code22 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code22));
      }
      return isInAstralSet2(code22, astralIdentifierStartCodes2) || isInAstralSet2(code22, astralIdentifierCodes2);
    }
    function isIdentifierName(name2) {
      var isFirst = true;
      for (var i2 = 0; i2 < name2.length; i2++) {
        var cp = name2.charCodeAt(i2);
        if ((cp & 64512) === 55296 && i2 + 1 < name2.length) {
          var trail = name2.charCodeAt(++i2);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart2(cp)) {
            return false;
          }
        } else if (!isIdentifierChar2(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
    var reservedWords2 = {
      keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
      ],
      strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
      ],
      strictBind: [
        "eval",
        "arguments"
      ]
    };
    var keywords2 = new Set(reservedWords2.keyword);
    var reservedWordsStrictSet = new Set(reservedWords2.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isKeyword(word) {
      return keywords2.has(word);
    }
    var _isDigit = function isDigit(code22) {
      return code22 >= 48 && code22 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
      ]),
      hex: /* @__PURE__ */ new Set([
        46,
        88,
        95,
        120
      ])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: function(ch) {
        return ch === 48 || ch === 49;
      },
      oct: function(ch) {
        return ch >= 48 && ch <= 55;
      },
      dec: function(ch) {
        return ch >= 48 && ch <= 57;
      },
      hex: function(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
    };
    function readStringContents(type3, input, pos, lineStart, curLine, errors) {
      var initialPos = pos;
      var initialLineStart = lineStart;
      var initialCurLine = curLine;
      var out = "";
      var firstInvalidLoc = null;
      var chunkStart = pos;
      var length = input.length;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        var ch = input.charCodeAt(pos);
        if (isStringEnd(type3, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          var res = readEscapedChar(input, pos, lineStart, curLine, type3 === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          var ref2;
          ref2 = res, pos = ref2.pos, lineStart = ref2.lineStart, curLine = ref2.curLine, ref2;
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type3 === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine
      };
    }
    function isStringEnd(type3, ch, input, pos) {
      if (type3 === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type3 === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      var throwOnInvalid = !inTemplate;
      pos++;
      var res = function(ch2) {
        return {
          pos,
          ch: ch2,
          lineStart,
          curLine
        };
      };
      var ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          var code22;
          var ref2;
          ref2 = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), code22 = ref2.code, pos = ref2.pos, ref2;
          return res(code22 === null ? null : String.fromCharCode(code22));
        }
        case 117: {
          var code21;
          var ref1;
          ref1 = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), code21 = ref1.code, pos = ref1.pos, ref1;
          return res(code21 === null ? null : String.fromCodePoint(code21));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var startPos = pos - 1;
            var match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            var octalStr = match[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            var next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      var initialPos = pos;
      var n2;
      var ref2;
      ref2 = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), n2 = ref2.n, pos = ref2.pos, ref2;
      if (n2 === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n2,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      var start2 = pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      var invalid2 = false;
      var total = 0;
      for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2) {
        var code22 = input.charCodeAt(pos);
        var val = void 0;
        if (code22 === 95 && allowNumSeparator !== "bail") {
          var prev = input.charCodeAt(pos - 1);
          var next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code22 >= 97) {
          val = code22 - 97 + 10;
        } else if (code22 >= 65) {
          val = code22 - 65 + 10;
        } else if (_isDigit(code22)) {
          val = code22 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid2 = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start2 || len != null && pos - start2 !== len || invalid2) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      var ch = input.charCodeAt(pos);
      var code22;
      if (ch === 123) {
        ++pos;
        var ref2;
        ref2 = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors), code22 = ref2.code, pos = ref2.pos, ref2;
        ++pos;
        if (code22 !== null && code22 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        var ref1;
        ref1 = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors), code22 = ref1.code, pos = ref1.pos, ref1;
      }
      return {
        code: code22,
        pos
      };
    }
    function shallowEqual(actual, expected) {
      var keys2 = Object.keys(expected);
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          if (actual[key] !== expected[key]) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return true;
    }
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName) {
      var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (warnings.has(oldName))
        return;
      warnings.add(oldName);
      var _captureShortStackTrace = captureShortStackTrace(1, 2), internal = _captureShortStackTrace.internal, trace = _captureShortStackTrace.trace;
      if (internal) {
        return;
      }
      console.warn("".concat(prefix2, "`").concat(oldName, "` has been deprecated, please migrate to `").concat(newName, "`\n").concat(trace));
    }
    function captureShortStackTrace(skip2, length) {
      var stackTraceLimit = Error.stackTraceLimit, prepareStackTrace = Error.prepareStackTrace;
      var stackTrace;
      Error.stackTraceLimit = 1 + skip2 + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace)
        return {
          internal: false,
          trace: ""
        };
      var shortStackTrace = stackTrace.slice(1 + skip2, 1 + skip2 + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map(function(frame) {
          return "    at ".concat(frame);
        }).join("\n")
      };
    }
    function isArrayExpression2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isAssignmentExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AssignmentExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBinaryExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BinaryExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isInterpreterDirective(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterpreterDirective")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDirective(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Directive")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDirectiveLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DirectiveLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBlockStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BlockStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBreakStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BreakStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isCallExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "CallExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isCatchClause(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "CatchClause")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isConditionalExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ConditionalExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isContinueStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ContinueStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDebuggerStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DebuggerStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDoWhileStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DoWhileStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEmptyStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EmptyStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExpressionStatement2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExpressionStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isFile(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "File")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isForInStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForInStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isForStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunctionDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunctionExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isIdentifier2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Identifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isIfStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IfStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isLabeledStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "LabeledStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isStringLiteral2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNumericLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumericLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNullLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBooleanLiteral2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isRegExpLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RegExpLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isLogicalExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "LogicalExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MemberExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNewExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NewExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isProgram(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Program")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectMethod")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isRestElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RestElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isReturnStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ReturnStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSequenceExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SequenceExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isParenthesizedExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ParenthesizedExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSwitchCase(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SwitchCase")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSwitchStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SwitchStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isThisExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThisExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isThrowStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThrowStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTryStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TryStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isUnaryExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UnaryExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isUpdateExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UpdateExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isVariableDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VariableDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isVariableDeclarator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VariableDeclarator")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isWhileStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "WhileStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isWithStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "WithStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isAssignmentPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AssignmentPattern")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isArrayPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayPattern")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isArrowFunctionExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrowFunctionExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportAllDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportAllDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportDefaultDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportDefaultDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportNamedDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportNamedDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isForOfStatement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ForOfStatement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportDefaultSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportDefaultSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportNamespaceSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportNamespaceSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isMetaProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MetaProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassMethod")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectPattern(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectPattern")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSpreadElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SpreadElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSuper(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Super")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTaggedTemplateExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TaggedTemplateExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTemplateElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TemplateElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTemplateLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TemplateLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isYieldExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "YieldExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isAwaitExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AwaitExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImport(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Import")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBigIntLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BigIntLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportNamespaceSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportNamespaceSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isOptionalMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalMemberExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isOptionalCallExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalCallExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassAccessorProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassAccessorProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassPrivateProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassPrivateProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassPrivateMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassPrivateMethod")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isPrivateName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PrivateName")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isStaticBlock(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StaticBlock")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isAnyTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "AnyTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isArrayTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArrayTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBooleanTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBooleanLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BooleanLiteralTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNullLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullLiteralTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isClassImplements(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ClassImplements")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareClass(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareClass")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareFunction")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareInterface(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareInterface")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareModule(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareModule")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareModuleExports(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareModuleExports")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareTypeAlias(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareTypeAlias")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareOpaqueType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareOpaqueType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareVariable(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareVariable")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareExportDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclareExportAllDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclareExportAllDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclaredPredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DeclaredPredicate")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExistsTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExistsTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunctionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunctionTypeParam(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "FunctionTypeParam")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isGenericTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "GenericTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isInferredPredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InferredPredicate")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isInterfaceExtends(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceExtends")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isInterfaceDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isInterfaceTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "InterfaceTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isIntersectionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IntersectionTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isMixedTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "MixedTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEmptyTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EmptyTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNullableTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NullableTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNumberLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumberLiteralTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNumberTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "NumberTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeInternalSlot(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeInternalSlot")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeCallProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeCallProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeIndexer(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeIndexer")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectTypeSpreadProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ObjectTypeSpreadProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isOpaqueType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OpaqueType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isQualifiedTypeIdentifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "QualifiedTypeIdentifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isStringLiteralTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringLiteralTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isStringTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "StringTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSymbolTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "SymbolTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isThisTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ThisTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTupleTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TupleTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeofTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeofTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeAlias(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeAlias")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeCastExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeCastExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeParameter(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameter")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeParameterDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameterDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeParameterInstantiation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TypeParameterInstantiation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isUnionTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "UnionTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isVariance(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Variance")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isVoidTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "VoidTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumBooleanBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumBooleanBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumNumberBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumNumberBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumStringBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumStringBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumSymbolBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumSymbolBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumBooleanMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumBooleanMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumNumberMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumNumberMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumStringMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumStringMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumDefaultedMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "EnumDefaultedMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "IndexedAccessType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isOptionalIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "OptionalIndexedAccessType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXAttribute")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXClosingElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXClosingElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXElement2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXEmptyExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXEmptyExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXExpressionContainer2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXExpressionContainer")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXSpreadChild(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXSpreadChild")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXIdentifier2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXIdentifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXMemberExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXMemberExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXNamespacedName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXNamespacedName")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXOpeningElement(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXOpeningElement")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXSpreadAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXSpreadAttribute")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXText(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXText")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXFragment2(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXFragment")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXOpeningFragment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXOpeningFragment")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSXClosingFragment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "JSXClosingFragment")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isNoop(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Noop")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isPlaceholder(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Placeholder")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isV8IntrinsicIdentifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "V8IntrinsicIdentifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isArgumentPlaceholder(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ArgumentPlaceholder")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isBindExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "BindExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportAttribute(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ImportAttribute")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDecorator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "Decorator")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDoExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DoExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportDefaultSpecifier(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ExportDefaultSpecifier")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isRecordExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "RecordExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTupleExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TupleExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isDecimalLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "DecimalLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isModuleExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "ModuleExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTopicReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TopicReference")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isPipelineTopicExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelineTopicExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isPipelineBareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelineBareFunction")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isPipelinePrimaryTopicReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "PipelinePrimaryTopicReference")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSParameterProperty(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSParameterProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSDeclareFunction(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSDeclareFunction")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSDeclareMethod(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSDeclareMethod")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSQualifiedName(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSQualifiedName")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSCallSignatureDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSCallSignatureDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSConstructSignatureDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConstructSignatureDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSPropertySignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSPropertySignature")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSMethodSignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSMethodSignature")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSIndexSignature(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIndexSignature")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSAnyKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSAnyKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSBooleanKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSBooleanKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSBigIntKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSBigIntKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSIntrinsicKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIntrinsicKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNeverKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNeverKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNullKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNullKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNumberKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNumberKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSObjectKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSObjectKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSStringKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSStringKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSSymbolKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSSymbolKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSUndefinedKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUndefinedKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSUnknownKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUnknownKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSVoidKeyword(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSVoidKeyword")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSThisType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSThisType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSFunctionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSFunctionType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSConstructorType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConstructorType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeReference")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypePredicate(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypePredicate")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeQuery(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeQuery")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeLiteral(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSArrayType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSArrayType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTupleType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTupleType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSOptionalType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSOptionalType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSRestType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSRestType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNamedTupleMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNamedTupleMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSUnionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSUnionType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSIntersectionType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIntersectionType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSConditionalType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSConditionalType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSInferType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInferType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSParenthesizedType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSParenthesizedType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeOperator(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeOperator")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSIndexedAccessType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSIndexedAccessType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSMappedType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSMappedType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSLiteralType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSLiteralType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSExpressionWithTypeArguments(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExpressionWithTypeArguments")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSInterfaceDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInterfaceDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSInterfaceBody(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInterfaceBody")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeAliasDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAliasDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSInstantiationExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSInstantiationExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSAsExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSAsExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSSatisfiesExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSSatisfiesExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeAssertion(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAssertion")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSEnumDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSEnumDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSEnumMember(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSEnumMember")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSModuleDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSModuleDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSModuleBlock(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSModuleBlock")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSImportType(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSImportType")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSImportEqualsDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSImportEqualsDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSExternalModuleReference(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExternalModuleReference")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNonNullExpression(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNonNullExpression")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSExportAssignment(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSExportAssignment")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSNamespaceExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSNamespaceExportDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeAnnotation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeAnnotation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeParameterInstantiation(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameterInstantiation")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeParameterDeclaration(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameterDeclaration")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeParameter(node2, opts) {
      if (!node2)
        return false;
      if (node2.type !== "TSTypeParameter")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isStandardized(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isExpression(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isBinary(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isScopable(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isBlockParent(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isBlock(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node2.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTerminatorless(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isCompletionStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isConditional(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isLoop(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isWhile(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isExpressionWrapper(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFor(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isForXStatement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunction(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFunctionParent(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isPureish(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node2.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isDeclaration2(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Declaration")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isPatternLike(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isLVal(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node2.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSEntityName(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Identifier")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isLiteral(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node2.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isUserWhitespacable(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isMethod(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isObjectMember(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isProperty(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isUnaryLike(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isPattern(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node2.expectedNode === "Pattern")
            break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isClass(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isImportOrExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isExportDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isModuleSpecifier(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isAccessor(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isPrivate(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFlow(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFlowType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFlowBaseAnnotation(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFlowDeclaration(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isFlowPredicate(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumBody(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isEnumMember(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isJSX(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isMiscellaneous(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTypeScript(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSTypeElement(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isTSBaseType(node2, opts) {
      if (!node2)
        return false;
      switch (node2.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || shallowEqual(node2, opts);
    }
    function isNumberLiteral(node2, opts) {
      deprecationWarning("isNumberLiteral", "isNumericLiteral");
      if (!node2)
        return false;
      if (node2.type !== "NumberLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isRegexLiteral(node2, opts) {
      deprecationWarning("isRegexLiteral", "isRegExpLiteral");
      if (!node2)
        return false;
      if (node2.type !== "RegexLiteral")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isRestProperty(node2, opts) {
      deprecationWarning("isRestProperty", "isRestElement");
      if (!node2)
        return false;
      if (node2.type !== "RestProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isSpreadProperty(node2, opts) {
      deprecationWarning("isSpreadProperty", "isSpreadElement");
      if (!node2)
        return false;
      if (node2.type !== "SpreadProperty")
        return false;
      return opts == null || shallowEqual(node2, opts);
    }
    function isModuleDeclaration(node2, opts) {
      deprecationWarning("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node2, opts);
    }
    function matchesPattern(member, match, allowPartial) {
      if (!isMemberExpression(member))
        return false;
      var parts = Array.isArray(match) ? match : match.split(".");
      var nodes2 = [];
      var node2;
      for (node2 = member; isMemberExpression(node2); node2 = node2.object) {
        nodes2.push(node2.property);
      }
      nodes2.push(node2);
      if (nodes2.length < parts.length)
        return false;
      if (!allowPartial && nodes2.length > parts.length)
        return false;
      for (var i2 = 0, j = nodes2.length - 1; i2 < parts.length; i2++, j--) {
        var node22 = nodes2[j];
        var value1 = void 0;
        if (isIdentifier2(node22)) {
          value1 = node22.name;
        } else if (isStringLiteral2(node22)) {
          value1 = node22.value;
        } else if (isThisExpression(node22)) {
          value1 = "this";
        } else {
          return false;
        }
        if (parts[i2] !== value1)
          return false;
      }
      return true;
    }
    function buildMatchMemberExpression(match, allowPartial) {
      var parts = match.split(".");
      return function(member) {
        return matchesPattern(member, parts, allowPartial);
      };
    }
    var isReactComponent = buildMatchMemberExpression("React.Component");
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (nodeType == null)
        return false;
      if (ALIAS_KEYS[targetType])
        return false;
      var aliases = FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = aliases[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var alias2 = _step8.value;
            if (nodeType === alias2)
              return true;
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      return false;
    }
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      var aliases = PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = aliases[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var alias2 = _step8.value;
            if (targetType === alias2)
              return true;
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      return false;
    }
    function is2(type3, node2, opts) {
      if (!node2)
        return false;
      var matches = isType(node2.type, type3);
      if (!matches) {
        if (!opts && node2.type === "Placeholder" && type3 in FLIPPED_ALIAS_KEYS) {
          return isPlaceholderType(node2.expectedNode, type3);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node2, opts);
      }
    }
    function isValidIdentifier(name2) {
      var reserved = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (typeof name2 !== "string")
        return false;
      if (reserved) {
        if (isKeyword(name2) || isStrictReservedWord(name2, true)) {
          return false;
        }
      }
      return isIdentifierName(name2);
    }
    var STATEMENT_OR_BLOCK_KEYS = [
      "consequent",
      "body",
      "alternate"
    ];
    var FLATTENABLE_KEYS = [
      "body",
      "expressions"
    ];
    var FOR_INIT_KEYS = [
      "left",
      "init"
    ];
    var COMMENT_KEYS = [
      "leadingComments",
      "trailingComments",
      "innerComments"
    ];
    var LOGICAL_OPERATORS = [
      "||",
      "&&",
      "??"
    ];
    var UPDATE_OPERATORS = [
      "++",
      "--"
    ];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [
      ">",
      "<",
      ">=",
      "<="
    ];
    var EQUALITY_BINARY_OPERATORS = [
      "==",
      "===",
      "!=",
      "!=="
    ];
    var COMPARISON_BINARY_OPERATORS = _to_consumable_array(EQUALITY_BINARY_OPERATORS).concat([
      "in",
      "instanceof"
    ]);
    var BOOLEAN_BINARY_OPERATORS = _to_consumable_array(COMPARISON_BINARY_OPERATORS).concat(_to_consumable_array(BOOLEAN_NUMBER_BINARY_OPERATORS));
    var NUMBER_BINARY_OPERATORS = [
      "-",
      "/",
      "%",
      "*",
      "**",
      "&",
      "|",
      ">>",
      ">>>",
      "<<",
      "^"
    ];
    var BINARY_OPERATORS = [
      "+"
    ].concat(_to_consumable_array(NUMBER_BINARY_OPERATORS), _to_consumable_array(BOOLEAN_BINARY_OPERATORS), [
      "|>"
    ]);
    var ASSIGNMENT_OPERATORS = [
      "=",
      "+="
    ].concat(_to_consumable_array(NUMBER_BINARY_OPERATORS.map(function(op) {
      return op + "=";
    })), _to_consumable_array(LOGICAL_OPERATORS.map(function(op) {
      return op + "=";
    })));
    var BOOLEAN_UNARY_OPERATORS = [
      "delete",
      "!"
    ];
    var NUMBER_UNARY_OPERATORS = [
      "+",
      "-",
      "~"
    ];
    var STRING_UNARY_OPERATORS = [
      "typeof"
    ];
    var UNARY_OPERATORS = [
      "void",
      "throw"
    ].concat(_to_consumable_array(BOOLEAN_UNARY_OPERATORS), _to_consumable_array(NUMBER_UNARY_OPERATORS), _to_consumable_array(STRING_UNARY_OPERATORS));
    var INHERIT_KEYS = {
      optional: [
        "typeAnnotation",
        "typeParameters",
        "returnType"
      ],
      force: [
        "start",
        "loc",
        "end"
      ]
    };
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    var VISITOR_KEYS = {};
    var ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = {};
    var BUILDER_KEYS = {};
    var DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val === "undefined" ? "undefined" : _type_of(val);
      }
    }
    function validate$1(validate4) {
      return {
        validate: validate4
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _to_consumable_array(typeName));
    }
    function validateType(typeName) {
      return validate$1(typeIs(typeName));
    }
    function validateOptional(validate4) {
      return {
        validate: validate4,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate$1(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node2, key, val) {
        if (!Array.isArray(val))
          return;
        for (var i2 = 0; i2 < val.length; i2++) {
          var subkey = "".concat(key, "[").concat(i2, "]");
          var v = val[i2];
          callback(node2, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING)
            validateChild(node2, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      function validate4(node2, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError("Property ".concat(key, " expected value to be one of ").concat(JSON.stringify(values), " but got ").concat(JSON.stringify(val)));
        }
      }
      validate4.oneOf = values;
      return validate4;
    }
    function assertNodeType() {
      for (var _len = arguments.length, types22 = new Array(_len), _key = 0; _key < _len; _key++) {
        types22[_key] = arguments[_key];
      }
      function validate4(node2, key, val) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = types22[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var type3 = _step8.value;
            if (is2(type3, val)) {
              validateChild(node2, key, val);
              return;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        throw new TypeError("Property ".concat(key, " of ").concat(node2.type, " expected node to be of a type ").concat(JSON.stringify(types22), " but instead got ").concat(JSON.stringify(val === null || val === void 0 ? void 0 : val.type)));
      }
      validate4.oneOfNodeTypes = types22;
      return validate4;
    }
    function assertNodeOrValueType() {
      for (var _len = arguments.length, types22 = new Array(_len), _key = 0; _key < _len; _key++) {
        types22[_key] = arguments[_key];
      }
      function validate4(node2, key, val) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = types22[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var type3 = _step8.value;
            if (getType(val) === type3 || is2(type3, val)) {
              validateChild(node2, key, val);
              return;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        throw new TypeError("Property ".concat(key, " of ").concat(node2.type, " expected node to be of a type ").concat(JSON.stringify(types22), " but instead got ").concat(JSON.stringify(val === null || val === void 0 ? void 0 : val.type)));
      }
      validate4.oneOfNodeOrValueTypes = types22;
      return validate4;
    }
    function assertValueType(type3) {
      function validate4(node2, key, val) {
        var valid2 = getType(val) === type3;
        if (!valid2) {
          throw new TypeError("Property ".concat(key, " expected type of ").concat(type3, " but got ").concat(getType(val)));
        }
      }
      validate4.type = type3;
      return validate4;
    }
    function assertShape(shape) {
      function validate4(node2, key, val) {
        var errors = [];
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = Object.keys(shape)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var property = _step8.value;
            try {
              validateField(node2, property, val[property], shape[property]);
            } catch (error) {
              if (_instanceof(error, TypeError)) {
                errors.push(error.message);
                continue;
              }
              throw error;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        if (errors.length) {
          throw new TypeError("Property ".concat(key, " of ").concat(node2.type, " expected to have the following:\n").concat(errors.join("\n")));
        }
      }
      validate4.shapeOf = shape;
      return validate4;
    }
    function assertOptionalChainStart() {
      function validate4(node2) {
        var current2 = node2;
        while (node2) {
          var type3 = current2.type;
          if (type3 === "OptionalCallExpression") {
            if (current2.optional)
              return;
            current2 = current2.callee;
            continue;
          }
          if (type3 === "OptionalMemberExpression") {
            if (current2.optional)
              return;
            current2 = current2.object;
            continue;
          }
          break;
        }
        throw new TypeError("Non-optional ".concat(node2.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat(current2 === null || current2 === void 0 ? void 0 : current2.type));
      }
      return validate4;
    }
    function chain() {
      for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      function validate4() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = fns[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var fn = _step8.value;
            fn.apply(void 0, _to_consumable_array(args));
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      validate4.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
      }
      return validate4;
    }
    var validTypeOpts = [
      "aliases",
      "builder",
      "deprecatedAlias",
      "fields",
      "inherits",
      "visitor",
      "validate"
    ];
    var validFieldKeys = [
      "default",
      "optional",
      "deprecated",
      "validate"
    ];
    var store = {};
    function defineAliasedType() {
      for (var _len = arguments.length, aliases = new Array(_len), _key = 0; _key < _len; _key++) {
        aliases[_key] = arguments[_key];
      }
      return function(type3) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _defined;
        var defined = opts.aliases;
        if (!defined) {
          var _store_opts_inherits_aliases;
          if (opts.inherits)
            defined = (_store_opts_inherits_aliases = store[opts.inherits].aliases) === null || _store_opts_inherits_aliases === void 0 ? void 0 : _store_opts_inherits_aliases.slice();
          defined !== null && defined !== void 0 ? defined : defined = [];
          opts.aliases = defined;
        }
        var additional = aliases.filter(function(a) {
          return !defined.includes(a);
        });
        (_defined = defined).unshift.apply(_defined, _to_consumable_array(additional));
        defineType$5(type3, opts);
      };
    }
    function defineType$5(type3) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var inherits2 = opts.inherits && store[opts.inherits] || {};
      var fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits2.fields) {
          var keys2 = Object.getOwnPropertyNames(inherits2.fields);
          var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
          try {
            for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var key = _step8.value;
              var field = inherits2.fields[key];
              var def = field.default;
              if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
                throw new Error("field defaults can only be primitives or empty arrays currently");
              }
              fields[key] = {
                default: Array.isArray(def) ? [] : def,
                optional: field.optional,
                deprecated: field.deprecated,
                validate: field.validate
              };
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }
      var visitor4 = opts.visitor || inherits2.visitor || [];
      var aliases = opts.aliases || inherits2.aliases || [];
      var builder = opts.builder || inherits2.builder || opts.visitor || [];
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = Object.keys(opts)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var k = _step12.value;
          if (validTypeOpts.indexOf(k) === -1) {
            throw new Error('Unknown type option "'.concat(k, '" on ').concat(type3));
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type3;
      }
      var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
      try {
        for (var _iterator22 = visitor4.concat(builder)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var key1 = _step22.value;
          fields[key1] = fields[key1] || {};
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
            _iterator22.return();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }
      var _iteratorNormalCompletion32 = true, _didIteratorError32 = false, _iteratorError32 = void 0;
      try {
        for (var _iterator32 = Object.keys(fields)[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
          var key2 = _step32.value;
          var field1 = fields[key2];
          if (field1.default !== void 0 && builder.indexOf(key2) === -1) {
            field1.optional = true;
          }
          if (field1.default === void 0) {
            field1.default = null;
          } else if (!field1.validate && field1.default != null) {
            field1.validate = assertValueType(getType(field1.default));
          }
          var _iteratorNormalCompletion42 = true, _didIteratorError42 = false, _iteratorError42 = void 0;
          try {
            for (var _iterator42 = Object.keys(field1)[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
              var k1 = _step42.value;
              if (validFieldKeys.indexOf(k1) === -1) {
                throw new Error('Unknown field key "'.concat(k1, '" on ').concat(type3, ".").concat(key2));
              }
            }
          } catch (err) {
            _didIteratorError42 = true;
            _iteratorError42 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion42 && _iterator42.return != null) {
                _iterator42.return();
              }
            } finally {
              if (_didIteratorError42) {
                throw _iteratorError42;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError32 = true;
        _iteratorError32 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
            _iterator32.return();
          }
        } finally {
          if (_didIteratorError32) {
            throw _iteratorError32;
          }
        }
      }
      VISITOR_KEYS[type3] = opts.visitor = visitor4;
      BUILDER_KEYS[type3] = opts.builder = builder;
      NODE_FIELDS[type3] = opts.fields = fields;
      ALIAS_KEYS[type3] = opts.aliases = aliases;
      aliases.forEach(function(alias2) {
        FLIPPED_ALIAS_KEYS[alias2] = FLIPPED_ALIAS_KEYS[alias2] || [];
        FLIPPED_ALIAS_KEYS[alias2].push(type3);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type3] = opts.validate;
      }
      store[type3] = opts;
    }
    var defineType$4 = defineAliasedType("Standardized");
    defineType$4("ArrayExpression", {
      fields: {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: [
        "elements"
      ],
      aliases: [
        "Expression"
      ]
    });
    defineType$4("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertValueType("string");
            }
            var identifier7 = assertOneOf.apply(void 0, _to_consumable_array(ASSIGNMENT_OPERATORS));
            var pattern = assertOneOf("=");
            return function(node2, key, val) {
              var validator = is2("Pattern", node2.left) ? pattern : identifier7;
              validator(node2, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal", "OptionalMemberExpression") : assertNodeType("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: assertNodeType("Expression")
        }
      },
      builder: [
        "operator",
        "left",
        "right"
      ],
      visitor: [
        "left",
        "right"
      ],
      aliases: [
        "Expression"
      ]
    });
    defineType$4("BinaryExpression", {
      builder: [
        "operator",
        "left",
        "right"
      ],
      fields: {
        operator: {
          validate: assertOneOf.apply(void 0, _to_consumable_array(BINARY_OPERATORS))
        },
        left: {
          validate: function() {
            var expression2 = assertNodeType("Expression");
            var inOp = assertNodeType("Expression", "PrivateName");
            var validator = Object.assign(function(node2, key, val) {
              var validator2 = node2.operator === "in" ? inOp : expression2;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: [
                "Expression",
                "PrivateName"
              ]
            });
            return validator;
          }()
        },
        right: {
          validate: assertNodeType("Expression")
        }
      },
      visitor: [
        "left",
        "right"
      ],
      aliases: [
        "Binary",
        "Expression"
      ]
    });
    defineType$4("InterpreterDirective", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType$4("Directive", {
      visitor: [
        "value"
      ],
      fields: {
        value: {
          validate: assertNodeType("DirectiveLiteral")
        }
      }
    });
    defineType$4("DirectiveLiteral", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType$4("BlockStatement", {
      builder: [
        "body",
        "directives"
      ],
      visitor: [
        "directives",
        "body"
      ],
      fields: {
        directives: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
          default: []
        },
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      },
      aliases: [
        "Scopable",
        "BlockParent",
        "Block",
        "Statement"
      ]
    });
    defineType$4("BreakStatement", {
      visitor: [
        "label"
      ],
      fields: {
        label: {
          validate: assertNodeType("Identifier"),
          optional: true
        }
      },
      aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
      ]
    });
    defineType$4("CallExpression", {
      visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
      ],
      builder: [
        "callee",
        "arguments"
      ],
      aliases: [
        "Expression"
      ],
      fields: Object.assign({
        callee: {
          validate: assertNodeType("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: assertOneOf(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: assertNodeType("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType$4("CatchClause", {
      visitor: [
        "param",
        "body"
      ],
      fields: {
        param: {
          validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      },
      aliases: [
        "Scopable",
        "BlockParent"
      ]
    });
    defineType$4("ConditionalExpression", {
      visitor: [
        "test",
        "consequent",
        "alternate"
      ],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        consequent: {
          validate: assertNodeType("Expression")
        },
        alternate: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: [
        "Expression",
        "Conditional"
      ]
    });
    defineType$4("ContinueStatement", {
      visitor: [
        "label"
      ],
      fields: {
        label: {
          validate: assertNodeType("Identifier"),
          optional: true
        }
      },
      aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
      ]
    });
    defineType$4("DebuggerStatement", {
      aliases: [
        "Statement"
      ]
    });
    defineType$4("DoWhileStatement", {
      visitor: [
        "test",
        "body"
      ],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      },
      aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
      ]
    });
    defineType$4("EmptyStatement", {
      aliases: [
        "Statement"
      ]
    });
    defineType$4("ExpressionStatement", {
      visitor: [
        "expression"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: [
        "Statement",
        "ExpressionWrapper"
      ]
    });
    defineType$4("File", {
      builder: [
        "program",
        "comments",
        "tokens"
      ],
      visitor: [
        "program"
      ],
      fields: {
        program: {
          validate: assertNodeType("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          }, {
            each: {
              oneOfNodeTypes: [
                "CommentBlock",
                "CommentLine"
              ]
            }
          }) : assertEach(assertNodeType("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: assertEach(Object.assign(function() {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType$4("ForInStatement", {
      visitor: [
        "left",
        "right",
        "body"
      ],
      aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
      ],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType$4("ForStatement", {
      visitor: [
        "init",
        "test",
        "update",
        "body"
      ],
      aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop"
      ],
      fields: {
        init: {
          validate: assertNodeType("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        update: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    var functionCommon = function() {
      return {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement")))
        },
        generator: {
          default: false
        },
        async: {
          default: false
        }
      };
    };
    var functionTypeAnnotationCommon = function() {
      return {
        returnType: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration"),
          optional: true
        }
      };
    };
    var functionDeclarationCommon = function() {
      return Object.assign({}, functionCommon(), {
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        }
      });
    };
    defineType$4("FunctionDeclaration", {
      builder: [
        "id",
        "params",
        "body",
        "generator",
        "async"
      ],
      visitor: [
        "id",
        "params",
        "body",
        "returnType",
        "typeParameters"
      ],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: assertNodeType("BlockStatement")
        },
        predicate: {
          validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration"
      ],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return function() {
          };
        var identifier7 = assertNodeType("Identifier");
        return function(parent, key, node2) {
          if (!is2("ExportDefaultDeclaration", parent)) {
            identifier7(node2, "id", node2.id);
          }
        };
      }()
    });
    defineType$4("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
      ],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        },
        predicate: {
          validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = function() {
      return {
        typeAnnotation: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation"),
          optional: true
        },
        optional: {
          validate: assertValueType("boolean"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      };
    };
    defineType$4("Identifier", {
      builder: [
        "name"
      ],
      visitor: [
        "typeAnnotation",
        "decorators"
      ],
      aliases: [
        "Expression",
        "PatternLike",
        "LVal",
        "TSEntityName"
      ],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: chain(assertValueType("string"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!isValidIdentifier(val, false)) {
              throw new TypeError('"'.concat(val, '" is not a valid identifier name'));
            }
          }, {
            type: "string"
          }))
        }
      }),
      validate: function validate4(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        var match = /\.(\w+)$/.exec(key);
        if (!match)
          return;
        var _match = _sliced_to_array(match, 2), parentKey = _match[1];
        var nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if (is2("MemberExpression", parent, nonComp))
            return;
          if (is2("OptionalMemberExpression", parent, nonComp))
            return;
        } else if (parentKey === "key") {
          if (is2("Property", parent, nonComp))
            return;
          if (is2("Method", parent, nonComp))
            return;
        } else if (parentKey === "exported") {
          if (is2("ExportSpecifier", parent))
            return;
        } else if (parentKey === "imported") {
          if (is2("ImportSpecifier", parent, {
            imported: node2
          }))
            return;
        } else if (parentKey === "meta") {
          if (is2("MetaProperty", parent, {
            meta: node2
          }))
            return;
        }
        if ((isKeyword(node2.name) || isReservedWord(node2.name, false)) && node2.name !== "this") {
          throw new TypeError('"'.concat(node2.name, '" is not a valid identifier'));
        }
      }
    });
    defineType$4("IfStatement", {
      visitor: [
        "test",
        "consequent",
        "alternate"
      ],
      aliases: [
        "Statement",
        "Conditional"
      ],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        consequent: {
          validate: assertNodeType("Statement")
        },
        alternate: {
          optional: true,
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType$4("LabeledStatement", {
      visitor: [
        "label",
        "body"
      ],
      aliases: [
        "Statement"
      ],
      fields: {
        label: {
          validate: assertNodeType("Identifier")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType$4("StringLiteral", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$4("NumericLiteral", {
      builder: [
        "value"
      ],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: chain(assertValueType("number"), Object.assign(function(node2, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              var error = new Error("NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(".concat(val, ") instead."));
              {
                {
                  if (!new Error().stack.includes("regenerator")) {
                    throw error;
                  }
                }
              }
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$4("NullLiteral", {
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$4("BooleanLiteral", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("boolean")
        }
      },
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$4("RegExpLiteral", {
      builder: [
        "pattern",
        "flags"
      ],
      deprecatedAlias: "RegexLiteral",
      aliases: [
        "Expression",
        "Pureish",
        "Literal"
      ],
      fields: {
        pattern: {
          validate: assertValueType("string")
        },
        flags: {
          validate: chain(assertValueType("string"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            var invalid2 = /[^gimsuy]/.exec(val);
            if (invalid2) {
              throw new TypeError('"'.concat(invalid2[0], '" is not a valid RegExp flag'));
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    defineType$4("LogicalExpression", {
      builder: [
        "operator",
        "left",
        "right"
      ],
      visitor: [
        "left",
        "right"
      ],
      aliases: [
        "Binary",
        "Expression"
      ],
      fields: {
        operator: {
          validate: assertOneOf.apply(void 0, _to_consumable_array(LOGICAL_OPERATORS))
        },
        left: {
          validate: assertNodeType("Expression")
        },
        right: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("MemberExpression", {
      builder: [
        "object",
        "property",
        "computed"
      ].concat(_to_consumable_array(!process.env.BABEL_TYPES_8_BREAKING ? [
        "optional"
      ] : [])),
      visitor: [
        "object",
        "property"
      ],
      aliases: [
        "Expression",
        "LVal"
      ],
      fields: Object.assign({
        object: {
          validate: assertNodeType("Expression", "Super")
        },
        property: {
          validate: function() {
            var normal = assertNodeType("Identifier", "PrivateName");
            var computed = assertNodeType("Expression");
            var validator = function validator2(node2, key, val) {
              var validator22 = node2.computed ? computed : normal;
              validator22(node2, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "PrivateName"
            ];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: assertOneOf(true, false),
          optional: true
        }
      } : {})
    });
    defineType$4("NewExpression", {
      inherits: "CallExpression"
    });
    defineType$4("Program", {
      visitor: [
        "directives",
        "body"
      ],
      builder: [
        "body",
        "directives",
        "sourceType",
        "interpreter"
      ],
      fields: {
        sourceFile: {
          validate: assertValueType("string")
        },
        sourceType: {
          validate: assertOneOf("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: assertNodeType("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
          default: []
        },
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      },
      aliases: [
        "Scopable",
        "BlockParent",
        "Block"
      ]
    });
    defineType$4("ObjectExpression", {
      visitor: [
        "properties"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType$4("ObjectMethod", {
      builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async"
      ],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: assertOneOf("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            var computed = assertNodeType("Expression");
            var validator = function validator2(node2, key, val) {
              var validator22 = node2.computed ? computed : normal;
              validator22(node2, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral"
            ];
            return validator;
          }()
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      }),
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
      ],
      aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember"
      ]
    });
    defineType$4("ObjectProperty", {
      builder: [
        "key",
        "value",
        "computed",
        "shorthand"
      ].concat(_to_consumable_array(!process.env.BABEL_TYPES_8_BREAKING ? [
        "decorators"
      ] : [])),
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            var computed = assertNodeType("Expression");
            var validator = Object.assign(function(node2, key, val) {
              var validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: [
                "Expression",
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "DecimalLiteral",
                "PrivateName"
              ]
            });
            return validator;
          }()
        },
        value: {
          validate: assertNodeType("Expression", "PatternLike")
        },
        shorthand: {
          validate: chain(assertValueType("boolean"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !is2("Identifier", node2.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      },
      visitor: [
        "key",
        "value",
        "decorators"
      ],
      aliases: [
        "UserWhitespacable",
        "Property",
        "ObjectMember"
      ],
      validate: function() {
        var pattern = assertNodeType("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        var expression2 = assertNodeType("Expression");
        return function(parent, key, node2) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          var validator = is2("ObjectPattern", parent) ? pattern : expression2;
          validator(node2, "value", node2.value);
        };
      }()
    });
    defineType$4("RestElement", {
      visitor: [
        "argument",
        "typeAnnotation"
      ],
      builder: [
        "argument"
      ],
      aliases: [
        "LVal",
        "PatternLike"
      ],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate: function validate4(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        var match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match)
          throw new Error("Internal Babel error: malformed key.");
        var _match = _sliced_to_array(match, 3), listKey = _match[1], index3 = _match[2];
        if (parent[listKey].length > +index3 + 1) {
          throw new TypeError("RestElement must be last element of ".concat(listKey));
        }
      }
    });
    defineType$4("ReturnStatement", {
      visitor: [
        "argument"
      ],
      aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
      ],
      fields: {
        argument: {
          validate: assertNodeType("Expression"),
          optional: true
        }
      }
    });
    defineType$4("SequenceExpression", {
      visitor: [
        "expressions"
      ],
      fields: {
        expressions: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")))
        }
      },
      aliases: [
        "Expression"
      ]
    });
    defineType$4("ParenthesizedExpression", {
      visitor: [
        "expression"
      ],
      aliases: [
        "Expression",
        "ExpressionWrapper"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("SwitchCase", {
      visitor: [
        "test",
        "consequent"
      ],
      fields: {
        test: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        consequent: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      }
    });
    defineType$4("SwitchStatement", {
      visitor: [
        "discriminant",
        "cases"
      ],
      aliases: [
        "Statement",
        "BlockParent",
        "Scopable"
      ],
      fields: {
        discriminant: {
          validate: assertNodeType("Expression")
        },
        cases: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
        }
      }
    });
    defineType$4("ThisExpression", {
      aliases: [
        "Expression"
      ]
    });
    defineType$4("ThrowStatement", {
      visitor: [
        "argument"
      ],
      aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
      ],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("TryStatement", {
      visitor: [
        "block",
        "handler",
        "finalizer"
      ],
      aliases: [
        "Statement"
      ],
      fields: {
        block: {
          validate: chain(assertNodeType("BlockStatement"), Object.assign(function(node2) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node2.handler && !node2.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: [
              "BlockStatement"
            ]
          }))
        },
        handler: {
          optional: true,
          validate: assertNodeType("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: assertNodeType("BlockStatement")
        }
      }
    });
    defineType$4("UnaryExpression", {
      builder: [
        "operator",
        "argument",
        "prefix"
      ],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: assertNodeType("Expression")
        },
        operator: {
          validate: assertOneOf.apply(void 0, _to_consumable_array(UNARY_OPERATORS))
        }
      },
      visitor: [
        "argument"
      ],
      aliases: [
        "UnaryLike",
        "Expression"
      ]
    });
    defineType$4("UpdateExpression", {
      builder: [
        "operator",
        "argument",
        "prefix"
      ],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
        },
        operator: {
          validate: assertOneOf.apply(void 0, _to_consumable_array(UPDATE_OPERATORS))
        }
      },
      visitor: [
        "argument"
      ],
      aliases: [
        "Expression"
      ]
    });
    defineType$4("VariableDeclaration", {
      builder: [
        "kind",
        "declarations"
      ],
      visitor: [
        "declarations"
      ],
      aliases: [
        "Statement",
        "Declaration"
      ],
      fields: {
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        kind: {
          validate: assertOneOf("var", "let", "const", "using", "await using")
        },
        declarations: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
        }
      },
      validate: function validate4(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!is2("ForXStatement", parent, {
          left: node2
        }))
          return;
        if (node2.declarations.length !== 1) {
          throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(parent.type));
        }
      }
    });
    defineType$4("VariableDeclarator", {
      visitor: [
        "id",
        "init"
      ],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertNodeType("LVal");
            }
            var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
            var without = assertNodeType("Identifier");
            return function(node2, key, val) {
              var validator = node2.init ? normal : without;
              validator(node2, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: assertValueType("boolean")
        },
        init: {
          optional: true,
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("WhileStatement", {
      visitor: [
        "test",
        "body"
      ],
      aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
      ],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType$4("WithStatement", {
      visitor: [
        "object",
        "body"
      ],
      aliases: [
        "Statement"
      ],
      fields: {
        object: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType$4("AssignmentPattern", {
      visitor: [
        "left",
        "right",
        "decorators"
      ],
      builder: [
        "left",
        "right"
      ],
      aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
      ],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: assertNodeType("Expression")
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      })
    });
    defineType$4("ArrayPattern", {
      visitor: [
        "elements",
        "typeAnnotation"
      ],
      builder: [
        "elements"
      ],
      aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
      ],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType$4("ArrowFunctionExpression", {
      builder: [
        "params",
        "body",
        "async"
      ],
      visitor: [
        "params",
        "body",
        "returnType",
        "typeParameters"
      ],
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
      ],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: assertValueType("boolean")
        },
        body: {
          validate: assertNodeType("BlockStatement", "Expression")
        },
        predicate: {
          validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType$4("ClassBody", {
      visitor: [
        "body"
      ],
      fields: {
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
      }
    });
    defineType$4("ClassExpression", {
      builder: [
        "id",
        "superClass",
        "body",
        "decorators"
      ],
      visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators"
      ],
      aliases: [
        "Scopable",
        "Class",
        "Expression"
      ],
      fields: {
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration"),
          optional: true
        },
        body: {
          validate: assertNodeType("ClassBody")
        },
        superClass: {
          optional: true,
          validate: assertNodeType("Expression")
        },
        superTypeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        mixins: {
          validate: assertNodeType("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType$4("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: [
        "Scopable",
        "Class",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration"),
          optional: true
        },
        body: {
          validate: assertNodeType("ClassBody")
        },
        superClass: {
          optional: true,
          validate: assertNodeType("Expression")
        },
        superTypeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        mixins: {
          validate: assertNodeType("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        abstract: {
          validate: assertValueType("boolean"),
          optional: true
        }
      },
      validate: function() {
        var identifier7 = assertNodeType("Identifier");
        return function(parent, key, node2) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!is2("ExportDefaultDeclaration", parent)) {
            identifier7(node2, "id", node2.id);
          }
        };
      }()
    });
    defineType$4("ExportAllDeclaration", {
      builder: [
        "source"
      ],
      visitor: [
        "source",
        "attributes",
        "assertions"
      ],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
      ],
      fields: {
        source: {
          validate: assertNodeType("StringLiteral")
        },
        exportKind: validateOptional(assertOneOf("type", "value")),
        attributes: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        }
      }
    });
    defineType$4("ExportDefaultDeclaration", {
      visitor: [
        "declaration"
      ],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
      ],
      fields: {
        declaration: {
          validate: assertNodeType("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: validateOptional(assertOneOf("value"))
      }
    });
    defineType$4("ExportNamedDeclaration", {
      builder: [
        "declaration",
        "specifiers",
        "source"
      ],
      visitor: [
        "declaration",
        "specifiers",
        "source",
        "attributes",
        "assertions"
      ],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
      ],
      fields: {
        declaration: {
          optional: true,
          validate: chain(assertNodeType("Declaration"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: [
              "Declaration"
            ]
          }), function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node2.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        attributes: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: chain(assertValueType("array"), assertEach(function() {
            var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            var sourceless = assertNodeType("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node2, key, val) {
              var validator = node2.source ? sourced : sourceless;
              validator(node2, key, val);
            };
          }()))
        },
        source: {
          validate: assertNodeType("StringLiteral"),
          optional: true
        },
        exportKind: validateOptional(assertOneOf("type", "value"))
      }
    });
    defineType$4("ExportSpecifier", {
      visitor: [
        "local",
        "exported"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        },
        exported: {
          validate: assertNodeType("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: assertOneOf("type", "value"),
          optional: true
        }
      }
    });
    defineType$4("ForOfStatement", {
      visitor: [
        "left",
        "right",
        "body"
      ],
      builder: [
        "left",
        "right",
        "body",
        "await"
      ],
      aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
      ],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertNodeType("VariableDeclaration", "LVal");
            }
            var declaration = assertNodeType("VariableDeclaration");
            var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return function(node2, key, val) {
              if (is2("VariableDeclaration", val)) {
                declaration(node2, key, val);
              } else {
                lval(node2, key, val);
              }
            };
          }()
        },
        right: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType$4("ImportDeclaration", {
      builder: [
        "specifiers",
        "source"
      ],
      visitor: [
        "specifiers",
        "source",
        "attributes",
        "assertions"
      ],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration"
      ],
      fields: {
        attributes: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
        },
        module: {
          optional: true,
          validate: assertValueType("boolean")
        },
        phase: {
          default: null,
          validate: assertOneOf("source", "defer")
        },
        specifiers: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: assertNodeType("StringLiteral")
        },
        importKind: {
          validate: assertOneOf("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType$4("ImportDefaultSpecifier", {
      visitor: [
        "local"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType$4("ImportNamespaceSpecifier", {
      visitor: [
        "local"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType$4("ImportSpecifier", {
      visitor: [
        "local",
        "imported"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        },
        imported: {
          validate: assertNodeType("Identifier", "StringLiteral")
        },
        importKind: {
          validate: assertOneOf("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType$4("ImportExpression", {
      visitor: [
        "source",
        "options"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        phase: {
          default: null,
          validate: assertOneOf("source", "defer")
        },
        source: {
          validate: assertNodeType("Expression")
        },
        options: {
          validate: assertNodeType("Expression"),
          optional: true
        }
      }
    });
    defineType$4("MetaProperty", {
      visitor: [
        "meta",
        "property"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        meta: {
          validate: chain(assertNodeType("Identifier"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            var property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!is2("Identifier", node2.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: [
              "Identifier"
            ]
          }))
        },
        property: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = function() {
      return {
        abstract: {
          validate: assertValueType("boolean"),
          optional: true
        },
        accessibility: {
          validate: assertOneOf("public", "private", "protected"),
          optional: true
        },
        static: {
          default: false
        },
        override: {
          default: false
        },
        computed: {
          default: false
        },
        optional: {
          validate: assertValueType("boolean"),
          optional: true
        },
        key: {
          validate: chain(function() {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            var computed = assertNodeType("Expression");
            return function(node2, key, val) {
              var validator = node2.computed ? computed : normal;
              validator(node2, key, val);
            };
          }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
        }
      };
    };
    var classMethodOrDeclareMethodCommon = function() {
      return Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
        },
        kind: {
          validate: assertOneOf("get", "set", "method", "constructor"),
          default: "method"
        },
        access: {
          validate: chain(assertValueType("string"), assertOneOf("public", "private", "protected")),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      });
    };
    defineType$4("ClassMethod", {
      aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method"
      ],
      builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async"
      ],
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
      ],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: assertNodeType("BlockStatement")
        }
      })
    });
    defineType$4("ObjectPattern", {
      visitor: [
        "properties",
        "typeAnnotation",
        "decorators"
      ],
      builder: [
        "properties"
      ],
      aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
      ],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType$4("SpreadElement", {
      visitor: [
        "argument"
      ],
      aliases: [
        "UnaryLike"
      ],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("Super", void 0);
    defineType$4("TaggedTemplateExpression", {
      visitor: [
        "tag",
        "quasi",
        "typeParameters"
      ],
      builder: [
        "tag",
        "quasi"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        tag: {
          validate: assertNodeType("Expression")
        },
        quasi: {
          validate: assertNodeType("TemplateLiteral")
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType$4("TemplateElement", {
      builder: [
        "value",
        "tail"
      ],
      fields: {
        value: {
          validate: chain(assertShape({
            raw: {
              validate: assertValueType("string")
            },
            cooked: {
              validate: assertValueType("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node2) {
            var raw = node2.value.raw;
            var unterminatedCalled = false;
            var error = function() {
              throw new Error("Internal @babel/types error.");
            };
            var _readStringContents = readStringContents("template", raw, 0, 0, 0, {
              unterminated: function unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            }), str = _readStringContents.str, firstInvalidLoc = _readStringContents.firstInvalidLoc;
            if (!unterminatedCalled)
              throw new Error("Invalid raw");
            node2.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType$4("TemplateLiteral", {
      visitor: [
        "quasis",
        "expressions"
      ],
      aliases: [
        "Expression",
        "Literal"
      ],
      fields: {
        quasis: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
        },
        expressions: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "TSType")), function(node2, key, val) {
            if (node2.quasis.length !== val.length + 1) {
              throw new TypeError("Number of ".concat(node2.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(val.length + 1, " quasis but got ").concat(node2.quasis.length));
            }
          })
        }
      }
    });
    defineType$4("YieldExpression", {
      builder: [
        "argument",
        "delegate"
      ],
      visitor: [
        "argument"
      ],
      aliases: [
        "Expression",
        "Terminatorless"
      ],
      fields: {
        delegate: {
          validate: chain(assertValueType("boolean"), Object.assign(function(node2, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node2.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("AwaitExpression", {
      builder: [
        "argument"
      ],
      visitor: [
        "argument"
      ],
      aliases: [
        "Expression",
        "Terminatorless"
      ],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$4("Import", {
      aliases: [
        "Expression"
      ]
    });
    defineType$4("BigIntLiteral", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$4("ExportNamespaceSpecifier", {
      visitor: [
        "exported"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        exported: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType$4("OptionalMemberExpression", {
      builder: [
        "object",
        "property",
        "computed",
        "optional"
      ],
      visitor: [
        "object",
        "property"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        object: {
          validate: assertNodeType("Expression")
        },
        property: {
          validate: function() {
            var normal = assertNodeType("Identifier");
            var computed = assertNodeType("Expression");
            var validator = Object.assign(function(node2, key, val) {
              var validator2 = node2.computed ? computed : normal;
              validator2(node2, key, val);
            }, {
              oneOfNodeTypes: [
                "Expression",
                "Identifier"
              ]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
        }
      }
    });
    defineType$4("OptionalCallExpression", {
      visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
      ],
      builder: [
        "callee",
        "arguments",
        "optional"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
        },
        typeArguments: {
          validate: assertNodeType("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType$4("ClassProperty", {
      visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
      ],
      builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
      ],
      aliases: [
        "Property"
      ],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        definite: {
          validate: assertValueType("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        variance: {
          validate: assertNodeType("Variance"),
          optional: true
        }
      })
    });
    defineType$4("ClassAccessorProperty", {
      visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
      ],
      builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
      ],
      aliases: [
        "Property",
        "Accessor"
      ],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: chain(function() {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            var computed = assertNodeType("Expression");
            return function(node2, key, val) {
              var validator = node2.computed ? computed : normal;
              validator(node2, key, val);
            };
          }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        definite: {
          validate: assertValueType("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        variance: {
          validate: assertNodeType("Variance"),
          optional: true
        }
      })
    });
    defineType$4("ClassPrivateProperty", {
      visitor: [
        "key",
        "value",
        "decorators",
        "typeAnnotation"
      ],
      builder: [
        "key",
        "value",
        "decorators",
        "static"
      ],
      aliases: [
        "Property",
        "Private"
      ],
      fields: {
        key: {
          validate: assertNodeType("PrivateName")
        },
        value: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        static: {
          validate: assertValueType("boolean"),
          default: false
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        definite: {
          validate: assertValueType("boolean"),
          optional: true
        },
        variance: {
          validate: assertNodeType("Variance"),
          optional: true
        }
      }
    });
    defineType$4("ClassPrivateMethod", {
      builder: [
        "kind",
        "key",
        "params",
        "body",
        "static"
      ],
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
      ],
      aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private"
      ],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: assertOneOf("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: assertNodeType("PrivateName")
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      })
    });
    defineType$4("PrivateName", {
      visitor: [
        "id"
      ],
      aliases: [
        "Private"
      ],
      fields: {
        id: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType$4("StaticBlock", {
      visitor: [
        "body"
      ],
      fields: {
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      },
      aliases: [
        "Scopable",
        "BlockParent",
        "FunctionParent"
      ]
    });
    var defineType$3 = defineAliasedType("Flow");
    var defineInterfaceishType = function(name2) {
      var isDeclareClass2 = name2 === "DeclareClass";
      defineType$3(name2, {
        builder: [
          "id",
          "typeParameters",
          "extends",
          "body"
        ],
        visitor: [
          "id",
          "typeParameters",
          "extends"
        ].concat(_to_consumable_array(isDeclareClass2 ? [
          "mixins",
          "implements"
        ] : []), [
          "body"
        ]),
        aliases: [
          "FlowDeclaration",
          "Statement",
          "Declaration"
        ],
        fields: Object.assign({
          id: validateType("Identifier"),
          typeParameters: validateOptionalType("TypeParameterDeclaration"),
          extends: validateOptional(arrayOfType("InterfaceExtends"))
        }, isDeclareClass2 ? {
          mixins: validateOptional(arrayOfType("InterfaceExtends")),
          implements: validateOptional(arrayOfType("ClassImplements"))
        } : {}, {
          body: validateType("ObjectTypeAnnotation")
        })
      });
    };
    defineType$3("AnyTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("ArrayTypeAnnotation", {
      visitor: [
        "elementType"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        elementType: validateType("FlowType")
      }
    });
    defineType$3("BooleanTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("BooleanLiteralTypeAnnotation", {
      builder: [
        "value"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        value: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("NullLiteralTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("ClassImplements", {
      visitor: [
        "id",
        "typeParameters"
      ],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType$3("DeclareFunction", {
      visitor: [
        "id"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier"),
        predicate: validateOptionalType("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType$3("DeclareModule", {
      builder: [
        "id",
        "body",
        "kind"
      ],
      visitor: [
        "id",
        "body"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType([
          "Identifier",
          "StringLiteral"
        ]),
        body: validateType("BlockStatement"),
        kind: validateOptional(assertOneOf("CommonJS", "ES"))
      }
    });
    defineType$3("DeclareModuleExports", {
      visitor: [
        "typeAnnotation"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        typeAnnotation: validateType("TypeAnnotation")
      }
    });
    defineType$3("DeclareTypeAlias", {
      visitor: [
        "id",
        "typeParameters",
        "right"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        right: validateType("FlowType")
      }
    });
    defineType$3("DeclareOpaqueType", {
      visitor: [
        "id",
        "typeParameters",
        "supertype"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        supertype: validateOptionalType("FlowType"),
        impltype: validateOptionalType("FlowType")
      }
    });
    defineType$3("DeclareVariable", {
      visitor: [
        "id"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier")
      }
    });
    defineType$3("DeclareExportDeclaration", {
      visitor: [
        "declaration",
        "specifiers",
        "source"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        declaration: validateOptionalType("Flow"),
        specifiers: validateOptional(arrayOfType([
          "ExportSpecifier",
          "ExportNamespaceSpecifier"
        ])),
        source: validateOptionalType("StringLiteral"),
        default: validateOptional(assertValueType("boolean"))
      }
    });
    defineType$3("DeclareExportAllDeclaration", {
      visitor: [
        "source"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        source: validateType("StringLiteral"),
        exportKind: validateOptional(assertOneOf("type", "value"))
      }
    });
    defineType$3("DeclaredPredicate", {
      visitor: [
        "value"
      ],
      aliases: [
        "FlowPredicate"
      ],
      fields: {
        value: validateType("Flow")
      }
    });
    defineType$3("ExistsTypeAnnotation", {
      aliases: [
        "FlowType"
      ]
    });
    defineType$3("FunctionTypeAnnotation", {
      visitor: [
        "typeParameters",
        "params",
        "rest",
        "returnType"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        params: validate$1(arrayOfType("FunctionTypeParam")),
        rest: validateOptionalType("FunctionTypeParam"),
        this: validateOptionalType("FunctionTypeParam"),
        returnType: validateType("FlowType")
      }
    });
    defineType$3("FunctionTypeParam", {
      visitor: [
        "name",
        "typeAnnotation"
      ],
      fields: {
        name: validateOptionalType("Identifier"),
        typeAnnotation: validateType("FlowType"),
        optional: validateOptional(assertValueType("boolean"))
      }
    });
    defineType$3("GenericTypeAnnotation", {
      visitor: [
        "id",
        "typeParameters"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        id: validateType([
          "Identifier",
          "QualifiedTypeIdentifier"
        ]),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineType$3("InferredPredicate", {
      aliases: [
        "FlowPredicate"
      ]
    });
    defineType$3("InterfaceExtends", {
      visitor: [
        "id",
        "typeParameters"
      ],
      fields: {
        id: validateType([
          "Identifier",
          "QualifiedTypeIdentifier"
        ]),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType$3("InterfaceTypeAnnotation", {
      visitor: [
        "extends",
        "body"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        extends: validateOptional(arrayOfType("InterfaceExtends")),
        body: validateType("ObjectTypeAnnotation")
      }
    });
    defineType$3("IntersectionTypeAnnotation", {
      visitor: [
        "types"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType$3("MixedTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("EmptyTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("NullableTypeAnnotation", {
      visitor: [
        "typeAnnotation"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        typeAnnotation: validateType("FlowType")
      }
    });
    defineType$3("NumberLiteralTypeAnnotation", {
      builder: [
        "value"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        value: validate$1(assertValueType("number"))
      }
    });
    defineType$3("NumberTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("ObjectTypeAnnotation", {
      visitor: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots"
      ],
      aliases: [
        "FlowType"
      ],
      builder: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots",
        "exact"
      ],
      fields: {
        properties: validate$1(arrayOfType([
          "ObjectTypeProperty",
          "ObjectTypeSpreadProperty"
        ])),
        indexers: {
          validate: arrayOfType("ObjectTypeIndexer"),
          optional: false,
          default: []
        },
        callProperties: {
          validate: arrayOfType("ObjectTypeCallProperty"),
          optional: false,
          default: []
        },
        internalSlots: {
          validate: arrayOfType("ObjectTypeInternalSlot"),
          optional: false,
          default: []
        },
        exact: {
          validate: assertValueType("boolean"),
          default: false
        },
        inexact: validateOptional(assertValueType("boolean"))
      }
    });
    defineType$3("ObjectTypeInternalSlot", {
      visitor: [
        "id",
        "value",
        "optional",
        "static",
        "method"
      ],
      aliases: [
        "UserWhitespacable"
      ],
      fields: {
        id: validateType("Identifier"),
        value: validateType("FlowType"),
        optional: validate$1(assertValueType("boolean")),
        static: validate$1(assertValueType("boolean")),
        method: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("ObjectTypeCallProperty", {
      visitor: [
        "value"
      ],
      aliases: [
        "UserWhitespacable"
      ],
      fields: {
        value: validateType("FlowType"),
        static: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("ObjectTypeIndexer", {
      visitor: [
        "id",
        "key",
        "value",
        "variance"
      ],
      aliases: [
        "UserWhitespacable"
      ],
      fields: {
        id: validateOptionalType("Identifier"),
        key: validateType("FlowType"),
        value: validateType("FlowType"),
        static: validate$1(assertValueType("boolean")),
        variance: validateOptionalType("Variance")
      }
    });
    defineType$3("ObjectTypeProperty", {
      visitor: [
        "key",
        "value",
        "variance"
      ],
      aliases: [
        "UserWhitespacable"
      ],
      fields: {
        key: validateType([
          "Identifier",
          "StringLiteral"
        ]),
        value: validateType("FlowType"),
        kind: validate$1(assertOneOf("init", "get", "set")),
        static: validate$1(assertValueType("boolean")),
        proto: validate$1(assertValueType("boolean")),
        optional: validate$1(assertValueType("boolean")),
        variance: validateOptionalType("Variance"),
        method: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("ObjectTypeSpreadProperty", {
      visitor: [
        "argument"
      ],
      aliases: [
        "UserWhitespacable"
      ],
      fields: {
        argument: validateType("FlowType")
      }
    });
    defineType$3("OpaqueType", {
      visitor: [
        "id",
        "typeParameters",
        "supertype",
        "impltype"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        supertype: validateOptionalType("FlowType"),
        impltype: validateType("FlowType")
      }
    });
    defineType$3("QualifiedTypeIdentifier", {
      visitor: [
        "id",
        "qualification"
      ],
      fields: {
        id: validateType("Identifier"),
        qualification: validateType([
          "Identifier",
          "QualifiedTypeIdentifier"
        ])
      }
    });
    defineType$3("StringLiteralTypeAnnotation", {
      builder: [
        "value"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        value: validate$1(assertValueType("string"))
      }
    });
    defineType$3("StringTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("SymbolTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("ThisTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("TupleTypeAnnotation", {
      visitor: [
        "types"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType$3("TypeofTypeAnnotation", {
      visitor: [
        "argument"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        argument: validateType("FlowType")
      }
    });
    defineType$3("TypeAlias", {
      visitor: [
        "id",
        "typeParameters",
        "right"
      ],
      aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
      ],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        right: validateType("FlowType")
      }
    });
    defineType$3("TypeAnnotation", {
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        typeAnnotation: validateType("FlowType")
      }
    });
    defineType$3("TypeCastExpression", {
      visitor: [
        "expression",
        "typeAnnotation"
      ],
      aliases: [
        "ExpressionWrapper",
        "Expression"
      ],
      fields: {
        expression: validateType("Expression"),
        typeAnnotation: validateType("TypeAnnotation")
      }
    });
    defineType$3("TypeParameter", {
      visitor: [
        "bound",
        "default",
        "variance"
      ],
      fields: {
        name: validate$1(assertValueType("string")),
        bound: validateOptionalType("TypeAnnotation"),
        default: validateOptionalType("FlowType"),
        variance: validateOptionalType("Variance")
      }
    });
    defineType$3("TypeParameterDeclaration", {
      visitor: [
        "params"
      ],
      fields: {
        params: validate$1(arrayOfType("TypeParameter"))
      }
    });
    defineType$3("TypeParameterInstantiation", {
      visitor: [
        "params"
      ],
      fields: {
        params: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType$3("UnionTypeAnnotation", {
      visitor: [
        "types"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType$3("Variance", {
      builder: [
        "kind"
      ],
      fields: {
        kind: validate$1(assertOneOf("minus", "plus"))
      }
    });
    defineType$3("VoidTypeAnnotation", {
      aliases: [
        "FlowType",
        "FlowBaseAnnotation"
      ]
    });
    defineType$3("EnumDeclaration", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "body"
      ],
      fields: {
        id: validateType("Identifier"),
        body: validateType([
          "EnumBooleanBody",
          "EnumNumberBody",
          "EnumStringBody",
          "EnumSymbolBody"
        ])
      }
    });
    defineType$3("EnumBooleanBody", {
      aliases: [
        "EnumBody"
      ],
      visitor: [
        "members"
      ],
      fields: {
        explicitType: validate$1(assertValueType("boolean")),
        members: validateArrayOfType("EnumBooleanMember"),
        hasUnknownMembers: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("EnumNumberBody", {
      aliases: [
        "EnumBody"
      ],
      visitor: [
        "members"
      ],
      fields: {
        explicitType: validate$1(assertValueType("boolean")),
        members: validateArrayOfType("EnumNumberMember"),
        hasUnknownMembers: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("EnumStringBody", {
      aliases: [
        "EnumBody"
      ],
      visitor: [
        "members"
      ],
      fields: {
        explicitType: validate$1(assertValueType("boolean")),
        members: validateArrayOfType([
          "EnumStringMember",
          "EnumDefaultedMember"
        ]),
        hasUnknownMembers: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("EnumSymbolBody", {
      aliases: [
        "EnumBody"
      ],
      visitor: [
        "members"
      ],
      fields: {
        members: validateArrayOfType("EnumDefaultedMember"),
        hasUnknownMembers: validate$1(assertValueType("boolean"))
      }
    });
    defineType$3("EnumBooleanMember", {
      aliases: [
        "EnumMember"
      ],
      visitor: [
        "id"
      ],
      fields: {
        id: validateType("Identifier"),
        init: validateType("BooleanLiteral")
      }
    });
    defineType$3("EnumNumberMember", {
      aliases: [
        "EnumMember"
      ],
      visitor: [
        "id",
        "init"
      ],
      fields: {
        id: validateType("Identifier"),
        init: validateType("NumericLiteral")
      }
    });
    defineType$3("EnumStringMember", {
      aliases: [
        "EnumMember"
      ],
      visitor: [
        "id",
        "init"
      ],
      fields: {
        id: validateType("Identifier"),
        init: validateType("StringLiteral")
      }
    });
    defineType$3("EnumDefaultedMember", {
      aliases: [
        "EnumMember"
      ],
      visitor: [
        "id"
      ],
      fields: {
        id: validateType("Identifier")
      }
    });
    defineType$3("IndexedAccessType", {
      visitor: [
        "objectType",
        "indexType"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        objectType: validateType("FlowType"),
        indexType: validateType("FlowType")
      }
    });
    defineType$3("OptionalIndexedAccessType", {
      visitor: [
        "objectType",
        "indexType"
      ],
      aliases: [
        "FlowType"
      ],
      fields: {
        objectType: validateType("FlowType"),
        indexType: validateType("FlowType"),
        optional: validate$1(assertValueType("boolean"))
      }
    });
    var defineType$2 = defineAliasedType("JSX");
    defineType$2("JSXAttribute", {
      visitor: [
        "name",
        "value"
      ],
      aliases: [
        "Immutable"
      ],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType$2("JSXClosingElement", {
      visitor: [
        "name"
      ],
      aliases: [
        "Immutable"
      ],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType$2("JSXElement", {
      builder: [
        "openingElement",
        "closingElement",
        "children"
      ],
      visitor: [
        "openingElement",
        "children",
        "closingElement"
      ],
      aliases: [
        "Immutable",
        "Expression"
      ],
      fields: Object.assign({
        openingElement: {
          validate: assertNodeType("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: assertNodeType("JSXClosingElement")
        },
        children: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }, {})
    });
    defineType$2("JSXEmptyExpression", {});
    defineType$2("JSXExpressionContainer", {
      visitor: [
        "expression"
      ],
      aliases: [
        "Immutable"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType$2("JSXSpreadChild", {
      visitor: [
        "expression"
      ],
      aliases: [
        "Immutable"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$2("JSXIdentifier", {
      builder: [
        "name"
      ],
      fields: {
        name: {
          validate: assertValueType("string")
        }
      }
    });
    defineType$2("JSXMemberExpression", {
      visitor: [
        "object",
        "property"
      ],
      fields: {
        object: {
          validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: assertNodeType("JSXIdentifier")
        }
      }
    });
    defineType$2("JSXNamespacedName", {
      visitor: [
        "namespace",
        "name"
      ],
      fields: {
        namespace: {
          validate: assertNodeType("JSXIdentifier")
        },
        name: {
          validate: assertNodeType("JSXIdentifier")
        }
      }
    });
    defineType$2("JSXOpeningElement", {
      builder: [
        "name",
        "attributes",
        "selfClosing"
      ],
      visitor: [
        "name",
        "attributes"
      ],
      aliases: [
        "Immutable"
      ],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType$2("JSXSpreadAttribute", {
      visitor: [
        "argument"
      ],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$2("JSXText", {
      aliases: [
        "Immutable"
      ],
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType$2("JSXFragment", {
      builder: [
        "openingFragment",
        "closingFragment",
        "children"
      ],
      visitor: [
        "openingFragment",
        "children",
        "closingFragment"
      ],
      aliases: [
        "Immutable",
        "Expression"
      ],
      fields: {
        openingFragment: {
          validate: assertNodeType("JSXOpeningFragment")
        },
        closingFragment: {
          validate: assertNodeType("JSXClosingFragment")
        },
        children: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType$2("JSXOpeningFragment", {
      aliases: [
        "Immutable"
      ]
    });
    defineType$2("JSXClosingFragment", {
      aliases: [
        "Immutable"
      ]
    });
    var PLACEHOLDERS = [
      "Identifier",
      "StringLiteral",
      "Expression",
      "Statement",
      "Declaration",
      "BlockStatement",
      "ClassBody",
      "Pattern"
    ];
    var PLACEHOLDERS_ALIAS = {
      Declaration: [
        "Statement"
      ],
      Pattern: [
        "PatternLike",
        "LVal"
      ]
    };
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (_iterator = PLACEHOLDERS[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        type = _step.value;
        alias = ALIAS_KEYS[type];
        if (alias === null || alias === void 0 ? void 0 : alias.length)
          PLACEHOLDERS_ALIAS[type] = alias;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var type;
    var alias;
    var _iterator;
    var _step;
    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach(function(type3) {
      PLACEHOLDERS_ALIAS[type3].forEach(function(alias2) {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias2)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias2] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias2].push(type3);
      });
    });
    var defineType$1 = defineAliasedType("Miscellaneous");
    defineType$1("Placeholder", {
      visitor: [],
      builder: [
        "expectedNode",
        "name"
      ],
      fields: {
        name: {
          validate: assertNodeType("Identifier")
        },
        expectedNode: {
          validate: assertOneOf.apply(void 0, _to_consumable_array(PLACEHOLDERS))
        }
      }
    });
    defineType$1("V8IntrinsicIdentifier", {
      builder: [
        "name"
      ],
      fields: {
        name: {
          validate: assertValueType("string")
        }
      }
    });
    defineType$5("ArgumentPlaceholder", {});
    defineType$5("BindExpression", {
      visitor: [
        "object",
        "callee"
      ],
      aliases: [
        "Expression"
      ],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(function() {
          }, {
            oneOfNodeTypes: [
              "Expression"
            ]
          })
        },
        callee: {
          validate: Object.assign(function() {
          }, {
            oneOfNodeTypes: [
              "Expression"
            ]
          })
        }
      } : {
        object: {
          validate: assertNodeType("Expression")
        },
        callee: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$5("ImportAttribute", {
      visitor: [
        "key",
        "value"
      ],
      fields: {
        key: {
          validate: assertNodeType("Identifier", "StringLiteral")
        },
        value: {
          validate: assertNodeType("StringLiteral")
        }
      }
    });
    defineType$5("Decorator", {
      visitor: [
        "expression"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType$5("DoExpression", {
      visitor: [
        "body"
      ],
      builder: [
        "body",
        "async"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        body: {
          validate: assertNodeType("BlockStatement")
        },
        async: {
          validate: assertValueType("boolean"),
          default: false
        }
      }
    });
    defineType$5("ExportDefaultSpecifier", {
      visitor: [
        "exported"
      ],
      aliases: [
        "ModuleSpecifier"
      ],
      fields: {
        exported: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType$5("RecordExpression", {
      visitor: [
        "properties"
      ],
      aliases: [
        "Expression"
      ],
      fields: {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType$5("TupleExpression", {
      fields: {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: [
        "elements"
      ],
      aliases: [
        "Expression"
      ]
    });
    defineType$5("DecimalLiteral", {
      builder: [
        "value"
      ],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
      ]
    });
    defineType$5("ModuleExpression", {
      visitor: [
        "body"
      ],
      fields: {
        body: {
          validate: assertNodeType("Program")
        }
      },
      aliases: [
        "Expression"
      ]
    });
    defineType$5("TopicReference", {
      aliases: [
        "Expression"
      ]
    });
    defineType$5("PipelineTopicExpression", {
      builder: [
        "expression"
      ],
      visitor: [
        "expression"
      ],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: [
        "Expression"
      ]
    });
    defineType$5("PipelineBareFunction", {
      builder: [
        "callee"
      ],
      visitor: [
        "callee"
      ],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: [
        "Expression"
      ]
    });
    defineType$5("PipelinePrimaryTopicReference", {
      aliases: [
        "Expression"
      ]
    });
    var defineType = defineAliasedType("TypeScript");
    var bool = assertValueType("boolean");
    var tSFunctionTypeAnnotationCommon = function() {
      return {
        returnType: {
          validate: assertNodeType("TSTypeAnnotation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterDeclaration"),
          optional: true
        }
      };
    };
    defineType("TSParameterProperty", {
      aliases: [
        "LVal"
      ],
      visitor: [
        "parameter"
      ],
      fields: {
        accessibility: {
          validate: assertOneOf("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        parameter: {
          validate: assertNodeType("Identifier", "AssignmentPattern")
        },
        override: {
          validate: assertValueType("boolean"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "typeParameters",
        "params",
        "returnType"
      ],
      fields: Object.assign({}, functionDeclarationCommon(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: [
        "decorators",
        "key",
        "typeParameters",
        "params",
        "returnType"
      ],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: [
        "TSEntityName"
      ],
      visitor: [
        "left",
        "right"
      ],
      fields: {
        left: validateType("TSEntityName"),
        right: validateType("Identifier")
      }
    });
    var signatureDeclarationCommon = function() {
      var _obj;
      return _obj = {
        typeParameters: validateOptionalType("TSTypeParameterDeclaration")
      }, _define_property(_obj, "params", validateArrayOfType([
        "ArrayPattern",
        "Identifier",
        "ObjectPattern",
        "RestElement"
      ])), _define_property(_obj, "returnType", validateOptionalType("TSTypeAnnotation")), _obj;
    };
    var callConstructSignatureDeclaration = {
      aliases: [
        "TSTypeElement"
      ],
      visitor: [
        "typeParameters",
        "params",
        "returnType"
      ],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = function() {
      return {
        key: validateType("Expression"),
        computed: {
          default: false
        },
        optional: validateOptional(bool)
      };
    };
    defineType("TSPropertySignature", {
      aliases: [
        "TSTypeElement"
      ],
      visitor: [
        "key",
        "typeAnnotation"
      ],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: validateOptional(bool),
        typeAnnotation: validateOptionalType("TSTypeAnnotation"),
        kind: {
          validate: assertOneOf("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: [
        "TSTypeElement"
      ],
      visitor: [
        "key",
        "typeParameters",
        "params",
        "returnType"
      ],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: assertOneOf("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: [
        "TSTypeElement"
      ],
      visitor: [
        "parameters",
        "typeAnnotation"
      ],
      fields: {
        readonly: validateOptional(bool),
        static: validateOptional(bool),
        parameters: validateArrayOfType("Identifier"),
        typeAnnotation: validateOptionalType("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = [
      "TSAnyKeyword",
      "TSBooleanKeyword",
      "TSBigIntKeyword",
      "TSIntrinsicKeyword",
      "TSNeverKeyword",
      "TSNullKeyword",
      "TSNumberKeyword",
      "TSObjectKeyword",
      "TSStringKeyword",
      "TSSymbolKeyword",
      "TSUndefinedKeyword",
      "TSUnknownKeyword",
      "TSVoidKeyword"
    ];
    var _iteratorNormalCompletion1 = true;
    var _didIteratorError1 = false;
    var _iteratorError1 = void 0;
    try {
      for (_iterator1 = tsKeywordTypes[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        type1 = _step1.value;
        defineType(type1, {
          aliases: [
            "TSType",
            "TSBaseType"
          ],
          visitor: [],
          fields: {}
        });
      }
    } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
          _iterator1.return();
        }
      } finally {
        if (_didIteratorError1) {
          throw _iteratorError1;
        }
      }
    }
    var type1;
    var _iterator1;
    var _step1;
    defineType("TSThisType", {
      aliases: [
        "TSType",
        "TSBaseType"
      ],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeParameters",
        "params",
        "returnType"
      ]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: validateOptional(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeName",
        "typeParameters"
      ],
      fields: {
        typeName: validateType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "parameterName",
        "typeAnnotation"
      ],
      builder: [
        "parameterName",
        "typeAnnotation",
        "asserts"
      ],
      fields: {
        parameterName: validateType([
          "Identifier",
          "TSThisType"
        ]),
        typeAnnotation: validateOptionalType("TSTypeAnnotation"),
        asserts: validateOptional(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "exprName",
        "typeParameters"
      ],
      fields: {
        exprName: validateType([
          "TSEntityName",
          "TSImportType"
        ]),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "members"
      ],
      fields: {
        members: validateArrayOfType("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "elementType"
      ],
      fields: {
        elementType: validateType("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "elementTypes"
      ],
      fields: {
        elementTypes: validateArrayOfType([
          "TSType",
          "TSNamedTupleMember"
        ])
      }
    });
    defineType("TSOptionalType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: [
        "label",
        "elementType"
      ],
      builder: [
        "label",
        "elementType",
        "optional"
      ],
      fields: {
        label: validateType("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: validateType("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: [
        "TSType"
      ],
      visitor: [
        "types"
      ],
      fields: {
        types: validateArrayOfType("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "checkType",
        "extendsType",
        "trueType",
        "falseType"
      ],
      fields: {
        checkType: validateType("TSType"),
        extendsType: validateType("TSType"),
        trueType: validateType("TSType"),
        falseType: validateType("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeParameter"
      ],
      fields: {
        typeParameter: validateType("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        operator: validate$1(assertValueType("string")),
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "objectType",
        "indexType"
      ],
      fields: {
        objectType: validateType("TSType"),
        indexType: validateType("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "typeParameter",
        "typeAnnotation",
        "nameType"
      ],
      fields: {
        readonly: validateOptional(assertOneOf(true, false, "+", "-")),
        typeParameter: validateType("TSTypeParameter"),
        optional: validateOptional(assertOneOf(true, false, "+", "-")),
        typeAnnotation: validateOptionalType("TSType"),
        nameType: validateOptionalType("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: [
        "TSType",
        "TSBaseType"
      ],
      visitor: [
        "literal"
      ],
      fields: {
        literal: {
          validate: function() {
            var unaryExpression3 = assertNodeType("NumericLiteral", "BigIntLiteral");
            var unaryOperator = assertOneOf("-");
            var literal2 = assertNodeType("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node2) {
              if (is2("UnaryExpression", node2)) {
                unaryOperator(node2, "operator", node2.operator);
                unaryExpression3(node2, "argument", node2.argument);
              } else {
                literal2(parent, key, node2);
              }
            }
            validator.oneOfNodeTypes = [
              "NumericLiteral",
              "StringLiteral",
              "BooleanLiteral",
              "BigIntLiteral",
              "TemplateLiteral",
              "UnaryExpression"
            ];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "expression",
        "typeParameters"
      ],
      fields: {
        expression: validateType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "typeParameters",
        "extends",
        "body"
      ],
      fields: {
        declare: validateOptional(bool),
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
        extends: validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
        body: validateType("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: [
        "body"
      ],
      fields: {
        body: validateArrayOfType("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "typeParameters",
        "typeAnnotation"
      ],
      fields: {
        declare: validateOptional(bool),
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: [
        "Expression"
      ],
      visitor: [
        "expression",
        "typeParameters"
      ],
      fields: {
        expression: validateType("Expression"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: [
        "Expression",
        "LVal",
        "PatternLike"
      ],
      visitor: [
        "expression",
        "typeAnnotation"
      ],
      fields: {
        expression: validateType("Expression"),
        typeAnnotation: validateType("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: [
        "Expression",
        "LVal",
        "PatternLike"
      ],
      visitor: [
        "typeAnnotation",
        "expression"
      ],
      fields: {
        typeAnnotation: validateType("TSType"),
        expression: validateType("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "members"
      ],
      fields: {
        declare: validateOptional(bool),
        const: validateOptional(bool),
        id: validateType("Identifier"),
        members: validateArrayOfType("TSEnumMember"),
        initializer: validateOptionalType("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: [
        "id",
        "initializer"
      ],
      fields: {
        id: validateType([
          "Identifier",
          "StringLiteral"
        ]),
        initializer: validateOptionalType("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: [
        "Statement",
        "Declaration"
      ],
      visitor: [
        "id",
        "body"
      ],
      fields: {
        declare: validateOptional(bool),
        global: validateOptional(bool),
        id: validateType([
          "Identifier",
          "StringLiteral"
        ]),
        body: validateType([
          "TSModuleBlock",
          "TSModuleDeclaration"
        ])
      }
    });
    defineType("TSModuleBlock", {
      aliases: [
        "Scopable",
        "Block",
        "BlockParent",
        "FunctionParent"
      ],
      visitor: [
        "body"
      ],
      fields: {
        body: validateArrayOfType("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: [
        "TSType"
      ],
      visitor: [
        "argument",
        "qualifier",
        "typeParameters"
      ],
      fields: {
        argument: validateType("StringLiteral"),
        qualifier: validateOptionalType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: [
        "Statement"
      ],
      visitor: [
        "id",
        "moduleReference"
      ],
      fields: {
        isExport: validate$1(bool),
        id: validateType("Identifier"),
        moduleReference: validateType([
          "TSEntityName",
          "TSExternalModuleReference"
        ]),
        importKind: {
          validate: assertOneOf("type", "value"),
          optional: true
        }
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: [
        "expression"
      ],
      fields: {
        expression: validateType("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: [
        "Expression",
        "LVal",
        "PatternLike"
      ],
      visitor: [
        "expression"
      ],
      fields: {
        expression: validateType("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: [
        "Statement"
      ],
      visitor: [
        "expression"
      ],
      fields: {
        expression: validateType("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: [
        "Statement"
      ],
      visitor: [
        "id"
      ],
      fields: {
        id: validateType("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: [
        "typeAnnotation"
      ],
      fields: {
        typeAnnotation: {
          validate: assertNodeType("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: [
        "params"
      ],
      fields: {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: [
        "params"
      ],
      fields: {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: [
        "constraint",
        "default",
        "name"
      ],
      visitor: [
        "constraint",
        "default"
      ],
      fields: {
        name: {
          validate: assertNodeType("Identifier")
        },
        in: {
          validate: assertValueType("boolean"),
          optional: true
        },
        out: {
          validate: assertValueType("boolean"),
          optional: true
        },
        const: {
          validate: assertValueType("boolean"),
          optional: true
        },
        constraint: {
          validate: assertNodeType("TSType"),
          optional: true
        },
        default: {
          validate: assertNodeType("TSType"),
          optional: true
        }
      }
    });
    var DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
    Object.keys(DEPRECATED_ALIASES).forEach(function(deprecatedAlias) {
      FLIPPED_ALIAS_KEYS[deprecatedAlias] = FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];
    });
    (0, import_to_fast_properties.default)(VISITOR_KEYS);
    (0, import_to_fast_properties.default)(ALIAS_KEYS);
    (0, import_to_fast_properties.default)(FLIPPED_ALIAS_KEYS);
    (0, import_to_fast_properties.default)(NODE_FIELDS);
    (0, import_to_fast_properties.default)(BUILDER_KEYS);
    (0, import_to_fast_properties.default)(DEPRECATED_KEYS);
    (0, import_to_fast_properties.default)(PLACEHOLDERS_ALIAS);
    (0, import_to_fast_properties.default)(PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = [].concat(Object.keys(VISITOR_KEYS), Object.keys(FLIPPED_ALIAS_KEYS), Object.keys(DEPRECATED_KEYS));
    function validate(node2, key, val) {
      if (!node2)
        return;
      var fields = NODE_FIELDS[node2.type];
      if (!fields)
        return;
      var field = fields[key];
      validateField(node2, key, val, field);
      validateChild(node2, key, val);
    }
    function validateField(node2, key, val, field) {
      if (!(field === null || field === void 0 ? void 0 : field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node2, key, val);
    }
    function validateChild(node2, key, val) {
      if (val == null)
        return;
      var validate4 = NODE_PARENT_VALIDATIONS[val.type];
      if (!validate4)
        return;
      validate4(node2, key, val);
    }
    function validateNode(node2) {
      var keys2 = BUILDER_KEYS[node2.type];
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          validate(node2, key, node2[key]);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return node2;
    }
    function arrayExpression() {
      var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return validateNode({
        type: "ArrayExpression",
        elements
      });
    }
    function assignmentExpression(operator, left, right) {
      return validateNode({
        type: "AssignmentExpression",
        operator,
        left,
        right
      });
    }
    function binaryExpression(operator, left, right) {
      return validateNode({
        type: "BinaryExpression",
        operator,
        left,
        right
      });
    }
    function interpreterDirective(value1) {
      return validateNode({
        type: "InterpreterDirective",
        value: value1
      });
    }
    function directive(value1) {
      return validateNode({
        type: "Directive",
        value: value1
      });
    }
    function directiveLiteral(value1) {
      return validateNode({
        type: "DirectiveLiteral",
        value: value1
      });
    }
    function blockStatement(body) {
      var directives = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return validateNode({
        type: "BlockStatement",
        body,
        directives
      });
    }
    function breakStatement() {
      var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return validateNode({
        type: "BreakStatement",
        label
      });
    }
    function callExpression(callee, _arguments) {
      return validateNode({
        type: "CallExpression",
        callee,
        arguments: _arguments
      });
    }
    function catchClause() {
      var param = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, body = arguments.length > 1 ? arguments[1] : void 0;
      return validateNode({
        type: "CatchClause",
        param,
        body
      });
    }
    function conditionalExpression(test, consequent, alternate) {
      return validateNode({
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      });
    }
    function continueStatement() {
      var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return validateNode({
        type: "ContinueStatement",
        label
      });
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      return validateNode({
        type: "DoWhileStatement",
        test,
        body
      });
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression2) {
      return validateNode({
        type: "ExpressionStatement",
        expression: expression2
      });
    }
    function file(program3) {
      var comments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, tokens = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "File",
        program: program3,
        comments,
        tokens
      });
    }
    function forInStatement(left, right, body) {
      return validateNode({
        type: "ForInStatement",
        left,
        right,
        body
      });
    }
    function forStatement() {
      var init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, test = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, update = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, body = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "ForStatement",
        init,
        test,
        update,
        body
      });
    }
    function functionDeclaration() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, params = arguments.length > 1 ? arguments[1] : void 0, body = arguments.length > 2 ? arguments[2] : void 0, generator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, async = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      return validateNode({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function functionExpression() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, params = arguments.length > 1 ? arguments[1] : void 0, body = arguments.length > 2 ? arguments[2] : void 0, generator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, async = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      return validateNode({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function identifier(name2) {
      return validateNode({
        type: "Identifier",
        name: name2
      });
    }
    function ifStatement(test, consequent) {
      var alternate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "IfStatement",
        test,
        consequent,
        alternate
      });
    }
    function labeledStatement(label, body) {
      return validateNode({
        type: "LabeledStatement",
        label,
        body
      });
    }
    function stringLiteral(value1) {
      return validateNode({
        type: "StringLiteral",
        value: value1
      });
    }
    function numericLiteral(value1) {
      return validateNode({
        type: "NumericLiteral",
        value: value1
      });
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value1) {
      return validateNode({
        type: "BooleanLiteral",
        value: value1
      });
    }
    function regExpLiteral(pattern) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return validateNode({
        type: "RegExpLiteral",
        pattern,
        flags
      });
    }
    function logicalExpression(operator, left, right) {
      return validateNode({
        type: "LogicalExpression",
        operator,
        left,
        right
      });
    }
    function memberExpression(object, property) {
      var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, optional = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function newExpression(callee, _arguments) {
      return validateNode({
        type: "NewExpression",
        callee,
        arguments: _arguments
      });
    }
    function program(body) {
      var directives = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], sourceType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "script", interpreter = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
      });
    }
    function objectExpression(properties) {
      return validateNode({
        type: "ObjectExpression",
        properties
      });
    }
    function objectMethod() {
      var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", key = arguments.length > 1 ? arguments[1] : void 0, params = arguments.length > 2 ? arguments[2] : void 0, body = arguments.length > 3 ? arguments[3] : void 0, computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, generator = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, async = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
      return validateNode({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      });
    }
    function objectProperty(key, value1) {
      var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, shorthand = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, decorators = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      return validateNode({
        type: "ObjectProperty",
        key,
        value: value1,
        computed,
        shorthand,
        decorators
      });
    }
    function restElement(argument) {
      return validateNode({
        type: "RestElement",
        argument
      });
    }
    function returnStatement() {
      var argument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return validateNode({
        type: "ReturnStatement",
        argument
      });
    }
    function sequenceExpression(expressions) {
      return validateNode({
        type: "SequenceExpression",
        expressions
      });
    }
    function parenthesizedExpression(expression2) {
      return validateNode({
        type: "ParenthesizedExpression",
        expression: expression2
      });
    }
    function switchCase() {
      var test = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, consequent = arguments.length > 1 ? arguments[1] : void 0;
      return validateNode({
        type: "SwitchCase",
        test,
        consequent
      });
    }
    function switchStatement(discriminant, cases) {
      return validateNode({
        type: "SwitchStatement",
        discriminant,
        cases
      });
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      return validateNode({
        type: "ThrowStatement",
        argument
      });
    }
    function tryStatement(block) {
      var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, finalizer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TryStatement",
        block,
        handler,
        finalizer
      });
    }
    function unaryExpression(operator, argument) {
      var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return validateNode({
        type: "UnaryExpression",
        operator,
        argument,
        prefix: prefix2
      });
    }
    function updateExpression(operator, argument) {
      var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return validateNode({
        type: "UpdateExpression",
        operator,
        argument,
        prefix: prefix2
      });
    }
    function variableDeclaration(kind, declarations) {
      return validateNode({
        type: "VariableDeclaration",
        kind,
        declarations
      });
    }
    function variableDeclarator(id) {
      var init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "VariableDeclarator",
        id,
        init
      });
    }
    function whileStatement(test, body) {
      return validateNode({
        type: "WhileStatement",
        test,
        body
      });
    }
    function withStatement(object, body) {
      return validateNode({
        type: "WithStatement",
        object,
        body
      });
    }
    function assignmentPattern(left, right) {
      return validateNode({
        type: "AssignmentPattern",
        left,
        right
      });
    }
    function arrayPattern(elements) {
      return validateNode({
        type: "ArrayPattern",
        elements
      });
    }
    function arrowFunctionExpression(params, body) {
      var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return validateNode({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      });
    }
    function classBody(body) {
      return validateNode({
        type: "ClassBody",
        body
      });
    }
    function classExpression() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, superClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, body = arguments.length > 2 ? arguments[2] : void 0, decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      });
    }
    function classDeclaration() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, superClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, body = arguments.length > 2 ? arguments[2] : void 0, decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      });
    }
    function exportAllDeclaration(source) {
      return validateNode({
        type: "ExportAllDeclaration",
        source
      });
    }
    function exportDefaultDeclaration(declaration) {
      return validateNode({
        type: "ExportDefaultDeclaration",
        declaration
      });
    }
    function exportNamedDeclaration() {
      var declaration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, specifiers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function exportSpecifier(local, exported) {
      return validateNode({
        type: "ExportSpecifier",
        local,
        exported
      });
    }
    function forOfStatement(left, right, body) {
      var _await = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      return validateNode({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      });
    }
    function importDeclaration(specifiers, source) {
      return validateNode({
        type: "ImportDeclaration",
        specifiers,
        source
      });
    }
    function importDefaultSpecifier(local) {
      return validateNode({
        type: "ImportDefaultSpecifier",
        local
      });
    }
    function importNamespaceSpecifier(local) {
      return validateNode({
        type: "ImportNamespaceSpecifier",
        local
      });
    }
    function importSpecifier(local, imported) {
      return validateNode({
        type: "ImportSpecifier",
        local,
        imported
      });
    }
    function importExpression(source) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "ImportExpression",
        source,
        options
      });
    }
    function metaProperty(meta, property) {
      return validateNode({
        type: "MetaProperty",
        meta,
        property
      });
    }
    function classMethod() {
      var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", key = arguments.length > 1 ? arguments[1] : void 0, params = arguments.length > 2 ? arguments[2] : void 0, body = arguments.length > 3 ? arguments[3] : void 0, computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, generator = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, async = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
      return validateNode({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      });
    }
    function objectPattern(properties) {
      return validateNode({
        type: "ObjectPattern",
        properties
      });
    }
    function spreadElement(argument) {
      return validateNode({
        type: "SpreadElement",
        argument
      });
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      return validateNode({
        type: "TaggedTemplateExpression",
        tag,
        quasi
      });
    }
    function templateElement(value1) {
      var tail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return validateNode({
        type: "TemplateElement",
        value: value1,
        tail
      });
    }
    function templateLiteral(quasis, expressions) {
      return validateNode({
        type: "TemplateLiteral",
        quasis,
        expressions
      });
    }
    function yieldExpression() {
      var argument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, delegate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return validateNode({
        type: "YieldExpression",
        argument,
        delegate
      });
    }
    function awaitExpression(argument) {
      return validateNode({
        type: "AwaitExpression",
        argument
      });
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value1) {
      return validateNode({
        type: "BigIntLiteral",
        value: value1
      });
    }
    function exportNamespaceSpecifier(exported) {
      return validateNode({
        type: "ExportNamespaceSpecifier",
        exported
      });
    }
    function optionalMemberExpression(object, property) {
      var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, optional = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return validateNode({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      });
    }
    function classProperty(key) {
      var value1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      return validateNode({
        type: "ClassProperty",
        key,
        value: value1,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classAccessorProperty(key) {
      var value1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      return validateNode({
        type: "ClassAccessorProperty",
        key,
        value: value1,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classPrivateProperty(key) {
      var value1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, decorators = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, _static = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      return validateNode({
        type: "ClassPrivateProperty",
        key,
        value: value1,
        decorators,
        static: _static
      });
    }
    function classPrivateMethod() {
      var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", key = arguments.length > 1 ? arguments[1] : void 0, params = arguments.length > 2 ? arguments[2] : void 0, body = arguments.length > 3 ? arguments[3] : void 0, _static = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      return validateNode({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      });
    }
    function privateName(id) {
      return validateNode({
        type: "PrivateName",
        id
      });
    }
    function staticBlock(body) {
      return validateNode({
        type: "StaticBlock",
        body
      });
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      return validateNode({
        type: "ArrayTypeAnnotation",
        elementType
      });
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value1) {
      return validateNode({
        type: "BooleanLiteralTypeAnnotation",
        value: value1
      });
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "ClassImplements",
        id,
        typeParameters
      });
    }
    function declareClass(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, body = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareFunction(id) {
      return validateNode({
        type: "DeclareFunction",
        id
      });
    }
    function declareInterface(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, body = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareModule(id, body) {
      var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "DeclareModule",
        id,
        body,
        kind
      });
    }
    function declareModuleExports(typeAnnotation2) {
      return validateNode({
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      });
    }
    function declareTypeAlias(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, right = arguments.length > 2 ? arguments[2] : void 0;
      return validateNode({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function declareOpaqueType(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, supertype = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      });
    }
    function declareVariable(id) {
      return validateNode({
        type: "DeclareVariable",
        id
      });
    }
    function declareExportDeclaration() {
      var declaration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, specifiers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function declareExportAllDeclaration(source) {
      return validateNode({
        type: "DeclareExportAllDeclaration",
        source
      });
    }
    function declaredPredicate(value1) {
      return validateNode({
        type: "DeclaredPredicate",
        value: value1
      });
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation() {
      var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, params = arguments.length > 1 ? arguments[1] : void 0, rest = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, returnType = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      });
    }
    function functionTypeParam() {
      var name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, typeAnnotation2 = arguments.length > 1 ? arguments[1] : void 0;
      return validateNode({
        type: "FunctionTypeParam",
        name: name2,
        typeAnnotation: typeAnnotation2
      });
    }
    function genericTypeAnnotation(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      });
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "InterfaceExtends",
        id,
        typeParameters
      });
    }
    function interfaceDeclaration(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, body = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function interfaceTypeAnnotation() {
      var _extends = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, body = arguments.length > 1 ? arguments[1] : void 0;
      return validateNode({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      });
    }
    function intersectionTypeAnnotation(types22) {
      return validateNode({
        type: "IntersectionTypeAnnotation",
        types: types22
      });
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return validateNode({
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function numberLiteralTypeAnnotation(value1) {
      return validateNode({
        type: "NumberLiteralTypeAnnotation",
        value: value1
      });
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties) {
      var indexers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], callProperties = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], internalSlots = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], exact = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      return validateNode({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      });
    }
    function objectTypeInternalSlot(id, value1, optional, _static, method) {
      return validateNode({
        type: "ObjectTypeInternalSlot",
        id,
        value: value1,
        optional,
        static: _static,
        method
      });
    }
    function objectTypeCallProperty(value1) {
      return validateNode({
        type: "ObjectTypeCallProperty",
        value: value1,
        static: null
      });
    }
    function objectTypeIndexer() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, key = arguments.length > 1 ? arguments[1] : void 0, value1 = arguments.length > 2 ? arguments[2] : void 0, variance2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "ObjectTypeIndexer",
        id,
        key,
        value: value1,
        variance: variance2,
        static: null
      });
    }
    function objectTypeProperty(key, value1) {
      var variance2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "ObjectTypeProperty",
        key,
        value: value1,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      });
    }
    function objectTypeSpreadProperty(argument) {
      return validateNode({
        type: "ObjectTypeSpreadProperty",
        argument
      });
    }
    function opaqueType(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, supertype = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, impltype = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      });
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return validateNode({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      });
    }
    function stringLiteralTypeAnnotation(value1) {
      return validateNode({
        type: "StringLiteralTypeAnnotation",
        value: value1
      });
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types22) {
      return validateNode({
        type: "TupleTypeAnnotation",
        types: types22
      });
    }
    function typeofTypeAnnotation(argument) {
      return validateNode({
        type: "TypeofTypeAnnotation",
        argument
      });
    }
    function typeAlias(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, right = arguments.length > 2 ? arguments[2] : void 0;
      return validateNode({
        type: "TypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function typeAnnotation(typeAnnotation2) {
      return validateNode({
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function typeCastExpression(expression2, typeAnnotation2) {
      return validateNode({
        type: "TypeCastExpression",
        expression: expression2,
        typeAnnotation: typeAnnotation2
      });
    }
    function typeParameter() {
      var bound = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, _default = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, variance2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      });
    }
    function typeParameterDeclaration(params) {
      return validateNode({
        type: "TypeParameterDeclaration",
        params
      });
    }
    function typeParameterInstantiation(params) {
      return validateNode({
        type: "TypeParameterInstantiation",
        params
      });
    }
    function unionTypeAnnotation(types22) {
      return validateNode({
        type: "UnionTypeAnnotation",
        types: types22
      });
    }
    function variance(kind) {
      return validateNode({
        type: "Variance",
        kind
      });
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      return validateNode({
        type: "EnumDeclaration",
        id,
        body
      });
    }
    function enumBooleanBody(members) {
      return validateNode({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumNumberBody(members) {
      return validateNode({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumStringBody(members) {
      return validateNode({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumSymbolBody(members) {
      return validateNode({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      });
    }
    function enumBooleanMember(id) {
      return validateNode({
        type: "EnumBooleanMember",
        id,
        init: null
      });
    }
    function enumNumberMember(id, init) {
      return validateNode({
        type: "EnumNumberMember",
        id,
        init
      });
    }
    function enumStringMember(id, init) {
      return validateNode({
        type: "EnumStringMember",
        id,
        init
      });
    }
    function enumDefaultedMember(id) {
      return validateNode({
        type: "EnumDefaultedMember",
        id
      });
    }
    function indexedAccessType(objectType, indexType) {
      return validateNode({
        type: "IndexedAccessType",
        objectType,
        indexType
      });
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return validateNode({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      });
    }
    function jsxAttribute2(name2) {
      var value1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "JSXAttribute",
        name: name2,
        value: value1
      });
    }
    function jsxClosingElement2(name2) {
      return validateNode({
        type: "JSXClosingElement",
        name: name2
      });
    }
    function jsxElement2(openingElement) {
      var closingElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, children = arguments.length > 2 ? arguments[2] : void 0, selfClosing = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      });
    }
    function jsxEmptyExpression2() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer2(expression2) {
      return validateNode({
        type: "JSXExpressionContainer",
        expression: expression2
      });
    }
    function jsxSpreadChild(expression2) {
      return validateNode({
        type: "JSXSpreadChild",
        expression: expression2
      });
    }
    function jsxIdentifier2(name2) {
      return validateNode({
        type: "JSXIdentifier",
        name: name2
      });
    }
    function jsxMemberExpression2(object, property) {
      return validateNode({
        type: "JSXMemberExpression",
        object,
        property
      });
    }
    function jsxNamespacedName2(namespace, name2) {
      return validateNode({
        type: "JSXNamespacedName",
        namespace,
        name: name2
      });
    }
    function jsxOpeningElement2(name2, attributes) {
      var selfClosing = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return validateNode({
        type: "JSXOpeningElement",
        name: name2,
        attributes,
        selfClosing
      });
    }
    function jsxSpreadAttribute2(argument) {
      return validateNode({
        type: "JSXSpreadAttribute",
        argument
      });
    }
    function jsxText3(value1) {
      return validateNode({
        type: "JSXText",
        value: value1
      });
    }
    function jsxFragment2(openingFragment, closingFragment, children) {
      return validateNode({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      });
    }
    function jsxOpeningFragment2() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment2() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name2) {
      return validateNode({
        type: "Placeholder",
        expectedNode,
        name: name2
      });
    }
    function v8IntrinsicIdentifier(name2) {
      return validateNode({
        type: "V8IntrinsicIdentifier",
        name: name2
      });
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      return validateNode({
        type: "BindExpression",
        object,
        callee
      });
    }
    function importAttribute(key, value1) {
      return validateNode({
        type: "ImportAttribute",
        key,
        value: value1
      });
    }
    function decorator(expression2) {
      return validateNode({
        type: "Decorator",
        expression: expression2
      });
    }
    function doExpression(body) {
      var async = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return validateNode({
        type: "DoExpression",
        body,
        async
      });
    }
    function exportDefaultSpecifier(exported) {
      return validateNode({
        type: "ExportDefaultSpecifier",
        exported
      });
    }
    function recordExpression(properties) {
      return validateNode({
        type: "RecordExpression",
        properties
      });
    }
    function tupleExpression() {
      var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return validateNode({
        type: "TupleExpression",
        elements
      });
    }
    function decimalLiteral(value1) {
      return validateNode({
        type: "DecimalLiteral",
        value: value1
      });
    }
    function moduleExpression(body) {
      return validateNode({
        type: "ModuleExpression",
        body
      });
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression2) {
      return validateNode({
        type: "PipelineTopicExpression",
        expression: expression2
      });
    }
    function pipelineBareFunction(callee) {
      return validateNode({
        type: "PipelineBareFunction",
        callee
      });
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      return validateNode({
        type: "TSParameterProperty",
        parameter
      });
    }
    function tsDeclareFunction() {
      var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, params = arguments.length > 2 ? arguments[2] : void 0, returnType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      });
    }
    function tsDeclareMethod() {
      var decorators = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, key = arguments.length > 1 ? arguments[1] : void 0, typeParameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, params = arguments.length > 3 ? arguments[3] : void 0, returnType = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      return validateNode({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      });
    }
    function tsQualifiedName(left, right) {
      return validateNode({
        type: "TSQualifiedName",
        left,
        right
      });
    }
    function tsCallSignatureDeclaration() {
      var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, parameters = arguments.length > 1 ? arguments[1] : void 0, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructSignatureDeclaration() {
      var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, parameters = arguments.length > 1 ? arguments[1] : void 0, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsPropertySignature(key) {
      var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsMethodSignature(key) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, parameters = arguments.length > 2 ? arguments[2] : void 0, typeAnnotation2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return validateNode({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsIndexSignature(parameters) {
      var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType() {
      var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, parameters = arguments.length > 1 ? arguments[1] : void 0, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructorType() {
      var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, parameters = arguments.length > 1 ? arguments[1] : void 0, typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeReference(typeName) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSTypeReference",
        typeName,
        typeParameters
      });
    }
    function tsTypePredicate(parameterName) {
      var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, asserts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      });
    }
    function tsTypeQuery(exprName) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSTypeQuery",
        exprName,
        typeParameters
      });
    }
    function tsTypeLiteral(members) {
      return validateNode({
        type: "TSTypeLiteral",
        members
      });
    }
    function tsArrayType(elementType) {
      return validateNode({
        type: "TSArrayType",
        elementType
      });
    }
    function tsTupleType(elementTypes) {
      return validateNode({
        type: "TSTupleType",
        elementTypes
      });
    }
    function tsOptionalType(typeAnnotation2) {
      return validateNode({
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsRestType(typeAnnotation2) {
      return validateNode({
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsNamedTupleMember(label, elementType) {
      var optional = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return validateNode({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      });
    }
    function tsUnionType(types22) {
      return validateNode({
        type: "TSUnionType",
        types: types22
      });
    }
    function tsIntersectionType(types22) {
      return validateNode({
        type: "TSIntersectionType",
        types: types22
      });
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return validateNode({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      });
    }
    function tsInferType(typeParameter2) {
      return validateNode({
        type: "TSInferType",
        typeParameter: typeParameter2
      });
    }
    function tsParenthesizedType(typeAnnotation2) {
      return validateNode({
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeOperator(typeAnnotation2) {
      return validateNode({
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      });
    }
    function tsIndexedAccessType(objectType, indexType) {
      return validateNode({
        type: "TSIndexedAccessType",
        objectType,
        indexType
      });
    }
    function tsMappedType(typeParameter2) {
      var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, nameType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      });
    }
    function tsLiteralType(literal2) {
      return validateNode({
        type: "TSLiteralType",
        literal: literal2
      });
    }
    function tsExpressionWithTypeArguments(expression2) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSExpressionWithTypeArguments",
        expression: expression2,
        typeParameters
      });
    }
    function tsInterfaceDeclaration(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, body = arguments.length > 3 ? arguments[3] : void 0;
      return validateNode({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function tsInterfaceBody(body) {
      return validateNode({
        type: "TSInterfaceBody",
        body
      });
    }
    function tsTypeAliasDeclaration(id) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, typeAnnotation2 = arguments.length > 2 ? arguments[2] : void 0;
      return validateNode({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsInstantiationExpression(expression2) {
      var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSInstantiationExpression",
        expression: expression2,
        typeParameters
      });
    }
    function tsAsExpression(expression2, typeAnnotation2) {
      return validateNode({
        type: "TSAsExpression",
        expression: expression2,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsSatisfiesExpression(expression2, typeAnnotation2) {
      return validateNode({
        type: "TSSatisfiesExpression",
        expression: expression2,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeAssertion(typeAnnotation2, expression2) {
      return validateNode({
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression: expression2
      });
    }
    function tsEnumDeclaration(id, members) {
      return validateNode({
        type: "TSEnumDeclaration",
        id,
        members
      });
    }
    function tsEnumMember(id) {
      var initializer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return validateNode({
        type: "TSEnumMember",
        id,
        initializer
      });
    }
    function tsModuleDeclaration(id, body) {
      return validateNode({
        type: "TSModuleDeclaration",
        id,
        body
      });
    }
    function tsModuleBlock(body) {
      return validateNode({
        type: "TSModuleBlock",
        body
      });
    }
    function tsImportType(argument) {
      var qualifier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, typeParameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return validateNode({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      });
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return validateNode({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      });
    }
    function tsExternalModuleReference(expression2) {
      return validateNode({
        type: "TSExternalModuleReference",
        expression: expression2
      });
    }
    function tsNonNullExpression(expression2) {
      return validateNode({
        type: "TSNonNullExpression",
        expression: expression2
      });
    }
    function tsExportAssignment(expression2) {
      return validateNode({
        type: "TSExportAssignment",
        expression: expression2
      });
    }
    function tsNamespaceExportDeclaration(id) {
      return validateNode({
        type: "TSNamespaceExportDeclaration",
        id
      });
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return validateNode({
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeParameterInstantiation(params) {
      return validateNode({
        type: "TSTypeParameterInstantiation",
        params
      });
    }
    function tsTypeParameterDeclaration(params) {
      return validateNode({
        type: "TSTypeParameterDeclaration",
        params
      });
    }
    function tsTypeParameter() {
      var constraint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, _default = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, name2 = arguments.length > 2 ? arguments[2] : void 0;
      return validateNode({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name: name2
      });
    }
    function NumberLiteral(value1) {
      deprecationWarning("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value1);
    }
    function RegexLiteral(pattern) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      deprecationWarning("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      deprecationWarning("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      deprecationWarning("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
    function cleanJSXElementLiteralChild(child, args) {
      var lines = child.value.split(/\r\n|\n|\r/);
      var lastNonEmptyLine = 0;
      for (var i2 = 0; i2 < lines.length; i2++) {
        if (lines[i2].match(/[^ \t]/)) {
          lastNonEmptyLine = i2;
        }
      }
      var str = "";
      for (var i1 = 0; i1 < lines.length; i1++) {
        var line = lines[i1];
        var isFirstLine = i1 === 0;
        var isLastLine = i1 === lines.length - 1;
        var isLastNonEmptyLine = i1 === lastNonEmptyLine;
        var trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push(inherits(stringLiteral(str), child));
    }
    function buildChildren(node2) {
      var elements = [];
      for (var i2 = 0; i2 < node2.children.length; i2++) {
        var child = node2.children[i2];
        if (isJSXText(child)) {
          cleanJSXElementLiteralChild(child, elements);
          continue;
        }
        if (isJSXExpressionContainer2(child))
          child = child.expression;
        if (isJSXEmptyExpression(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
    function isNode2(node2) {
      return !!(node2 && VISITOR_KEYS[node2.type]);
    }
    function assertNode2(node2) {
      if (!isNode2(node2)) {
        var _node_type;
        var type3 = (_node_type = node2 === null || node2 === void 0 ? void 0 : node2.type) !== null && _node_type !== void 0 ? _node_type : JSON.stringify(node2);
        throw new TypeError('Not a valid node of type "'.concat(type3, '"'));
      }
    }
    function assert(type3, node2, opts) {
      if (!is2(type3, node2, opts)) {
        throw new Error('Expected type "'.concat(type3, '" with option ').concat(JSON.stringify(opts), ', but instead got "').concat(node2.type, '".'));
      }
    }
    function assertArrayExpression(node2, opts) {
      assert("ArrayExpression", node2, opts);
    }
    function assertAssignmentExpression(node2, opts) {
      assert("AssignmentExpression", node2, opts);
    }
    function assertBinaryExpression(node2, opts) {
      assert("BinaryExpression", node2, opts);
    }
    function assertInterpreterDirective(node2, opts) {
      assert("InterpreterDirective", node2, opts);
    }
    function assertDirective(node2, opts) {
      assert("Directive", node2, opts);
    }
    function assertDirectiveLiteral(node2, opts) {
      assert("DirectiveLiteral", node2, opts);
    }
    function assertBlockStatement(node2, opts) {
      assert("BlockStatement", node2, opts);
    }
    function assertBreakStatement(node2, opts) {
      assert("BreakStatement", node2, opts);
    }
    function assertCallExpression(node2, opts) {
      assert("CallExpression", node2, opts);
    }
    function assertCatchClause(node2, opts) {
      assert("CatchClause", node2, opts);
    }
    function assertConditionalExpression(node2, opts) {
      assert("ConditionalExpression", node2, opts);
    }
    function assertContinueStatement(node2, opts) {
      assert("ContinueStatement", node2, opts);
    }
    function assertDebuggerStatement(node2, opts) {
      assert("DebuggerStatement", node2, opts);
    }
    function assertDoWhileStatement(node2, opts) {
      assert("DoWhileStatement", node2, opts);
    }
    function assertEmptyStatement(node2, opts) {
      assert("EmptyStatement", node2, opts);
    }
    function assertExpressionStatement(node2, opts) {
      assert("ExpressionStatement", node2, opts);
    }
    function assertFile(node2, opts) {
      assert("File", node2, opts);
    }
    function assertForInStatement(node2, opts) {
      assert("ForInStatement", node2, opts);
    }
    function assertForStatement(node2, opts) {
      assert("ForStatement", node2, opts);
    }
    function assertFunctionDeclaration(node2, opts) {
      assert("FunctionDeclaration", node2, opts);
    }
    function assertFunctionExpression(node2, opts) {
      assert("FunctionExpression", node2, opts);
    }
    function assertIdentifier(node2, opts) {
      assert("Identifier", node2, opts);
    }
    function assertIfStatement(node2, opts) {
      assert("IfStatement", node2, opts);
    }
    function assertLabeledStatement(node2, opts) {
      assert("LabeledStatement", node2, opts);
    }
    function assertStringLiteral(node2, opts) {
      assert("StringLiteral", node2, opts);
    }
    function assertNumericLiteral(node2, opts) {
      assert("NumericLiteral", node2, opts);
    }
    function assertNullLiteral(node2, opts) {
      assert("NullLiteral", node2, opts);
    }
    function assertBooleanLiteral(node2, opts) {
      assert("BooleanLiteral", node2, opts);
    }
    function assertRegExpLiteral(node2, opts) {
      assert("RegExpLiteral", node2, opts);
    }
    function assertLogicalExpression(node2, opts) {
      assert("LogicalExpression", node2, opts);
    }
    function assertMemberExpression(node2, opts) {
      assert("MemberExpression", node2, opts);
    }
    function assertNewExpression(node2, opts) {
      assert("NewExpression", node2, opts);
    }
    function assertProgram(node2, opts) {
      assert("Program", node2, opts);
    }
    function assertObjectExpression(node2, opts) {
      assert("ObjectExpression", node2, opts);
    }
    function assertObjectMethod(node2, opts) {
      assert("ObjectMethod", node2, opts);
    }
    function assertObjectProperty(node2, opts) {
      assert("ObjectProperty", node2, opts);
    }
    function assertRestElement(node2, opts) {
      assert("RestElement", node2, opts);
    }
    function assertReturnStatement(node2, opts) {
      assert("ReturnStatement", node2, opts);
    }
    function assertSequenceExpression(node2, opts) {
      assert("SequenceExpression", node2, opts);
    }
    function assertParenthesizedExpression(node2, opts) {
      assert("ParenthesizedExpression", node2, opts);
    }
    function assertSwitchCase(node2, opts) {
      assert("SwitchCase", node2, opts);
    }
    function assertSwitchStatement(node2, opts) {
      assert("SwitchStatement", node2, opts);
    }
    function assertThisExpression(node2, opts) {
      assert("ThisExpression", node2, opts);
    }
    function assertThrowStatement(node2, opts) {
      assert("ThrowStatement", node2, opts);
    }
    function assertTryStatement(node2, opts) {
      assert("TryStatement", node2, opts);
    }
    function assertUnaryExpression(node2, opts) {
      assert("UnaryExpression", node2, opts);
    }
    function assertUpdateExpression(node2, opts) {
      assert("UpdateExpression", node2, opts);
    }
    function assertVariableDeclaration(node2, opts) {
      assert("VariableDeclaration", node2, opts);
    }
    function assertVariableDeclarator(node2, opts) {
      assert("VariableDeclarator", node2, opts);
    }
    function assertWhileStatement(node2, opts) {
      assert("WhileStatement", node2, opts);
    }
    function assertWithStatement(node2, opts) {
      assert("WithStatement", node2, opts);
    }
    function assertAssignmentPattern(node2, opts) {
      assert("AssignmentPattern", node2, opts);
    }
    function assertArrayPattern(node2, opts) {
      assert("ArrayPattern", node2, opts);
    }
    function assertArrowFunctionExpression(node2, opts) {
      assert("ArrowFunctionExpression", node2, opts);
    }
    function assertClassBody(node2, opts) {
      assert("ClassBody", node2, opts);
    }
    function assertClassExpression(node2, opts) {
      assert("ClassExpression", node2, opts);
    }
    function assertClassDeclaration(node2, opts) {
      assert("ClassDeclaration", node2, opts);
    }
    function assertExportAllDeclaration(node2, opts) {
      assert("ExportAllDeclaration", node2, opts);
    }
    function assertExportDefaultDeclaration(node2, opts) {
      assert("ExportDefaultDeclaration", node2, opts);
    }
    function assertExportNamedDeclaration(node2, opts) {
      assert("ExportNamedDeclaration", node2, opts);
    }
    function assertExportSpecifier(node2, opts) {
      assert("ExportSpecifier", node2, opts);
    }
    function assertForOfStatement(node2, opts) {
      assert("ForOfStatement", node2, opts);
    }
    function assertImportDeclaration(node2, opts) {
      assert("ImportDeclaration", node2, opts);
    }
    function assertImportDefaultSpecifier(node2, opts) {
      assert("ImportDefaultSpecifier", node2, opts);
    }
    function assertImportNamespaceSpecifier(node2, opts) {
      assert("ImportNamespaceSpecifier", node2, opts);
    }
    function assertImportSpecifier(node2, opts) {
      assert("ImportSpecifier", node2, opts);
    }
    function assertImportExpression(node2, opts) {
      assert("ImportExpression", node2, opts);
    }
    function assertMetaProperty(node2, opts) {
      assert("MetaProperty", node2, opts);
    }
    function assertClassMethod(node2, opts) {
      assert("ClassMethod", node2, opts);
    }
    function assertObjectPattern(node2, opts) {
      assert("ObjectPattern", node2, opts);
    }
    function assertSpreadElement(node2, opts) {
      assert("SpreadElement", node2, opts);
    }
    function assertSuper(node2, opts) {
      assert("Super", node2, opts);
    }
    function assertTaggedTemplateExpression(node2, opts) {
      assert("TaggedTemplateExpression", node2, opts);
    }
    function assertTemplateElement(node2, opts) {
      assert("TemplateElement", node2, opts);
    }
    function assertTemplateLiteral(node2, opts) {
      assert("TemplateLiteral", node2, opts);
    }
    function assertYieldExpression(node2, opts) {
      assert("YieldExpression", node2, opts);
    }
    function assertAwaitExpression(node2, opts) {
      assert("AwaitExpression", node2, opts);
    }
    function assertImport(node2, opts) {
      assert("Import", node2, opts);
    }
    function assertBigIntLiteral(node2, opts) {
      assert("BigIntLiteral", node2, opts);
    }
    function assertExportNamespaceSpecifier(node2, opts) {
      assert("ExportNamespaceSpecifier", node2, opts);
    }
    function assertOptionalMemberExpression(node2, opts) {
      assert("OptionalMemberExpression", node2, opts);
    }
    function assertOptionalCallExpression(node2, opts) {
      assert("OptionalCallExpression", node2, opts);
    }
    function assertClassProperty(node2, opts) {
      assert("ClassProperty", node2, opts);
    }
    function assertClassAccessorProperty(node2, opts) {
      assert("ClassAccessorProperty", node2, opts);
    }
    function assertClassPrivateProperty(node2, opts) {
      assert("ClassPrivateProperty", node2, opts);
    }
    function assertClassPrivateMethod(node2, opts) {
      assert("ClassPrivateMethod", node2, opts);
    }
    function assertPrivateName(node2, opts) {
      assert("PrivateName", node2, opts);
    }
    function assertStaticBlock(node2, opts) {
      assert("StaticBlock", node2, opts);
    }
    function assertAnyTypeAnnotation(node2, opts) {
      assert("AnyTypeAnnotation", node2, opts);
    }
    function assertArrayTypeAnnotation(node2, opts) {
      assert("ArrayTypeAnnotation", node2, opts);
    }
    function assertBooleanTypeAnnotation(node2, opts) {
      assert("BooleanTypeAnnotation", node2, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node2, opts) {
      assert("BooleanLiteralTypeAnnotation", node2, opts);
    }
    function assertNullLiteralTypeAnnotation(node2, opts) {
      assert("NullLiteralTypeAnnotation", node2, opts);
    }
    function assertClassImplements(node2, opts) {
      assert("ClassImplements", node2, opts);
    }
    function assertDeclareClass(node2, opts) {
      assert("DeclareClass", node2, opts);
    }
    function assertDeclareFunction(node2, opts) {
      assert("DeclareFunction", node2, opts);
    }
    function assertDeclareInterface(node2, opts) {
      assert("DeclareInterface", node2, opts);
    }
    function assertDeclareModule(node2, opts) {
      assert("DeclareModule", node2, opts);
    }
    function assertDeclareModuleExports(node2, opts) {
      assert("DeclareModuleExports", node2, opts);
    }
    function assertDeclareTypeAlias(node2, opts) {
      assert("DeclareTypeAlias", node2, opts);
    }
    function assertDeclareOpaqueType(node2, opts) {
      assert("DeclareOpaqueType", node2, opts);
    }
    function assertDeclareVariable(node2, opts) {
      assert("DeclareVariable", node2, opts);
    }
    function assertDeclareExportDeclaration(node2, opts) {
      assert("DeclareExportDeclaration", node2, opts);
    }
    function assertDeclareExportAllDeclaration(node2, opts) {
      assert("DeclareExportAllDeclaration", node2, opts);
    }
    function assertDeclaredPredicate(node2, opts) {
      assert("DeclaredPredicate", node2, opts);
    }
    function assertExistsTypeAnnotation(node2, opts) {
      assert("ExistsTypeAnnotation", node2, opts);
    }
    function assertFunctionTypeAnnotation(node2, opts) {
      assert("FunctionTypeAnnotation", node2, opts);
    }
    function assertFunctionTypeParam(node2, opts) {
      assert("FunctionTypeParam", node2, opts);
    }
    function assertGenericTypeAnnotation(node2, opts) {
      assert("GenericTypeAnnotation", node2, opts);
    }
    function assertInferredPredicate(node2, opts) {
      assert("InferredPredicate", node2, opts);
    }
    function assertInterfaceExtends(node2, opts) {
      assert("InterfaceExtends", node2, opts);
    }
    function assertInterfaceDeclaration(node2, opts) {
      assert("InterfaceDeclaration", node2, opts);
    }
    function assertInterfaceTypeAnnotation(node2, opts) {
      assert("InterfaceTypeAnnotation", node2, opts);
    }
    function assertIntersectionTypeAnnotation(node2, opts) {
      assert("IntersectionTypeAnnotation", node2, opts);
    }
    function assertMixedTypeAnnotation(node2, opts) {
      assert("MixedTypeAnnotation", node2, opts);
    }
    function assertEmptyTypeAnnotation(node2, opts) {
      assert("EmptyTypeAnnotation", node2, opts);
    }
    function assertNullableTypeAnnotation(node2, opts) {
      assert("NullableTypeAnnotation", node2, opts);
    }
    function assertNumberLiteralTypeAnnotation(node2, opts) {
      assert("NumberLiteralTypeAnnotation", node2, opts);
    }
    function assertNumberTypeAnnotation(node2, opts) {
      assert("NumberTypeAnnotation", node2, opts);
    }
    function assertObjectTypeAnnotation(node2, opts) {
      assert("ObjectTypeAnnotation", node2, opts);
    }
    function assertObjectTypeInternalSlot(node2, opts) {
      assert("ObjectTypeInternalSlot", node2, opts);
    }
    function assertObjectTypeCallProperty(node2, opts) {
      assert("ObjectTypeCallProperty", node2, opts);
    }
    function assertObjectTypeIndexer(node2, opts) {
      assert("ObjectTypeIndexer", node2, opts);
    }
    function assertObjectTypeProperty(node2, opts) {
      assert("ObjectTypeProperty", node2, opts);
    }
    function assertObjectTypeSpreadProperty(node2, opts) {
      assert("ObjectTypeSpreadProperty", node2, opts);
    }
    function assertOpaqueType(node2, opts) {
      assert("OpaqueType", node2, opts);
    }
    function assertQualifiedTypeIdentifier(node2, opts) {
      assert("QualifiedTypeIdentifier", node2, opts);
    }
    function assertStringLiteralTypeAnnotation(node2, opts) {
      assert("StringLiteralTypeAnnotation", node2, opts);
    }
    function assertStringTypeAnnotation(node2, opts) {
      assert("StringTypeAnnotation", node2, opts);
    }
    function assertSymbolTypeAnnotation(node2, opts) {
      assert("SymbolTypeAnnotation", node2, opts);
    }
    function assertThisTypeAnnotation(node2, opts) {
      assert("ThisTypeAnnotation", node2, opts);
    }
    function assertTupleTypeAnnotation(node2, opts) {
      assert("TupleTypeAnnotation", node2, opts);
    }
    function assertTypeofTypeAnnotation(node2, opts) {
      assert("TypeofTypeAnnotation", node2, opts);
    }
    function assertTypeAlias(node2, opts) {
      assert("TypeAlias", node2, opts);
    }
    function assertTypeAnnotation(node2, opts) {
      assert("TypeAnnotation", node2, opts);
    }
    function assertTypeCastExpression(node2, opts) {
      assert("TypeCastExpression", node2, opts);
    }
    function assertTypeParameter(node2, opts) {
      assert("TypeParameter", node2, opts);
    }
    function assertTypeParameterDeclaration(node2, opts) {
      assert("TypeParameterDeclaration", node2, opts);
    }
    function assertTypeParameterInstantiation(node2, opts) {
      assert("TypeParameterInstantiation", node2, opts);
    }
    function assertUnionTypeAnnotation(node2, opts) {
      assert("UnionTypeAnnotation", node2, opts);
    }
    function assertVariance(node2, opts) {
      assert("Variance", node2, opts);
    }
    function assertVoidTypeAnnotation(node2, opts) {
      assert("VoidTypeAnnotation", node2, opts);
    }
    function assertEnumDeclaration(node2, opts) {
      assert("EnumDeclaration", node2, opts);
    }
    function assertEnumBooleanBody(node2, opts) {
      assert("EnumBooleanBody", node2, opts);
    }
    function assertEnumNumberBody(node2, opts) {
      assert("EnumNumberBody", node2, opts);
    }
    function assertEnumStringBody(node2, opts) {
      assert("EnumStringBody", node2, opts);
    }
    function assertEnumSymbolBody(node2, opts) {
      assert("EnumSymbolBody", node2, opts);
    }
    function assertEnumBooleanMember(node2, opts) {
      assert("EnumBooleanMember", node2, opts);
    }
    function assertEnumNumberMember(node2, opts) {
      assert("EnumNumberMember", node2, opts);
    }
    function assertEnumStringMember(node2, opts) {
      assert("EnumStringMember", node2, opts);
    }
    function assertEnumDefaultedMember(node2, opts) {
      assert("EnumDefaultedMember", node2, opts);
    }
    function assertIndexedAccessType(node2, opts) {
      assert("IndexedAccessType", node2, opts);
    }
    function assertOptionalIndexedAccessType(node2, opts) {
      assert("OptionalIndexedAccessType", node2, opts);
    }
    function assertJSXAttribute(node2, opts) {
      assert("JSXAttribute", node2, opts);
    }
    function assertJSXClosingElement(node2, opts) {
      assert("JSXClosingElement", node2, opts);
    }
    function assertJSXElement(node2, opts) {
      assert("JSXElement", node2, opts);
    }
    function assertJSXEmptyExpression(node2, opts) {
      assert("JSXEmptyExpression", node2, opts);
    }
    function assertJSXExpressionContainer(node2, opts) {
      assert("JSXExpressionContainer", node2, opts);
    }
    function assertJSXSpreadChild(node2, opts) {
      assert("JSXSpreadChild", node2, opts);
    }
    function assertJSXIdentifier(node2, opts) {
      assert("JSXIdentifier", node2, opts);
    }
    function assertJSXMemberExpression(node2, opts) {
      assert("JSXMemberExpression", node2, opts);
    }
    function assertJSXNamespacedName(node2, opts) {
      assert("JSXNamespacedName", node2, opts);
    }
    function assertJSXOpeningElement(node2, opts) {
      assert("JSXOpeningElement", node2, opts);
    }
    function assertJSXSpreadAttribute(node2, opts) {
      assert("JSXSpreadAttribute", node2, opts);
    }
    function assertJSXText(node2, opts) {
      assert("JSXText", node2, opts);
    }
    function assertJSXFragment(node2, opts) {
      assert("JSXFragment", node2, opts);
    }
    function assertJSXOpeningFragment(node2, opts) {
      assert("JSXOpeningFragment", node2, opts);
    }
    function assertJSXClosingFragment(node2, opts) {
      assert("JSXClosingFragment", node2, opts);
    }
    function assertNoop(node2, opts) {
      assert("Noop", node2, opts);
    }
    function assertPlaceholder(node2, opts) {
      assert("Placeholder", node2, opts);
    }
    function assertV8IntrinsicIdentifier(node2, opts) {
      assert("V8IntrinsicIdentifier", node2, opts);
    }
    function assertArgumentPlaceholder(node2, opts) {
      assert("ArgumentPlaceholder", node2, opts);
    }
    function assertBindExpression(node2, opts) {
      assert("BindExpression", node2, opts);
    }
    function assertImportAttribute(node2, opts) {
      assert("ImportAttribute", node2, opts);
    }
    function assertDecorator(node2, opts) {
      assert("Decorator", node2, opts);
    }
    function assertDoExpression(node2, opts) {
      assert("DoExpression", node2, opts);
    }
    function assertExportDefaultSpecifier(node2, opts) {
      assert("ExportDefaultSpecifier", node2, opts);
    }
    function assertRecordExpression(node2, opts) {
      assert("RecordExpression", node2, opts);
    }
    function assertTupleExpression(node2, opts) {
      assert("TupleExpression", node2, opts);
    }
    function assertDecimalLiteral(node2, opts) {
      assert("DecimalLiteral", node2, opts);
    }
    function assertModuleExpression(node2, opts) {
      assert("ModuleExpression", node2, opts);
    }
    function assertTopicReference(node2, opts) {
      assert("TopicReference", node2, opts);
    }
    function assertPipelineTopicExpression(node2, opts) {
      assert("PipelineTopicExpression", node2, opts);
    }
    function assertPipelineBareFunction(node2, opts) {
      assert("PipelineBareFunction", node2, opts);
    }
    function assertPipelinePrimaryTopicReference(node2, opts) {
      assert("PipelinePrimaryTopicReference", node2, opts);
    }
    function assertTSParameterProperty(node2, opts) {
      assert("TSParameterProperty", node2, opts);
    }
    function assertTSDeclareFunction(node2, opts) {
      assert("TSDeclareFunction", node2, opts);
    }
    function assertTSDeclareMethod(node2, opts) {
      assert("TSDeclareMethod", node2, opts);
    }
    function assertTSQualifiedName(node2, opts) {
      assert("TSQualifiedName", node2, opts);
    }
    function assertTSCallSignatureDeclaration(node2, opts) {
      assert("TSCallSignatureDeclaration", node2, opts);
    }
    function assertTSConstructSignatureDeclaration(node2, opts) {
      assert("TSConstructSignatureDeclaration", node2, opts);
    }
    function assertTSPropertySignature(node2, opts) {
      assert("TSPropertySignature", node2, opts);
    }
    function assertTSMethodSignature(node2, opts) {
      assert("TSMethodSignature", node2, opts);
    }
    function assertTSIndexSignature(node2, opts) {
      assert("TSIndexSignature", node2, opts);
    }
    function assertTSAnyKeyword(node2, opts) {
      assert("TSAnyKeyword", node2, opts);
    }
    function assertTSBooleanKeyword(node2, opts) {
      assert("TSBooleanKeyword", node2, opts);
    }
    function assertTSBigIntKeyword(node2, opts) {
      assert("TSBigIntKeyword", node2, opts);
    }
    function assertTSIntrinsicKeyword(node2, opts) {
      assert("TSIntrinsicKeyword", node2, opts);
    }
    function assertTSNeverKeyword(node2, opts) {
      assert("TSNeverKeyword", node2, opts);
    }
    function assertTSNullKeyword(node2, opts) {
      assert("TSNullKeyword", node2, opts);
    }
    function assertTSNumberKeyword(node2, opts) {
      assert("TSNumberKeyword", node2, opts);
    }
    function assertTSObjectKeyword(node2, opts) {
      assert("TSObjectKeyword", node2, opts);
    }
    function assertTSStringKeyword(node2, opts) {
      assert("TSStringKeyword", node2, opts);
    }
    function assertTSSymbolKeyword(node2, opts) {
      assert("TSSymbolKeyword", node2, opts);
    }
    function assertTSUndefinedKeyword(node2, opts) {
      assert("TSUndefinedKeyword", node2, opts);
    }
    function assertTSUnknownKeyword(node2, opts) {
      assert("TSUnknownKeyword", node2, opts);
    }
    function assertTSVoidKeyword(node2, opts) {
      assert("TSVoidKeyword", node2, opts);
    }
    function assertTSThisType(node2, opts) {
      assert("TSThisType", node2, opts);
    }
    function assertTSFunctionType(node2, opts) {
      assert("TSFunctionType", node2, opts);
    }
    function assertTSConstructorType(node2, opts) {
      assert("TSConstructorType", node2, opts);
    }
    function assertTSTypeReference(node2, opts) {
      assert("TSTypeReference", node2, opts);
    }
    function assertTSTypePredicate(node2, opts) {
      assert("TSTypePredicate", node2, opts);
    }
    function assertTSTypeQuery(node2, opts) {
      assert("TSTypeQuery", node2, opts);
    }
    function assertTSTypeLiteral(node2, opts) {
      assert("TSTypeLiteral", node2, opts);
    }
    function assertTSArrayType(node2, opts) {
      assert("TSArrayType", node2, opts);
    }
    function assertTSTupleType(node2, opts) {
      assert("TSTupleType", node2, opts);
    }
    function assertTSOptionalType(node2, opts) {
      assert("TSOptionalType", node2, opts);
    }
    function assertTSRestType(node2, opts) {
      assert("TSRestType", node2, opts);
    }
    function assertTSNamedTupleMember(node2, opts) {
      assert("TSNamedTupleMember", node2, opts);
    }
    function assertTSUnionType(node2, opts) {
      assert("TSUnionType", node2, opts);
    }
    function assertTSIntersectionType(node2, opts) {
      assert("TSIntersectionType", node2, opts);
    }
    function assertTSConditionalType(node2, opts) {
      assert("TSConditionalType", node2, opts);
    }
    function assertTSInferType(node2, opts) {
      assert("TSInferType", node2, opts);
    }
    function assertTSParenthesizedType(node2, opts) {
      assert("TSParenthesizedType", node2, opts);
    }
    function assertTSTypeOperator(node2, opts) {
      assert("TSTypeOperator", node2, opts);
    }
    function assertTSIndexedAccessType(node2, opts) {
      assert("TSIndexedAccessType", node2, opts);
    }
    function assertTSMappedType(node2, opts) {
      assert("TSMappedType", node2, opts);
    }
    function assertTSLiteralType(node2, opts) {
      assert("TSLiteralType", node2, opts);
    }
    function assertTSExpressionWithTypeArguments(node2, opts) {
      assert("TSExpressionWithTypeArguments", node2, opts);
    }
    function assertTSInterfaceDeclaration(node2, opts) {
      assert("TSInterfaceDeclaration", node2, opts);
    }
    function assertTSInterfaceBody(node2, opts) {
      assert("TSInterfaceBody", node2, opts);
    }
    function assertTSTypeAliasDeclaration(node2, opts) {
      assert("TSTypeAliasDeclaration", node2, opts);
    }
    function assertTSInstantiationExpression(node2, opts) {
      assert("TSInstantiationExpression", node2, opts);
    }
    function assertTSAsExpression(node2, opts) {
      assert("TSAsExpression", node2, opts);
    }
    function assertTSSatisfiesExpression(node2, opts) {
      assert("TSSatisfiesExpression", node2, opts);
    }
    function assertTSTypeAssertion(node2, opts) {
      assert("TSTypeAssertion", node2, opts);
    }
    function assertTSEnumDeclaration(node2, opts) {
      assert("TSEnumDeclaration", node2, opts);
    }
    function assertTSEnumMember(node2, opts) {
      assert("TSEnumMember", node2, opts);
    }
    function assertTSModuleDeclaration(node2, opts) {
      assert("TSModuleDeclaration", node2, opts);
    }
    function assertTSModuleBlock(node2, opts) {
      assert("TSModuleBlock", node2, opts);
    }
    function assertTSImportType(node2, opts) {
      assert("TSImportType", node2, opts);
    }
    function assertTSImportEqualsDeclaration(node2, opts) {
      assert("TSImportEqualsDeclaration", node2, opts);
    }
    function assertTSExternalModuleReference(node2, opts) {
      assert("TSExternalModuleReference", node2, opts);
    }
    function assertTSNonNullExpression(node2, opts) {
      assert("TSNonNullExpression", node2, opts);
    }
    function assertTSExportAssignment(node2, opts) {
      assert("TSExportAssignment", node2, opts);
    }
    function assertTSNamespaceExportDeclaration(node2, opts) {
      assert("TSNamespaceExportDeclaration", node2, opts);
    }
    function assertTSTypeAnnotation(node2, opts) {
      assert("TSTypeAnnotation", node2, opts);
    }
    function assertTSTypeParameterInstantiation(node2, opts) {
      assert("TSTypeParameterInstantiation", node2, opts);
    }
    function assertTSTypeParameterDeclaration(node2, opts) {
      assert("TSTypeParameterDeclaration", node2, opts);
    }
    function assertTSTypeParameter(node2, opts) {
      assert("TSTypeParameter", node2, opts);
    }
    function assertStandardized(node2, opts) {
      assert("Standardized", node2, opts);
    }
    function assertExpression(node2, opts) {
      assert("Expression", node2, opts);
    }
    function assertBinary(node2, opts) {
      assert("Binary", node2, opts);
    }
    function assertScopable(node2, opts) {
      assert("Scopable", node2, opts);
    }
    function assertBlockParent(node2, opts) {
      assert("BlockParent", node2, opts);
    }
    function assertBlock(node2, opts) {
      assert("Block", node2, opts);
    }
    function assertStatement(node2, opts) {
      assert("Statement", node2, opts);
    }
    function assertTerminatorless(node2, opts) {
      assert("Terminatorless", node2, opts);
    }
    function assertCompletionStatement(node2, opts) {
      assert("CompletionStatement", node2, opts);
    }
    function assertConditional(node2, opts) {
      assert("Conditional", node2, opts);
    }
    function assertLoop(node2, opts) {
      assert("Loop", node2, opts);
    }
    function assertWhile(node2, opts) {
      assert("While", node2, opts);
    }
    function assertExpressionWrapper(node2, opts) {
      assert("ExpressionWrapper", node2, opts);
    }
    function assertFor(node2, opts) {
      assert("For", node2, opts);
    }
    function assertForXStatement(node2, opts) {
      assert("ForXStatement", node2, opts);
    }
    function assertFunction(node2, opts) {
      assert("Function", node2, opts);
    }
    function assertFunctionParent(node2, opts) {
      assert("FunctionParent", node2, opts);
    }
    function assertPureish(node2, opts) {
      assert("Pureish", node2, opts);
    }
    function assertDeclaration(node2, opts) {
      assert("Declaration", node2, opts);
    }
    function assertPatternLike(node2, opts) {
      assert("PatternLike", node2, opts);
    }
    function assertLVal(node2, opts) {
      assert("LVal", node2, opts);
    }
    function assertTSEntityName(node2, opts) {
      assert("TSEntityName", node2, opts);
    }
    function assertLiteral(node2, opts) {
      assert("Literal", node2, opts);
    }
    function assertImmutable(node2, opts) {
      assert("Immutable", node2, opts);
    }
    function assertUserWhitespacable(node2, opts) {
      assert("UserWhitespacable", node2, opts);
    }
    function assertMethod(node2, opts) {
      assert("Method", node2, opts);
    }
    function assertObjectMember(node2, opts) {
      assert("ObjectMember", node2, opts);
    }
    function assertProperty(node2, opts) {
      assert("Property", node2, opts);
    }
    function assertUnaryLike(node2, opts) {
      assert("UnaryLike", node2, opts);
    }
    function assertPattern(node2, opts) {
      assert("Pattern", node2, opts);
    }
    function assertClass(node2, opts) {
      assert("Class", node2, opts);
    }
    function assertImportOrExportDeclaration(node2, opts) {
      assert("ImportOrExportDeclaration", node2, opts);
    }
    function assertExportDeclaration(node2, opts) {
      assert("ExportDeclaration", node2, opts);
    }
    function assertModuleSpecifier(node2, opts) {
      assert("ModuleSpecifier", node2, opts);
    }
    function assertAccessor(node2, opts) {
      assert("Accessor", node2, opts);
    }
    function assertPrivate(node2, opts) {
      assert("Private", node2, opts);
    }
    function assertFlow(node2, opts) {
      assert("Flow", node2, opts);
    }
    function assertFlowType(node2, opts) {
      assert("FlowType", node2, opts);
    }
    function assertFlowBaseAnnotation(node2, opts) {
      assert("FlowBaseAnnotation", node2, opts);
    }
    function assertFlowDeclaration(node2, opts) {
      assert("FlowDeclaration", node2, opts);
    }
    function assertFlowPredicate(node2, opts) {
      assert("FlowPredicate", node2, opts);
    }
    function assertEnumBody(node2, opts) {
      assert("EnumBody", node2, opts);
    }
    function assertEnumMember(node2, opts) {
      assert("EnumMember", node2, opts);
    }
    function assertJSX(node2, opts) {
      assert("JSX", node2, opts);
    }
    function assertMiscellaneous(node2, opts) {
      assert("Miscellaneous", node2, opts);
    }
    function assertTypeScript(node2, opts) {
      assert("TypeScript", node2, opts);
    }
    function assertTSTypeElement(node2, opts) {
      assert("TSTypeElement", node2, opts);
    }
    function assertTSType(node2, opts) {
      assert("TSType", node2, opts);
    }
    function assertTSBaseType(node2, opts) {
      assert("TSBaseType", node2, opts);
    }
    function assertNumberLiteral(node2, opts) {
      deprecationWarning("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node2, opts);
    }
    function assertRegexLiteral(node2, opts) {
      deprecationWarning("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node2, opts);
    }
    function assertRestProperty(node2, opts) {
      deprecationWarning("assertRestProperty", "assertRestElement");
      assert("RestProperty", node2, opts);
    }
    function assertSpreadProperty(node2, opts) {
      deprecationWarning("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node2, opts);
    }
    function assertModuleDeclaration(node2, opts) {
      deprecationWarning("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node2, opts);
    }
    function createTypeAnnotationBasedOnTypeof(type3) {
      switch (type3) {
        case "string":
          return stringTypeAnnotation();
        case "number":
          return numberTypeAnnotation();
        case "undefined":
          return voidTypeAnnotation();
        case "boolean":
          return booleanTypeAnnotation();
        case "function":
          return genericTypeAnnotation(identifier("Function"));
        case "object":
          return genericTypeAnnotation(identifier("Object"));
        case "symbol":
          return genericTypeAnnotation(identifier("Symbol"));
        case "bigint":
          return anyTypeAnnotation();
      }
      throw new Error("Invalid typeof value: " + type3);
    }
    function getQualifiedName$1(node2) {
      return isIdentifier2(node2) ? node2.name : "".concat(node2.id.name, ".").concat(getQualifiedName$1(node2.qualification));
    }
    function removeTypeDuplicates$1(nodesIn) {
      var nodes2 = Array.from(nodesIn);
      var generics = /* @__PURE__ */ new Map();
      var bases = /* @__PURE__ */ new Map();
      var typeGroups = /* @__PURE__ */ new Set();
      var types22 = [];
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var node2 = nodes2[i2];
        if (!node2)
          continue;
        if (types22.indexOf(node2) >= 0) {
          continue;
        }
        if (isAnyTypeAnnotation(node2)) {
          return [
            node2
          ];
        }
        if (isFlowBaseAnnotation(node2)) {
          bases.set(node2.type, node2);
          continue;
        }
        if (isUnionTypeAnnotation(node2)) {
          if (!typeGroups.has(node2.types)) {
            var _nodes2;
            (_nodes2 = nodes2).push.apply(_nodes2, _to_consumable_array(node2.types));
            typeGroups.add(node2.types);
          }
          continue;
        }
        if (isGenericTypeAnnotation(node2)) {
          var name2 = getQualifiedName$1(node2.id);
          if (generics.has(name2)) {
            var existing = generics.get(name2);
            if (existing.typeParameters) {
              if (node2.typeParameters) {
                var _existing_typeParameters_params;
                (_existing_typeParameters_params = existing.typeParameters.params).push.apply(_existing_typeParameters_params, _to_consumable_array(node2.typeParameters.params));
                existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
              }
            } else {
              existing = node2.typeParameters;
            }
          } else {
            generics.set(name2, node2);
          }
          continue;
        }
        types22.push(node2);
      }
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = bases[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step_value = _sliced_to_array(_step8.value, 2), baseType = _step_value[1];
          types22.push(baseType);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = generics[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var _step_value1 = _sliced_to_array(_step12.value, 2), genericName = _step_value1[1];
          types22.push(genericName);
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      return types22;
    }
    function createFlowUnionType(types22) {
      var flattened = removeTypeDuplicates$1(types22);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return unionTypeAnnotation(flattened);
      }
    }
    function getQualifiedName(node2) {
      return isIdentifier2(node2) ? node2.name : "".concat(node2.right.name, ".").concat(getQualifiedName(node2.left));
    }
    function removeTypeDuplicates(nodesIn) {
      var nodes2 = Array.from(nodesIn);
      var generics = /* @__PURE__ */ new Map();
      var bases = /* @__PURE__ */ new Map();
      var typeGroups = /* @__PURE__ */ new Set();
      var types22 = [];
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var node2 = nodes2[i2];
        if (!node2)
          continue;
        if (types22.indexOf(node2) >= 0) {
          continue;
        }
        if (isTSAnyKeyword(node2)) {
          return [
            node2
          ];
        }
        if (isTSBaseType(node2)) {
          bases.set(node2.type, node2);
          continue;
        }
        if (isTSUnionType(node2)) {
          if (!typeGroups.has(node2.types)) {
            var _nodes2;
            (_nodes2 = nodes2).push.apply(_nodes2, _to_consumable_array(node2.types));
            typeGroups.add(node2.types);
          }
          continue;
        }
        if (isTSTypeReference(node2) && node2.typeParameters) {
          var name2 = getQualifiedName(node2.typeName);
          if (generics.has(name2)) {
            var existing = generics.get(name2);
            if (existing.typeParameters) {
              if (node2.typeParameters) {
                var _existing_typeParameters_params;
                (_existing_typeParameters_params = existing.typeParameters.params).push.apply(_existing_typeParameters_params, _to_consumable_array(node2.typeParameters.params));
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node2.typeParameters;
            }
          } else {
            generics.set(name2, node2);
          }
          continue;
        }
        types22.push(node2);
      }
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = bases[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step_value = _sliced_to_array(_step8.value, 2), baseType = _step_value[1];
          types22.push(baseType);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = generics[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var _step_value1 = _sliced_to_array(_step12.value, 2), genericName = _step_value1[1];
          types22.push(genericName);
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      return types22;
    }
    function createTSUnionType(typeAnnotations) {
      var types22 = typeAnnotations.map(function(type3) {
        return isTSTypeAnnotation(type3) ? type3.typeAnnotation : type3;
      });
      var flattened = removeTypeDuplicates(types22);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return tsUnionType(flattened);
      }
    }
    function buildUndefinedNode() {
      return unaryExpression("void", numericLiteral(0), true);
    }
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map(function(node2) {
          return cloneIfNode(node2, deep, withoutLoc, commentsCache);
        });
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node2) {
      var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, withoutLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return cloneNodeInternal(node2, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node2) {
      var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, withoutLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, commentsCache = arguments.length > 3 ? arguments[3] : void 0;
      if (!node2)
        return node2;
      var type3 = node2.type;
      var newNode = {
        type: node2.type
      };
      if (isIdentifier2(node2)) {
        newNode.name = node2.name;
        if (has(node2, "optional") && typeof node2.optional === "boolean") {
          newNode.optional = node2.optional;
        }
        if (has(node2, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache) : node2.typeAnnotation;
        }
      } else if (!has(NODE_FIELDS, type3)) {
        throw new Error('Unknown node type: "'.concat(type3, '"'));
      } else {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = Object.keys(NODE_FIELDS[type3])[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var field = _step8.value;
            if (has(node2, field)) {
              if (deep) {
                newNode[field] = isFile(node2) && field === "comments" ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache);
              } else {
                newNode[field] = node2[field];
              }
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      if (has(node2, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node2.loc;
        }
      }
      if (has(node2, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node2, "extra")) {
        newNode.extra = Object.assign({}, node2.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map(function(comment2) {
        var cache2 = commentsCache.get(comment2);
        if (cache2)
          return cache2;
        var type3 = comment2.type, value1 = comment2.value, loc = comment2.loc;
        var ret = {
          type: type3,
          value: value1,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment2, ret);
        return ret;
      });
    }
    function clone(node2) {
      return cloneNode(node2, false);
    }
    function cloneDeep2(node2) {
      return cloneNode(node2);
    }
    function cloneDeepWithoutLoc(node2) {
      return cloneNode(node2, true, true);
    }
    function cloneWithoutLoc(node2) {
      return cloneNode(node2, false, true);
    }
    function addComments(node2, type3, comments) {
      if (!comments || !node2)
        return node2;
      var key = "".concat(type3, "Comments");
      if (node2[key]) {
        if (type3 === "leading") {
          node2[key] = comments.concat(node2[key]);
        } else {
          var _node_key;
          (_node_key = node2[key]).push.apply(_node_key, _to_consumable_array(comments));
        }
      } else {
        node2[key] = comments;
      }
      return node2;
    }
    function addComment(node2, type3, content3, line) {
      return addComments(node2, type3, [
        {
          type: line ? "CommentLine" : "CommentBlock",
          value: content3
        }
      ]);
    }
    function inherit2(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
    function inheritInnerComments(child, parent) {
      inherit2("innerComments", child, parent);
    }
    function inheritLeadingComments(child, parent) {
      inherit2("leadingComments", child, parent);
    }
    function inheritTrailingComments(child, parent) {
      inherit2("trailingComments", child, parent);
    }
    function inheritsComments(child, parent) {
      inheritTrailingComments(child, parent);
      inheritLeadingComments(child, parent);
      inheritInnerComments(child, parent);
      return child;
    }
    function removeComments(node2) {
      COMMENT_KEYS.forEach(function(key) {
        node2[key] = null;
      });
      return node2;
    }
    var STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS["Standardized"];
    var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
    var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS["Accessor"];
    var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
    var FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
    var MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS["Miscellaneous"];
    var TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS["TypeScript"];
    var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS["TSBaseType"];
    var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    function toBlock(node2, parent) {
      if (isBlockStatement(node2)) {
        return node2;
      }
      var blockNodes = [];
      if (isEmptyStatement(node2)) {
        blockNodes = [];
      } else {
        if (!isStatement(node2)) {
          if (isFunction(parent)) {
            node2 = returnStatement(node2);
          } else {
            node2 = expressionStatement(node2);
          }
        }
        blockNodes = [
          node2
        ];
      }
      return blockStatement(blockNodes);
    }
    function ensureBlock(node2) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body";
      var result = toBlock(node2[key], node2);
      node2[key] = result;
      return result;
    }
    function toIdentifier2(input) {
      input = input + "";
      var name2 = "";
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = input[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var c2 = _step8.value;
          name2 += isIdentifierChar2(c2.codePointAt(0)) ? c2 : "-";
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      name2 = name2.replace(/^[-0-9]+/, "");
      name2 = name2.replace(/[-\s]+(.)?/g, function(match, c3) {
        return c3 ? c3.toUpperCase() : "";
      });
      if (!isValidIdentifier(name2)) {
        name2 = "_".concat(name2);
      }
      return name2 || "_";
    }
    function toBindingIdentifierName(name2) {
      name2 = toIdentifier2(name2);
      if (name2 === "eval" || name2 === "arguments")
        name2 = "_" + name2;
      return name2;
    }
    function toComputedKey(node2) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node2.key || node2.property;
      if (!node2.computed && isIdentifier2(key))
        key = stringLiteral(key.name);
      return key;
    }
    function toExpression(node2) {
      if (isExpressionStatement2(node2)) {
        node2 = node2.expression;
      }
      if (isExpression(node2)) {
        return node2;
      }
      if (isClass(node2)) {
        node2.type = "ClassExpression";
      } else if (isFunction(node2)) {
        node2.type = "FunctionExpression";
      }
      if (!isExpression(node2)) {
        throw new Error("cannot turn ".concat(node2.type, " to an expression"));
      }
      return node2;
    }
    function traverseFast(node2, enter, opts) {
      if (!node2)
        return;
      var keys2 = VISITOR_KEYS[node2.type];
      if (!keys2)
        return;
      opts = opts || {};
      enter(node2, opts);
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          var subNode = node2[key];
          if (Array.isArray(subNode)) {
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = subNode[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var node22 = _step12.value;
                traverseFast(node22, enter, opts);
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          } else {
            traverseFast(subNode, enter, opts);
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    var CLEAR_KEYS = [
      "tokens",
      "start",
      "end",
      "loc",
      "raw",
      "rawValue"
    ];
    var CLEAR_KEYS_PLUS_COMMENTS = _to_consumable_array(COMMENT_KEYS).concat([
      "comments"
    ], _to_consumable_array(CLEAR_KEYS));
    function removeProperties(node2) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = map[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          if (node2[key] != null)
            node2[key] = void 0;
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = Object.keys(node2)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var key1 = _step12.value;
          if (key1[0] === "_" && node2[key1] != null)
            node2[key1] = void 0;
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      var symbols = Object.getOwnPropertySymbols(node2);
      var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
      try {
        for (var _iterator22 = symbols[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var sym = _step22.value;
          node2[sym] = null;
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
            _iterator22.return();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }
    }
    function removePropertiesDeep(tree, opts) {
      traverseFast(tree, removeProperties, opts);
      return tree;
    }
    function toKeyAlias(node2) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node2.key;
      var alias2;
      if (node2.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if (isIdentifier2(key)) {
        alias2 = key.name;
      } else if (isStringLiteral2(key)) {
        alias2 = JSON.stringify(key.value);
      } else {
        alias2 = JSON.stringify(removePropertiesDeep(cloneNode(key)));
      }
      if (node2.computed) {
        alias2 = "[".concat(alias2, "]");
      }
      if (node2.static) {
        alias2 = "static:".concat(alias2);
      }
      return alias2;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
    function toStatement(node2, ignore3) {
      if (isStatement(node2)) {
        return node2;
      }
      var mustHaveId = false;
      var newType;
      if (isClass(node2)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if (isFunction(node2)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if (isAssignmentExpression(node2)) {
        return expressionStatement(node2);
      }
      if (mustHaveId && !node2.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore3) {
          return false;
        } else {
          throw new Error("cannot turn ".concat(node2.type, " to a statement"));
        }
      }
      node2.type = newType;
      return node2;
    }
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value1) {
      return objectToString(value1) === "[object RegExp]";
    }
    function isPlainObject2(value1) {
      if (typeof value1 !== "object" || value1 === null || Object.prototype.toString.call(value1) !== "[object Object]") {
        return false;
      }
      var proto3 = Object.getPrototypeOf(value1);
      return proto3 === null || Object.getPrototypeOf(proto3) === null;
    }
    function valueToNode(value1) {
      if (value1 === void 0) {
        return identifier("undefined");
      }
      if (value1 === true || value1 === false) {
        return booleanLiteral(value1);
      }
      if (value1 === null) {
        return nullLiteral();
      }
      if (typeof value1 === "string") {
        return stringLiteral(value1);
      }
      if (typeof value1 === "number") {
        var result;
        if (Number.isFinite(value1)) {
          result = numericLiteral(Math.abs(value1));
        } else {
          var numerator;
          if (Number.isNaN(value1)) {
            numerator = numericLiteral(0);
          } else {
            numerator = numericLiteral(1);
          }
          result = binaryExpression("/", numerator, numericLiteral(0));
        }
        if (value1 < 0 || Object.is(value1, -0)) {
          result = unaryExpression("-", result);
        }
        return result;
      }
      if (isRegExp(value1)) {
        var pattern = value1.source;
        var flags = value1.toString().match(/\/([a-z]+|)$/)[1];
        return regExpLiteral(pattern, flags);
      }
      if (Array.isArray(value1)) {
        return arrayExpression(value1.map(valueToNode));
      }
      if (isPlainObject2(value1)) {
        var props = [];
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = Object.keys(value1)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var key = _step8.value;
            var nodeKey = void 0;
            if (isValidIdentifier(key)) {
              nodeKey = identifier(key);
            } else {
              nodeKey = stringLiteral(key);
            }
            props.push(objectProperty(nodeKey, valueToNode(value1[key])));
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return objectExpression(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
    function appendToMemberExpression(member, append) {
      var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      member.object = memberExpression(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = INHERIT_KEYS.optional[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          if (child[key] == null) {
            child[key] = parent[key];
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = Object.keys(parent)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var key1 = _step12.value;
          if (key1[0] === "_" && key1 !== "__clone") {
            child[key1] = parent[key1];
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
      try {
        for (var _iterator22 = INHERIT_KEYS.force[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var key2 = _step22.value;
          child[key2] = parent[key2];
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
            _iterator22.return();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }
      inheritsComments(child, parent);
      return child;
    }
    function prependToMemberExpression(member, prepend) {
      if (isSuper(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = memberExpression(prepend, member.object);
      return member;
    }
    function getBindingIdentifiers(node2, duplicates, outerOnly, newBindingsOnly) {
      var search2 = [].concat(node2);
      var ids = /* @__PURE__ */ Object.create(null);
      while (search2.length) {
        var id = search2.shift();
        if (!id)
          continue;
        if (newBindingsOnly && (isAssignmentExpression(id) || isUnaryExpression(id))) {
          continue;
        }
        var keys2 = getBindingIdentifiers.keys[id.type];
        if (isIdentifier2(id)) {
          if (duplicates) {
            var _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {
          if (isDeclaration2(id.declaration)) {
            search2.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (isFunctionDeclaration(id)) {
            search2.push(id.id);
            continue;
          }
          if (isFunctionExpression(id)) {
            continue;
          }
        }
        if (keys2) {
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var key = keys2[i2];
            var nodes2 = id[key];
            if (nodes2) {
              var _search;
              Array.isArray(nodes2) ? (_search = search2).push.apply(_search, _to_consumable_array(nodes2)) : search2.push(nodes2);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: [
        "id"
      ],
      DeclareFunction: [
        "id"
      ],
      DeclareModule: [
        "id"
      ],
      DeclareVariable: [
        "id"
      ],
      DeclareInterface: [
        "id"
      ],
      DeclareTypeAlias: [
        "id"
      ],
      DeclareOpaqueType: [
        "id"
      ],
      InterfaceDeclaration: [
        "id"
      ],
      TypeAlias: [
        "id"
      ],
      OpaqueType: [
        "id"
      ],
      CatchClause: [
        "param"
      ],
      LabeledStatement: [
        "label"
      ],
      UnaryExpression: [
        "argument"
      ],
      AssignmentExpression: [
        "left"
      ],
      ImportSpecifier: [
        "local"
      ],
      ImportNamespaceSpecifier: [
        "local"
      ],
      ImportDefaultSpecifier: [
        "local"
      ],
      ImportDeclaration: [
        "specifiers"
      ],
      ExportSpecifier: [
        "exported"
      ],
      ExportNamespaceSpecifier: [
        "exported"
      ],
      ExportDefaultSpecifier: [
        "exported"
      ],
      FunctionDeclaration: [
        "id",
        "params"
      ],
      FunctionExpression: [
        "id",
        "params"
      ],
      ArrowFunctionExpression: [
        "params"
      ],
      ObjectMethod: [
        "params"
      ],
      ClassMethod: [
        "params"
      ],
      ClassPrivateMethod: [
        "params"
      ],
      ForInStatement: [
        "left"
      ],
      ForOfStatement: [
        "left"
      ],
      ClassDeclaration: [
        "id"
      ],
      ClassExpression: [
        "id"
      ],
      RestElement: [
        "argument"
      ],
      UpdateExpression: [
        "argument"
      ],
      ObjectProperty: [
        "value"
      ],
      AssignmentPattern: [
        "left"
      ],
      ArrayPattern: [
        "elements"
      ],
      ObjectPattern: [
        "properties"
      ],
      VariableDeclaration: [
        "declarations"
      ],
      VariableDeclarator: [
        "id"
      ]
    };
    function getOuterBindingIdentifiers(node2, duplicates) {
      return getBindingIdentifiers(node2, duplicates, true);
    }
    function traverse(node2, handlers3, state) {
      if (typeof handlers3 === "function") {
        handlers3 = {
          enter: handlers3
        };
      }
      var enter = handlers3.enter, exit2 = handlers3.exit;
      traverseSimpleImpl(node2, enter, exit2, state, []);
    }
    function traverseSimpleImpl(node2, enter, exit2, state, ancestors) {
      var keys2 = VISITOR_KEYS[node2.type];
      if (!keys2)
        return;
      if (enter)
        enter(node2, ancestors, state);
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          var subNode = node2[key];
          if (Array.isArray(subNode)) {
            for (var i2 = 0; i2 < subNode.length; i2++) {
              var child = subNode[i2];
              if (!child)
                continue;
              ancestors.push({
                node: node2,
                key,
                index: i2
              });
              traverseSimpleImpl(child, enter, exit2, state, ancestors);
              ancestors.pop();
            }
          } else if (subNode) {
            ancestors.push({
              node: node2,
              key
            });
            traverseSimpleImpl(subNode, enter, exit2, state, ancestors);
            ancestors.pop();
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      if (exit2)
        exit2(node2, ancestors, state);
    }
    function isBinding(node2, parent, grandparent) {
      if (grandparent && node2.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      var keys2 = getBindingIdentifiers.keys[parent.type];
      if (keys2) {
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node2) >= 0)
              return true;
          } else {
            if (val === node2)
              return true;
          }
        }
      }
      return false;
    }
    function isLet(node2) {
      return isVariableDeclaration(node2) && (node2.kind !== "var" || node2[BLOCK_SCOPED_SYMBOL]);
    }
    function isBlockScoped(node2) {
      return isFunctionDeclaration(node2) || isClassDeclaration(node2) || isLet(node2);
    }
    function isImmutable(node2) {
      if (isType(node2.type, "Immutable"))
        return true;
      if (isIdentifier2(node2)) {
        if (node2.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
      var visitorKeys = VISITOR_KEYS[a.type];
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = fields[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var field = _step8.value;
          var val_a = a[field];
          var val_b = b[field];
          if ((typeof val_a === "undefined" ? "undefined" : _type_of(val_a)) !== (typeof val_b === "undefined" ? "undefined" : _type_of(val_b))) {
            return false;
          }
          if (val_a == null && val_b == null) {
            continue;
          } else if (val_a == null || val_b == null) {
            return false;
          }
          if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) {
              return false;
            }
            if (val_a.length !== val_b.length) {
              return false;
            }
            for (var i2 = 0; i2 < val_a.length; i2++) {
              if (!isNodesEquivalent(val_a[i2], val_b[i2])) {
                return false;
              }
            }
            continue;
          }
          if (typeof val_a === "object" && !(visitorKeys === null || visitorKeys === void 0 ? void 0 : visitorKeys.includes(field))) {
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = Object.keys(val_a)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var key = _step12.value;
                if (val_a[key] !== val_b[key]) {
                  return false;
                }
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
            continue;
          }
          if (!isNodesEquivalent(val_a, val_b)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return true;
    }
    function isReferenced(node2, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node2) {
            return !!parent.computed;
          }
          return parent.object === node2;
        case "JSXMemberExpression":
          return parent.object === node2;
        case "VariableDeclarator":
          return parent.init === node2;
        case "ArrowFunctionExpression":
          return parent.body === node2;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node2;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node2;
        case "AssignmentExpression":
          return parent.right === node2;
        case "AssignmentPattern":
          return parent.right === node2;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent === null || grandparent === void 0 ? void 0 : grandparent.source) {
            return false;
          }
          return parent.local === node2;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node2;
        case "TSEnumMember":
          return parent.id !== node2;
        case "TSPropertySignature":
          if (parent.key === node2) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
    function isScope(node2, parent) {
      if (isBlockStatement(node2) && (isFunction(parent) || isCatchClause(parent))) {
        return false;
      }
      if (isPattern(node2) && (isFunction(parent) || isCatchClause(parent))) {
        return true;
      }
      return isScopable(node2);
    }
    function isSpecifierDefault(specifier) {
      return isImportDefaultSpecifier(specifier) || isIdentifier2(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set([
      "abstract",
      "boolean",
      "byte",
      "char",
      "double",
      "enum",
      "final",
      "float",
      "goto",
      "implements",
      "int",
      "interface",
      "long",
      "native",
      "package",
      "private",
      "protected",
      "public",
      "short",
      "static",
      "synchronized",
      "throws",
      "transient",
      "volatile"
    ]);
    function isValidES3Identifier(name2) {
      return isValidIdentifier(name2) && !RESERVED_WORDS_ES3_ONLY.has(name2);
    }
    function isVar(node2) {
      return isVariableDeclaration(node2, {
        kind: "var"
      }) && !node2[BLOCK_SCOPED_SYMBOL];
    }
    var react = {
      isReactComponent,
      isCompatTag,
      buildChildren
    };
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Position3 = function Position4(line, col, index3) {
      "use strict";
      _class_call_check(this, Position4);
      __publicField(this, "line");
      __publicField(this, "column");
      __publicField(this, "index");
      this.line = line;
      this.column = col;
      this.index = index3;
    };
    var SourceLocation3 = function SourceLocation4(start2, end) {
      "use strict";
      _class_call_check(this, SourceLocation4);
      __publicField(this, "start");
      __publicField(this, "end");
      __publicField(this, "filename");
      __publicField(this, "identifierName");
      this.start = start2;
      this.end = end;
    };
    function createPositionWithColumnOffset(position3, columnOffset) {
      var line = position3.line, column = position3.column, index3 = position3.index;
      return new Position3(line, column + columnOffset, index3 + columnOffset);
    }
    var code2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: code2
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: code2
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = function(param) {
      var type3 = param.type, prefix2 = param.prefix;
      return type3 === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type3];
    };
    var StandardErrors = {
      AccessorIsGenerator: function(param) {
        var kind = param.kind;
        return "A ".concat(kind, "ter cannot be a generator.");
      },
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: function(param) {
        var kind = param.kind;
        return "Missing initializer in ".concat(kind, " declaration.");
      },
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: function(param) {
        var exportName = param.exportName;
        return "`".concat(exportName, "` has already been exported. Exported identifiers must be unique.");
      },
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: function(param) {
        var phase = param.phase;
        return "'import.".concat(phase, "(...)' can only be parsed when using the 'createImportExpressions' option.");
      },
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: function(param) {
        var localName = param.localName, exportName = param.exportName;
        return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(localName, "' as '").concat(exportName, "' } from 'some-module'`?");
      },
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: function(param) {
        var type3 = param.type;
        return "'".concat(type3 === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
      },
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: function(param) {
        var type3 = param.type;
        return "Unsyntactic ".concat(type3 === "BreakStatement" ? "break" : "continue", ".");
      },
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
      ImportBindingIsString: function(param) {
        var importName = param.importName;
        return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(importName, '" as foo }`?');
      },
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: function(param) {
        var maxArgumentCount = param.maxArgumentCount;
        return "`import()` requires exactly ".concat(maxArgumentCount === 1 ? "one argument" : "one or two arguments", ".");
      },
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: function(param) {
        var radix = param.radix;
        return "Expected number in radix ".concat(radix, ".");
      },
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: function(param) {
        var reservedWord = param.reservedWord;
        return "Escape sequence in keyword ".concat(reservedWord, ".");
      },
      InvalidIdentifier: function(param) {
        var identifierName = param.identifierName;
        return "Invalid identifier ".concat(identifierName, ".");
      },
      InvalidLhs: function(param) {
        var ancestor = param.ancestor;
        return "Invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
      },
      InvalidLhsBinding: function(param) {
        var ancestor = param.ancestor;
        return "Binding invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
      },
      InvalidLhsOptionalChaining: function(param) {
        var ancestor = param.ancestor;
        return "Invalid optional chaining in the left-hand side of ".concat(toNodeDescription(ancestor), ".");
      },
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: function(param) {
        var unexpected = param.unexpected;
        return "Unexpected character '".concat(unexpected, "'.");
      },
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: function(param) {
        var identifierName = param.identifierName;
        return "Private name #".concat(identifierName, " is not defined.");
      },
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: function(param) {
        var labelName = param.labelName;
        return "Label '".concat(labelName, "' is already declared.");
      },
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: function(param) {
        var missingPlugin = param.missingPlugin;
        return "This experimental syntax requires enabling the parser plugin: ".concat(missingPlugin.map(function(name2) {
          return JSON.stringify(name2);
        }).join(", "), ".");
      },
      MissingOneOfPlugins: function(param) {
        var missingPlugin = param.missingPlugin;
        return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(missingPlugin.map(function(name2) {
          return JSON.stringify(name2);
        }).join(", "), ".");
      },
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: function(param) {
        var key = param.key;
        return 'Duplicate key "'.concat(key, '" is not allowed in module attributes.');
      },
      ModuleExportNameHasLoneSurrogate: function(param) {
        var surrogateCharCode = param.surrogateCharCode;
        return "An export name cannot include a lone surrogate, found '\\u".concat(surrogateCharCode.toString(16), "'.");
      },
      ModuleExportUndefined: function(param) {
        var localName = param.localName;
        return "Export '".concat(localName, "' is not defined.");
      },
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: function(param) {
        var identifierName = param.identifierName;
        return "Private names are only allowed in property accesses (`obj.#".concat(identifierName, "`) or in `in` expressions (`#").concat(identifierName, " in obj`).");
      },
      PrivateNameRedeclaration: function(param) {
        var identifierName = param.identifierName;
        return "Duplicate private name #".concat(identifierName, ".");
      },
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: function(param) {
        var keyword = param.keyword;
        return "Unexpected keyword '".concat(keyword, "'.");
      },
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: function(param) {
        var reservedWord = param.reservedWord;
        return "Unexpected reserved word '".concat(reservedWord, "'.");
      },
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: function(param) {
        var expected = param.expected, unexpected = param.unexpected;
        return "Unexpected token".concat(unexpected ? " '".concat(unexpected, "'.") : "").concat(expected ? ', expected "'.concat(expected, '"') : "");
      },
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: function(param) {
        var target = param.target, onlyValidPropertyName = param.onlyValidPropertyName;
        return "The only valid meta property for ".concat(target, " is ").concat(target, ".").concat(onlyValidPropertyName, ".");
      },
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: function(param) {
        var identifierName = param.identifierName;
        return "Identifier '".concat(identifierName, "' has already been declared.");
      },
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: function(param) {
        var referenceName = param.referenceName;
        return "Assigning to '".concat(referenceName, "' in strict mode.");
      },
      StrictEvalArgumentsBinding: function(param) {
        var bindingName = param.bindingName;
        return "Binding '".concat(bindingName, "' in strict mode.");
      },
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([
      "ArrowFunctionExpression",
      "AssignmentExpression",
      "ConditionalExpression",
      "YieldExpression"
    ]);
    var PipelineOperatorErrors = {
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: function(param) {
        var token = param.token;
        return "Invalid topic token ".concat(token, ". In order to use ").concat(token, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(token, '" }.');
      },
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: function(param) {
        var type3 = param.type;
        return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({
          type: type3
        }), "; please wrap it in parentheses.");
      },
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    };
    var _excluded$1 = [
      "toMessage"
    ];
    var _excluded2$1 = [
      "message"
    ];
    function defineHidden(obj, key, value1) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value: value1
      });
    }
    function toParseErrorConstructor(_ref) {
      var toMessage = _ref.toMessage, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
      return function constructor(param) {
        var loc = param.loc, details = param.details;
        var error = new SyntaxError();
        Object.assign(error, properties, {
          loc,
          pos: loc.index
        });
        if ("missingPlugin" in details) {
          Object.assign(error, {
            missingPlugin: details.missingPlugin
          });
        }
        defineHidden(error, "clone", function clone3() {
          var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _overrides_loc;
          var _$_ref = (_overrides_loc = overrides.loc) !== null && _overrides_loc !== void 0 ? _overrides_loc : loc, line = _$_ref.line, column = _$_ref.column, index3 = _$_ref.index;
          return constructor({
            loc: new Position3(line, column, index3),
            details: Object.assign({}, details, overrides.details)
          });
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get: function get3() {
            var message = "".concat(toMessage(details), " (").concat(loc.line, ":").concat(loc.column, ")");
            this.message = message;
            return message;
          },
          set: function set(value1) {
            Object.defineProperty(this, "message", {
              value: value1,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return function(parseErrorTemplates) {
          return ParseErrorEnum(parseErrorTemplates, argument[0]);
        };
      }
      var ParseErrorConstructors = {};
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        var _loop5 = function() {
          var reasonCode = _step8.value;
          var _$template = argument[reasonCode];
          var _ref2 = typeof _$template === "string" ? {
            message: function() {
              return _$template;
            }
          } : typeof _$template === "function" ? {
            message: _$template
          } : _$template, message = _ref2.message, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          var toMessage = typeof message === "string" ? function() {
            return message;
          } : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: "BABEL_PARSER_SYNTAX_ERROR",
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        };
        for (var _iterator8 = Object.keys(argument)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true)
          _loop5();
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(_templateObject())(PipelineOperatorErrors));
    var defineProperty = Object.defineProperty;
    var toUnenumerable = function(object, key) {
      return defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
    };
    function toESTreeLocation(node2) {
      node2.loc.start && toUnenumerable(node2.loc.start, "index");
      node2.loc.end && toUnenumerable(node2.loc.end, "index");
      return node2;
    }
    var estree = function(superClass) {
      var ESTreeParserMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(ESTreeParserMixin2, superClass2);
        var _super3 = _create_super(ESTreeParserMixin2);
        function ESTreeParserMixin2() {
          _class_call_check(this, ESTreeParserMixin2);
          return _super3.apply(this, arguments);
        }
        _create_class(ESTreeParserMixin2, [
          {
            key: "parse",
            value: function parse5() {
              var file2 = toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin2.prototype), "parse", this).call(this));
              if (this.options.tokens) {
                file2.tokens = file2.tokens.map(toESTreeLocation);
              }
              return file2;
            }
          },
          {
            key: "parseRegExpLiteral",
            value: function parseRegExpLiteral(param) {
              var pattern = param.pattern, flags = param.flags;
              var regex2 = null;
              try {
                regex2 = new RegExp(pattern, flags);
              } catch (e) {
              }
              var node2 = this.estreeParseLiteral(regex2);
              node2.regex = {
                pattern,
                flags
              };
              return node2;
            }
          },
          {
            key: "parseBigIntLiteral",
            value: function parseBigIntLiteral(value1) {
              var bigInt;
              try {
                bigInt = BigInt(value1);
              } catch (e) {
                bigInt = null;
              }
              var node2 = this.estreeParseLiteral(bigInt);
              node2.bigint = String(node2.value || value1);
              return node2;
            }
          },
          {
            key: "parseDecimalLiteral",
            value: function parseDecimalLiteral(value1) {
              var decimal = null;
              var node2 = this.estreeParseLiteral(decimal);
              node2.decimal = String(node2.value || value1);
              return node2;
            }
          },
          {
            key: "estreeParseLiteral",
            value: function estreeParseLiteral(value1) {
              return this.parseLiteral(value1, "Literal");
            }
          },
          {
            key: "parseStringLiteral",
            value: function parseStringLiteral(value1) {
              return this.estreeParseLiteral(value1);
            }
          },
          {
            key: "parseNumericLiteral",
            value: function parseNumericLiteral(value1) {
              return this.estreeParseLiteral(value1);
            }
          },
          {
            key: "parseNullLiteral",
            value: function parseNullLiteral() {
              return this.estreeParseLiteral(null);
            }
          },
          {
            key: "parseBooleanLiteral",
            value: function parseBooleanLiteral(value1) {
              return this.estreeParseLiteral(value1);
            }
          },
          {
            key: "directiveToStmt",
            value: function directiveToStmt(directive2) {
              var expression2 = directive2.value;
              delete directive2.value;
              expression2.type = "Literal";
              expression2.raw = expression2.extra.raw;
              expression2.value = expression2.extra.expressionValue;
              var stmt = directive2;
              stmt.type = "ExpressionStatement";
              stmt.expression = expression2;
              stmt.directive = expression2.extra.rawValue;
              delete expression2.extra;
              return stmt;
            }
          },
          {
            key: "initFunction",
            value: function initFunction(node2, isAsync) {
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "initFunction", this).call(this, node2, isAsync);
              node2.expression = false;
            }
          },
          {
            key: "checkDeclaration",
            value: function checkDeclaration(node2) {
              if (node2 != null && this.isObjectProperty(node2)) {
                this.checkDeclaration(node2.value);
              } else {
                _get(_get_prototype_of(ESTreeParserMixin2.prototype), "checkDeclaration", this).call(this, node2);
              }
            }
          },
          {
            key: "getObjectOrClassMethodParams",
            value: function getObjectOrClassMethodParams(method) {
              return method.value.params;
            }
          },
          {
            key: "isValidDirective",
            value: function isValidDirective(stmt) {
              var _stmt_expression_extra;
              return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt_expression_extra = stmt.expression.extra) === null || _stmt_expression_extra === void 0 ? void 0 : _stmt_expression_extra.parenthesized);
            }
          },
          {
            key: "parseBlockBody",
            value: function parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
              var _this = this;
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseBlockBody", this).call(this, node2, allowDirectives, topLevel, end, afterBlockParse);
              var directiveStatements = node2.directives.map(function(d) {
                return _this.directiveToStmt(d);
              });
              node2.body = directiveStatements.concat(node2.body);
              delete node2.directives;
            }
          },
          {
            key: "pushClassMethod",
            value: function pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
              if (method.typeParameters) {
                method.value.typeParameters = method.typeParameters;
                delete method.typeParameters;
              }
              classBody2.body.push(method);
            }
          },
          {
            key: "parsePrivateName",
            value: function parsePrivateName() {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parsePrivateName", this).call(this);
              return this.convertPrivateNameToPrivateIdentifier(node2);
            }
          },
          {
            key: "convertPrivateNameToPrivateIdentifier",
            value: function convertPrivateNameToPrivateIdentifier(node2) {
              var name2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "getPrivateNameSV", this).call(this, node2);
              node2 = node2;
              delete node2.id;
              node2.name = name2;
              node2.type = "PrivateIdentifier";
              return node2;
            }
          },
          {
            key: "isPrivateName",
            value: function isPrivateName3(node2) {
              return node2.type === "PrivateIdentifier";
            }
          },
          {
            key: "getPrivateNameSV",
            value: function getPrivateNameSV(node2) {
              return node2.name;
            }
          },
          {
            key: "parseLiteral",
            value: function parseLiteral(value1, type3) {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseLiteral", this).call(this, value1, type3);
              node2.raw = node2.extra.raw;
              delete node2.extra;
              return node2;
            }
          },
          {
            key: "parseFunctionBody",
            value: function parseFunctionBody(node2, allowExpression) {
              var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseFunctionBody", this).call(this, node2, allowExpression, isMethod3);
              node2.expression = node2.body.type !== "BlockStatement";
            }
          },
          {
            key: "parseMethod",
            value: function parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type3) {
              var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              var funcNode = this.startNode();
              funcNode.kind = node2.kind;
              funcNode = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type3, inClassScope);
              funcNode.type = "FunctionExpression";
              delete funcNode.kind;
              node2.value = funcNode;
              if (type3 === "ClassPrivateMethod") {
                node2.computed = false;
              }
              return this.finishNode(node2, "MethodDefinition");
            }
          },
          {
            key: "parseClassProperty",
            value: function parseClassProperty() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var _$_get;
              var propertyNode = (_$_get = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseClassProperty", this)).call.apply(_$_get, [
                this
              ].concat(_to_consumable_array(args)));
              propertyNode.type = "PropertyDefinition";
              return propertyNode;
            }
          },
          {
            key: "parseClassPrivateProperty",
            value: function parseClassPrivateProperty() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var _$_get;
              var propertyNode = (_$_get = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseClassPrivateProperty", this)).call.apply(_$_get, [
                this
              ].concat(_to_consumable_array(args)));
              propertyNode.type = "PropertyDefinition";
              propertyNode.computed = false;
              return propertyNode;
            }
          },
          {
            key: "parseObjectMethod",
            value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern2, isAccessor2);
              if (node2) {
                node2.type = "Property";
                if (node2.kind === "method") {
                  node2.kind = "init";
                }
                node2.shorthand = false;
              }
              return node2;
            }
          },
          {
            key: "parseObjectProperty",
            value: function parseObjectProperty(prop, startLoc, isPattern2, refExpressionErrors) {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseObjectProperty", this).call(this, prop, startLoc, isPattern2, refExpressionErrors);
              if (node2) {
                node2.kind = "init";
                node2.type = "Property";
              }
              return node2;
            }
          },
          {
            key: "isValidLVal",
            value: function isValidLVal(type3, isUnparenthesizedInAssign, binding) {
              return type3 === "Property" ? "value" : _get(_get_prototype_of(ESTreeParserMixin2.prototype), "isValidLVal", this).call(this, type3, isUnparenthesizedInAssign, binding);
            }
          },
          {
            key: "isAssignable",
            value: function isAssignable(node2, isBinding3) {
              if (node2 != null && this.isObjectProperty(node2)) {
                return this.isAssignable(node2.value, isBinding3);
              }
              return _get(_get_prototype_of(ESTreeParserMixin2.prototype), "isAssignable", this).call(this, node2, isBinding3);
            }
          },
          {
            key: "toAssignable",
            value: function toAssignable(node2) {
              var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (node2 != null && this.isObjectProperty(node2)) {
                var key = node2.key, value1 = node2.value;
                if (this.isPrivateName(key)) {
                  this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                }
                this.toAssignable(value1, isLHS);
              } else {
                _get(_get_prototype_of(ESTreeParserMixin2.prototype), "toAssignable", this).call(this, node2, isLHS);
              }
            }
          },
          {
            key: "toAssignableObjectExpressionProp",
            value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
              if (prop.kind === "get" || prop.kind === "set") {
                this.raise(Errors.PatternHasAccessor, {
                  at: prop.key
                });
              } else if (prop.method) {
                this.raise(Errors.PatternHasMethod, {
                  at: prop.key
                });
              } else {
                _get(_get_prototype_of(ESTreeParserMixin2.prototype), "toAssignableObjectExpressionProp", this).call(this, prop, isLast, isLHS);
              }
            }
          },
          {
            key: "finishCallExpression",
            value: function finishCallExpression(unfinished, optional) {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "finishCallExpression", this).call(this, unfinished, optional);
              if (node2.callee.type === "Import") {
                node2.type = "ImportExpression";
                node2.source = node2.arguments[0];
                if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                  var _node_arguments_;
                  node2.options = (_node_arguments_ = node2.arguments[1]) !== null && _node_arguments_ !== void 0 ? _node_arguments_ : null;
                  var _node_arguments_1;
                  node2.attributes = (_node_arguments_1 = node2.arguments[1]) !== null && _node_arguments_1 !== void 0 ? _node_arguments_1 : null;
                }
                delete node2.arguments;
                delete node2.callee;
              }
              return node2;
            }
          },
          {
            key: "toReferencedArguments",
            value: function toReferencedArguments(node2) {
              if (node2.type === "ImportExpression") {
                return;
              }
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "toReferencedArguments", this).call(this, node2);
            }
          },
          {
            key: "parseExport",
            value: function parseExport(unfinished, decorators) {
              var exportStartLoc = this.state.lastTokStartLoc;
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseExport", this).call(this, unfinished, decorators);
              switch (node2.type) {
                case "ExportAllDeclaration":
                  node2.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
                    node2.type = "ExportAllDeclaration";
                    node2.exported = node2.specifiers[0].exported;
                    delete node2.specifiers;
                  }
                case "ExportDefaultDeclaration":
                  {
                    var _declaration_decorators;
                    var declaration = node2.declaration;
                    if ((declaration === null || declaration === void 0 ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration_decorators = declaration.decorators) === null || _declaration_decorators === void 0 ? void 0 : _declaration_decorators.length) > 0 && declaration.start === node2.start) {
                      this.resetStartLocation(node2, exportStartLoc);
                    }
                  }
                  break;
              }
              return node2;
            }
          },
          {
            key: "parseSubscript",
            value: function parseSubscript(base, startLoc, noCalls, state) {
              var node2 = _get(_get_prototype_of(ESTreeParserMixin2.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
              if (state.optionalChainMember) {
                if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
                  node2.type = node2.type.substring(8);
                }
                if (state.stop) {
                  var chain2 = this.startNodeAtNode(node2);
                  chain2.expression = node2;
                  return this.finishNode(chain2, "ChainExpression");
                }
              } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
                node2.optional = false;
              }
              return node2;
            }
          },
          {
            key: "isOptionalMemberExpression",
            value: function isOptionalMemberExpression3(node2) {
              if (node2.type === "ChainExpression") {
                return node2.expression.type === "MemberExpression";
              }
              return _get(_get_prototype_of(ESTreeParserMixin2.prototype), "isOptionalMemberExpression", this).call(this, node2);
            }
          },
          {
            key: "hasPropertyAsPrivateName",
            value: function hasPropertyAsPrivateName(node2) {
              if (node2.type === "ChainExpression") {
                node2 = node2.expression;
              }
              return _get(_get_prototype_of(ESTreeParserMixin2.prototype), "hasPropertyAsPrivateName", this).call(this, node2);
            }
          },
          {
            key: "isObjectProperty",
            value: function isObjectProperty4(node2) {
              return node2.type === "Property" && node2.kind === "init" && !node2.method;
            }
          },
          {
            key: "isObjectMethod",
            value: function isObjectMethod3(node2) {
              return node2.method || node2.kind === "get" || node2.kind === "set";
            }
          },
          {
            key: "finishNodeAt",
            value: function finishNodeAt2(node2, type3, endLoc) {
              return toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin2.prototype), "finishNodeAt", this).call(this, node2, type3, endLoc));
            }
          },
          {
            key: "resetStartLocation",
            value: function resetStartLocation(node2, startLoc) {
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "resetStartLocation", this).call(this, node2, startLoc);
              toESTreeLocation(node2);
            }
          },
          {
            key: "resetEndLocation",
            value: function resetEndLocation(node2) {
              var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              _get(_get_prototype_of(ESTreeParserMixin2.prototype), "resetEndLocation", this).call(this, node2, endLoc);
              toESTreeLocation(node2);
            }
          }
        ]);
        return ESTreeParserMixin2;
      }(superClass);
      return ESTreeParserMixin;
    };
    var TokContext3 = function TokContext4(token, preserveSpace) {
      "use strict";
      _class_call_check(this, TokContext4);
      __publicField(this, "token");
      __publicField(this, "preserveSpace");
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    };
    var types2 = {
      brace: new TokContext3("{"),
      j_oTag: new TokContext3("<tag"),
      j_cTag: new TokContext3("</tag"),
      j_expr: new TokContext3("<tag>...</tag>", true)
    };
    var beforeExpr2 = true;
    var startsExpr2 = true;
    var isLoop2 = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = function ExportedTokenType2(label) {
      "use strict";
      var conf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _class_call_check(this, ExportedTokenType2);
      __publicField(this, "label");
      __publicField(this, "keyword");
      __publicField(this, "beforeExpr");
      __publicField(this, "startsExpr");
      __publicField(this, "rightAssociative");
      __publicField(this, "isLoop");
      __publicField(this, "isAssign");
      __publicField(this, "prefix");
      __publicField(this, "postfix");
      __publicField(this, "binop");
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
    };
    var keywords$12 = /* @__PURE__ */ new Map();
    function createKeyword(name2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      options.keyword = name2;
      var token = createToken(name2, options);
      keywords$12.set(name2, token);
      return token;
    }
    function createBinop(name2, binop2) {
      return createToken(name2, {
        beforeExpr: beforeExpr2,
        binop: binop2
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      ++tokenTypeCounter;
      tokenLabels.push(name2);
      var _options_binop;
      tokenBinops.push((_options_binop = options.binop) !== null && _options_binop !== void 0 ? _options_binop : -1);
      var _options_beforeExpr;
      tokenBeforeExprs.push((_options_beforeExpr = options.beforeExpr) !== null && _options_beforeExpr !== void 0 ? _options_beforeExpr : false);
      var _options_startsExpr;
      tokenStartsExprs.push((_options_startsExpr = options.startsExpr) !== null && _options_startsExpr !== void 0 ? _options_startsExpr : false);
      var _options_prefix;
      tokenPrefixes.push((_options_prefix = options.prefix) !== null && _options_prefix !== void 0 ? _options_prefix : false);
      tokenTypes.push(new ExportedTokenType(name2, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      ++tokenTypeCounter;
      keywords$12.set(name2, tokenTypeCounter);
      tokenLabels.push(name2);
      var _options_binop;
      tokenBinops.push((_options_binop = options.binop) !== null && _options_binop !== void 0 ? _options_binop : -1);
      var _options_beforeExpr;
      tokenBeforeExprs.push((_options_beforeExpr = options.beforeExpr) !== null && _options_beforeExpr !== void 0 ? _options_beforeExpr : false);
      var _options_startsExpr;
      tokenStartsExprs.push((_options_startsExpr = options.startsExpr) !== null && _options_startsExpr !== void 0 ? _options_startsExpr : false);
      var _options_prefix;
      tokenPrefixes.push((_options_prefix = options.prefix) !== null && _options_prefix !== void 0 ? _options_prefix : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketHashL: createToken("#[", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketBarL: createToken("[|", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceBarL: createToken("{|", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceHashL: createToken("#{", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr: beforeExpr2
      }),
      semi: createToken(";", {
        beforeExpr: beforeExpr2
      }),
      colon: createToken(":", {
        beforeExpr: beforeExpr2
      }),
      doubleColon: createToken("::", {
        beforeExpr: beforeExpr2
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr: beforeExpr2
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr: beforeExpr2
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr: beforeExpr2
      }),
      backQuote: createToken("`", {
        startsExpr: startsExpr2
      }),
      dollarBraceL: createToken("${", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      templateTail: createToken("...`", {
        startsExpr: startsExpr2
      }),
      templateNonTail: createToken("...${", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr: startsExpr2
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr: startsExpr2
      }),
      bang: createToken("!", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      tilde: createToken("~", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      doubleCaret: createToken("^^", {
        startsExpr: startsExpr2
      }),
      doubleAt: createToken("@@", {
        startsExpr: startsExpr2
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr: beforeExpr2,
        binop: 9,
        prefix,
        startsExpr: startsExpr2
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr: startsExpr2
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr: beforeExpr2,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr: beforeExpr2,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr: beforeExpr2,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr: beforeExpr2
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr: beforeExpr2
      }),
      _else: createKeyword("else", {
        beforeExpr: beforeExpr2
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr: startsExpr2
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr: beforeExpr2
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      _this: createKeyword("this", {
        startsExpr: startsExpr2
      }),
      _super: createKeyword("super", {
        startsExpr: startsExpr2
      }),
      _class: createKeyword("class", {
        startsExpr: startsExpr2
      }),
      _extends: createKeyword("extends", {
        beforeExpr: beforeExpr2
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr: startsExpr2
      }),
      _null: createKeyword("null", {
        startsExpr: startsExpr2
      }),
      _true: createKeyword("true", {
        startsExpr: startsExpr2
      }),
      _false: createKeyword("false", {
        startsExpr: startsExpr2
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _void: createKeyword("void", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _delete: createKeyword("delete", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _do: createKeyword("do", {
        isLoop: isLoop2,
        beforeExpr: beforeExpr2
      }),
      _for: createKeyword("for", {
        isLoop: isLoop2
      }),
      _while: createKeyword("while", {
        isLoop: isLoop2
      }),
      _as: createKeywordLike("as", {
        startsExpr: startsExpr2
      }),
      _assert: createKeywordLike("assert", {
        startsExpr: startsExpr2
      }),
      _async: createKeywordLike("async", {
        startsExpr: startsExpr2
      }),
      _await: createKeywordLike("await", {
        startsExpr: startsExpr2
      }),
      _defer: createKeywordLike("defer", {
        startsExpr: startsExpr2
      }),
      _from: createKeywordLike("from", {
        startsExpr: startsExpr2
      }),
      _get: createKeywordLike("get", {
        startsExpr: startsExpr2
      }),
      _let: createKeywordLike("let", {
        startsExpr: startsExpr2
      }),
      _meta: createKeywordLike("meta", {
        startsExpr: startsExpr2
      }),
      _of: createKeywordLike("of", {
        startsExpr: startsExpr2
      }),
      _sent: createKeywordLike("sent", {
        startsExpr: startsExpr2
      }),
      _set: createKeywordLike("set", {
        startsExpr: startsExpr2
      }),
      _source: createKeywordLike("source", {
        startsExpr: startsExpr2
      }),
      _static: createKeywordLike("static", {
        startsExpr: startsExpr2
      }),
      _using: createKeywordLike("using", {
        startsExpr: startsExpr2
      }),
      _yield: createKeywordLike("yield", {
        startsExpr: startsExpr2
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr: startsExpr2
      }),
      _checks: createKeywordLike("checks", {
        startsExpr: startsExpr2
      }),
      _exports: createKeywordLike("exports", {
        startsExpr: startsExpr2
      }),
      _global: createKeywordLike("global", {
        startsExpr: startsExpr2
      }),
      _implements: createKeywordLike("implements", {
        startsExpr: startsExpr2
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr: startsExpr2
      }),
      _infer: createKeywordLike("infer", {
        startsExpr: startsExpr2
      }),
      _is: createKeywordLike("is", {
        startsExpr: startsExpr2
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr: startsExpr2
      }),
      _proto: createKeywordLike("proto", {
        startsExpr: startsExpr2
      }),
      _require: createKeywordLike("require", {
        startsExpr: startsExpr2
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr: startsExpr2
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr: startsExpr2
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr: startsExpr2
      }),
      _unique: createKeywordLike("unique", {
        startsExpr: startsExpr2
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr: startsExpr2
      }),
      _declare: createKeywordLike("declare", {
        startsExpr: startsExpr2
      }),
      _enum: createKeywordLike("enum", {
        startsExpr: startsExpr2
      }),
      _module: createKeywordLike("module", {
        startsExpr: startsExpr2
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr: startsExpr2
      }),
      _interface: createKeywordLike("interface", {
        startsExpr: startsExpr2
      }),
      _type: createKeywordLike("type", {
        startsExpr: startsExpr2
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr: startsExpr2
      }),
      name: createToken("name", {
        startsExpr: startsExpr2
      }),
      string: createToken("string", {
        startsExpr: startsExpr2
      }),
      num: createToken("num", {
        startsExpr: startsExpr2
      }),
      bigint: createToken("bigint", {
        startsExpr: startsExpr2
      }),
      decimal: createToken("decimal", {
        startsExpr: startsExpr2
      }),
      regexp: createToken("regexp", {
        startsExpr: startsExpr2
      }),
      privateName: createToken("#name", {
        startsExpr: startsExpr2
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 132;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 132;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 136;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    var nonASCIIidentifierStartChars22 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars22 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart22 = new RegExp("[" + nonASCIIidentifierStartChars22 + "]");
    var nonASCIIidentifier22 = new RegExp("[" + nonASCIIidentifierStartChars22 + nonASCIIidentifierChars22 + "]");
    nonASCIIidentifierStartChars22 = nonASCIIidentifierChars22 = null;
    var astralIdentifierStartCodes22 = [
      0,
      11,
      2,
      25,
      2,
      18,
      2,
      1,
      2,
      14,
      3,
      13,
      35,
      122,
      70,
      52,
      268,
      28,
      4,
      48,
      48,
      31,
      14,
      29,
      6,
      37,
      11,
      29,
      3,
      35,
      5,
      7,
      2,
      4,
      43,
      157,
      19,
      35,
      5,
      35,
      5,
      39,
      9,
      51,
      13,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      2,
      10,
      2,
      14,
      2,
      6,
      2,
      1,
      68,
      310,
      10,
      21,
      11,
      7,
      25,
      5,
      2,
      41,
      2,
      8,
      70,
      5,
      3,
      0,
      2,
      43,
      2,
      1,
      4,
      0,
      3,
      22,
      11,
      22,
      10,
      30,
      66,
      18,
      2,
      1,
      11,
      21,
      11,
      25,
      71,
      55,
      7,
      1,
      65,
      0,
      16,
      3,
      2,
      2,
      2,
      28,
      43,
      28,
      4,
      28,
      36,
      7,
      2,
      27,
      28,
      53,
      11,
      21,
      11,
      18,
      14,
      17,
      111,
      72,
      56,
      50,
      14,
      50,
      14,
      35,
      349,
      41,
      7,
      1,
      79,
      28,
      11,
      0,
      9,
      21,
      43,
      17,
      47,
      20,
      28,
      22,
      13,
      52,
      58,
      1,
      3,
      0,
      14,
      44,
      33,
      24,
      27,
      35,
      30,
      0,
      3,
      0,
      9,
      34,
      4,
      0,
      13,
      47,
      15,
      3,
      22,
      0,
      2,
      0,
      36,
      17,
      2,
      24,
      20,
      1,
      64,
      6,
      2,
      0,
      2,
      3,
      2,
      14,
      2,
      9,
      8,
      46,
      39,
      7,
      3,
      1,
      3,
      21,
      2,
      6,
      2,
      1,
      2,
      4,
      4,
      0,
      19,
      0,
      13,
      4,
      159,
      52,
      19,
      3,
      21,
      2,
      31,
      47,
      21,
      1,
      2,
      0,
      185,
      46,
      42,
      3,
      37,
      47,
      21,
      0,
      60,
      42,
      14,
      0,
      72,
      26,
      38,
      6,
      186,
      43,
      117,
      63,
      32,
      7,
      3,
      0,
      3,
      7,
      2,
      1,
      2,
      23,
      16,
      0,
      2,
      0,
      95,
      7,
      3,
      38,
      17,
      0,
      2,
      0,
      29,
      0,
      11,
      39,
      8,
      0,
      22,
      0,
      12,
      45,
      20,
      0,
      19,
      72,
      264,
      8,
      2,
      36,
      18,
      0,
      50,
      29,
      113,
      6,
      2,
      1,
      2,
      37,
      22,
      0,
      26,
      5,
      2,
      1,
      2,
      31,
      15,
      0,
      328,
      18,
      16,
      0,
      2,
      12,
      2,
      33,
      125,
      0,
      80,
      921,
      103,
      110,
      18,
      195,
      2637,
      96,
      16,
      1071,
      18,
      5,
      4026,
      582,
      8634,
      568,
      8,
      30,
      18,
      78,
      18,
      29,
      19,
      47,
      17,
      3,
      32,
      20,
      6,
      18,
      689,
      63,
      129,
      74,
      6,
      0,
      67,
      12,
      65,
      1,
      2,
      0,
      29,
      6135,
      9,
      1237,
      43,
      8,
      8936,
      3,
      2,
      6,
      2,
      1,
      2,
      290,
      16,
      0,
      30,
      2,
      3,
      0,
      15,
      3,
      9,
      395,
      2309,
      106,
      6,
      12,
      4,
      8,
      8,
      9,
      5991,
      84,
      2,
      70,
      2,
      1,
      3,
      0,
      3,
      1,
      3,
      3,
      2,
      11,
      2,
      0,
      2,
      6,
      2,
      64,
      2,
      3,
      3,
      7,
      2,
      6,
      2,
      27,
      2,
      3,
      2,
      4,
      2,
      0,
      4,
      6,
      2,
      339,
      3,
      24,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      30,
      2,
      24,
      2,
      7,
      1845,
      30,
      7,
      5,
      262,
      61,
      147,
      44,
      11,
      6,
      17,
      0,
      322,
      29,
      19,
      43,
      485,
      27,
      757,
      6,
      2,
      3,
      2,
      1,
      2,
      14,
      2,
      196,
      60,
      67,
      8,
      0,
      1205,
      3,
      2,
      26,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      9,
      2,
      3,
      2,
      0,
      2,
      0,
      7,
      0,
      5,
      0,
      2,
      0,
      2,
      0,
      2,
      2,
      2,
      1,
      2,
      0,
      3,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      0,
      2,
      1,
      2,
      0,
      3,
      3,
      2,
      6,
      2,
      3,
      2,
      3,
      2,
      0,
      2,
      9,
      2,
      16,
      6,
      2,
      2,
      4,
      2,
      16,
      4421,
      42719,
      33,
      4153,
      7,
      221,
      3,
      5761,
      15,
      7472,
      16,
      621,
      2467,
      541,
      1507,
      4938,
      6,
      4191
    ];
    var astralIdentifierCodes22 = [
      509,
      0,
      227,
      0,
      150,
      4,
      294,
      9,
      1368,
      2,
      2,
      1,
      6,
      3,
      41,
      2,
      5,
      0,
      166,
      1,
      574,
      3,
      9,
      9,
      370,
      1,
      81,
      2,
      71,
      10,
      50,
      3,
      123,
      2,
      54,
      14,
      32,
      10,
      3,
      1,
      11,
      3,
      46,
      10,
      8,
      0,
      46,
      9,
      7,
      2,
      37,
      13,
      2,
      9,
      6,
      1,
      45,
      0,
      13,
      2,
      49,
      13,
      9,
      3,
      2,
      11,
      83,
      11,
      7,
      0,
      3,
      0,
      158,
      11,
      6,
      9,
      7,
      3,
      56,
      1,
      2,
      6,
      3,
      1,
      3,
      2,
      10,
      0,
      11,
      1,
      3,
      6,
      4,
      4,
      193,
      17,
      10,
      9,
      5,
      0,
      82,
      19,
      13,
      9,
      214,
      6,
      3,
      8,
      28,
      1,
      83,
      16,
      16,
      9,
      82,
      12,
      9,
      9,
      84,
      14,
      5,
      9,
      243,
      14,
      166,
      9,
      71,
      5,
      2,
      1,
      3,
      3,
      2,
      0,
      2,
      1,
      13,
      9,
      120,
      6,
      3,
      6,
      4,
      0,
      29,
      9,
      41,
      6,
      2,
      3,
      9,
      0,
      10,
      10,
      47,
      15,
      406,
      7,
      2,
      7,
      17,
      9,
      57,
      21,
      2,
      13,
      123,
      5,
      4,
      0,
      2,
      1,
      2,
      6,
      2,
      0,
      9,
      9,
      49,
      4,
      2,
      1,
      2,
      4,
      9,
      9,
      330,
      3,
      10,
      1,
      2,
      0,
      49,
      6,
      4,
      4,
      14,
      9,
      5351,
      0,
      7,
      14,
      13835,
      9,
      87,
      9,
      39,
      4,
      60,
      6,
      26,
      9,
      1014,
      0,
      2,
      54,
      8,
      3,
      82,
      0,
      12,
      1,
      19628,
      1,
      4706,
      45,
      3,
      22,
      543,
      4,
      4,
      5,
      9,
      7,
      3,
      6,
      31,
      3,
      149,
      2,
      1418,
      49,
      513,
      54,
      5,
      49,
      9,
      0,
      15,
      0,
      23,
      4,
      2,
      14,
      1361,
      6,
      2,
      16,
      3,
      6,
      2,
      1,
      2,
      4,
      101,
      0,
      161,
      6,
      10,
      9,
      357,
      0,
      62,
      13,
      499,
      13,
      983,
      6,
      110,
      6,
      6,
      9,
      4759,
      9,
      787719,
      239
    ];
    function isInAstralSet22(code22, set) {
      var pos = 65536;
      for (var i2 = 0, length = set.length; i2 < length; i2 += 2) {
        pos += set[i2];
        if (pos > code22)
          return false;
        pos += set[i2 + 1];
        if (pos >= code22)
          return true;
      }
      return false;
    }
    function isIdentifierStart22(code22) {
      if (code22 < 65)
        return code22 === 36;
      if (code22 <= 90)
        return true;
      if (code22 < 97)
        return code22 === 95;
      if (code22 <= 122)
        return true;
      if (code22 <= 65535) {
        return code22 >= 170 && nonASCIIidentifierStart22.test(String.fromCharCode(code22));
      }
      return isInAstralSet22(code22, astralIdentifierStartCodes22);
    }
    function isIdentifierChar22(code22) {
      if (code22 < 48)
        return code22 === 36;
      if (code22 < 58)
        return true;
      if (code22 < 65)
        return false;
      if (code22 <= 90)
        return true;
      if (code22 < 97)
        return code22 === 95;
      if (code22 <= 122)
        return true;
      if (code22 <= 65535) {
        return code22 >= 170 && nonASCIIidentifier22.test(String.fromCharCode(code22));
      }
      return isInAstralSet22(code22, astralIdentifierStartCodes22) || isInAstralSet22(code22, astralIdentifierCodes22);
    }
    var reservedWords22 = {
      keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
      ],
      strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
      ],
      strictBind: [
        "eval",
        "arguments"
      ]
    };
    var keywords22 = new Set(reservedWords22.keyword);
    var reservedWordsStrictSet2 = new Set(reservedWords22.strict);
    var reservedWordsStrictBindSet2 = new Set(reservedWords22.strictBind);
    function isReservedWord2(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord2(word, inModule) {
      return isReservedWord2(word, inModule) || reservedWordsStrictSet2.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet2.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord2(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword2(word) {
      return keywords22.has(word);
    }
    function isIteratorStart(current2, next, next2) {
      return current2 === 64 && next === 64 && isIdentifierStart22(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set([
      "break",
      "case",
      "catch",
      "continue",
      "debugger",
      "default",
      "do",
      "else",
      "finally",
      "for",
      "function",
      "if",
      "return",
      "switch",
      "throw",
      "try",
      "var",
      "const",
      "while",
      "with",
      "new",
      "this",
      "super",
      "class",
      "extends",
      "export",
      "import",
      "null",
      "true",
      "false",
      "in",
      "instanceof",
      "typeof",
      "void",
      "delete",
      "implements",
      "interface",
      "let",
      "package",
      "private",
      "protected",
      "public",
      "static",
      "yield",
      "eval",
      "arguments",
      "enum",
      "await"
    ]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope4 = function Scope5(flags) {
      "use strict";
      _class_call_check(this, Scope5);
      __publicField(this, "var", /* @__PURE__ */ new Set());
      __publicField(this, "lexical", /* @__PURE__ */ new Set());
      __publicField(this, "functions", /* @__PURE__ */ new Set());
      this.flags = flags;
    };
    var ScopeHandler = /* @__PURE__ */ function() {
      "use strict";
      function ScopeHandler2(parser, inModule) {
        _class_call_check(this, ScopeHandler2);
        __publicField(this, "parser");
        __publicField(this, "scopeStack", []);
        __publicField(this, "inModule");
        __publicField(this, "undefinedExports", /* @__PURE__ */ new Map());
        this.parser = parser;
        this.inModule = inModule;
      }
      _create_class(ScopeHandler2, [
        {
          key: "inTopLevel",
          get: function get3() {
            return (this.currentScope().flags & 1) > 0;
          }
        },
        {
          key: "inFunction",
          get: function get3() {
            return (this.currentVarScopeFlags() & 2) > 0;
          }
        },
        {
          key: "allowSuper",
          get: function get3() {
            return (this.currentThisScopeFlags() & 16) > 0;
          }
        },
        {
          key: "allowDirectSuper",
          get: function get3() {
            return (this.currentThisScopeFlags() & 32) > 0;
          }
        },
        {
          key: "inClass",
          get: function get3() {
            return (this.currentThisScopeFlags() & 64) > 0;
          }
        },
        {
          key: "inClassAndNotInNonArrowFunction",
          get: function get3() {
            var flags = this.currentThisScopeFlags();
            return (flags & 64) > 0 && (flags & 2) === 0;
          }
        },
        {
          key: "inStaticBlock",
          get: function get3() {
            for (var i2 = this.scopeStack.length - 1; ; i2--) {
              var flags = this.scopeStack[i2].flags;
              if (flags & 128) {
                return true;
              }
              if (flags & (387 | 64)) {
                return false;
              }
            }
          }
        },
        {
          key: "inNonArrowFunction",
          get: function get3() {
            return (this.currentThisScopeFlags() & 2) > 0;
          }
        },
        {
          key: "treatFunctionsAsVar",
          get: function get3() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
        },
        {
          key: "createScope",
          value: function createScope(flags) {
            return new Scope4(flags);
          }
        },
        {
          key: "enter",
          value: function enter(flags) {
            this.scopeStack.push(this.createScope(flags));
          }
        },
        {
          key: "exit",
          value: function exit2() {
            var scope2 = this.scopeStack.pop();
            return scope2.flags;
          }
        },
        {
          key: "treatFunctionsAsVarInScope",
          value: function treatFunctionsAsVarInScope(scope2) {
            return !!(scope2.flags & (2 | 128) || !this.parser.inModule && scope2.flags & 1);
          }
        },
        {
          key: "declareName",
          value: function declareName(name2, bindingType, loc) {
            var scope2 = this.currentScope();
            if (bindingType & 8 || bindingType & 16) {
              this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
              if (bindingType & 16) {
                scope2.functions.add(name2);
              } else {
                scope2.lexical.add(name2);
              }
              if (bindingType & 8) {
                this.maybeExportDefined(scope2, name2);
              }
            } else if (bindingType & 4) {
              for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
                scope2 = this.scopeStack[i2];
                this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
                scope2.var.add(name2);
                this.maybeExportDefined(scope2, name2);
                if (scope2.flags & 387)
                  break;
              }
            }
            if (this.parser.inModule && scope2.flags & 1) {
              this.undefinedExports.delete(name2);
            }
          }
        },
        {
          key: "maybeExportDefined",
          value: function maybeExportDefined(scope2, name2) {
            if (this.parser.inModule && scope2.flags & 1) {
              this.undefinedExports.delete(name2);
            }
          }
        },
        {
          key: "checkRedeclarationInScope",
          value: function checkRedeclarationInScope(scope2, name2, bindingType, loc) {
            if (this.isRedeclaredInScope(scope2, name2, bindingType)) {
              this.parser.raise(Errors.VarRedeclaration, {
                at: loc,
                identifierName: name2
              });
            }
          }
        },
        {
          key: "isRedeclaredInScope",
          value: function isRedeclaredInScope(scope2, name2, bindingType) {
            if (!(bindingType & 1))
              return false;
            if (bindingType & 8) {
              return scope2.lexical.has(name2) || scope2.functions.has(name2) || scope2.var.has(name2);
            }
            if (bindingType & 16) {
              return scope2.lexical.has(name2) || !this.treatFunctionsAsVarInScope(scope2) && scope2.var.has(name2);
            }
            return scope2.lexical.has(name2) && !(scope2.flags & 8 && scope2.lexical.values().next().value === name2) || !this.treatFunctionsAsVarInScope(scope2) && scope2.functions.has(name2);
          }
        },
        {
          key: "checkLocalExport",
          value: function checkLocalExport(id) {
            var name2 = id.name;
            var topLevelScope = this.scopeStack[0];
            if (!topLevelScope.lexical.has(name2) && !topLevelScope.var.has(name2) && !topLevelScope.functions.has(name2)) {
              this.undefinedExports.set(name2, id.loc.start);
            }
          }
        },
        {
          key: "currentScope",
          value: function currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
        },
        {
          key: "currentVarScopeFlags",
          value: function currentVarScopeFlags() {
            for (var i2 = this.scopeStack.length - 1; ; i2--) {
              var flags = this.scopeStack[i2].flags;
              if (flags & 387) {
                return flags;
              }
            }
          }
        },
        {
          key: "currentThisScopeFlags",
          value: function currentThisScopeFlags() {
            for (var i2 = this.scopeStack.length - 1; ; i2--) {
              var flags = this.scopeStack[i2].flags;
              if (flags & (387 | 64) && !(flags & 4)) {
                return flags;
              }
            }
          }
        }
      ]);
      return ScopeHandler2;
    }();
    var FlowScope = /* @__PURE__ */ function(Scope5) {
      "use strict";
      _inherits(FlowScope2, Scope5);
      var _super3 = _create_super(FlowScope2);
      function FlowScope2() {
        _class_call_check(this, FlowScope2);
        var _this;
        _this = _super3.call.apply(_super3, [
          this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assert_this_initialized(_this), "declareFunctions", /* @__PURE__ */ new Set());
        return _this;
      }
      return FlowScope2;
    }(Scope4);
    var FlowScopeHandler = /* @__PURE__ */ function(ScopeHandler2) {
      "use strict";
      _inherits(FlowScopeHandler2, ScopeHandler2);
      var _super3 = _create_super(FlowScopeHandler2);
      function FlowScopeHandler2() {
        _class_call_check(this, FlowScopeHandler2);
        return _super3.apply(this, arguments);
      }
      _create_class(FlowScopeHandler2, [
        {
          key: "createScope",
          value: function createScope(flags) {
            return new FlowScope(flags);
          }
        },
        {
          key: "declareName",
          value: function declareName(name2, bindingType, loc) {
            var scope2 = this.currentScope();
            if (bindingType & 2048) {
              this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
              this.maybeExportDefined(scope2, name2);
              scope2.declareFunctions.add(name2);
              return;
            }
            _get(_get_prototype_of(FlowScopeHandler2.prototype), "declareName", this).call(this, name2, bindingType, loc);
          }
        },
        {
          key: "isRedeclaredInScope",
          value: function isRedeclaredInScope(scope2, name2, bindingType) {
            if (_get(_get_prototype_of(FlowScopeHandler2.prototype), "isRedeclaredInScope", this).call(this, scope2, name2, bindingType))
              return true;
            if (bindingType & 2048) {
              return !scope2.declareFunctions.has(name2) && (scope2.lexical.has(name2) || scope2.functions.has(name2));
            }
            return false;
          }
        },
        {
          key: "checkLocalExport",
          value: function checkLocalExport(id) {
            if (!this.scopeStack[0].declareFunctions.has(id.name)) {
              _get(_get_prototype_of(FlowScopeHandler2.prototype), "checkLocalExport", this).call(this, id);
            }
          }
        }
      ]);
      return FlowScopeHandler2;
    }(ScopeHandler);
    var BaseParser = /* @__PURE__ */ function() {
      "use strict";
      function BaseParser2() {
        _class_call_check(this, BaseParser2);
        __publicField(this, "sawUnambiguousESM", false);
        __publicField(this, "ambiguousScriptDifferentAst", false);
      }
      _create_class(BaseParser2, [
        {
          key: "hasPlugin",
          value: function hasPlugin2(pluginConfig) {
            if (typeof pluginConfig === "string") {
              return this.plugins.has(pluginConfig);
            } else {
              var _pluginConfig = _sliced_to_array(pluginConfig, 2), pluginName = _pluginConfig[0], pluginOptions = _pluginConfig[1];
              if (!this.hasPlugin(pluginName)) {
                return false;
              }
              var actualOptions = this.plugins.get(pluginName);
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = Object.keys(pluginOptions)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var key = _step8.value;
                  if ((actualOptions === null || actualOptions === void 0 ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                    return false;
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              return true;
            }
          }
        },
        {
          key: "getPluginOption",
          value: function getPluginOption2(plugin2, name2) {
            var _this_plugins_get;
            return (_this_plugins_get = this.plugins.get(plugin2)) === null || _this_plugins_get === void 0 ? void 0 : _this_plugins_get[name2];
          }
        }
      ]);
      return BaseParser2;
    }();
    function setTrailingComments(node2, comments) {
      if (node2.trailingComments === void 0) {
        node2.trailingComments = comments;
      } else {
        var _node_trailingComments;
        (_node_trailingComments = node2.trailingComments).unshift.apply(_node_trailingComments, _to_consumable_array(comments));
      }
    }
    function setLeadingComments(node2, comments) {
      if (node2.leadingComments === void 0) {
        node2.leadingComments = comments;
      } else {
        var _node_leadingComments;
        (_node_leadingComments = node2.leadingComments).unshift.apply(_node_leadingComments, _to_consumable_array(comments));
      }
    }
    function setInnerComments(node2, comments) {
      if (node2.innerComments === void 0) {
        node2.innerComments = comments;
      } else {
        var _node_innerComments;
        (_node_innerComments = node2.innerComments).unshift.apply(_node_innerComments, _to_consumable_array(comments));
      }
    }
    function adjustInnerComments(node2, elements, commentWS) {
      var lastElement = null;
      var i2 = elements.length;
      while (lastElement === null && i2 > 0) {
        lastElement = elements[--i2];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node2, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = /* @__PURE__ */ function(BaseParser2) {
      "use strict";
      _inherits(CommentsParser2, BaseParser2);
      var _super3 = _create_super(CommentsParser2);
      function CommentsParser2() {
        _class_call_check(this, CommentsParser2);
        return _super3.apply(this, arguments);
      }
      _create_class(CommentsParser2, [
        {
          key: "addComment",
          value: function addComment3(comment2) {
            if (this.filename)
              comment2.loc.filename = this.filename;
            this.state.comments.push(comment2);
          }
        },
        {
          key: "processComment",
          value: function processComment(node2) {
            var commentStack = this.state.commentStack;
            var commentStackLength = commentStack.length;
            if (commentStackLength === 0)
              return;
            var i2 = commentStackLength - 1;
            var lastCommentWS = commentStack[i2];
            if (lastCommentWS.start === node2.end) {
              lastCommentWS.leadingNode = node2;
              i2--;
            }
            var nodeStart = node2.start;
            for (; i2 >= 0; i2--) {
              var commentWS = commentStack[i2];
              var commentEnd = commentWS.end;
              if (commentEnd > nodeStart) {
                commentWS.containingNode = node2;
                this.finalizeComment(commentWS);
                commentStack.splice(i2, 1);
              } else {
                if (commentEnd === nodeStart) {
                  commentWS.trailingNode = node2;
                }
                break;
              }
            }
          }
        },
        {
          key: "finalizeComment",
          value: function finalizeComment(commentWS) {
            var comments = commentWS.comments;
            if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
              if (commentWS.leadingNode !== null) {
                setTrailingComments(commentWS.leadingNode, comments);
              }
              if (commentWS.trailingNode !== null) {
                setLeadingComments(commentWS.trailingNode, comments);
              }
            } else {
              var node2 = commentWS.containingNode, commentStart = commentWS.start;
              if (this.input.charCodeAt(commentStart - 1) === 44) {
                switch (node2.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    adjustInnerComments(node2, node2.properties, commentWS);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    adjustInnerComments(node2, node2.arguments, commentWS);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    adjustInnerComments(node2, node2.params, commentWS);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    adjustInnerComments(node2, node2.elements, commentWS);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    adjustInnerComments(node2, node2.specifiers, commentWS);
                    break;
                  default: {
                    setInnerComments(node2, comments);
                  }
                }
              } else {
                setInnerComments(node2, comments);
              }
            }
          }
        },
        {
          key: "finalizeRemainingComments",
          value: function finalizeRemainingComments() {
            var commentStack = this.state.commentStack;
            for (var i2 = commentStack.length - 1; i2 >= 0; i2--) {
              this.finalizeComment(commentStack[i2]);
            }
            this.state.commentStack = [];
          }
        },
        {
          key: "resetPreviousNodeTrailingComments",
          value: function resetPreviousNodeTrailingComments(node2) {
            var commentStack = this.state.commentStack;
            var length = commentStack.length;
            if (length === 0)
              return;
            var commentWS = commentStack[length - 1];
            if (commentWS.leadingNode === node2) {
              commentWS.leadingNode = null;
            }
          }
        },
        {
          key: "resetPreviousIdentifierLeadingComments",
          value: function resetPreviousIdentifierLeadingComments(node2) {
            var commentStack = this.state.commentStack;
            var length = commentStack.length;
            if (length === 0)
              return;
            if (commentStack[length - 1].trailingNode === node2) {
              commentStack[length - 1].trailingNode = null;
            } else if (length >= 2 && commentStack[length - 2].trailingNode === node2) {
              commentStack[length - 2].trailingNode = null;
            }
          }
        },
        {
          key: "takeSurroundingComments",
          value: function takeSurroundingComments(node2, start2, end) {
            var commentStack = this.state.commentStack;
            var commentStackLength = commentStack.length;
            if (commentStackLength === 0)
              return;
            var i2 = commentStackLength - 1;
            for (; i2 >= 0; i2--) {
              var commentWS = commentStack[i2];
              var commentEnd = commentWS.end;
              var commentStart = commentWS.start;
              if (commentStart === end) {
                commentWS.leadingNode = node2;
              } else if (commentEnd === start2) {
                commentWS.trailingNode = node2;
              } else if (commentEnd < start2) {
                break;
              }
            }
          }
        }
      ]);
      return CommentsParser2;
    }(BaseParser);
    var lineBreak2 = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG2 = new RegExp(lineBreak2.source, "g");
    function isNewLine2(code22) {
      switch (code22) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(code22) {
      switch (code22) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State2 = /* @__PURE__ */ function() {
      "use strict";
      function _State() {
        _class_call_check(this, _State);
        __publicField(this, "strict");
        __publicField(this, "curLine");
        __publicField(this, "lineStart");
        __publicField(this, "startLoc");
        __publicField(this, "endLoc");
        __publicField(this, "errors", []);
        __publicField(this, "potentialArrowAt", -1);
        __publicField(this, "noArrowAt", []);
        __publicField(this, "noArrowParamsConversionAt", []);
        __publicField(this, "maybeInArrowParameters", false);
        __publicField(this, "inType", false);
        __publicField(this, "noAnonFunctionType", false);
        __publicField(this, "hasFlowComment", false);
        __publicField(this, "isAmbientContext", false);
        __publicField(this, "inAbstractClass", false);
        __publicField(this, "inDisallowConditionalTypesContext", false);
        __publicField(this, "topicContext", {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        });
        __publicField(this, "soloAwait", false);
        __publicField(this, "inFSharpPipelineDirectBody", false);
        __publicField(this, "labels", []);
        __publicField(this, "comments", []);
        __publicField(this, "commentStack", []);
        __publicField(this, "pos", 0);
        __publicField(this, "type", 139);
        __publicField(this, "value", null);
        __publicField(this, "start", 0);
        __publicField(this, "end", 0);
        __publicField(this, "lastTokEndLoc", null);
        __publicField(this, "lastTokStartLoc", null);
        __publicField(this, "lastTokStart", 0);
        __publicField(this, "context", [
          types2.brace
        ]);
        __publicField(this, "canStartJSXElement", true);
        __publicField(this, "containsEsc", false);
        __publicField(this, "firstInvalidTemplateEscapePos", null);
        __publicField(this, "strictErrors", /* @__PURE__ */ new Map());
        __publicField(this, "tokensLength", 0);
      }
      _create_class(_State, [
        {
          key: "init",
          value: function init(param) {
            var strictMode = param.strictMode, sourceType = param.sourceType, startLine = param.startLine, startColumn = param.startColumn;
            this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
            this.curLine = startLine;
            this.lineStart = -startColumn;
            this.startLoc = this.endLoc = new Position3(startLine, startColumn, 0);
          }
        },
        {
          key: "curPosition",
          value: function curPosition() {
            return new Position3(this.curLine, this.pos - this.lineStart, this.pos);
          }
        },
        {
          key: "clone",
          value: function clone3(skipArrays) {
            var state = new _State();
            var keys2 = Object.keys(this);
            for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
              var key = keys2[i2];
              var val = this[key];
              if (!skipArrays && Array.isArray(val)) {
                val = val.slice();
              }
              state[key] = val;
            }
            return state;
          }
        }
      ]);
      return _State;
    }();
    var _isDigit2 = function isDigit2(code22) {
      return code22 >= 48 && code22 <= 57;
    };
    var forbiddenNumericSeparatorSiblings2 = {
      decBinOct: /* @__PURE__ */ new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
      ]),
      hex: /* @__PURE__ */ new Set([
        46,
        88,
        95,
        120
      ])
    };
    var isAllowedNumericSeparatorSibling2 = {
      bin: function(ch) {
        return ch === 48 || ch === 49;
      },
      oct: function(ch) {
        return ch >= 48 && ch <= 55;
      },
      dec: function(ch) {
        return ch >= 48 && ch <= 57;
      },
      hex: function(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
    };
    function readStringContents2(type3, input, pos, lineStart, curLine, errors) {
      var initialPos = pos;
      var initialLineStart = lineStart;
      var initialCurLine = curLine;
      var out = "";
      var firstInvalidLoc = null;
      var chunkStart = pos;
      var length = input.length;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        var ch = input.charCodeAt(pos);
        if (isStringEnd2(type3, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          var res = readEscapedChar2(input, pos, lineStart, curLine, type3 === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          var ref2;
          ref2 = res, pos = ref2.pos, lineStart = ref2.lineStart, curLine = ref2.curLine, ref2;
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type3 === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine
      };
    }
    function isStringEnd2(type3, ch, input, pos) {
      if (type3 === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type3 === "double" ? 34 : 39);
    }
    function readEscapedChar2(input, pos, lineStart, curLine, inTemplate, errors) {
      var throwOnInvalid = !inTemplate;
      pos++;
      var res = function(ch2) {
        return {
          pos,
          ch: ch2,
          lineStart,
          curLine
        };
      };
      var ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          var code22;
          var ref2;
          ref2 = readHexChar2(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), code22 = ref2.code, pos = ref2.pos, ref2;
          return res(code22 === null ? null : String.fromCharCode(code22));
        }
        case 117: {
          var code21;
          var ref1;
          ref1 = readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors), code21 = ref1.code, pos = ref1.pos, ref1;
          return res(code21 === null ? null : String.fromCodePoint(code21));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var startPos = pos - 1;
            var match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            var octalStr = match[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            var next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar2(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      var initialPos = pos;
      var n2;
      var ref2;
      ref2 = readInt2(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), n2 = ref2.n, pos = ref2.pos, ref2;
      if (n2 === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n2,
        pos
      };
    }
    function readInt2(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      var start2 = pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings2.hex : forbiddenNumericSeparatorSiblings2.decBinOct;
      var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling2.hex : radix === 10 ? isAllowedNumericSeparatorSibling2.dec : radix === 8 ? isAllowedNumericSeparatorSibling2.oct : isAllowedNumericSeparatorSibling2.bin;
      var invalid2 = false;
      var total = 0;
      for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2) {
        var code22 = input.charCodeAt(pos);
        var val = void 0;
        if (code22 === 95 && allowNumSeparator !== "bail") {
          var prev = input.charCodeAt(pos - 1);
          var next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code22 >= 97) {
          val = code22 - 97 + 10;
        } else if (code22 >= 65) {
          val = code22 - 65 + 10;
        } else if (_isDigit2(code22)) {
          val = code22 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid2 = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start2 || len != null && pos - start2 !== len || invalid2) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      var ch = input.charCodeAt(pos);
      var code22;
      if (ch === 123) {
        ++pos;
        var ref2;
        ref2 = readHexChar2(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors), code22 = ref2.code, pos = ref2.pos, ref2;
        ++pos;
        if (code22 !== null && code22 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        var ref1;
        ref1 = readHexChar2(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors), code22 = ref1.code, pos = ref1.pos, ref1;
      }
      return {
        code: code22,
        pos
      };
    }
    var _excluded = [
      "at"
    ];
    var _excluded2 = [
      "at"
    ];
    function buildPosition(pos, lineStart, curLine) {
      return new Position3(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([
      103,
      109,
      115,
      105,
      121,
      117,
      100,
      118
    ]);
    var Token3 = function Token4(state) {
      "use strict";
      _class_call_check(this, Token4);
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation3(state.startLoc, state.endLoc);
    };
    var Tokenizer = /* @__PURE__ */ function(CommentsParser2) {
      "use strict";
      _inherits(Tokenizer2, CommentsParser2);
      var _super3 = _create_super(Tokenizer2);
      function Tokenizer2(options, input) {
        _class_call_check(this, Tokenizer2);
        var _this;
        _this = _super3.call(this);
        __publicField(_assert_this_initialized(_this), "isLookahead");
        __publicField(_assert_this_initialized(_this), "tokens", []);
        __publicField(_assert_this_initialized(_this), "errorHandlers_readInt", {
          invalidDigit: function(pos, lineStart, curLine, radix) {
            if (!_this.options.errorRecovery)
              return false;
            _this.raise(Errors.InvalidDigit, {
              at: buildPosition(pos, lineStart, curLine),
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: _this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: _this.errorBuilder(Errors.UnexpectedNumericSeparator)
        });
        __publicField(_assert_this_initialized(_this), "errorHandlers_readCodePoint", Object.assign({}, _this.errorHandlers_readInt, {
          invalidEscapeSequence: _this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: _this.errorBuilder(Errors.InvalidCodePoint)
        }));
        __publicField(_assert_this_initialized(_this), "errorHandlers_readStringContents_string", Object.assign({}, _this.errorHandlers_readCodePoint, {
          strictNumericEscape: function(pos, lineStart, curLine) {
            _this.recordStrictModeErrors(Errors.StrictNumericEscape, {
              at: buildPosition(pos, lineStart, curLine)
            });
          },
          unterminated: function(pos, lineStart, curLine) {
            throw _this.raise(Errors.UnterminatedString, {
              at: buildPosition(pos - 1, lineStart, curLine)
            });
          }
        }));
        __publicField(_assert_this_initialized(_this), "errorHandlers_readStringContents_template", Object.assign({}, _this.errorHandlers_readCodePoint, {
          strictNumericEscape: _this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: function(pos, lineStart, curLine) {
            throw _this.raise(Errors.UnterminatedTemplate, {
              at: buildPosition(pos, lineStart, curLine)
            });
          }
        }));
        _this.state = new State2();
        _this.state.init(options);
        _this.input = input;
        _this.length = input.length;
        _this.isLookahead = false;
        return _this;
      }
      _create_class(Tokenizer2, [
        {
          key: "pushToken",
          value: function pushToken(token) {
            this.tokens.length = this.state.tokensLength;
            this.tokens.push(token);
            ++this.state.tokensLength;
          }
        },
        {
          key: "next",
          value: function next() {
            this.checkKeywordEscapes();
            if (this.options.tokens) {
              this.pushToken(new Token3(this.state));
            }
            this.state.lastTokStart = this.state.start;
            this.state.lastTokEndLoc = this.state.endLoc;
            this.state.lastTokStartLoc = this.state.startLoc;
            this.nextToken();
          }
        },
        {
          key: "eat",
          value: function eat2(type3) {
            if (this.match(type3)) {
              this.next();
              return true;
            } else {
              return false;
            }
          }
        },
        {
          key: "match",
          value: function match(type3) {
            return this.state.type === type3;
          }
        },
        {
          key: "createLookaheadState",
          value: function createLookaheadState(state) {
            return {
              pos: state.pos,
              value: null,
              type: state.type,
              start: state.start,
              end: state.end,
              context: [
                this.curContext()
              ],
              inType: state.inType,
              startLoc: state.startLoc,
              lastTokEndLoc: state.lastTokEndLoc,
              curLine: state.curLine,
              lineStart: state.lineStart,
              curPosition: state.curPosition
            };
          }
        },
        {
          key: "lookahead",
          value: function lookahead2() {
            var old = this.state;
            this.state = this.createLookaheadState(old);
            this.isLookahead = true;
            this.nextToken();
            this.isLookahead = false;
            var curr = this.state;
            this.state = old;
            return curr;
          }
        },
        {
          key: "nextTokenStart",
          value: function nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
        },
        {
          key: "nextTokenStartSince",
          value: function nextTokenStartSince(pos) {
            skipWhiteSpace2.lastIndex = pos;
            return skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
          }
        },
        {
          key: "lookaheadCharCode",
          value: function lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
        },
        {
          key: "nextTokenInLineStart",
          value: function nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
        },
        {
          key: "nextTokenInLineStartSince",
          value: function nextTokenInLineStartSince(pos) {
            skipWhiteSpaceInLine.lastIndex = pos;
            return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
          }
        },
        {
          key: "lookaheadInLineCharCode",
          value: function lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
        },
        {
          key: "codePointAtPos",
          value: function codePointAtPos(pos) {
            var cp = this.input.charCodeAt(pos);
            if ((cp & 64512) === 55296 && ++pos < this.input.length) {
              var trail = this.input.charCodeAt(pos);
              if ((trail & 64512) === 56320) {
                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
              }
            }
            return cp;
          }
        },
        {
          key: "setStrict",
          value: function setStrict(strict) {
            var _this = this;
            this.state.strict = strict;
            if (strict) {
              this.state.strictErrors.forEach(function(param) {
                var _$_param = _sliced_to_array(param, 2), toParseError = _$_param[0], at2 = _$_param[1];
                return _this.raise(toParseError, {
                  at: at2
                });
              });
              this.state.strictErrors.clear();
            }
          }
        },
        {
          key: "curContext",
          value: function curContext() {
            return this.state.context[this.state.context.length - 1];
          }
        },
        {
          key: "nextToken",
          value: function nextToken() {
            this.skipSpace();
            this.state.start = this.state.pos;
            if (!this.isLookahead)
              this.state.startLoc = this.state.curPosition();
            if (this.state.pos >= this.length) {
              this.finishToken(139);
              return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
        },
        {
          key: "skipBlockComment",
          value: function skipBlockComment(commentEnd) {
            var startLoc;
            if (!this.isLookahead)
              startLoc = this.state.curPosition();
            var start2 = this.state.pos;
            var end = this.input.indexOf(commentEnd, start2 + 2);
            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }
            this.state.pos = end + commentEnd.length;
            lineBreakG2.lastIndex = start2 + 2;
            while (lineBreakG2.test(this.input) && lineBreakG2.lastIndex <= end) {
              ++this.state.curLine;
              this.state.lineStart = lineBreakG2.lastIndex;
            }
            if (this.isLookahead)
              return;
            var comment2 = {
              type: "CommentBlock",
              value: this.input.slice(start2 + 2, end),
              start: start2,
              end: end + commentEnd.length,
              loc: new SourceLocation3(startLoc, this.state.curPosition())
            };
            if (this.options.tokens)
              this.pushToken(comment2);
            return comment2;
          }
        },
        {
          key: "skipLineComment",
          value: function skipLineComment(startSkip) {
            var start2 = this.state.pos;
            var startLoc;
            if (!this.isLookahead)
              startLoc = this.state.curPosition();
            var ch = this.input.charCodeAt(this.state.pos += startSkip);
            if (this.state.pos < this.length) {
              while (!isNewLine2(ch) && ++this.state.pos < this.length) {
                ch = this.input.charCodeAt(this.state.pos);
              }
            }
            if (this.isLookahead)
              return;
            var end = this.state.pos;
            var value1 = this.input.slice(start2 + startSkip, end);
            var comment2 = {
              type: "CommentLine",
              value: value1,
              start: start2,
              end,
              loc: new SourceLocation3(startLoc, this.state.curPosition())
            };
            if (this.options.tokens)
              this.pushToken(comment2);
            return comment2;
          }
        },
        {
          key: "skipSpace",
          value: function skipSpace() {
            var spaceStart = this.state.pos;
            var comments = [];
            loop:
              while (this.state.pos < this.length) {
                var ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                      ++this.state.pos;
                    }
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        var comment2 = this.skipBlockComment("*/");
                        if (comment2 !== void 0) {
                          this.addComment(comment2);
                          if (this.options.attachComment)
                            comments.push(comment2);
                        }
                        break;
                      }
                      case 47: {
                        var comment1 = this.skipLineComment(2);
                        if (comment1 !== void 0) {
                          this.addComment(comment1);
                          if (this.options.attachComment)
                            comments.push(comment1);
                        }
                        break;
                      }
                      default:
                        break loop;
                    }
                    break;
                  default:
                    if (isWhitespace(ch)) {
                      ++this.state.pos;
                    } else if (ch === 45 && !this.inModule && this.options.annexB) {
                      var pos = this.state.pos;
                      if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                        var comment22 = this.skipLineComment(3);
                        if (comment22 !== void 0) {
                          this.addComment(comment22);
                          if (this.options.attachComment)
                            comments.push(comment22);
                        }
                      } else {
                        break loop;
                      }
                    } else if (ch === 60 && !this.inModule && this.options.annexB) {
                      var pos1 = this.state.pos;
                      if (this.input.charCodeAt(pos1 + 1) === 33 && this.input.charCodeAt(pos1 + 2) === 45 && this.input.charCodeAt(pos1 + 3) === 45) {
                        var comment3 = this.skipLineComment(4);
                        if (comment3 !== void 0) {
                          this.addComment(comment3);
                          if (this.options.attachComment)
                            comments.push(comment3);
                        }
                      } else {
                        break loop;
                      }
                    } else {
                      break loop;
                    }
                }
              }
            if (comments.length > 0) {
              var end = this.state.pos;
              var commentWhitespace = {
                start: spaceStart,
                end,
                comments,
                leadingNode: null,
                trailingNode: null,
                containingNode: null
              };
              this.state.commentStack.push(commentWhitespace);
            }
          }
        },
        {
          key: "finishToken",
          value: function finishToken(type3, val) {
            this.state.end = this.state.pos;
            this.state.endLoc = this.state.curPosition();
            var prevType = this.state.type;
            this.state.type = type3;
            this.state.value = val;
            if (!this.isLookahead) {
              this.updateContext(prevType);
            }
          }
        },
        {
          key: "replaceToken",
          value: function replaceToken(type3) {
            this.state.type = type3;
            this.updateContext();
          }
        },
        {
          key: "readToken_numberSign",
          value: function readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) {
              return;
            }
            var nextPos = this.state.pos + 1;
            var next = this.codePointAtPos(nextPos);
            if (next >= 48 && next <= 57) {
              throw this.raise(Errors.UnexpectedDigitAfterHash, {
                at: this.state.curPosition()
              });
            }
            if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
              this.expectPlugin("recordAndTuple");
              if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
                throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              if (next === 123) {
                this.finishToken(7);
              } else {
                this.finishToken(1);
              }
            } else if (isIdentifierStart22(next)) {
              ++this.state.pos;
              this.finishToken(138, this.readWord1(next));
            } else if (next === 92) {
              ++this.state.pos;
              this.finishToken(138, this.readWord1());
            } else {
              this.finishOp(27, 1);
            }
          }
        },
        {
          key: "readToken_dot",
          value: function readToken_dot() {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next >= 48 && next <= 57) {
              this.readNumber(true);
              return;
            }
            if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
              this.state.pos += 3;
              this.finishToken(21);
            } else {
              ++this.state.pos;
              this.finishToken(16);
            }
          }
        },
        {
          key: "readToken_slash",
          value: function readToken_slash() {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61) {
              this.finishOp(31, 2);
            } else {
              this.finishOp(56, 1);
            }
          }
        },
        {
          key: "readToken_interpreter",
          value: function readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            var ch = this.input.charCodeAt(this.state.pos + 1);
            if (ch !== 33)
              return false;
            var start2 = this.state.pos;
            this.state.pos += 1;
            while (!isNewLine2(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
            var value1 = this.input.slice(start2 + 2, this.state.pos);
            this.finishToken(28, value1);
            return true;
          }
        },
        {
          key: "readToken_mult_modulo",
          value: function readToken_mult_modulo(code22) {
            var type3 = code22 === 42 ? 55 : 54;
            var width = 1;
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (code22 === 42 && next === 42) {
              width++;
              next = this.input.charCodeAt(this.state.pos + 2);
              type3 = 57;
            }
            if (next === 61 && !this.state.inType) {
              width++;
              type3 = code22 === 37 ? 33 : 30;
            }
            this.finishOp(type3, width);
          }
        },
        {
          key: "readToken_pipe_amp",
          value: function readToken_pipe_amp(code22) {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === code22) {
              if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                this.finishOp(30, 3);
              } else {
                this.finishOp(code22 === 124 ? 41 : 42, 2);
              }
              return;
            }
            if (code22 === 124) {
              if (next === 62) {
                this.finishOp(39, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && next === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(9);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && next === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(4);
                return;
              }
            }
            if (next === 61) {
              this.finishOp(30, 2);
              return;
            }
            this.finishOp(code22 === 124 ? 43 : 45, 1);
          }
        },
        {
          key: "readToken_caret",
          value: function readToken_caret() {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61 && !this.state.inType) {
              this.finishOp(32, 2);
            } else if (next === 94 && this.hasPlugin([
              "pipelineOperator",
              {
                proposal: "hack",
                topicToken: "^^"
              }
            ])) {
              this.finishOp(37, 2);
              var lookaheadCh = this.input.codePointAt(this.state.pos);
              if (lookaheadCh === 94) {
                this.unexpected();
              }
            } else {
              this.finishOp(44, 1);
            }
          }
        },
        {
          key: "readToken_atSign",
          value: function readToken_atSign() {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 64 && this.hasPlugin([
              "pipelineOperator",
              {
                proposal: "hack",
                topicToken: "@@"
              }
            ])) {
              this.finishOp(38, 2);
            } else {
              this.finishOp(26, 1);
            }
          }
        },
        {
          key: "readToken_plus_min",
          value: function readToken_plus_min(code22) {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === code22) {
              this.finishOp(34, 2);
              return;
            }
            if (next === 61) {
              this.finishOp(30, 2);
            } else {
              this.finishOp(53, 1);
            }
          }
        },
        {
          key: "readToken_lt",
          value: function readToken_lt() {
            var pos = this.state.pos;
            var next = this.input.charCodeAt(pos + 1);
            if (next === 60) {
              if (this.input.charCodeAt(pos + 2) === 61) {
                this.finishOp(30, 3);
                return;
              }
              this.finishOp(51, 2);
              return;
            }
            if (next === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(47, 1);
          }
        },
        {
          key: "readToken_gt",
          value: function readToken_gt() {
            var pos = this.state.pos;
            var next = this.input.charCodeAt(pos + 1);
            if (next === 62) {
              var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(pos + size) === 61) {
                this.finishOp(30, size + 1);
                return;
              }
              this.finishOp(52, size);
              return;
            }
            if (next === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(48, 1);
          }
        },
        {
          key: "readToken_eq_excl",
          value: function readToken_eq_excl(code22) {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 61) {
              this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (code22 === 61 && next === 62) {
              this.state.pos += 2;
              this.finishToken(19);
              return;
            }
            this.finishOp(code22 === 61 ? 29 : 35, 1);
          }
        },
        {
          key: "readToken_question",
          value: function readToken_question() {
            var next = this.input.charCodeAt(this.state.pos + 1);
            var next2 = this.input.charCodeAt(this.state.pos + 2);
            if (next === 63) {
              if (next2 === 61) {
                this.finishOp(30, 3);
              } else {
                this.finishOp(40, 2);
              }
            } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
              this.state.pos += 2;
              this.finishToken(18);
            } else {
              ++this.state.pos;
              this.finishToken(17);
            }
          }
        },
        {
          key: "getTokenFromCode",
          value: function getTokenFromCode(code22) {
            switch (code22) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos;
                this.finishToken(10);
                return;
              case 41:
                ++this.state.pos;
                this.finishToken(11);
                return;
              case 59:
                ++this.state.pos;
                this.finishToken(13);
                return;
              case 44:
                ++this.state.pos;
                this.finishToken(12);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                      at: this.state.curPosition()
                    });
                  }
                  this.state.pos += 2;
                  this.finishToken(2);
                } else {
                  ++this.state.pos;
                  this.finishToken(0);
                }
                return;
              case 93:
                ++this.state.pos;
                this.finishToken(3);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                    throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                      at: this.state.curPosition()
                    });
                  }
                  this.state.pos += 2;
                  this.finishToken(6);
                } else {
                  ++this.state.pos;
                  this.finishToken(5);
                }
                return;
              case 125:
                ++this.state.pos;
                this.finishToken(8);
                return;
              case 58:
                if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                  this.finishOp(15, 2);
                } else {
                  ++this.state.pos;
                  this.finishToken(14);
                }
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                this.readTemplateToken();
                return;
              case 48: {
                var next = this.input.charCodeAt(this.state.pos + 1);
                if (next === 120 || next === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (next === 111 || next === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (next === 98 || next === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(code22);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(code22);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(code22);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(code22);
                return;
              case 60:
                this.readToken_lt();
                return;
              case 62:
                this.readToken_gt();
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(code22);
                return;
              case 126:
                this.finishOp(36, 1);
                return;
              case 64:
                this.readToken_atSign();
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (isIdentifierStart22(code22)) {
                  this.readWord(code22);
                  return;
                }
            }
            throw this.raise(Errors.InvalidOrUnexpectedToken, {
              at: this.state.curPosition(),
              unexpected: String.fromCodePoint(code22)
            });
          }
        },
        {
          key: "finishOp",
          value: function finishOp(type3, size) {
            var str = this.input.slice(this.state.pos, this.state.pos + size);
            this.state.pos += size;
            this.finishToken(type3, str);
          }
        },
        {
          key: "readRegexp",
          value: function readRegexp() {
            var startLoc = this.state.startLoc;
            var start2 = this.state.start + 1;
            var escaped, inClass;
            var pos = this.state.pos;
            for (; ; ++pos) {
              if (pos >= this.length) {
                throw this.raise(Errors.UnterminatedRegExp, {
                  at: createPositionWithColumnOffset(startLoc, 1)
                });
              }
              var ch = this.input.charCodeAt(pos);
              if (isNewLine2(ch)) {
                throw this.raise(Errors.UnterminatedRegExp, {
                  at: createPositionWithColumnOffset(startLoc, 1)
                });
              }
              if (escaped) {
                escaped = false;
              } else {
                if (ch === 91) {
                  inClass = true;
                } else if (ch === 93 && inClass) {
                  inClass = false;
                } else if (ch === 47 && !inClass) {
                  break;
                }
                escaped = ch === 92;
              }
            }
            var content3 = this.input.slice(start2, pos);
            ++pos;
            var mods = "";
            var nextPos = function() {
              return createPositionWithColumnOffset(startLoc, pos + 2 - start2);
            };
            while (pos < this.length) {
              var cp = this.codePointAtPos(pos);
              var char = String.fromCharCode(cp);
              if (VALID_REGEX_FLAGS.has(cp)) {
                if (cp === 118) {
                  if (mods.includes("u")) {
                    this.raise(Errors.IncompatibleRegExpUVFlags, {
                      at: nextPos()
                    });
                  }
                } else if (cp === 117) {
                  if (mods.includes("v")) {
                    this.raise(Errors.IncompatibleRegExpUVFlags, {
                      at: nextPos()
                    });
                  }
                }
                if (mods.includes(char)) {
                  this.raise(Errors.DuplicateRegExpFlags, {
                    at: nextPos()
                  });
                }
              } else if (isIdentifierChar22(cp) || cp === 92) {
                this.raise(Errors.MalformedRegExpFlags, {
                  at: nextPos()
                });
              } else {
                break;
              }
              ++pos;
              mods += char;
            }
            this.state.pos = pos;
            this.finishToken(137, {
              pattern: content3,
              flags: mods
            });
          }
        },
        {
          key: "readInt",
          value: function readInt3(radix, len) {
            var forceLen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, allowNumSeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
            var _readInt2 = readInt2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false), n2 = _readInt2.n, pos = _readInt2.pos;
            this.state.pos = pos;
            return n2;
          }
        },
        {
          key: "readRadixNumber",
          value: function readRadixNumber(radix) {
            var startLoc = this.state.curPosition();
            var isBigInt = false;
            this.state.pos += 2;
            var val = this.readInt(radix);
            if (val == null) {
              this.raise(Errors.InvalidDigit, {
                at: createPositionWithColumnOffset(startLoc, 2),
                radix
              });
            }
            var next = this.input.charCodeAt(this.state.pos);
            if (next === 110) {
              ++this.state.pos;
              isBigInt = true;
            } else if (next === 109) {
              throw this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            if (isIdentifierStart22(this.codePointAtPos(this.state.pos))) {
              throw this.raise(Errors.NumberIdentifier, {
                at: this.state.curPosition()
              });
            }
            if (isBigInt) {
              var str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, str);
              return;
            }
            this.finishToken(134, val);
          }
        },
        {
          key: "readNumber",
          value: function readNumber(startsWithDot) {
            var start2 = this.state.pos;
            var startLoc = this.state.curPosition();
            var isFloat = false;
            var isBigInt = false;
            var isDecimal2 = false;
            var hasExponent = false;
            var isOctal = false;
            if (!startsWithDot && this.readInt(10) === null) {
              this.raise(Errors.InvalidNumber, {
                at: this.state.curPosition()
              });
            }
            var hasLeadingZero = this.state.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
            if (hasLeadingZero) {
              var integer = this.input.slice(start2, this.state.pos);
              this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
                at: startLoc
              });
              if (!this.state.strict) {
                var underscorePos = integer.indexOf("_");
                if (underscorePos > 0) {
                  this.raise(Errors.ZeroDigitNumericSeparator, {
                    at: createPositionWithColumnOffset(startLoc, underscorePos)
                  });
                }
              }
              isOctal = hasLeadingZero && !/[89]/.test(integer);
            }
            var next = this.input.charCodeAt(this.state.pos);
            if (next === 46 && !isOctal) {
              ++this.state.pos;
              this.readInt(10);
              isFloat = true;
              next = this.input.charCodeAt(this.state.pos);
            }
            if ((next === 69 || next === 101) && !isOctal) {
              next = this.input.charCodeAt(++this.state.pos);
              if (next === 43 || next === 45) {
                ++this.state.pos;
              }
              if (this.readInt(10) === null) {
                this.raise(Errors.InvalidOrMissingExponent, {
                  at: startLoc
                });
              }
              isFloat = true;
              hasExponent = true;
              next = this.input.charCodeAt(this.state.pos);
            }
            if (next === 110) {
              if (isFloat || hasLeadingZero) {
                this.raise(Errors.InvalidBigIntLiteral, {
                  at: startLoc
                });
              }
              ++this.state.pos;
              isBigInt = true;
            }
            if (next === 109) {
              this.expectPlugin("decimal", this.state.curPosition());
              if (hasExponent || hasLeadingZero) {
                this.raise(Errors.InvalidDecimal, {
                  at: startLoc
                });
              }
              ++this.state.pos;
              isDecimal2 = true;
            }
            if (isIdentifierStart22(this.codePointAtPos(this.state.pos))) {
              throw this.raise(Errors.NumberIdentifier, {
                at: this.state.curPosition()
              });
            }
            var str = this.input.slice(start2, this.state.pos).replace(/[_mn]/g, "");
            if (isBigInt) {
              this.finishToken(135, str);
              return;
            }
            if (isDecimal2) {
              this.finishToken(136, str);
              return;
            }
            var val = isOctal ? parseInt(str, 8) : parseFloat(str);
            this.finishToken(134, val);
          }
        },
        {
          key: "readCodePoint",
          value: function readCodePoint3(throwOnInvalid) {
            var _readCodePoint2 = readCodePoint2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint), code22 = _readCodePoint2.code, pos = _readCodePoint2.pos;
            this.state.pos = pos;
            return code22;
          }
        },
        {
          key: "readString",
          value: function readString(quote) {
            var _readStringContents2 = readStringContents2(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string), str = _readStringContents2.str, pos = _readStringContents2.pos, curLine = _readStringContents2.curLine, lineStart = _readStringContents2.lineStart;
            this.state.pos = pos + 1;
            this.state.lineStart = lineStart;
            this.state.curLine = curLine;
            this.finishToken(133, str);
          }
        },
        {
          key: "readTemplateContinuation",
          value: function readTemplateContinuation() {
            if (!this.match(8)) {
              this.unexpected(null, 8);
            }
            this.state.pos--;
            this.readTemplateToken();
          }
        },
        {
          key: "readTemplateToken",
          value: function readTemplateToken() {
            var opening = this.input[this.state.pos];
            var _readStringContents2 = readStringContents2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template), str = _readStringContents2.str, firstInvalidLoc = _readStringContents2.firstInvalidLoc, pos = _readStringContents2.pos, curLine = _readStringContents2.curLine, lineStart = _readStringContents2.lineStart;
            this.state.pos = pos + 1;
            this.state.lineStart = lineStart;
            this.state.curLine = curLine;
            if (firstInvalidLoc) {
              this.state.firstInvalidTemplateEscapePos = new Position3(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
            }
            if (this.input.codePointAt(pos) === 96) {
              this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
            } else {
              this.state.pos++;
              this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
            }
          }
        },
        {
          key: "recordStrictModeErrors",
          value: function recordStrictModeErrors(toParseError, param) {
            var at2 = param.at;
            var index3 = at2.index;
            if (this.state.strict && !this.state.strictErrors.has(index3)) {
              this.raise(toParseError, {
                at: at2
              });
            } else {
              this.state.strictErrors.set(index3, [
                toParseError,
                at2
              ]);
            }
          }
        },
        {
          key: "readWord1",
          value: function readWord1(firstCode) {
            this.state.containsEsc = false;
            var word = "";
            var start2 = this.state.pos;
            var chunkStart = this.state.pos;
            if (firstCode !== void 0) {
              this.state.pos += firstCode <= 65535 ? 1 : 2;
            }
            while (this.state.pos < this.length) {
              var ch = this.codePointAtPos(this.state.pos);
              if (isIdentifierChar22(ch)) {
                this.state.pos += ch <= 65535 ? 1 : 2;
              } else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                var escStart = this.state.curPosition();
                var identifierCheck = this.state.pos === start2 ? isIdentifierStart22 : isIdentifierChar22;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(Errors.MissingUnicodeEscape, {
                    at: this.state.curPosition()
                  });
                  chunkStart = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                var esc = this.readCodePoint(true);
                if (esc !== null) {
                  if (!identifierCheck(esc)) {
                    this.raise(Errors.EscapedCharNotAnIdentifier, {
                      at: escStart
                    });
                  }
                  word += String.fromCodePoint(esc);
                }
                chunkStart = this.state.pos;
              } else {
                break;
              }
            }
            return word + this.input.slice(chunkStart, this.state.pos);
          }
        },
        {
          key: "readWord",
          value: function readWord(firstCode) {
            var word = this.readWord1(firstCode);
            var type3 = keywords$12.get(word);
            if (type3 !== void 0) {
              this.finishToken(type3, tokenLabelName(type3));
            } else {
              this.finishToken(132, word);
            }
          }
        },
        {
          key: "checkKeywordEscapes",
          value: function checkKeywordEscapes() {
            var type3 = this.state.type;
            if (tokenIsKeyword(type3) && this.state.containsEsc) {
              this.raise(Errors.InvalidEscapedReservedWord, {
                at: this.state.startLoc,
                reservedWord: tokenLabelName(type3)
              });
            }
          }
        },
        {
          key: "raise",
          value: function raise2(toParseError, raiseProperties) {
            var at2 = raiseProperties.at, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
            var loc = _instanceof(at2, Position3) ? at2 : at2.loc.start;
            var error = toParseError({
              loc,
              details
            });
            if (!this.options.errorRecovery)
              throw error;
            if (!this.isLookahead)
              this.state.errors.push(error);
            return error;
          }
        },
        {
          key: "raiseOverwrite",
          value: function raiseOverwrite(toParseError, raiseProperties) {
            var at2 = raiseProperties.at, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
            var loc = _instanceof(at2, Position3) ? at2 : at2.loc.start;
            var pos = loc.index;
            var errors = this.state.errors;
            for (var i2 = errors.length - 1; i2 >= 0; i2--) {
              var error = errors[i2];
              if (error.loc.index === pos) {
                return errors[i2] = toParseError({
                  loc,
                  details
                });
              }
              if (error.loc.index < pos)
                break;
            }
            return this.raise(toParseError, raiseProperties);
          }
        },
        {
          key: "updateContext",
          value: function updateContext(prevType) {
          }
        },
        {
          key: "unexpected",
          value: function unexpected(loc, type3) {
            throw this.raise(Errors.UnexpectedToken, {
              expected: type3 ? tokenLabelName(type3) : null,
              at: loc != null ? loc : this.state.startLoc
            });
          }
        },
        {
          key: "expectPlugin",
          value: function expectPlugin(pluginName, loc) {
            if (this.hasPlugin(pluginName)) {
              return true;
            }
            throw this.raise(Errors.MissingPlugin, {
              at: loc != null ? loc : this.state.startLoc,
              missingPlugin: [
                pluginName
              ]
            });
          }
        },
        {
          key: "expectOnePlugin",
          value: function expectOnePlugin(pluginNames) {
            var _this = this;
            if (!pluginNames.some(function(name2) {
              return _this.hasPlugin(name2);
            })) {
              throw this.raise(Errors.MissingOneOfPlugins, {
                at: this.state.startLoc,
                missingPlugin: pluginNames
              });
            }
          }
        },
        {
          key: "errorBuilder",
          value: function errorBuilder(error) {
            var _this = this;
            return function(pos, lineStart, curLine) {
              _this.raise(error, {
                at: buildPosition(pos, lineStart, curLine)
              });
            };
          }
        }
      ]);
      return Tokenizer2;
    }(CommentsParser);
    var ClassScope = function ClassScope2() {
      "use strict";
      _class_call_check(this, ClassScope2);
      __publicField(this, "privateNames", /* @__PURE__ */ new Set());
      __publicField(this, "loneAccessors", /* @__PURE__ */ new Map());
      __publicField(this, "undefinedPrivateNames", /* @__PURE__ */ new Map());
    };
    var ClassScopeHandler = /* @__PURE__ */ function() {
      "use strict";
      function ClassScopeHandler2(parser) {
        _class_call_check(this, ClassScopeHandler2);
        __publicField(this, "parser");
        __publicField(this, "stack", []);
        __publicField(this, "undefinedPrivateNames", /* @__PURE__ */ new Map());
        this.parser = parser;
      }
      _create_class(ClassScopeHandler2, [
        {
          key: "current",
          value: function current2() {
            return this.stack[this.stack.length - 1];
          }
        },
        {
          key: "enter",
          value: function enter() {
            this.stack.push(new ClassScope());
          }
        },
        {
          key: "exit",
          value: function exit2() {
            var oldClassScope = this.stack.pop();
            var current2 = this.current();
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = Array.from(oldClassScope.undefinedPrivateNames)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _step_value = _sliced_to_array(_step8.value, 2), name2 = _step_value[0], loc = _step_value[1];
                if (current2) {
                  if (!current2.undefinedPrivateNames.has(name2)) {
                    current2.undefinedPrivateNames.set(name2, loc);
                  }
                } else {
                  this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                    at: loc,
                    identifierName: name2
                  });
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        {
          key: "declarePrivateName",
          value: function declarePrivateName(name2, elementType, loc) {
            var _this_current = this.current(), privateNames = _this_current.privateNames, loneAccessors = _this_current.loneAccessors, undefinedPrivateNames = _this_current.undefinedPrivateNames;
            var redefined = privateNames.has(name2);
            if (elementType & 3) {
              var accessor = redefined && loneAccessors.get(name2);
              if (accessor) {
                var oldStatic = accessor & 4;
                var newStatic = elementType & 4;
                var oldKind = accessor & 3;
                var newKind = elementType & 3;
                redefined = oldKind === newKind || oldStatic !== newStatic;
                if (!redefined)
                  loneAccessors.delete(name2);
              } else if (!redefined) {
                loneAccessors.set(name2, elementType);
              }
            }
            if (redefined) {
              this.parser.raise(Errors.PrivateNameRedeclaration, {
                at: loc,
                identifierName: name2
              });
            }
            privateNames.add(name2);
            undefinedPrivateNames.delete(name2);
          }
        },
        {
          key: "usePrivateName",
          value: function usePrivateName(name2, loc) {
            var classScope;
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = this.stack[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                classScope = _step8.value;
                if (classScope.privateNames.has(name2))
                  return;
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            if (classScope) {
              classScope.undefinedPrivateNames.set(name2, loc);
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name2
              });
            }
          }
        }
      ]);
      return ClassScopeHandler2;
    }();
    var ExpressionScope = /* @__PURE__ */ function() {
      "use strict";
      function ExpressionScope2() {
        var type3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        _class_call_check(this, ExpressionScope2);
        this.type = type3;
      }
      _create_class(ExpressionScope2, [
        {
          key: "canBeArrowParameterDeclaration",
          value: function canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
        },
        {
          key: "isCertainlyParameterDeclaration",
          value: function isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
      ]);
      return ExpressionScope2;
    }();
    var ArrowHeadParsingScope = /* @__PURE__ */ function(ExpressionScope2) {
      "use strict";
      _inherits(ArrowHeadParsingScope2, ExpressionScope2);
      var _super3 = _create_super(ArrowHeadParsingScope2);
      function ArrowHeadParsingScope2(type3) {
        _class_call_check(this, ArrowHeadParsingScope2);
        var _this;
        _this = _super3.call(this, type3);
        __publicField(_assert_this_initialized(_this), "declarationErrors", /* @__PURE__ */ new Map());
        return _this;
      }
      _create_class(ArrowHeadParsingScope2, [
        {
          key: "recordDeclarationError",
          value: function recordDeclarationError(ParsingErrorClass, param) {
            var at2 = param.at;
            var index3 = at2.index;
            this.declarationErrors.set(index3, [
              ParsingErrorClass,
              at2
            ]);
          }
        },
        {
          key: "clearDeclarationError",
          value: function clearDeclarationError(index3) {
            this.declarationErrors.delete(index3);
          }
        },
        {
          key: "iterateErrors",
          value: function iterateErrors(iterator) {
            this.declarationErrors.forEach(iterator);
          }
        }
      ]);
      return ArrowHeadParsingScope2;
    }(ExpressionScope);
    var ExpressionScopeHandler = /* @__PURE__ */ function() {
      "use strict";
      function ExpressionScopeHandler2(parser) {
        _class_call_check(this, ExpressionScopeHandler2);
        __publicField(this, "parser");
        __publicField(this, "stack", [
          new ExpressionScope()
        ]);
        this.parser = parser;
      }
      _create_class(ExpressionScopeHandler2, [
        {
          key: "enter",
          value: function enter(scope2) {
            this.stack.push(scope2);
          }
        },
        {
          key: "exit",
          value: function exit2() {
            this.stack.pop();
          }
        },
        {
          key: "recordParameterInitializerError",
          value: function recordParameterInitializerError(toParseError, param) {
            var node2 = param.at;
            var origin = {
              at: node2.loc.start
            };
            var stack = this.stack;
            var i2 = stack.length - 1;
            var scope2 = stack[i2];
            while (!scope2.isCertainlyParameterDeclaration()) {
              if (scope2.canBeArrowParameterDeclaration()) {
                scope2.recordDeclarationError(toParseError, origin);
              } else {
                return;
              }
              scope2 = stack[--i2];
            }
            this.parser.raise(toParseError, origin);
          }
        },
        {
          key: "recordArrowParameterBindingError",
          value: function recordArrowParameterBindingError(error, param) {
            var node2 = param.at;
            var stack = this.stack;
            var scope2 = stack[stack.length - 1];
            var origin = {
              at: node2.loc.start
            };
            if (scope2.isCertainlyParameterDeclaration()) {
              this.parser.raise(error, origin);
            } else if (scope2.canBeArrowParameterDeclaration()) {
              scope2.recordDeclarationError(error, origin);
            } else {
              return;
            }
          }
        },
        {
          key: "recordAsyncArrowParametersError",
          value: function recordAsyncArrowParametersError(param) {
            var at2 = param.at;
            var stack = this.stack;
            var i2 = stack.length - 1;
            var scope2 = stack[i2];
            while (scope2.canBeArrowParameterDeclaration()) {
              if (scope2.type === 2) {
                scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                  at: at2
                });
              }
              scope2 = stack[--i2];
            }
          }
        },
        {
          key: "validateAsPattern",
          value: function validateAsPattern() {
            var _this = this;
            var stack = this.stack;
            var currentScope = stack[stack.length - 1];
            if (!currentScope.canBeArrowParameterDeclaration())
              return;
            currentScope.iterateErrors(function(param) {
              var _$_param = _sliced_to_array(param, 2), toParseError = _$_param[0], loc = _$_param[1];
              _this.parser.raise(toParseError, {
                at: loc
              });
              var i2 = stack.length - 2;
              var scope2 = stack[i2];
              while (scope2.canBeArrowParameterDeclaration()) {
                scope2.clearDeclarationError(loc.index);
                scope2 = stack[--i2];
              }
            });
          }
        }
      ]);
      return ExpressionScopeHandler2;
    }();
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = /* @__PURE__ */ function() {
      "use strict";
      function ProductionParameterHandler2() {
        _class_call_check(this, ProductionParameterHandler2);
        __publicField(this, "stacks", []);
      }
      _create_class(ProductionParameterHandler2, [
        {
          key: "enter",
          value: function enter(flags) {
            this.stacks.push(flags);
          }
        },
        {
          key: "exit",
          value: function exit2() {
            this.stacks.pop();
          }
        },
        {
          key: "currentFlags",
          value: function currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
        },
        {
          key: "hasAwait",
          get: function get3() {
            return (this.currentFlags() & 2) > 0;
          }
        },
        {
          key: "hasYield",
          get: function get3() {
            return (this.currentFlags() & 1) > 0;
          }
        },
        {
          key: "hasReturn",
          get: function get3() {
            return (this.currentFlags() & 4) > 0;
          }
        },
        {
          key: "hasIn",
          get: function get3() {
            return (this.currentFlags() & 8) > 0;
          }
        }
      ]);
      return ProductionParameterHandler2;
    }();
    function functionFlags2(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = /* @__PURE__ */ function(Tokenizer2) {
      "use strict";
      _inherits(UtilParser2, Tokenizer2);
      var _super3 = _create_super(UtilParser2);
      function UtilParser2() {
        _class_call_check(this, UtilParser2);
        return _super3.apply(this, arguments);
      }
      _create_class(UtilParser2, [
        {
          key: "addExtra",
          value: function addExtra(node2, key, value1) {
            var enumerable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
            if (!node2)
              return;
            var extra = node2.extra = node2.extra || {};
            if (enumerable) {
              extra[key] = value1;
            } else {
              Object.defineProperty(extra, key, {
                enumerable,
                value: value1
              });
            }
          }
        },
        {
          key: "isContextual",
          value: function isContextual(token) {
            return this.state.type === token && !this.state.containsEsc;
          }
        },
        {
          key: "isUnparsedContextual",
          value: function isUnparsedContextual(nameStart, name2) {
            var nameEnd = nameStart + name2.length;
            if (this.input.slice(nameStart, nameEnd) === name2) {
              var nextCh = this.input.charCodeAt(nameEnd);
              return !(isIdentifierChar22(nextCh) || (nextCh & 64512) === 55296);
            }
            return false;
          }
        },
        {
          key: "isLookaheadContextual",
          value: function isLookaheadContextual(name2) {
            var next = this.nextTokenStart();
            return this.isUnparsedContextual(next, name2);
          }
        },
        {
          key: "eatContextual",
          value: function eatContextual(token) {
            if (this.isContextual(token)) {
              this.next();
              return true;
            }
            return false;
          }
        },
        {
          key: "expectContextual",
          value: function expectContextual(token, toParseError) {
            if (!this.eatContextual(token)) {
              if (toParseError != null) {
                throw this.raise(toParseError, {
                  at: this.state.startLoc
                });
              }
              this.unexpected(null, token);
            }
          }
        },
        {
          key: "canInsertSemicolon",
          value: function canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
        },
        {
          key: "hasPrecedingLineBreak",
          value: function hasPrecedingLineBreak() {
            return lineBreak2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
        },
        {
          key: "hasFollowingLineBreak",
          value: function hasFollowingLineBreak() {
            skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
            return skipWhiteSpaceToLineBreak.test(this.input);
          }
        },
        {
          key: "isLineTerminator",
          value: function isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
        },
        {
          key: "semicolon",
          value: function semicolon2() {
            var allowAsi = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            if (allowAsi ? this.isLineTerminator() : this.eat(13))
              return;
            this.raise(Errors.MissingSemicolon, {
              at: this.state.lastTokEndLoc
            });
          }
        },
        {
          key: "expect",
          value: function expect(type3, loc) {
            this.eat(type3) || this.unexpected(loc, type3);
          }
        },
        {
          key: "tryParse",
          value: function tryParse(fn) {
            var oldState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone();
            var abortSignal = {
              node: null
            };
            try {
              var node2 = fn(function() {
                var node22 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                abortSignal.node = node22;
                throw abortSignal;
              });
              if (this.state.errors.length > oldState.errors.length) {
                var failState = this.state;
                this.state = oldState;
                this.state.tokensLength = failState.tokensLength;
                return {
                  node: node2,
                  error: failState.errors[oldState.errors.length],
                  thrown: false,
                  aborted: false,
                  failState
                };
              }
              return {
                node: node2,
                error: null,
                thrown: false,
                aborted: false,
                failState: null
              };
            } catch (error) {
              var failState1 = this.state;
              this.state = oldState;
              if (_instanceof(error, SyntaxError)) {
                return {
                  node: null,
                  error,
                  thrown: true,
                  aborted: false,
                  failState: failState1
                };
              }
              if (error === abortSignal) {
                return {
                  node: abortSignal.node,
                  error: null,
                  thrown: false,
                  aborted: true,
                  failState: failState1
                };
              }
              throw error;
            }
          }
        },
        {
          key: "checkExpressionErrors",
          value: function checkExpressionErrors(refExpressionErrors, andThrow) {
            if (!refExpressionErrors)
              return false;
            var shorthandAssignLoc = refExpressionErrors.shorthandAssignLoc, doubleProtoLoc = refExpressionErrors.doubleProtoLoc, privateKeyLoc = refExpressionErrors.privateKeyLoc, optionalParametersLoc = refExpressionErrors.optionalParametersLoc;
            var hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
            if (!andThrow) {
              return hasErrors;
            }
            if (shorthandAssignLoc != null) {
              this.raise(Errors.InvalidCoverInitializedName, {
                at: shorthandAssignLoc
              });
            }
            if (doubleProtoLoc != null) {
              this.raise(Errors.DuplicateProto, {
                at: doubleProtoLoc
              });
            }
            if (privateKeyLoc != null) {
              this.raise(Errors.UnexpectedPrivateField, {
                at: privateKeyLoc
              });
            }
            if (optionalParametersLoc != null) {
              this.unexpected(optionalParametersLoc);
            }
          }
        },
        {
          key: "isLiteralPropertyName",
          value: function isLiteralPropertyName() {
            return tokenIsLiteralPropertyName(this.state.type);
          }
        },
        {
          key: "isPrivateName",
          value: function isPrivateName3(node2) {
            return node2.type === "PrivateName";
          }
        },
        {
          key: "getPrivateNameSV",
          value: function getPrivateNameSV(node2) {
            return node2.id.name;
          }
        },
        {
          key: "hasPropertyAsPrivateName",
          value: function hasPropertyAsPrivateName(node2) {
            return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
          }
        },
        {
          key: "isObjectProperty",
          value: function isObjectProperty4(node2) {
            return node2.type === "ObjectProperty";
          }
        },
        {
          key: "isObjectMethod",
          value: function isObjectMethod3(node2) {
            return node2.type === "ObjectMethod";
          }
        },
        {
          key: "initializeScopes",
          value: function initializeScopes() {
            var inModule = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module";
            var _this = this;
            var oldLabels = this.state.labels;
            this.state.labels = [];
            var oldExportedIdentifiers = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            var oldInModule = this.inModule;
            this.inModule = inModule;
            var oldScope = this.scope;
            var ScopeHandler2 = this.getScopeHandler();
            this.scope = new ScopeHandler2(this, inModule);
            var oldProdParam = this.prodParam;
            this.prodParam = new ProductionParameterHandler();
            var oldClassScope = this.classScope;
            this.classScope = new ClassScopeHandler(this);
            var oldExpressionScope = this.expressionScope;
            this.expressionScope = new ExpressionScopeHandler(this);
            return function() {
              _this.state.labels = oldLabels;
              _this.exportedIdentifiers = oldExportedIdentifiers;
              _this.inModule = oldInModule;
              _this.scope = oldScope;
              _this.prodParam = oldProdParam;
              _this.classScope = oldClassScope;
              _this.expressionScope = oldExpressionScope;
            };
          }
        },
        {
          key: "enterInitialScopes",
          value: function enterInitialScopes() {
            var paramFlags = 0;
            if (this.inModule) {
              paramFlags |= 2;
            }
            this.scope.enter(1);
            this.prodParam.enter(paramFlags);
          }
        },
        {
          key: "checkDestructuringPrivate",
          value: function checkDestructuringPrivate(refExpressionErrors) {
            var privateKeyLoc = refExpressionErrors.privateKeyLoc;
            if (privateKeyLoc !== null) {
              this.expectPlugin("destructuringPrivate", privateKeyLoc);
            }
          }
        }
      ]);
      return UtilParser2;
    }(Tokenizer);
    var ExpressionErrors = function ExpressionErrors2() {
      "use strict";
      _class_call_check(this, ExpressionErrors2);
      __publicField(this, "shorthandAssignLoc", null);
      __publicField(this, "doubleProtoLoc", null);
      __publicField(this, "privateKeyLoc", null);
      __publicField(this, "optionalParametersLoc", null);
    };
    var Node3 = function Node4(parser, pos, loc) {
      "use strict";
      _class_call_check(this, Node4);
      __publicField(this, "type", "");
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation3(loc);
      if (parser === null || parser === void 0 ? void 0 : parser.options.ranges)
        this.range = [
          pos,
          0
        ];
      if (parser === null || parser === void 0 ? void 0 : parser.filename)
        this.loc.filename = parser.filename;
    };
    var NodePrototype = Node3.prototype;
    function clonePlaceholder(node2) {
      return cloneIdentifier(node2);
    }
    function cloneIdentifier(node2) {
      var type3 = node2.type, start2 = node2.start, end = node2.end, loc = node2.loc, range = node2.range, extra = node2.extra, name2 = node2.name;
      var cloned = Object.create(NodePrototype);
      cloned.type = type3;
      cloned.start = start2;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name2;
      if (type3 === "Placeholder") {
        cloned.expectedNode = node2.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node2) {
      var type3 = node2.type, start2 = node2.start, end = node2.end, loc = node2.loc, range = node2.range, extra = node2.extra;
      if (type3 === "Placeholder") {
        return clonePlaceholder(node2);
      }
      var cloned = Object.create(NodePrototype);
      cloned.type = type3;
      cloned.start = start2;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node2.raw !== void 0) {
        cloned.raw = node2.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node2.value;
      return cloned;
    }
    var NodeUtils = /* @__PURE__ */ function(UtilParser2) {
      "use strict";
      _inherits(NodeUtils2, UtilParser2);
      var _super3 = _create_super(NodeUtils2);
      function NodeUtils2() {
        _class_call_check(this, NodeUtils2);
        return _super3.apply(this, arguments);
      }
      _create_class(NodeUtils2, [
        {
          key: "startNode",
          value: function startNode() {
            return new Node3(this, this.state.start, this.state.startLoc);
          }
        },
        {
          key: "startNodeAt",
          value: function startNodeAt(loc) {
            return new Node3(this, loc.index, loc);
          }
        },
        {
          key: "startNodeAtNode",
          value: function startNodeAtNode(type3) {
            return this.startNodeAt(type3.loc.start);
          }
        },
        {
          key: "finishNode",
          value: function finishNode(node2, type3) {
            return this.finishNodeAt(node2, type3, this.state.lastTokEndLoc);
          }
        },
        {
          key: "finishNodeAt",
          value: function finishNodeAt2(node2, type3, endLoc) {
            node2.type = type3;
            node2.end = endLoc.index;
            node2.loc.end = endLoc;
            if (this.options.ranges)
              node2.range[1] = endLoc.index;
            if (this.options.attachComment)
              this.processComment(node2);
            return node2;
          }
        },
        {
          key: "resetStartLocation",
          value: function resetStartLocation(node2, startLoc) {
            node2.start = startLoc.index;
            node2.loc.start = startLoc;
            if (this.options.ranges)
              node2.range[0] = startLoc.index;
          }
        },
        {
          key: "resetEndLocation",
          value: function resetEndLocation(node2) {
            var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
            node2.end = endLoc.index;
            node2.loc.end = endLoc;
            if (this.options.ranges)
              node2.range[1] = endLoc.index;
          }
        },
        {
          key: "resetStartLocationFromNode",
          value: function resetStartLocationFromNode(node2, locationNode) {
            this.resetStartLocation(node2, locationNode.loc.start);
          }
        }
      ]);
      return NodeUtils2;
    }(UtilParser);
    var reservedTypes = /* @__PURE__ */ new Set([
      "_",
      "any",
      "bool",
      "boolean",
      "empty",
      "extends",
      "false",
      "interface",
      "mixed",
      "null",
      "number",
      "static",
      "string",
      "true",
      "typeof",
      "void"
    ]);
    var FlowErrors = ParseErrorEnum(_templateObject1())({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: function(param) {
        var reservedType = param.reservedType;
        return "Cannot overwrite reserved type ".concat(reservedType, ".");
      },
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: function(param) {
        var memberName = param.memberName, enumName = param.enumName;
        return "Boolean enum members need to be initialized. Use either `".concat(memberName, " = true,` or `").concat(memberName, " = false,` in enum `").concat(enumName, "`.");
      },
      EnumDuplicateMemberName: function(param) {
        var memberName = param.memberName, enumName = param.enumName;
        return "Enum member names need to be unique, but the name `".concat(memberName, "` has already been used before in enum `").concat(enumName, "`.");
      },
      EnumInconsistentMemberValues: function(param) {
        var enumName = param.enumName;
        return "Enum `".concat(enumName, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
      },
      EnumInvalidExplicitType: function(param) {
        var invalidEnumType = param.invalidEnumType, enumName = param.enumName;
        return "Enum type `".concat(invalidEnumType, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(enumName, "`.");
      },
      EnumInvalidExplicitTypeUnknownSupplied: function(param) {
        var enumName = param.enumName;
        return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(enumName, "`.");
      },
      EnumInvalidMemberInitializerPrimaryType: function(param) {
        var enumName = param.enumName, memberName = param.memberName, explicitType = param.explicitType;
        return "Enum `".concat(enumName, "` has type `").concat(explicitType, "`, so the initializer of `").concat(memberName, "` needs to be a ").concat(explicitType, " literal.");
      },
      EnumInvalidMemberInitializerSymbolType: function(param) {
        var enumName = param.enumName, memberName = param.memberName;
        return "Symbol enum members cannot be initialized. Use `".concat(memberName, ",` in enum `").concat(enumName, "`.");
      },
      EnumInvalidMemberInitializerUnknownType: function(param) {
        var enumName = param.enumName, memberName = param.memberName;
        return "The enum member initializer for `".concat(memberName, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(enumName, "`.");
      },
      EnumInvalidMemberName: function(param) {
        var enumName = param.enumName, memberName = param.memberName, suggestion = param.suggestion;
        return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(memberName, "`, consider using `").concat(suggestion, "`, in enum `").concat(enumName, "`.");
      },
      EnumNumberMemberNotInitialized: function(param) {
        var enumName = param.enumName, memberName = param.memberName;
        return "Number enum members need to be initialized, e.g. `".concat(memberName, " = 1` in enum `").concat(enumName, "`.");
      },
      EnumStringMemberInconsistentlyInitialized: function(param) {
        var enumName = param.enumName;
        return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(enumName, "`.");
      },
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {}),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: function(param) {
        var reservedType = param.reservedType;
        return "Unexpected reserved type ".concat(reservedType, ".");
      },
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: function(param) {
        var unsupportedExportKind = param.unsupportedExportKind, suggestion = param.suggestion;
        return "`declare export ".concat(unsupportedExportKind, "` is not supported. Use `").concat(suggestion, "` instead.");
      },
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node2) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list3, test) {
      var list1 = [];
      var list22 = [];
      for (var i2 = 0; i2 < list3.length; i2++) {
        (test(list3[i2], i2, list3) ? list1 : list22).push(list3[i2]);
      }
      return [
        list1,
        list22
      ];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow3 = function(superClass) {
      var FlowParserMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(FlowParserMixin2, superClass2);
        var _super3 = _create_super(FlowParserMixin2);
        function FlowParserMixin2() {
          _class_call_check(this, FlowParserMixin2);
          var _this;
          _this = _super3.call.apply(_super3, [
            this
          ].concat(Array.prototype.slice.call(arguments)));
          __publicField(_assert_this_initialized(_this), "flowPragma");
          return _this;
        }
        _create_class(FlowParserMixin2, [
          {
            key: "getScopeHandler",
            value: function getScopeHandler() {
              return FlowScopeHandler;
            }
          },
          {
            key: "shouldParseTypes",
            value: function shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
          },
          {
            key: "shouldParseEnums",
            value: function shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
          },
          {
            key: "finishToken",
            value: function finishToken(type3, val) {
              if (type3 !== 133 && type3 !== 13 && type3 !== 28) {
                if (this.flowPragma === void 0) {
                  this.flowPragma = null;
                }
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "finishToken", this).call(this, type3, val);
            }
          },
          {
            key: "addComment",
            value: function addComment3(comment2) {
              if (this.flowPragma === void 0) {
                var matches = FLOW_PRAGMA_REGEX.exec(comment2.value);
                if (!matches)
                  ;
                else if (matches[1] === "flow") {
                  this.flowPragma = "flow";
                } else if (matches[1] === "noflow") {
                  this.flowPragma = "noflow";
                } else {
                  throw new Error("Unexpected flow pragma");
                }
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "addComment", this).call(this, comment2);
            }
          },
          {
            key: "flowParseTypeInitialiser",
            value: function flowParseTypeInitialiser(tok) {
              var oldInType = this.state.inType;
              this.state.inType = true;
              this.expect(tok || 14);
              var type3 = this.flowParseType();
              this.state.inType = oldInType;
              return type3;
            }
          },
          {
            key: "flowParsePredicate",
            value: function flowParsePredicate() {
              var node2 = this.startNode();
              var moduloLoc = this.state.startLoc;
              this.next();
              this.expectContextual(110);
              if (this.state.lastTokStart > moduloLoc.index + 1) {
                this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
                  at: moduloLoc
                });
              }
              if (this.eat(10)) {
                node2.value = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExpression", this).call(this);
                this.expect(11);
                return this.finishNode(node2, "DeclaredPredicate");
              } else {
                return this.finishNode(node2, "InferredPredicate");
              }
            }
          },
          {
            key: "flowParseTypeAndPredicateInitialiser",
            value: function flowParseTypeAndPredicateInitialiser() {
              var oldInType = this.state.inType;
              this.state.inType = true;
              this.expect(14);
              var type3 = null;
              var predicate = null;
              if (this.match(54)) {
                this.state.inType = oldInType;
                predicate = this.flowParsePredicate();
              } else {
                type3 = this.flowParseType();
                this.state.inType = oldInType;
                if (this.match(54)) {
                  predicate = this.flowParsePredicate();
                }
              }
              return [
                type3,
                predicate
              ];
            }
          },
          {
            key: "flowParseDeclareClass",
            value: function flowParseDeclareClass(node2) {
              this.next();
              this.flowParseInterfaceish(node2, true);
              return this.finishNode(node2, "DeclareClass");
            }
          },
          {
            key: "flowParseDeclareFunction",
            value: function flowParseDeclareFunction(node2) {
              this.next();
              var id = node2.id = this.parseIdentifier();
              var typeNode = this.startNode();
              var typeContainer = this.startNode();
              if (this.match(47)) {
                typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                typeNode.typeParameters = null;
              }
              this.expect(10);
              var tmp = this.flowParseFunctionTypeParams();
              typeNode.params = tmp.params;
              typeNode.rest = tmp.rest;
              typeNode.this = tmp._this;
              this.expect(11);
              var ref2;
              ref2 = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.returnType = ref2[0], node2.predicate = ref2[1], ref2;
              typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
              id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
              this.resetEndLocation(id);
              this.semicolon();
              this.scope.declareName(node2.id.name, 2048, node2.id.loc.start);
              return this.finishNode(node2, "DeclareFunction");
            }
          },
          {
            key: "flowParseDeclare",
            value: function flowParseDeclare(node2, insideModule) {
              if (this.match(80)) {
                return this.flowParseDeclareClass(node2);
              } else if (this.match(68)) {
                return this.flowParseDeclareFunction(node2);
              } else if (this.match(74)) {
                return this.flowParseDeclareVariable(node2);
              } else if (this.eatContextual(127)) {
                if (this.match(16)) {
                  return this.flowParseDeclareModuleExports(node2);
                } else {
                  if (insideModule) {
                    this.raise(FlowErrors.NestedDeclareModule, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                  return this.flowParseDeclareModule(node2);
                }
              } else if (this.isContextual(130)) {
                return this.flowParseDeclareTypeAlias(node2);
              } else if (this.isContextual(131)) {
                return this.flowParseDeclareOpaqueType(node2);
              } else if (this.isContextual(129)) {
                return this.flowParseDeclareInterface(node2);
              } else if (this.match(82)) {
                return this.flowParseDeclareExportDeclaration(node2, insideModule);
              } else {
                this.unexpected();
              }
            }
          },
          {
            key: "flowParseDeclareVariable",
            value: function flowParseDeclareVariable(node2) {
              this.next();
              node2.id = this.flowParseTypeAnnotatableIdentifier(true);
              this.scope.declareName(node2.id.name, 5, node2.id.loc.start);
              this.semicolon();
              return this.finishNode(node2, "DeclareVariable");
            }
          },
          {
            key: "flowParseDeclareModule",
            value: function flowParseDeclareModule(node2) {
              var _this = this;
              this.scope.enter(0);
              if (this.match(133)) {
                node2.id = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExprAtom", this).call(this);
              } else {
                node2.id = this.parseIdentifier();
              }
              var bodyNode = node2.body = this.startNode();
              var body = bodyNode.body = [];
              this.expect(5);
              while (!this.match(8)) {
                var bodyNode2 = this.startNode();
                if (this.match(83)) {
                  this.next();
                  if (!this.isContextual(130) && !this.match(87)) {
                    this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                  _get(_get_prototype_of(FlowParserMixin2.prototype), "parseImport", this).call(this, bodyNode2);
                } else {
                  this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
                  bodyNode2 = this.flowParseDeclare(bodyNode2, true);
                }
                body.push(bodyNode2);
              }
              this.scope.exit();
              this.expect(8);
              this.finishNode(bodyNode, "BlockStatement");
              var kind = null;
              var hasModuleExport = false;
              body.forEach(function(bodyElement) {
                if (isEsModuleType(bodyElement)) {
                  if (kind === "CommonJS") {
                    _this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                      at: bodyElement
                    });
                  }
                  kind = "ES";
                } else if (bodyElement.type === "DeclareModuleExports") {
                  if (hasModuleExport) {
                    _this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                      at: bodyElement
                    });
                  }
                  if (kind === "ES") {
                    _this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                      at: bodyElement
                    });
                  }
                  kind = "CommonJS";
                  hasModuleExport = true;
                }
              });
              node2.kind = kind || "CommonJS";
              return this.finishNode(node2, "DeclareModule");
            }
          },
          {
            key: "flowParseDeclareExportDeclaration",
            value: function flowParseDeclareExportDeclaration(node2, insideModule) {
              this.expect(82);
              if (this.eat(65)) {
                if (this.match(68) || this.match(80)) {
                  node2.declaration = this.flowParseDeclare(this.startNode());
                } else {
                  node2.declaration = this.flowParseType();
                  this.semicolon();
                }
                node2.default = true;
                return this.finishNode(node2, "DeclareExportDeclaration");
              } else {
                if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
                  var label = this.state.value;
                  throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                    at: this.state.startLoc,
                    unsupportedExportKind: label,
                    suggestion: exportSuggestions[label]
                  });
                }
                if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
                  node2.declaration = this.flowParseDeclare(this.startNode());
                  node2.default = false;
                  return this.finishNode(node2, "DeclareExportDeclaration");
                } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
                  node2 = this.parseExport(node2, null);
                  if (node2.type === "ExportNamedDeclaration") {
                    node2.type = "ExportDeclaration";
                    node2.default = false;
                    delete node2.exportKind;
                  }
                  node2.type = "Declare" + node2.type;
                  return node2;
                }
              }
              this.unexpected();
            }
          },
          {
            key: "flowParseDeclareModuleExports",
            value: function flowParseDeclareModuleExports(node2) {
              this.next();
              this.expectContextual(111);
              node2.typeAnnotation = this.flowParseTypeAnnotation();
              this.semicolon();
              return this.finishNode(node2, "DeclareModuleExports");
            }
          },
          {
            key: "flowParseDeclareTypeAlias",
            value: function flowParseDeclareTypeAlias(node2) {
              this.next();
              var finished = this.flowParseTypeAlias(node2);
              finished.type = "DeclareTypeAlias";
              return finished;
            }
          },
          {
            key: "flowParseDeclareOpaqueType",
            value: function flowParseDeclareOpaqueType(node2) {
              this.next();
              var finished = this.flowParseOpaqueType(node2, true);
              finished.type = "DeclareOpaqueType";
              return finished;
            }
          },
          {
            key: "flowParseDeclareInterface",
            value: function flowParseDeclareInterface(node2) {
              this.next();
              this.flowParseInterfaceish(node2, false);
              return this.finishNode(node2, "DeclareInterface");
            }
          },
          {
            key: "flowParseInterfaceish",
            value: function flowParseInterfaceish(node2, isClass3) {
              node2.id = this.flowParseRestrictedIdentifier(!isClass3, true);
              this.scope.declareName(node2.id.name, isClass3 ? 17 : 8201, node2.id.loc.start);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.extends = [];
              if (this.eat(81)) {
                do {
                  node2.extends.push(this.flowParseInterfaceExtends());
                } while (!isClass3 && this.eat(12));
              }
              if (isClass3) {
                node2.implements = [];
                node2.mixins = [];
                if (this.eatContextual(117)) {
                  do {
                    node2.mixins.push(this.flowParseInterfaceExtends());
                  } while (this.eat(12));
                }
                if (this.eatContextual(113)) {
                  do {
                    node2.implements.push(this.flowParseInterfaceExtends());
                  } while (this.eat(12));
                }
              }
              node2.body = this.flowParseObjectType({
                allowStatic: isClass3,
                allowExact: false,
                allowSpread: false,
                allowProto: isClass3,
                allowInexact: false
              });
            }
          },
          {
            key: "flowParseInterfaceExtends",
            value: function flowParseInterfaceExtends() {
              var node2 = this.startNode();
              node2.id = this.flowParseQualifiedTypeIdentifier();
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              return this.finishNode(node2, "InterfaceExtends");
            }
          },
          {
            key: "flowParseInterface",
            value: function flowParseInterface(node2) {
              this.flowParseInterfaceish(node2, false);
              return this.finishNode(node2, "InterfaceDeclaration");
            }
          },
          {
            key: "checkNotUnderscore",
            value: function checkNotUnderscore(word) {
              if (word === "_") {
                this.raise(FlowErrors.UnexpectedReservedUnderscore, {
                  at: this.state.startLoc
                });
              }
            }
          },
          {
            key: "checkReservedType",
            value: function checkReservedType(word, startLoc, declaration) {
              if (!reservedTypes.has(word))
                return;
              this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
                at: startLoc,
                reservedType: word
              });
            }
          },
          {
            key: "flowParseRestrictedIdentifier",
            value: function flowParseRestrictedIdentifier(liberal, declaration) {
              this.checkReservedType(this.state.value, this.state.startLoc, declaration);
              return this.parseIdentifier(liberal);
            }
          },
          {
            key: "flowParseTypeAlias",
            value: function flowParseTypeAlias(node2) {
              node2.id = this.flowParseRestrictedIdentifier(false, true);
              this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.right = this.flowParseTypeInitialiser(29);
              this.semicolon();
              return this.finishNode(node2, "TypeAlias");
            }
          },
          {
            key: "flowParseOpaqueType",
            value: function flowParseOpaqueType(node2, declare) {
              this.expectContextual(130);
              node2.id = this.flowParseRestrictedIdentifier(true, true);
              this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              } else {
                node2.typeParameters = null;
              }
              node2.supertype = null;
              if (this.match(14)) {
                node2.supertype = this.flowParseTypeInitialiser(14);
              }
              node2.impltype = null;
              if (!declare) {
                node2.impltype = this.flowParseTypeInitialiser(29);
              }
              this.semicolon();
              return this.finishNode(node2, "OpaqueType");
            }
          },
          {
            key: "flowParseTypeParameter",
            value: function flowParseTypeParameter() {
              var requireDefault = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var nodeStartLoc = this.state.startLoc;
              var node2 = this.startNode();
              var variance2 = this.flowParseVariance();
              var ident = this.flowParseTypeAnnotatableIdentifier();
              node2.name = ident.name;
              node2.variance = variance2;
              node2.bound = ident.typeAnnotation;
              if (this.match(29)) {
                this.eat(29);
                node2.default = this.flowParseType();
              } else {
                if (requireDefault) {
                  this.raise(FlowErrors.MissingTypeParamDefault, {
                    at: nodeStartLoc
                  });
                }
              }
              return this.finishNode(node2, "TypeParameter");
            }
          },
          {
            key: "flowParseTypeParameterDeclaration",
            value: function flowParseTypeParameterDeclaration() {
              var oldInType = this.state.inType;
              var node2 = this.startNode();
              node2.params = [];
              this.state.inType = true;
              if (this.match(47) || this.match(142)) {
                this.next();
              } else {
                this.unexpected();
              }
              var defaultRequired = false;
              do {
                var typeParameter2 = this.flowParseTypeParameter(defaultRequired);
                node2.params.push(typeParameter2);
                if (typeParameter2.default) {
                  defaultRequired = true;
                }
                if (!this.match(48)) {
                  this.expect(12);
                }
              } while (!this.match(48));
              this.expect(48);
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterDeclaration");
            }
          },
          {
            key: "flowParseTypeParameterInstantiation",
            value: function flowParseTypeParameterInstantiation() {
              var node2 = this.startNode();
              var oldInType = this.state.inType;
              node2.params = [];
              this.state.inType = true;
              this.expect(47);
              var oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = false;
              while (!this.match(48)) {
                node2.params.push(this.flowParseType());
                if (!this.match(48)) {
                  this.expect(12);
                }
              }
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              this.expect(48);
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterInstantiation");
            }
          },
          {
            key: "flowParseTypeParameterInstantiationCallOrNew",
            value: function flowParseTypeParameterInstantiationCallOrNew() {
              var node2 = this.startNode();
              var oldInType = this.state.inType;
              node2.params = [];
              this.state.inType = true;
              this.expect(47);
              while (!this.match(48)) {
                node2.params.push(this.flowParseTypeOrImplicitInstantiation());
                if (!this.match(48)) {
                  this.expect(12);
                }
              }
              this.expect(48);
              this.state.inType = oldInType;
              return this.finishNode(node2, "TypeParameterInstantiation");
            }
          },
          {
            key: "flowParseInterfaceType",
            value: function flowParseInterfaceType() {
              var node2 = this.startNode();
              this.expectContextual(129);
              node2.extends = [];
              if (this.eat(81)) {
                do {
                  node2.extends.push(this.flowParseInterfaceExtends());
                } while (this.eat(12));
              }
              node2.body = this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: false,
                allowProto: false,
                allowInexact: false
              });
              return this.finishNode(node2, "InterfaceTypeAnnotation");
            }
          },
          {
            key: "flowParseObjectPropertyKey",
            value: function flowParseObjectPropertyKey() {
              return this.match(134) || this.match(133) ? _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExprAtom", this).call(this) : this.parseIdentifier(true);
            }
          },
          {
            key: "flowParseObjectTypeIndexer",
            value: function flowParseObjectTypeIndexer(node2, isStatic2, variance2) {
              node2.static = isStatic2;
              if (this.lookahead().type === 14) {
                node2.id = this.flowParseObjectPropertyKey();
                node2.key = this.flowParseTypeInitialiser();
              } else {
                node2.id = null;
                node2.key = this.flowParseType();
              }
              this.expect(3);
              node2.value = this.flowParseTypeInitialiser();
              node2.variance = variance2;
              return this.finishNode(node2, "ObjectTypeIndexer");
            }
          },
          {
            key: "flowParseObjectTypeInternalSlot",
            value: function flowParseObjectTypeInternalSlot(node2, isStatic2) {
              node2.static = isStatic2;
              node2.id = this.flowParseObjectPropertyKey();
              this.expect(3);
              this.expect(3);
              if (this.match(47) || this.match(10)) {
                node2.method = true;
                node2.optional = false;
                node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
              } else {
                node2.method = false;
                if (this.eat(17)) {
                  node2.optional = true;
                }
                node2.value = this.flowParseTypeInitialiser();
              }
              return this.finishNode(node2, "ObjectTypeInternalSlot");
            }
          },
          {
            key: "flowParseObjectTypeMethodish",
            value: function flowParseObjectTypeMethodish(node2) {
              node2.params = [];
              node2.rest = null;
              node2.typeParameters = null;
              node2.this = null;
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              this.expect(10);
              if (this.match(78)) {
                node2.this = this.flowParseFunctionTypeParam(true);
                node2.this.name = null;
                if (!this.match(11)) {
                  this.expect(12);
                }
              }
              while (!this.match(11) && !this.match(21)) {
                node2.params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) {
                  this.expect(12);
                }
              }
              if (this.eat(21)) {
                node2.rest = this.flowParseFunctionTypeParam(false);
              }
              this.expect(11);
              node2.returnType = this.flowParseTypeInitialiser();
              return this.finishNode(node2, "FunctionTypeAnnotation");
            }
          },
          {
            key: "flowParseObjectTypeCallProperty",
            value: function flowParseObjectTypeCallProperty(node2, isStatic2) {
              var valueNode = this.startNode();
              node2.static = isStatic2;
              node2.value = this.flowParseObjectTypeMethodish(valueNode);
              return this.finishNode(node2, "ObjectTypeCallProperty");
            }
          },
          {
            key: "flowParseObjectType",
            value: function flowParseObjectType(param) {
              var allowStatic = param.allowStatic, allowExact = param.allowExact, allowSpread = param.allowSpread, allowProto = param.allowProto, allowInexact = param.allowInexact;
              var oldInType = this.state.inType;
              this.state.inType = true;
              var nodeStart = this.startNode();
              nodeStart.callProperties = [];
              nodeStart.properties = [];
              nodeStart.indexers = [];
              nodeStart.internalSlots = [];
              var endDelim;
              var exact;
              var inexact = false;
              if (allowExact && this.match(6)) {
                this.expect(6);
                endDelim = 9;
                exact = true;
              } else {
                this.expect(5);
                endDelim = 8;
                exact = false;
              }
              nodeStart.exact = exact;
              while (!this.match(endDelim)) {
                var isStatic2 = false;
                var protoStartLoc = null;
                var inexactStartLoc = null;
                var node2 = this.startNode();
                if (allowProto && this.isContextual(118)) {
                  var lookahead2 = this.lookahead();
                  if (lookahead2.type !== 14 && lookahead2.type !== 17) {
                    this.next();
                    protoStartLoc = this.state.startLoc;
                    allowStatic = false;
                  }
                }
                if (allowStatic && this.isContextual(106)) {
                  var lookahead1 = this.lookahead();
                  if (lookahead1.type !== 14 && lookahead1.type !== 17) {
                    this.next();
                    isStatic2 = true;
                  }
                }
                var variance2 = this.flowParseVariance();
                if (this.eat(0)) {
                  if (protoStartLoc != null) {
                    this.unexpected(protoStartLoc);
                  }
                  if (this.eat(0)) {
                    if (variance2) {
                      this.unexpected(variance2.loc.start);
                    }
                    nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic2));
                  } else {
                    nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic2, variance2));
                  }
                } else if (this.match(10) || this.match(47)) {
                  if (protoStartLoc != null) {
                    this.unexpected(protoStartLoc);
                  }
                  if (variance2) {
                    this.unexpected(variance2.loc.start);
                  }
                  nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic2));
                } else {
                  var kind = "init";
                  if (this.isContextual(99) || this.isContextual(104)) {
                    var lookahead22 = this.lookahead();
                    if (tokenIsLiteralPropertyName(lookahead22.type)) {
                      kind = this.state.value;
                      this.next();
                    }
                  }
                  var propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic2, protoStartLoc, variance2, kind, allowSpread, allowInexact !== null && allowInexact !== void 0 ? allowInexact : !exact);
                  if (propOrInexact === null) {
                    inexact = true;
                    inexactStartLoc = this.state.lastTokStartLoc;
                  } else {
                    nodeStart.properties.push(propOrInexact);
                  }
                }
                this.flowObjectTypeSemicolon();
                if (inexactStartLoc && !this.match(8) && !this.match(9)) {
                  this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                    at: inexactStartLoc
                  });
                }
              }
              this.expect(endDelim);
              if (allowSpread) {
                nodeStart.inexact = inexact;
              }
              var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
              this.state.inType = oldInType;
              return out;
            }
          },
          {
            key: "flowParseObjectTypeProperty",
            value: function flowParseObjectTypeProperty(node2, isStatic2, protoStartLoc, variance2, kind, allowSpread, allowInexact) {
              if (this.eat(21)) {
                var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                if (isInexactToken) {
                  if (!allowSpread) {
                    this.raise(FlowErrors.InexactInsideNonObject, {
                      at: this.state.lastTokStartLoc
                    });
                  } else if (!allowInexact) {
                    this.raise(FlowErrors.InexactInsideExact, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                  if (variance2) {
                    this.raise(FlowErrors.InexactVariance, {
                      at: variance2
                    });
                  }
                  return null;
                }
                if (!allowSpread) {
                  this.raise(FlowErrors.UnexpectedSpreadType, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (protoStartLoc != null) {
                  this.unexpected(protoStartLoc);
                }
                if (variance2) {
                  this.raise(FlowErrors.SpreadVariance, {
                    at: variance2
                  });
                }
                node2.argument = this.flowParseType();
                return this.finishNode(node2, "ObjectTypeSpreadProperty");
              } else {
                node2.key = this.flowParseObjectPropertyKey();
                node2.static = isStatic2;
                node2.proto = protoStartLoc != null;
                node2.kind = kind;
                var optional = false;
                if (this.match(47) || this.match(10)) {
                  node2.method = true;
                  if (protoStartLoc != null) {
                    this.unexpected(protoStartLoc);
                  }
                  if (variance2) {
                    this.unexpected(variance2.loc.start);
                  }
                  node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
                  if (kind === "get" || kind === "set") {
                    this.flowCheckGetterSetterParams(node2);
                  }
                  if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
                    this.raise(FlowErrors.ThisParamBannedInConstructor, {
                      at: node2.value.this
                    });
                  }
                } else {
                  if (kind !== "init")
                    this.unexpected();
                  node2.method = false;
                  if (this.eat(17)) {
                    optional = true;
                  }
                  node2.value = this.flowParseTypeInitialiser();
                  node2.variance = variance2;
                }
                node2.optional = optional;
                return this.finishNode(node2, "ObjectTypeProperty");
              }
            }
          },
          {
            key: "flowCheckGetterSetterParams",
            value: function flowCheckGetterSetterParams(property) {
              var paramCount = property.kind === "get" ? 0 : 1;
              var length = property.value.params.length + (property.value.rest ? 1 : 0);
              if (property.value.this) {
                this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
                  at: property.value.this
                });
              }
              if (length !== paramCount) {
                this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
                  at: property
                });
              }
              if (property.kind === "set" && property.value.rest) {
                this.raise(Errors.BadSetterRestParameter, {
                  at: property
                });
              }
            }
          },
          {
            key: "flowObjectTypeSemicolon",
            value: function flowObjectTypeSemicolon() {
              if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
                this.unexpected();
              }
            }
          },
          {
            key: "flowParseQualifiedTypeIdentifier",
            value: function flowParseQualifiedTypeIdentifier(startLoc, id) {
              startLoc !== null && startLoc !== void 0 ? startLoc : startLoc = this.state.startLoc;
              var node2 = id || this.flowParseRestrictedIdentifier(true);
              while (this.eat(16)) {
                var node22 = this.startNodeAt(startLoc);
                node22.qualification = node2;
                node22.id = this.flowParseRestrictedIdentifier(true);
                node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
              }
              return node2;
            }
          },
          {
            key: "flowParseGenericType",
            value: function flowParseGenericType(startLoc, id) {
              var node2 = this.startNodeAt(startLoc);
              node2.typeParameters = null;
              node2.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              }
              return this.finishNode(node2, "GenericTypeAnnotation");
            }
          },
          {
            key: "flowParseTypeofType",
            value: function flowParseTypeofType() {
              var node2 = this.startNode();
              this.expect(87);
              node2.argument = this.flowParsePrimaryType();
              return this.finishNode(node2, "TypeofTypeAnnotation");
            }
          },
          {
            key: "flowParseTupleType",
            value: function flowParseTupleType() {
              var node2 = this.startNode();
              node2.types = [];
              this.expect(0);
              while (this.state.pos < this.length && !this.match(3)) {
                node2.types.push(this.flowParseType());
                if (this.match(3))
                  break;
                this.expect(12);
              }
              this.expect(3);
              return this.finishNode(node2, "TupleTypeAnnotation");
            }
          },
          {
            key: "flowParseFunctionTypeParam",
            value: function flowParseFunctionTypeParam(first) {
              var name2 = null;
              var optional = false;
              var typeAnnotation2 = null;
              var node2 = this.startNode();
              var lh = this.lookahead();
              var isThis = this.state.type === 78;
              if (lh.type === 14 || lh.type === 17) {
                if (isThis && !first) {
                  this.raise(FlowErrors.ThisParamMustBeFirst, {
                    at: node2
                  });
                }
                name2 = this.parseIdentifier(isThis);
                if (this.eat(17)) {
                  optional = true;
                  if (isThis) {
                    this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                      at: node2
                    });
                  }
                }
                typeAnnotation2 = this.flowParseTypeInitialiser();
              } else {
                typeAnnotation2 = this.flowParseType();
              }
              node2.name = name2;
              node2.optional = optional;
              node2.typeAnnotation = typeAnnotation2;
              return this.finishNode(node2, "FunctionTypeParam");
            }
          },
          {
            key: "reinterpretTypeAsFunctionTypeParam",
            value: function reinterpretTypeAsFunctionTypeParam(type3) {
              var node2 = this.startNodeAt(type3.loc.start);
              node2.name = null;
              node2.optional = false;
              node2.typeAnnotation = type3;
              return this.finishNode(node2, "FunctionTypeParam");
            }
          },
          {
            key: "flowParseFunctionTypeParams",
            value: function flowParseFunctionTypeParams() {
              var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              var rest = null;
              var _this = null;
              if (this.match(78)) {
                _this = this.flowParseFunctionTypeParam(true);
                _this.name = null;
                if (!this.match(11)) {
                  this.expect(12);
                }
              }
              while (!this.match(11) && !this.match(21)) {
                params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) {
                  this.expect(12);
                }
              }
              if (this.eat(21)) {
                rest = this.flowParseFunctionTypeParam(false);
              }
              return {
                params,
                rest,
                _this
              };
            }
          },
          {
            key: "flowIdentToTypeAnnotation",
            value: function flowIdentToTypeAnnotation(startLoc, node2, id) {
              switch (id.name) {
                case "any":
                  return this.finishNode(node2, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(node2, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(node2, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(node2, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(node2, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(node2, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(node2, "SymbolTypeAnnotation");
                default:
                  this.checkNotUnderscore(id.name);
                  return this.flowParseGenericType(startLoc, id);
              }
            }
          },
          {
            key: "flowParsePrimaryType",
            value: function flowParsePrimaryType() {
              var startLoc = this.state.startLoc;
              var node2 = this.startNode();
              var tmp;
              var type3;
              var isGroupedType = false;
              var oldNoAnonFunctionType = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case 5:
                  return this.flowParseObjectType({
                    allowStatic: false,
                    allowExact: false,
                    allowSpread: true,
                    allowProto: false,
                    allowInexact: true
                  });
                case 6:
                  return this.flowParseObjectType({
                    allowStatic: false,
                    allowExact: true,
                    allowSpread: true,
                    allowProto: false,
                    allowInexact: false
                  });
                case 0:
                  this.state.noAnonFunctionType = false;
                  type3 = this.flowParseTupleType();
                  this.state.noAnonFunctionType = oldNoAnonFunctionType;
                  return type3;
                case 47:
                  node2.typeParameters = this.flowParseTypeParameterDeclaration();
                  this.expect(10);
                  tmp = this.flowParseFunctionTypeParams();
                  node2.params = tmp.params;
                  node2.rest = tmp.rest;
                  node2.this = tmp._this;
                  this.expect(11);
                  this.expect(19);
                  node2.returnType = this.flowParseType();
                  return this.finishNode(node2, "FunctionTypeAnnotation");
                case 10:
                  this.next();
                  if (!this.match(11) && !this.match(21)) {
                    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                      var token = this.lookahead().type;
                      isGroupedType = token !== 17 && token !== 14;
                    } else {
                      isGroupedType = true;
                    }
                  }
                  if (isGroupedType) {
                    this.state.noAnonFunctionType = false;
                    type3 = this.flowParseType();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                      this.expect(11);
                      return type3;
                    } else {
                      this.eat(12);
                    }
                  }
                  if (type3) {
                    tmp = this.flowParseFunctionTypeParams([
                      this.reinterpretTypeAsFunctionTypeParam(type3)
                    ]);
                  } else {
                    tmp = this.flowParseFunctionTypeParams();
                  }
                  node2.params = tmp.params;
                  node2.rest = tmp.rest;
                  node2.this = tmp._this;
                  this.expect(11);
                  this.expect(19);
                  node2.returnType = this.flowParseType();
                  node2.typeParameters = null;
                  return this.finishNode(node2, "FunctionTypeAnnotation");
                case 133:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                  node2.value = this.match(85);
                  this.next();
                  return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
                case 53:
                  if (this.state.value === "-") {
                    this.next();
                    if (this.match(134)) {
                      return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
                    }
                    if (this.match(135)) {
                      return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
                    }
                    throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                      at: this.state.startLoc
                    });
                  }
                  this.unexpected();
                  return;
                case 134:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 135:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                  this.next();
                  return this.finishNode(node2, "VoidTypeAnnotation");
                case 84:
                  this.next();
                  return this.finishNode(node2, "NullLiteralTypeAnnotation");
                case 78:
                  this.next();
                  return this.finishNode(node2, "ThisTypeAnnotation");
                case 55:
                  this.next();
                  return this.finishNode(node2, "ExistsTypeAnnotation");
                case 87:
                  return this.flowParseTypeofType();
                default:
                  if (tokenIsKeyword(this.state.type)) {
                    var label = tokenLabelName(this.state.type);
                    this.next();
                    return _get(_get_prototype_of(FlowParserMixin2.prototype), "createIdentifier", this).call(this, node2, label);
                  } else if (tokenIsIdentifier(this.state.type)) {
                    if (this.isContextual(129)) {
                      return this.flowParseInterfaceType();
                    }
                    return this.flowIdentToTypeAnnotation(startLoc, node2, this.parseIdentifier());
                  }
              }
              this.unexpected();
            }
          },
          {
            key: "flowParsePostfixType",
            value: function flowParsePostfixType() {
              var startLoc = this.state.startLoc;
              var type3 = this.flowParsePrimaryType();
              var seenOptionalIndexedAccess = false;
              while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
                var node2 = this.startNodeAt(startLoc);
                var optional = this.eat(18);
                seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                this.expect(0);
                if (!optional && this.match(3)) {
                  node2.elementType = type3;
                  this.next();
                  type3 = this.finishNode(node2, "ArrayTypeAnnotation");
                } else {
                  node2.objectType = type3;
                  node2.indexType = this.flowParseType();
                  this.expect(3);
                  if (seenOptionalIndexedAccess) {
                    node2.optional = optional;
                    type3 = this.finishNode(node2, "OptionalIndexedAccessType");
                  } else {
                    type3 = this.finishNode(node2, "IndexedAccessType");
                  }
                }
              }
              return type3;
            }
          },
          {
            key: "flowParsePrefixType",
            value: function flowParsePrefixType() {
              var node2 = this.startNode();
              if (this.eat(17)) {
                node2.typeAnnotation = this.flowParsePrefixType();
                return this.finishNode(node2, "NullableTypeAnnotation");
              } else {
                return this.flowParsePostfixType();
              }
            }
          },
          {
            key: "flowParseAnonFunctionWithoutParens",
            value: function flowParseAnonFunctionWithoutParens() {
              var param = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(19)) {
                var node2 = this.startNodeAt(param.loc.start);
                node2.params = [
                  this.reinterpretTypeAsFunctionTypeParam(param)
                ];
                node2.rest = null;
                node2.this = null;
                node2.returnType = this.flowParseType();
                node2.typeParameters = null;
                return this.finishNode(node2, "FunctionTypeAnnotation");
              }
              return param;
            }
          },
          {
            key: "flowParseIntersectionType",
            value: function flowParseIntersectionType() {
              var node2 = this.startNode();
              this.eat(45);
              var type3 = this.flowParseAnonFunctionWithoutParens();
              node2.types = [
                type3
              ];
              while (this.eat(45)) {
                node2.types.push(this.flowParseAnonFunctionWithoutParens());
              }
              return node2.types.length === 1 ? type3 : this.finishNode(node2, "IntersectionTypeAnnotation");
            }
          },
          {
            key: "flowParseUnionType",
            value: function flowParseUnionType() {
              var node2 = this.startNode();
              this.eat(43);
              var type3 = this.flowParseIntersectionType();
              node2.types = [
                type3
              ];
              while (this.eat(43)) {
                node2.types.push(this.flowParseIntersectionType());
              }
              return node2.types.length === 1 ? type3 : this.finishNode(node2, "UnionTypeAnnotation");
            }
          },
          {
            key: "flowParseType",
            value: function flowParseType() {
              var oldInType = this.state.inType;
              this.state.inType = true;
              var type3 = this.flowParseUnionType();
              this.state.inType = oldInType;
              return type3;
            }
          },
          {
            key: "flowParseTypeOrImplicitInstantiation",
            value: function flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === 132 && this.state.value === "_") {
                var startLoc = this.state.startLoc;
                var node2 = this.parseIdentifier();
                return this.flowParseGenericType(startLoc, node2);
              } else {
                return this.flowParseType();
              }
            }
          },
          {
            key: "flowParseTypeAnnotation",
            value: function flowParseTypeAnnotation() {
              var node2 = this.startNode();
              node2.typeAnnotation = this.flowParseTypeInitialiser();
              return this.finishNode(node2, "TypeAnnotation");
            }
          },
          {
            key: "flowParseTypeAnnotatableIdentifier",
            value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
              var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              if (this.match(14)) {
                ident.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(ident);
              }
              return ident;
            }
          },
          {
            key: "typeCastToParameter",
            value: function typeCastToParameter(node2) {
              node2.expression.typeAnnotation = node2.typeAnnotation;
              this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
              return node2.expression;
            }
          },
          {
            key: "flowParseVariance",
            value: function flowParseVariance() {
              var variance2 = null;
              if (this.match(53)) {
                variance2 = this.startNode();
                if (this.state.value === "+") {
                  variance2.kind = "plus";
                } else {
                  variance2.kind = "minus";
                }
                this.next();
                return this.finishNode(variance2, "Variance");
              }
              return variance2;
            }
          },
          {
            key: "parseFunctionBody",
            value: function parseFunctionBody(node2, allowExpressionBody) {
              var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var _this = this;
              if (allowExpressionBody) {
                this.forwardNoArrowParamsConversionAt(node2, function() {
                  return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseFunctionBody", _this).call(_this, node2, true, isMethod3);
                });
                return;
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseFunctionBody", this).call(this, node2, false, isMethod3);
            }
          },
          {
            key: "parseFunctionBodyAndFinish",
            value: function parseFunctionBodyAndFinish(node2, type3) {
              var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                var typeNode = this.startNode();
                var ref2;
                ref2 = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref2[0], node2.predicate = ref2[1], ref2;
                node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseFunctionBodyAndFinish", this).call(this, node2, type3, isMethod3);
            }
          },
          {
            key: "parseStatementLike",
            value: function parseStatementLike(flags) {
              if (this.state.strict && this.isContextual(129)) {
                var lookahead2 = this.lookahead();
                if (tokenIsKeywordOrIdentifier(lookahead2.type)) {
                  var node2 = this.startNode();
                  this.next();
                  return this.flowParseInterface(node2);
                }
              } else if (this.shouldParseEnums() && this.isContextual(126)) {
                var node1 = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node1);
              }
              var stmt = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseStatementLike", this).call(this, flags);
              if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
                this.flowPragma = null;
              }
              return stmt;
            }
          },
          {
            key: "parseExpressionStatement",
            value: function parseExpressionStatement(node2, expr, decorators) {
              if (expr.type === "Identifier") {
                if (expr.name === "declare") {
                  if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                    return this.flowParseDeclare(node2);
                  }
                } else if (tokenIsIdentifier(this.state.type)) {
                  if (expr.name === "interface") {
                    return this.flowParseInterface(node2);
                  } else if (expr.name === "type") {
                    return this.flowParseTypeAlias(node2);
                  } else if (expr.name === "opaque") {
                    return this.flowParseOpaqueType(node2, false);
                  }
                }
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExpressionStatement", this).call(this, node2, expr, decorators);
            }
          },
          {
            key: "shouldParseExportDeclaration",
            value: function shouldParseExportDeclaration() {
              var type3 = this.state.type;
              if (tokenIsFlowInterfaceOrTypeOrOpaque(type3) || this.shouldParseEnums() && type3 === 126) {
                return !this.state.containsEsc;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "shouldParseExportDeclaration", this).call(this);
            }
          },
          {
            key: "isExportDefaultSpecifier",
            value: function isExportDefaultSpecifier3() {
              var type3 = this.state.type;
              if (tokenIsFlowInterfaceOrTypeOrOpaque(type3) || this.shouldParseEnums() && type3 === 126) {
                return this.state.containsEsc;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "isExportDefaultSpecifier", this).call(this);
            }
          },
          {
            key: "parseExportDefaultExpression",
            value: function parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual(126)) {
                var node2 = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node2);
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExportDefaultExpression", this).call(this);
            }
          },
          {
            key: "parseConditional",
            value: function parseConditional(expr, startLoc, refExpressionErrors) {
              var _this = this;
              if (!this.match(17))
                return expr;
              if (this.state.maybeInArrowParameters) {
                var nextCh = this.lookaheadCharCode();
                if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                  this.setOptionalParametersError(refExpressionErrors);
                  return expr;
                }
              }
              this.expect(17);
              var state = this.state.clone();
              var originalNoArrowAt = this.state.noArrowAt;
              var node2 = this.startNodeAt(startLoc);
              var _this_tryParseConditionalConsequent = this.tryParseConditionalConsequent(), consequent = _this_tryParseConditionalConsequent.consequent, failed = _this_tryParseConditionalConsequent.failed;
              var _this_getArrowLikeExpressions = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid2 = _this_getArrowLikeExpressions[0], invalid2 = _this_getArrowLikeExpressions[1];
              if (failed || invalid2.length > 0) {
                var noArrowAt = _to_consumable_array(originalNoArrowAt);
                if (invalid2.length > 0) {
                  this.state = state;
                  this.state.noArrowAt = noArrowAt;
                  for (var i2 = 0; i2 < invalid2.length; i2++) {
                    noArrowAt.push(invalid2[i2].start);
                  }
                  var ref2;
                  ref2 = this.tryParseConditionalConsequent(), consequent = ref2.consequent, failed = ref2.failed, ref2;
                  var ref1;
                  ref1 = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid2 = ref1[0], invalid2 = ref1[1], ref1;
                }
                if (failed && valid2.length > 1) {
                  this.raise(FlowErrors.AmbiguousConditionalArrow, {
                    at: state.startLoc
                  });
                }
                if (failed && valid2.length === 1) {
                  this.state = state;
                  noArrowAt.push(valid2[0].start);
                  this.state.noArrowAt = noArrowAt;
                  var ref22;
                  ref22 = this.tryParseConditionalConsequent(), consequent = ref22.consequent, failed = ref22.failed, ref22;
                }
              }
              this.getArrowLikeExpressions(consequent, true);
              this.state.noArrowAt = originalNoArrowAt;
              this.expect(14);
              node2.test = expr;
              node2.consequent = consequent;
              node2.alternate = this.forwardNoArrowParamsConversionAt(node2, function() {
                return _this.parseMaybeAssign(void 0, void 0);
              });
              return this.finishNode(node2, "ConditionalExpression");
            }
          },
          {
            key: "tryParseConditionalConsequent",
            value: function tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              var consequent = this.parseMaybeAssignAllowIn();
              var failed = !this.match(14);
              this.state.noArrowParamsConversionAt.pop();
              return {
                consequent,
                failed
              };
            }
          },
          {
            key: "getArrowLikeExpressions",
            value: function getArrowLikeExpressions(node2, disallowInvalid) {
              var _this = this;
              var stack = [
                node2
              ];
              var arrows = [];
              while (stack.length !== 0) {
                var node22 = stack.pop();
                if (node22.type === "ArrowFunctionExpression") {
                  if (node22.typeParameters || !node22.returnType) {
                    this.finishArrowValidation(node22);
                  } else {
                    arrows.push(node22);
                  }
                  stack.push(node22.body);
                } else if (node22.type === "ConditionalExpression") {
                  stack.push(node22.consequent);
                  stack.push(node22.alternate);
                }
              }
              if (disallowInvalid) {
                arrows.forEach(function(node23) {
                  return _this.finishArrowValidation(node23);
                });
                return [
                  arrows,
                  []
                ];
              }
              return partition(arrows, function(node23) {
                return node23.params.every(function(param) {
                  return _this.isAssignable(param, true);
                });
              });
            }
          },
          {
            key: "finishArrowValidation",
            value: function finishArrowValidation(node2) {
              var _node_extra;
              this.toAssignableList(node2.params, (_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.trailingCommaLoc, false);
              this.scope.enter(2 | 4);
              _get(_get_prototype_of(FlowParserMixin2.prototype), "checkParams", this).call(this, node2, false, true);
              this.scope.exit();
            }
          },
          {
            key: "forwardNoArrowParamsConversionAt",
            value: function forwardNoArrowParamsConversionAt(node2, parse22) {
              var result;
              if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                result = parse22();
                this.state.noArrowParamsConversionAt.pop();
              } else {
                result = parse22();
              }
              return result;
            }
          },
          {
            key: "parseParenItem",
            value: function parseParenItem(node2, startLoc) {
              node2 = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseParenItem", this).call(this, node2, startLoc);
              if (this.eat(17)) {
                node2.optional = true;
                this.resetEndLocation(node2);
              }
              if (this.match(14)) {
                var typeCastNode = this.startNodeAt(startLoc);
                typeCastNode.expression = node2;
                typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TypeCastExpression");
              }
              return node2;
            }
          },
          {
            key: "assertModuleNodeAllowed",
            value: function assertModuleNodeAllowed(node2) {
              if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
                return;
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "assertModuleNodeAllowed", this).call(this, node2);
            }
          },
          {
            key: "parseExportDeclaration",
            value: function parseExportDeclaration(node2) {
              if (this.isContextual(130)) {
                node2.exportKind = "type";
                var declarationNode = this.startNode();
                this.next();
                if (this.match(5)) {
                  node2.specifiers = this.parseExportSpecifiers(true);
                  _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExportFrom", this).call(this, node2);
                  return null;
                } else {
                  return this.flowParseTypeAlias(declarationNode);
                }
              } else if (this.isContextual(131)) {
                node2.exportKind = "type";
                var declarationNode1 = this.startNode();
                this.next();
                return this.flowParseOpaqueType(declarationNode1, false);
              } else if (this.isContextual(129)) {
                node2.exportKind = "type";
                var declarationNode2 = this.startNode();
                this.next();
                return this.flowParseInterface(declarationNode2);
              } else if (this.shouldParseEnums() && this.isContextual(126)) {
                node2.exportKind = "value";
                var declarationNode3 = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(declarationNode3);
              } else {
                return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseExportDeclaration", this).call(this, node2);
              }
            }
          },
          {
            key: "eatExportStar",
            value: function eatExportStar(node2) {
              if (_get(_get_prototype_of(FlowParserMixin2.prototype), "eatExportStar", this).call(this, node2))
                return true;
              if (this.isContextual(130) && this.lookahead().type === 55) {
                node2.exportKind = "type";
                this.next();
                this.next();
                return true;
              }
              return false;
            }
          },
          {
            key: "maybeParseExportNamespaceSpecifier",
            value: function maybeParseExportNamespaceSpecifier(node2) {
              var startLoc = this.state.startLoc;
              var hasNamespace = _get(_get_prototype_of(FlowParserMixin2.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node2);
              if (hasNamespace && node2.exportKind === "type") {
                this.unexpected(startLoc);
              }
              return hasNamespace;
            }
          },
          {
            key: "parseClassId",
            value: function parseClassId(node2, isStatement5, optionalId) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassId", this).call(this, node2, isStatement5, optionalId);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
            }
          },
          {
            key: "parseClassMember",
            value: function parseClassMember(classBody2, member, state) {
              var startLoc = this.state.startLoc;
              if (this.isContextual(125)) {
                if (_get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassMemberFromModifier", this).call(this, classBody2, member)) {
                  return;
                }
                member.declare = true;
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassMember", this).call(this, classBody2, member, state);
              if (member.declare) {
                if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
                  this.raise(FlowErrors.DeclareClassElement, {
                    at: startLoc
                  });
                } else if (member.value) {
                  this.raise(FlowErrors.DeclareClassFieldInitializer, {
                    at: member.value
                  });
                }
              }
            }
          },
          {
            key: "isIterator",
            value: function isIterator(word) {
              return word === "iterator" || word === "asyncIterator";
            }
          },
          {
            key: "readIterator",
            value: function readIterator() {
              var word = _get(_get_prototype_of(FlowParserMixin2.prototype), "readWord1", this).call(this);
              var fullWord = "@@" + word;
              if (!this.isIterator(word) || !this.state.inType) {
                this.raise(Errors.InvalidIdentifier, {
                  at: this.state.curPosition(),
                  identifierName: fullWord
                });
              }
              this.finishToken(132, fullWord);
            }
          },
          {
            key: "getTokenFromCode",
            value: function getTokenFromCode(code22) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (code22 === 123 && next === 124) {
                this.finishOp(6, 2);
              } else if (this.state.inType && (code22 === 62 || code22 === 60)) {
                this.finishOp(code22 === 62 ? 48 : 47, 1);
              } else if (this.state.inType && code22 === 63) {
                if (next === 46) {
                  this.finishOp(18, 2);
                } else {
                  this.finishOp(17, 1);
                }
              } else if (isIteratorStart(code22, next, this.input.charCodeAt(this.state.pos + 2))) {
                this.state.pos += 2;
                this.readIterator();
              } else {
                _get(_get_prototype_of(FlowParserMixin2.prototype), "getTokenFromCode", this).call(this, code22);
              }
            }
          },
          {
            key: "isAssignable",
            value: function isAssignable(node2, isBinding3) {
              if (node2.type === "TypeCastExpression") {
                return this.isAssignable(node2.expression, isBinding3);
              } else {
                return _get(_get_prototype_of(FlowParserMixin2.prototype), "isAssignable", this).call(this, node2, isBinding3);
              }
            }
          },
          {
            key: "toAssignable",
            value: function toAssignable(node2) {
              var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (!isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression") {
                node2.left = this.typeCastToParameter(node2.left);
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "toAssignable", this).call(this, node2, isLHS);
            }
          },
          {
            key: "toAssignableList",
            value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
              for (var i2 = 0; i2 < exprList.length; i2++) {
                var expr = exprList[i2];
                if ((expr === null || expr === void 0 ? void 0 : expr.type) === "TypeCastExpression") {
                  exprList[i2] = this.typeCastToParameter(expr);
                }
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
            }
          },
          {
            key: "toReferencedList",
            value: function toReferencedList(exprList, isParenthesizedExpr) {
              for (var i2 = 0; i2 < exprList.length; i2++) {
                var _expr_extra;
                var expr = exprList[i2];
                if (expr && expr.type === "TypeCastExpression" && !((_expr_extra = expr.extra) === null || _expr_extra === void 0 ? void 0 : _expr_extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
                  this.raise(FlowErrors.TypeCastInPattern, {
                    at: expr.typeAnnotation
                  });
                }
              }
              return exprList;
            }
          },
          {
            key: "parseArrayLike",
            value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
              var node2 = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
              if (canBePattern && !this.state.maybeInArrowParameters) {
                this.toReferencedList(node2.elements);
              }
              return node2;
            }
          },
          {
            key: "isValidLVal",
            value: function isValidLVal(type3, isParenthesized, binding) {
              return type3 === "TypeCastExpression" || _get(_get_prototype_of(FlowParserMixin2.prototype), "isValidLVal", this).call(this, type3, isParenthesized, binding);
            }
          },
          {
            key: "parseClassProperty",
            value: function parseClassProperty(node2) {
              if (this.match(14)) {
                node2.typeAnnotation = this.flowParseTypeAnnotation();
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassProperty", this).call(this, node2);
            }
          },
          {
            key: "parseClassPrivateProperty",
            value: function parseClassPrivateProperty(node2) {
              if (this.match(14)) {
                node2.typeAnnotation = this.flowParseTypeAnnotation();
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassPrivateProperty", this).call(this, node2);
            }
          },
          {
            key: "isClassMethod",
            value: function isClassMethod2() {
              return this.match(47) || _get(_get_prototype_of(FlowParserMixin2.prototype), "isClassMethod", this).call(this);
            }
          },
          {
            key: "isClassProperty",
            value: function isClassProperty2() {
              return this.match(14) || _get(_get_prototype_of(FlowParserMixin2.prototype), "isClassProperty", this).call(this);
            }
          },
          {
            key: "isNonstaticConstructor",
            value: function isNonstaticConstructor(method) {
              return !this.match(14) && _get(_get_prototype_of(FlowParserMixin2.prototype), "isNonstaticConstructor", this).call(this, method);
            }
          },
          {
            key: "pushClassMethod",
            value: function pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              if (method.variance) {
                this.unexpected(method.variance.loc.start);
              }
              delete method.variance;
              if (this.match(47)) {
                method.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "pushClassMethod", this).call(this, classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
              if (method.params && isConstructor) {
                var params = method.params;
                if (params.length > 0 && this.isThisParam(params[0])) {
                  this.raise(FlowErrors.ThisParamBannedInConstructor, {
                    at: method
                  });
                }
              } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
                var params1 = method.value.params;
                if (params1.length > 0 && this.isThisParam(params1[0])) {
                  this.raise(FlowErrors.ThisParamBannedInConstructor, {
                    at: method
                  });
                }
              }
            }
          },
          {
            key: "pushClassPrivateMethod",
            value: function pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
              if (method.variance) {
                this.unexpected(method.variance.loc.start);
              }
              delete method.variance;
              if (this.match(47)) {
                method.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "pushClassPrivateMethod", this).call(this, classBody2, method, isGenerator, isAsync);
            }
          },
          {
            key: "parseClassSuper",
            value: function parseClassSuper(node2) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseClassSuper", this).call(this, node2);
              if (node2.superClass && this.match(47)) {
                node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
              }
              if (this.isContextual(113)) {
                this.next();
                var implemented = node2.implements = [];
                do {
                  var node22 = this.startNode();
                  node22.id = this.flowParseRestrictedIdentifier(true);
                  if (this.match(47)) {
                    node22.typeParameters = this.flowParseTypeParameterInstantiation();
                  } else {
                    node22.typeParameters = null;
                  }
                  implemented.push(this.finishNode(node22, "ClassImplements"));
                } while (this.eat(12));
              }
            }
          },
          {
            key: "checkGetterSetterParams",
            value: function checkGetterSetterParams(method) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "checkGetterSetterParams", this).call(this, method);
              var params = this.getObjectOrClassMethodParams(method);
              if (params.length > 0) {
                var param = params[0];
                if (this.isThisParam(param) && method.kind === "get") {
                  this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                    at: param
                  });
                } else if (this.isThisParam(param)) {
                  this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                    at: param
                  });
                }
              }
            }
          },
          {
            key: "parsePropertyNamePrefixOperator",
            value: function parsePropertyNamePrefixOperator(node2) {
              node2.variance = this.flowParseVariance();
            }
          },
          {
            key: "parseObjPropValue",
            value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
              if (prop.variance) {
                this.unexpected(prop.variance.loc.start);
              }
              delete prop.variance;
              var typeParameters;
              if (this.match(47) && !isAccessor2) {
                typeParameters = this.flowParseTypeParameterDeclaration();
                if (!this.match(10))
                  this.unexpected();
              }
              var result = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors);
              if (typeParameters) {
                (result.value || result).typeParameters = typeParameters;
              }
              return result;
            }
          },
          {
            key: "parseAssignableListItemTypes",
            value: function parseAssignableListItemTypes(param) {
              if (this.eat(17)) {
                if (param.type !== "Identifier") {
                  this.raise(FlowErrors.PatternIsOptional, {
                    at: param
                  });
                }
                if (this.isThisParam(param)) {
                  this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                    at: param
                  });
                }
                param.optional = true;
              }
              if (this.match(14)) {
                param.typeAnnotation = this.flowParseTypeAnnotation();
              } else if (this.isThisParam(param)) {
                this.raise(FlowErrors.ThisParamAnnotationRequired, {
                  at: param
                });
              }
              if (this.match(29) && this.isThisParam(param)) {
                this.raise(FlowErrors.ThisParamNoDefault, {
                  at: param
                });
              }
              this.resetEndLocation(param);
              return param;
            }
          },
          {
            key: "parseMaybeDefault",
            value: function parseMaybeDefault(startLoc, left) {
              var node2 = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
              if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
                this.raise(FlowErrors.TypeBeforeInitializer, {
                  at: node2.typeAnnotation
                });
              }
              return node2;
            }
          },
          {
            key: "checkImportReflection",
            value: function checkImportReflection(node2) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "checkImportReflection", this).call(this, node2);
              if (node2.module && node2.importKind !== "value") {
                this.raise(FlowErrors.ImportReflectionHasImportType, {
                  at: node2.specifiers[0].loc.start
                });
              }
            }
          },
          {
            key: "parseImportSpecifierLocal",
            value: function parseImportSpecifierLocal(node2, specifier, type3) {
              specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
              node2.specifiers.push(this.finishImportSpecifier(specifier, type3));
            }
          },
          {
            key: "isPotentialImportPhase",
            value: function isPotentialImportPhase(isExport) {
              if (_get(_get_prototype_of(FlowParserMixin2.prototype), "isPotentialImportPhase", this).call(this, isExport))
                return true;
              if (this.isContextual(130)) {
                if (!isExport)
                  return true;
                var ch = this.lookaheadCharCode();
                return ch === 123 || ch === 42;
              }
              return !isExport && this.isContextual(87);
            }
          },
          {
            key: "applyImportPhase",
            value: function applyImportPhase(node2, isExport, phase, loc) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "applyImportPhase", this).call(this, node2, isExport, phase, loc);
              if (isExport) {
                if (!phase && this.match(65)) {
                  return;
                }
                node2.exportKind = phase === "type" ? phase : "value";
              } else {
                if (phase === "type" && this.match(55))
                  this.unexpected();
                node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
              }
            }
          },
          {
            key: "parseImportSpecifier",
            value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
              var firstIdent = specifier.imported;
              var specifierTypeKind = null;
              if (firstIdent.type === "Identifier") {
                if (firstIdent.name === "type") {
                  specifierTypeKind = "type";
                } else if (firstIdent.name === "typeof") {
                  specifierTypeKind = "typeof";
                }
              }
              var isBinding3 = false;
              if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                var as_ident = this.parseIdentifier(true);
                if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                  specifier.imported = as_ident;
                  specifier.importKind = specifierTypeKind;
                  specifier.local = cloneIdentifier(as_ident);
                } else {
                  specifier.imported = firstIdent;
                  specifier.importKind = null;
                  specifier.local = this.parseIdentifier();
                }
              } else {
                if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                  specifier.imported = this.parseIdentifier(true);
                  specifier.importKind = specifierTypeKind;
                } else {
                  if (importedIsString) {
                    throw this.raise(Errors.ImportBindingIsString, {
                      at: specifier,
                      importName: firstIdent.value
                    });
                  }
                  specifier.imported = firstIdent;
                  specifier.importKind = null;
                }
                if (this.eatContextual(93)) {
                  specifier.local = this.parseIdentifier();
                } else {
                  isBinding3 = true;
                  specifier.local = cloneIdentifier(specifier.imported);
                }
              }
              var specifierIsTypeImport = hasTypeImportKind(specifier);
              if (isInTypeOnlyImport && specifierIsTypeImport) {
                this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
                  at: specifier
                });
              }
              if (isInTypeOnlyImport || specifierIsTypeImport) {
                this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
              }
              if (isBinding3 && !isInTypeOnlyImport && !specifierIsTypeImport) {
                this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
              }
              return this.finishImportSpecifier(specifier, "ImportSpecifier");
            }
          },
          {
            key: "parseBindingAtom",
            value: function parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseBindingAtom", this).call(this);
              }
            }
          },
          {
            key: "parseFunctionParams",
            value: function parseFunctionParams(node2, isConstructor) {
              var kind = node2.kind;
              if (kind !== "get" && kind !== "set" && this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterDeclaration();
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseFunctionParams", this).call(this, node2, isConstructor);
            }
          },
          {
            key: "parseVarId",
            value: function parseVarId(decl, kind) {
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseVarId", this).call(this, decl, kind);
              if (this.match(14)) {
                decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(decl.id);
              }
            }
          },
          {
            key: "parseAsyncArrowFromCallExpression",
            value: function parseAsyncArrowFromCallExpression(node2, call2) {
              if (this.match(14)) {
                var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                node2.returnType = this.flowParseTypeAnnotation();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node2, call2);
            }
          },
          {
            key: "shouldParseAsyncArrow",
            value: function shouldParseAsyncArrow() {
              return this.match(14) || _get(_get_prototype_of(FlowParserMixin2.prototype), "shouldParseAsyncArrow", this).call(this);
            }
          },
          {
            key: "parseMaybeAssign",
            value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
              var _this = this;
              var state = null;
              var jsx22;
              if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
                state = this.state.clone();
                jsx22 = this.tryParse(function() {
                  return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                }, state);
                if (!jsx22.error)
                  return jsx22.node;
                var context = this.state.context;
                var currentContext = context[context.length - 1];
                if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
                  context.pop();
                }
              }
              if ((jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.error) || this.match(47)) {
                state = state || this.state.clone();
                var typeParameters;
                var arrow = this.tryParse(function(abort) {
                  var _arrowExpression2_extra;
                  typeParameters = _this.flowParseTypeParameterDeclaration();
                  var arrowExpression2 = _this.forwardNoArrowParamsConversionAt(typeParameters, function() {
                    var result = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                    _this.resetStartLocationFromNode(result, typeParameters);
                    return result;
                  });
                  if ((_arrowExpression2_extra = arrowExpression2.extra) === null || _arrowExpression2_extra === void 0 ? void 0 : _arrowExpression2_extra.parenthesized)
                    abort();
                  var expr = _this.maybeUnwrapTypeCastExpression(arrowExpression2);
                  if (expr.type !== "ArrowFunctionExpression")
                    abort();
                  expr.typeParameters = typeParameters;
                  _this.resetStartLocationFromNode(expr, typeParameters);
                  return arrowExpression2;
                }, state);
                var arrowExpression = null;
                if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                  if (!arrow.error && !arrow.aborted) {
                    if (arrow.node.async) {
                      this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                        at: typeParameters
                      });
                    }
                    return arrow.node;
                  }
                  arrowExpression = arrow.node;
                }
                if (jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.node) {
                  this.state = jsx22.failState;
                  return jsx22.node;
                }
                if (arrowExpression) {
                  this.state = arrow.failState;
                  return arrowExpression;
                }
                if (jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.thrown)
                  throw jsx22.error;
                if (arrow.thrown)
                  throw arrow.error;
                throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
                  at: typeParameters
                });
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
            }
          },
          {
            key: "parseArrow",
            value: function parseArrow(node2) {
              var _this = this;
              if (this.match(14)) {
                var result = this.tryParse(function() {
                  var oldNoAnonFunctionType = _this.state.noAnonFunctionType;
                  _this.state.noAnonFunctionType = true;
                  var typeNode = _this.startNode();
                  var ref2;
                  ref2 = _sliced_to_array(_this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref2[0], node2.predicate = ref2[1], ref2;
                  _this.state.noAnonFunctionType = oldNoAnonFunctionType;
                  if (_this.canInsertSemicolon())
                    _this.unexpected();
                  if (!_this.match(19))
                    _this.unexpected();
                  return typeNode;
                });
                if (result.thrown)
                  return null;
                if (result.error)
                  this.state = result.failState;
                node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseArrow", this).call(this, node2);
            }
          },
          {
            key: "shouldParseArrow",
            value: function shouldParseArrow(params) {
              return this.match(14) || _get(_get_prototype_of(FlowParserMixin2.prototype), "shouldParseArrow", this).call(this, params);
            }
          },
          {
            key: "setArrowFunctionParameters",
            value: function setArrowFunctionParameters(node2, params) {
              if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                node2.params = params;
              } else {
                _get(_get_prototype_of(FlowParserMixin2.prototype), "setArrowFunctionParameters", this).call(this, node2, params);
              }
            }
          },
          {
            key: "checkParams",
            value: function checkParams(node2, allowDuplicates, isArrowFunction) {
              var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
                return;
              }
              for (var i2 = 0; i2 < node2.params.length; i2++) {
                if (this.isThisParam(node2.params[i2]) && i2 > 0) {
                  this.raise(FlowErrors.ThisParamMustBeFirst, {
                    at: node2.params[i2]
                  });
                }
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "checkParams", this).call(this, node2, allowDuplicates, isArrowFunction, strictModeChanged);
            }
          },
          {
            key: "parseParenAndDistinguishExpression",
            value: function parseParenAndDistinguishExpression(canBeArrow) {
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
          },
          {
            key: "parseSubscripts",
            value: function parseSubscripts(base, startLoc, noCalls) {
              var _this = this;
              if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
                this.next();
                var node2 = this.startNodeAt(startLoc);
                node2.callee = base;
                node2.arguments = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseCallExpressionArguments", this).call(this, 11, false);
                base = this.finishNode(node2, "CallExpression");
              } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
                var state = this.state.clone();
                var arrow = this.tryParse(function(abort) {
                  return _this.parseAsyncArrowWithTypeParameters(startLoc) || abort();
                }, state);
                if (!arrow.error && !arrow.aborted)
                  return arrow.node;
                var result = this.tryParse(function() {
                  return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseSubscripts", _this).call(_this, base, startLoc, noCalls);
                }, state);
                if (result.node && !result.error)
                  return result.node;
                if (arrow.node) {
                  this.state = arrow.failState;
                  return arrow.node;
                }
                if (result.node) {
                  this.state = result.failState;
                  return result.node;
                }
                throw arrow.error || result.error;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseSubscripts", this).call(this, base, startLoc, noCalls);
            }
          },
          {
            key: "parseSubscript",
            value: function parseSubscript(base, startLoc, noCalls, subscriptState) {
              var _this = this;
              if (this.match(18) && this.isLookaheadToken_lt()) {
                subscriptState.optionalChainMember = true;
                if (noCalls) {
                  subscriptState.stop = true;
                  return base;
                }
                this.next();
                var node2 = this.startNodeAt(startLoc);
                node2.callee = base;
                node2.typeArguments = this.flowParseTypeParameterInstantiation();
                this.expect(10);
                node2.arguments = this.parseCallExpressionArguments(11, false);
                node2.optional = true;
                return this.finishCallExpression(node2, true);
              } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
                var node1 = this.startNodeAt(startLoc);
                node1.callee = base;
                var result = this.tryParse(function() {
                  node1.typeArguments = _this.flowParseTypeParameterInstantiationCallOrNew();
                  _this.expect(10);
                  node1.arguments = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseCallExpressionArguments", _this).call(_this, 11, false);
                  if (subscriptState.optionalChainMember) {
                    node1.optional = false;
                  }
                  return _this.finishCallExpression(node1, subscriptState.optionalChainMember);
                });
                if (result.node) {
                  if (result.error)
                    this.state = result.failState;
                  return result.node;
                }
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, subscriptState);
            }
          },
          {
            key: "parseNewCallee",
            value: function parseNewCallee(node2) {
              var _this = this;
              _get(_get_prototype_of(FlowParserMixin2.prototype), "parseNewCallee", this).call(this, node2);
              var targs = null;
              if (this.shouldParseTypes() && this.match(47)) {
                targs = this.tryParse(function() {
                  return _this.flowParseTypeParameterInstantiationCallOrNew();
                }).node;
              }
              node2.typeArguments = targs;
            }
          },
          {
            key: "parseAsyncArrowWithTypeParameters",
            value: function parseAsyncArrowWithTypeParameters(startLoc) {
              var node2 = this.startNodeAt(startLoc);
              this.parseFunctionParams(node2, false);
              if (!this.parseArrow(node2))
                return;
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "parseArrowExpression", this).call(this, node2, void 0, true);
            }
          },
          {
            key: "readToken_mult_modulo",
            value: function readToken_mult_modulo(code22) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (code22 === 42 && next === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false;
                this.state.pos += 2;
                this.nextToken();
                return;
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "readToken_mult_modulo", this).call(this, code22);
            }
          },
          {
            key: "readToken_pipe_amp",
            value: function readToken_pipe_amp(code22) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              if (code22 === 124 && next === 125) {
                this.finishOp(9, 2);
                return;
              }
              _get(_get_prototype_of(FlowParserMixin2.prototype), "readToken_pipe_amp", this).call(this, code22);
            }
          },
          {
            key: "parseTopLevel",
            value: function parseTopLevel(file2, program3) {
              var fileNode = _get(_get_prototype_of(FlowParserMixin2.prototype), "parseTopLevel", this).call(this, file2, program3);
              if (this.state.hasFlowComment) {
                this.raise(FlowErrors.UnterminatedFlowComment, {
                  at: this.state.curPosition()
                });
              }
              return fileNode;
            }
          },
          {
            key: "skipBlockComment",
            value: function skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) {
                  throw this.raise(FlowErrors.NestedFlowComment, {
                    at: this.state.startLoc
                  });
                }
                this.hasFlowCommentCompletion();
                var commentSkip = this.skipFlowComment();
                if (commentSkip) {
                  this.state.pos += commentSkip;
                  this.state.hasFlowComment = true;
                }
                return;
              }
              return _get(_get_prototype_of(FlowParserMixin2.prototype), "skipBlockComment", this).call(this, this.state.hasFlowComment ? "*-/" : "*/");
            }
          },
          {
            key: "skipFlowComment",
            value: function skipFlowComment() {
              var pos = this.state.pos;
              var shiftToFirstNonWhiteSpace = 2;
              while ([
                32,
                9
              ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
                shiftToFirstNonWhiteSpace++;
              }
              var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
              var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
              if (ch2 === 58 && ch3 === 58) {
                return shiftToFirstNonWhiteSpace + 2;
              }
              if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
                return shiftToFirstNonWhiteSpace + 12;
              }
              if (ch2 === 58 && ch3 !== 58) {
                return shiftToFirstNonWhiteSpace;
              }
              return false;
            }
          },
          {
            key: "hasFlowCommentCompletion",
            value: function hasFlowCommentCompletion() {
              var end = this.input.indexOf("*/", this.state.pos);
              if (end === -1) {
                throw this.raise(Errors.UnterminatedComment, {
                  at: this.state.curPosition()
                });
              }
            }
          },
          {
            key: "flowEnumErrorBooleanMemberNotInitialized",
            value: function flowEnumErrorBooleanMemberNotInitialized(loc, param) {
              var enumName = param.enumName, memberName = param.memberName;
              this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
                at: loc,
                memberName,
                enumName
              });
            }
          },
          {
            key: "flowEnumErrorInvalidMemberInitializer",
            value: function flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
              return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
                at: loc
              }, enumContext));
            }
          },
          {
            key: "flowEnumErrorNumberMemberNotInitialized",
            value: function flowEnumErrorNumberMemberNotInitialized(loc, param) {
              var enumName = param.enumName, memberName = param.memberName;
              this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
                at: loc,
                enumName,
                memberName
              });
            }
          },
          {
            key: "flowEnumErrorStringMemberInconsistentlyInitialized",
            value: function flowEnumErrorStringMemberInconsistentlyInitialized(node2, param) {
              var enumName = param.enumName;
              this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
                at: node2,
                enumName
              });
            }
          },
          {
            key: "flowEnumMemberInit",
            value: function flowEnumMemberInit() {
              var _this = this;
              var startLoc = this.state.startLoc;
              var endOfInit = function() {
                return _this.match(12) || _this.match(8);
              };
              switch (this.state.type) {
                case 134: {
                  var literal2 = this.parseNumericLiteral(this.state.value);
                  if (endOfInit()) {
                    return {
                      type: "number",
                      loc: literal2.loc.start,
                      value: literal2
                    };
                  }
                  return {
                    type: "invalid",
                    loc: startLoc
                  };
                }
                case 133: {
                  var literal1 = this.parseStringLiteral(this.state.value);
                  if (endOfInit()) {
                    return {
                      type: "string",
                      loc: literal1.loc.start,
                      value: literal1
                    };
                  }
                  return {
                    type: "invalid",
                    loc: startLoc
                  };
                }
                case 85:
                case 86: {
                  var literal22 = this.parseBooleanLiteral(this.match(85));
                  if (endOfInit()) {
                    return {
                      type: "boolean",
                      loc: literal22.loc.start,
                      value: literal22
                    };
                  }
                  return {
                    type: "invalid",
                    loc: startLoc
                  };
                }
                default:
                  return {
                    type: "invalid",
                    loc: startLoc
                  };
              }
            }
          },
          {
            key: "flowEnumMemberRaw",
            value: function flowEnumMemberRaw() {
              var loc = this.state.startLoc;
              var id = this.parseIdentifier(true);
              var init = this.eat(29) ? this.flowEnumMemberInit() : {
                type: "none",
                loc
              };
              return {
                id,
                init
              };
            }
          },
          {
            key: "flowEnumCheckExplicitTypeMismatch",
            value: function flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
              var explicitType = context.explicitType;
              if (explicitType === null) {
                return;
              }
              if (explicitType !== expectedType) {
                this.flowEnumErrorInvalidMemberInitializer(loc, context);
              }
            }
          },
          {
            key: "flowEnumMembers",
            value: function flowEnumMembers(param) {
              var enumName = param.enumName, explicitType = param.explicitType;
              var seenNames = /* @__PURE__ */ new Set();
              var members = {
                booleanMembers: [],
                numberMembers: [],
                stringMembers: [],
                defaultedMembers: []
              };
              var hasUnknownMembers = false;
              while (!this.match(8)) {
                if (this.eat(21)) {
                  hasUnknownMembers = true;
                  break;
                }
                var memberNode = this.startNode();
                var _this_flowEnumMemberRaw = this.flowEnumMemberRaw(), id = _this_flowEnumMemberRaw.id, init = _this_flowEnumMemberRaw.init;
                var memberName = id.name;
                if (memberName === "") {
                  continue;
                }
                if (/^[a-z]/.test(memberName)) {
                  this.raise(FlowErrors.EnumInvalidMemberName, {
                    at: id,
                    memberName,
                    suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                    enumName
                  });
                }
                if (seenNames.has(memberName)) {
                  this.raise(FlowErrors.EnumDuplicateMemberName, {
                    at: id,
                    memberName,
                    enumName
                  });
                }
                seenNames.add(memberName);
                var context = {
                  enumName,
                  explicitType,
                  memberName
                };
                memberNode.id = id;
                switch (init.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                    memberNode.init = init.value;
                    members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                    memberNode.init = init.value;
                    members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                    memberNode.init = init.value;
                    members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                    break;
                  }
                  case "invalid": {
                    throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                  }
                  case "none": {
                    switch (explicitType) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                        break;
                      default:
                        members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                    }
                  }
                }
                if (!this.match(8)) {
                  this.expect(12);
                }
              }
              return {
                members,
                hasUnknownMembers
              };
            }
          },
          {
            key: "flowEnumStringMembers",
            value: function flowEnumStringMembers(initializedMembers, defaultedMembers, param) {
              var enumName = param.enumName;
              if (initializedMembers.length === 0) {
                return defaultedMembers;
              } else if (defaultedMembers.length === 0) {
                return initializedMembers;
              } else if (defaultedMembers.length > initializedMembers.length) {
                var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
                try {
                  for (var _iterator8 = initializedMembers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var member = _step8.value;
                    this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
                      enumName
                    });
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }
                return defaultedMembers;
              } else {
                var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                try {
                  for (var _iterator12 = defaultedMembers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var member1 = _step12.value;
                    this.flowEnumErrorStringMemberInconsistentlyInitialized(member1, {
                      enumName
                    });
                  }
                } catch (err) {
                  _didIteratorError12 = true;
                  _iteratorError12 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                      _iterator12.return();
                    }
                  } finally {
                    if (_didIteratorError12) {
                      throw _iteratorError12;
                    }
                  }
                }
                return initializedMembers;
              }
            }
          },
          {
            key: "flowEnumParseExplicitType",
            value: function flowEnumParseExplicitType(param) {
              var enumName = param.enumName;
              if (!this.eatContextual(102))
                return null;
              if (!tokenIsIdentifier(this.state.type)) {
                throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
                  at: this.state.startLoc,
                  enumName
                });
              }
              var value1 = this.state.value;
              this.next();
              if (value1 !== "boolean" && value1 !== "number" && value1 !== "string" && value1 !== "symbol") {
                this.raise(FlowErrors.EnumInvalidExplicitType, {
                  at: this.state.startLoc,
                  enumName,
                  invalidEnumType: value1
                });
              }
              return value1;
            }
          },
          {
            key: "flowEnumBody",
            value: function flowEnumBody(node2, id) {
              var _this = this;
              var enumName = id.name;
              var nameLoc = id.loc.start;
              var explicitType = this.flowEnumParseExplicitType({
                enumName
              });
              this.expect(5);
              var _this_flowEnumMembers = this.flowEnumMembers({
                enumName,
                explicitType
              }), members = _this_flowEnumMembers.members, hasUnknownMembers = _this_flowEnumMembers.hasUnknownMembers;
              node2.hasUnknownMembers = hasUnknownMembers;
              switch (explicitType) {
                case "boolean":
                  node2.explicitType = true;
                  node2.members = members.booleanMembers;
                  this.expect(8);
                  return this.finishNode(node2, "EnumBooleanBody");
                case "number":
                  node2.explicitType = true;
                  node2.members = members.numberMembers;
                  this.expect(8);
                  return this.finishNode(node2, "EnumNumberBody");
                case "string":
                  node2.explicitType = true;
                  node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                    enumName
                  });
                  this.expect(8);
                  return this.finishNode(node2, "EnumStringBody");
                case "symbol":
                  node2.members = members.defaultedMembers;
                  this.expect(8);
                  return this.finishNode(node2, "EnumSymbolBody");
                default: {
                  var empty5 = function() {
                    node2.members = [];
                    _this.expect(8);
                    return _this.finishNode(node2, "EnumStringBody");
                  };
                  node2.explicitType = false;
                  var boolsLen = members.booleanMembers.length;
                  var numsLen = members.numberMembers.length;
                  var strsLen = members.stringMembers.length;
                  var defaultedLen = members.defaultedMembers.length;
                  if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                    return empty5();
                  } else if (!boolsLen && !numsLen) {
                    node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                      enumName
                    });
                    this.expect(8);
                    return this.finishNode(node2, "EnumStringBody");
                  } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                    var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
                    try {
                      for (var _iterator8 = members.defaultedMembers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                        var member = _step8.value;
                        this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                          enumName,
                          memberName: member.id.name
                        });
                      }
                    } catch (err) {
                      _didIteratorError8 = true;
                      _iteratorError8 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                          _iterator8.return();
                        }
                      } finally {
                        if (_didIteratorError8) {
                          throw _iteratorError8;
                        }
                      }
                    }
                    node2.members = members.booleanMembers;
                    this.expect(8);
                    return this.finishNode(node2, "EnumBooleanBody");
                  } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                    var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                    try {
                      for (var _iterator12 = members.defaultedMembers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                        var member1 = _step12.value;
                        this.flowEnumErrorNumberMemberNotInitialized(member1.loc.start, {
                          enumName,
                          memberName: member1.id.name
                        });
                      }
                    } catch (err) {
                      _didIteratorError12 = true;
                      _iteratorError12 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                          _iterator12.return();
                        }
                      } finally {
                        if (_didIteratorError12) {
                          throw _iteratorError12;
                        }
                      }
                    }
                    node2.members = members.numberMembers;
                    this.expect(8);
                    return this.finishNode(node2, "EnumNumberBody");
                  } else {
                    this.raise(FlowErrors.EnumInconsistentMemberValues, {
                      at: nameLoc,
                      enumName
                    });
                    return empty5();
                  }
                }
              }
            }
          },
          {
            key: "flowParseEnumDeclaration",
            value: function flowParseEnumDeclaration(node2) {
              var id = this.parseIdentifier();
              node2.id = id;
              node2.body = this.flowEnumBody(this.startNode(), id);
              return this.finishNode(node2, "EnumDeclaration");
            }
          },
          {
            key: "isLookaheadToken_lt",
            value: function isLookaheadToken_lt() {
              var next = this.nextTokenStart();
              if (this.input.charCodeAt(next) === 60) {
                var afterNext = this.input.charCodeAt(next + 1);
                return afterNext !== 60 && afterNext !== 61;
              }
              return false;
            }
          },
          {
            key: "maybeUnwrapTypeCastExpression",
            value: function maybeUnwrapTypeCastExpression(node2) {
              return node2.type === "TypeCastExpression" ? node2.expression : node2;
            }
          }
        ]);
        return FlowParserMixin2;
      }(superClass);
      return FlowParserMixin;
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum(_templateObject2())({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: function(param) {
        var openingTagName = param.openingTagName;
        return "Expected corresponding JSX closing tag for <".concat(openingTagName, ">.");
      },
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: function(param) {
        var unexpected = param.unexpected, HTMLEntity = param.HTMLEntity;
        return "Unexpected token `".concat(unexpected, "`. Did you mean `").concat(HTMLEntity, "` or `{'").concat(unexpected, "'}`?");
      },
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx2 = function(superClass) {
      var JSXParserMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(JSXParserMixin2, superClass2);
        var _super3 = _create_super(JSXParserMixin2);
        function JSXParserMixin2() {
          _class_call_check(this, JSXParserMixin2);
          return _super3.apply(this, arguments);
        }
        _create_class(JSXParserMixin2, [
          {
            key: "jsxReadToken",
            value: function jsxReadToken() {
              var out = "";
              var chunkStart = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(JsxErrors.UnterminatedJsxContent, {
                    at: this.state.startLoc
                  });
                }
                var ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 60:
                  case 123:
                    if (this.state.pos === this.state.start) {
                      if (ch === 60 && this.state.canStartJSXElement) {
                        ++this.state.pos;
                        this.finishToken(142);
                      } else {
                        _get(_get_prototype_of(JSXParserMixin2.prototype), "getTokenFromCode", this).call(this, ch);
                      }
                      return;
                    }
                    out += this.input.slice(chunkStart, this.state.pos);
                    this.finishToken(141, out);
                    return;
                  case 38:
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadEntity();
                    chunkStart = this.state.pos;
                    break;
                  case 62:
                  case 125: {
                    this.raise(JsxErrors.UnexpectedToken, {
                      at: this.state.curPosition(),
                      unexpected: this.input[this.state.pos],
                      HTMLEntity: ch === 125 ? "&rbrace;" : "&gt;"
                    });
                  }
                  default:
                    if (isNewLine2(ch)) {
                      out += this.input.slice(chunkStart, this.state.pos);
                      out += this.jsxReadNewLine(true);
                      chunkStart = this.state.pos;
                    } else {
                      ++this.state.pos;
                    }
                }
              }
            }
          },
          {
            key: "jsxReadNewLine",
            value: function jsxReadNewLine(normalizeCRLF) {
              var ch = this.input.charCodeAt(this.state.pos);
              var out;
              ++this.state.pos;
              if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
                out = normalizeCRLF ? "\n" : "\r\n";
              } else {
                out = String.fromCharCode(ch);
              }
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              return out;
            }
          },
          {
            key: "jsxReadString",
            value: function jsxReadString(quote) {
              var out = "";
              var chunkStart = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) {
                  throw this.raise(Errors.UnterminatedString, {
                    at: this.state.startLoc
                  });
                }
                var ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote)
                  break;
                if (ch === 38) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadEntity();
                  chunkStart = this.state.pos;
                } else if (isNewLine2(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(false);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
              }
              out += this.input.slice(chunkStart, this.state.pos++);
              this.finishToken(133, out);
            }
          },
          {
            key: "jsxReadEntity",
            value: function jsxReadEntity() {
              var startPos = ++this.state.pos;
              if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                var radix = 10;
                if (this.codePointAtPos(this.state.pos) === 120) {
                  radix = 16;
                  ++this.state.pos;
                }
                var codePoint = this.readInt(radix, void 0, false, "bail");
                if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                  ++this.state.pos;
                  return String.fromCodePoint(codePoint);
                }
              } else {
                var count = 0;
                var semi = false;
                while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
                  ++this.state.pos;
                }
                if (semi) {
                  var desc = this.input.slice(startPos, this.state.pos);
                  var entity = entities[desc];
                  ++this.state.pos;
                  if (entity) {
                    return entity;
                  }
                }
              }
              this.state.pos = startPos;
              return "&";
            }
          },
          {
            key: "jsxReadWord",
            value: function jsxReadWord() {
              var ch;
              var start2 = this.state.pos;
              do {
                ch = this.input.charCodeAt(++this.state.pos);
              } while (isIdentifierChar22(ch) || ch === 45);
              this.finishToken(140, this.input.slice(start2, this.state.pos));
            }
          },
          {
            key: "jsxParseIdentifier",
            value: function jsxParseIdentifier() {
              var node2 = this.startNode();
              if (this.match(140)) {
                node2.name = this.state.value;
              } else if (tokenIsKeyword(this.state.type)) {
                node2.name = tokenLabelName(this.state.type);
              } else {
                this.unexpected();
              }
              this.next();
              return this.finishNode(node2, "JSXIdentifier");
            }
          },
          {
            key: "jsxParseNamespacedName",
            value: function jsxParseNamespacedName() {
              var startLoc = this.state.startLoc;
              var name2 = this.jsxParseIdentifier();
              if (!this.eat(14))
                return name2;
              var node2 = this.startNodeAt(startLoc);
              node2.namespace = name2;
              node2.name = this.jsxParseIdentifier();
              return this.finishNode(node2, "JSXNamespacedName");
            }
          },
          {
            key: "jsxParseElementName",
            value: function jsxParseElementName() {
              var startLoc = this.state.startLoc;
              var node2 = this.jsxParseNamespacedName();
              if (node2.type === "JSXNamespacedName") {
                return node2;
              }
              while (this.eat(16)) {
                var newNode = this.startNodeAt(startLoc);
                newNode.object = node2;
                newNode.property = this.jsxParseIdentifier();
                node2 = this.finishNode(newNode, "JSXMemberExpression");
              }
              return node2;
            }
          },
          {
            key: "jsxParseAttributeValue",
            value: function jsxParseAttributeValue() {
              var node2;
              switch (this.state.type) {
                case 5:
                  node2 = this.startNode();
                  this.setContext(types2.brace);
                  this.next();
                  node2 = this.jsxParseExpressionContainer(node2, types2.j_oTag);
                  if (node2.expression.type === "JSXEmptyExpression") {
                    this.raise(JsxErrors.AttributeIsEmpty, {
                      at: node2
                    });
                  }
                  return node2;
                case 142:
                case 133:
                  return this.parseExprAtom();
                default:
                  throw this.raise(JsxErrors.UnsupportedJsxValue, {
                    at: this.state.startLoc
                  });
              }
            }
          },
          {
            key: "jsxParseEmptyExpression",
            value: function jsxParseEmptyExpression() {
              var node2 = this.startNodeAt(this.state.lastTokEndLoc);
              return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
            }
          },
          {
            key: "jsxParseSpreadChild",
            value: function jsxParseSpreadChild(node2) {
              this.next();
              node2.expression = this.parseExpression();
              this.setContext(types2.j_expr);
              this.state.canStartJSXElement = true;
              this.expect(8);
              return this.finishNode(node2, "JSXSpreadChild");
            }
          },
          {
            key: "jsxParseExpressionContainer",
            value: function jsxParseExpressionContainer(node2, previousContext) {
              if (this.match(8)) {
                node2.expression = this.jsxParseEmptyExpression();
              } else {
                var expression2 = this.parseExpression();
                {
                  var _expression2_extra;
                  if (expression2.type === "SequenceExpression" && !((_expression2_extra = expression2.extra) === null || _expression2_extra === void 0 ? void 0 : _expression2_extra.parenthesized)) {
                    this.raise(JsxErrors.UnexpectedSequenceExpression, {
                      at: expression2.expressions[1]
                    });
                  }
                }
                node2.expression = expression2;
              }
              this.setContext(previousContext);
              this.state.canStartJSXElement = true;
              this.expect(8);
              return this.finishNode(node2, "JSXExpressionContainer");
            }
          },
          {
            key: "jsxParseAttribute",
            value: function jsxParseAttribute() {
              var node2 = this.startNode();
              if (this.match(5)) {
                this.setContext(types2.brace);
                this.next();
                this.expect(21);
                node2.argument = this.parseMaybeAssignAllowIn();
                this.setContext(types2.j_oTag);
                this.state.canStartJSXElement = true;
                this.expect(8);
                return this.finishNode(node2, "JSXSpreadAttribute");
              }
              node2.name = this.jsxParseNamespacedName();
              node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
              return this.finishNode(node2, "JSXAttribute");
            }
          },
          {
            key: "jsxParseOpeningElementAt",
            value: function jsxParseOpeningElementAt(startLoc) {
              var node2 = this.startNodeAt(startLoc);
              if (this.eat(143)) {
                return this.finishNode(node2, "JSXOpeningFragment");
              }
              node2.name = this.jsxParseElementName();
              return this.jsxParseOpeningElementAfterName(node2);
            }
          },
          {
            key: "jsxParseOpeningElementAfterName",
            value: function jsxParseOpeningElementAfterName(node2) {
              var attributes = [];
              while (!this.match(56) && !this.match(143)) {
                attributes.push(this.jsxParseAttribute());
              }
              node2.attributes = attributes;
              node2.selfClosing = this.eat(56);
              this.expect(143);
              return this.finishNode(node2, "JSXOpeningElement");
            }
          },
          {
            key: "jsxParseClosingElementAt",
            value: function jsxParseClosingElementAt(startLoc) {
              var node2 = this.startNodeAt(startLoc);
              if (this.eat(143)) {
                return this.finishNode(node2, "JSXClosingFragment");
              }
              node2.name = this.jsxParseElementName();
              this.expect(143);
              return this.finishNode(node2, "JSXClosingElement");
            }
          },
          {
            key: "jsxParseElementAt",
            value: function jsxParseElementAt(startLoc) {
              var node2 = this.startNodeAt(startLoc);
              var children = [];
              var openingElement = this.jsxParseOpeningElementAt(startLoc);
              var closingElement = null;
              if (!openingElement.selfClosing) {
                contents:
                  for (; ; ) {
                    switch (this.state.type) {
                      case 142:
                        startLoc = this.state.startLoc;
                        this.next();
                        if (this.eat(56)) {
                          closingElement = this.jsxParseClosingElementAt(startLoc);
                          break contents;
                        }
                        children.push(this.jsxParseElementAt(startLoc));
                        break;
                      case 141:
                        children.push(this.parseExprAtom());
                        break;
                      case 5: {
                        var node22 = this.startNode();
                        this.setContext(types2.brace);
                        this.next();
                        if (this.match(21)) {
                          children.push(this.jsxParseSpreadChild(node22));
                        } else {
                          children.push(this.jsxParseExpressionContainer(node22, types2.j_expr));
                        }
                        break;
                      }
                      default:
                        this.unexpected();
                    }
                  }
                if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
                  this.raise(JsxErrors.MissingClosingTagFragment, {
                    at: closingElement
                  });
                } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                  this.raise(JsxErrors.MissingClosingTagElement, {
                    at: closingElement,
                    openingTagName: getQualifiedJSXName(openingElement.name)
                  });
                } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                  if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                    this.raise(JsxErrors.MissingClosingTagElement, {
                      at: closingElement,
                      openingTagName: getQualifiedJSXName(openingElement.name)
                    });
                  }
                }
              }
              if (isFragment(openingElement)) {
                node2.openingFragment = openingElement;
                node2.closingFragment = closingElement;
              } else {
                node2.openingElement = openingElement;
                node2.closingElement = closingElement;
              }
              node2.children = children;
              if (this.match(47)) {
                throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
                  at: this.state.startLoc
                });
              }
              return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
            }
          },
          {
            key: "jsxParseElement",
            value: function jsxParseElement() {
              var startLoc = this.state.startLoc;
              this.next();
              return this.jsxParseElementAt(startLoc);
            }
          },
          {
            key: "setContext",
            value: function setContext2(newContext) {
              var context = this.state.context;
              context[context.length - 1] = newContext;
            }
          },
          {
            key: "parseExprAtom",
            value: function parseExprAtom(refExpressionErrors) {
              if (this.match(141)) {
                return this.parseLiteral(this.state.value, "JSXText");
              } else if (this.match(142)) {
                return this.jsxParseElement();
              } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                this.replaceToken(142);
                return this.jsxParseElement();
              } else {
                return _get(_get_prototype_of(JSXParserMixin2.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
              }
            }
          },
          {
            key: "skipSpace",
            value: function skipSpace() {
              var curContext = this.curContext();
              if (!curContext.preserveSpace)
                _get(_get_prototype_of(JSXParserMixin2.prototype), "skipSpace", this).call(this);
            }
          },
          {
            key: "getTokenFromCode",
            value: function getTokenFromCode(code22) {
              var context = this.curContext();
              if (context === types2.j_expr) {
                this.jsxReadToken();
                return;
              }
              if (context === types2.j_oTag || context === types2.j_cTag) {
                if (isIdentifierStart22(code22)) {
                  this.jsxReadWord();
                  return;
                }
                if (code22 === 62) {
                  ++this.state.pos;
                  this.finishToken(143);
                  return;
                }
                if ((code22 === 34 || code22 === 39) && context === types2.j_oTag) {
                  this.jsxReadString(code22);
                  return;
                }
              }
              if (code22 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos;
                this.finishToken(142);
                return;
              }
              _get(_get_prototype_of(JSXParserMixin2.prototype), "getTokenFromCode", this).call(this, code22);
            }
          },
          {
            key: "updateContext",
            value: function updateContext(prevType) {
              var _this_state = this.state, context = _this_state.context, type3 = _this_state.type;
              if (type3 === 56 && prevType === 142) {
                context.splice(-2, 2, types2.j_cTag);
                this.state.canStartJSXElement = false;
              } else if (type3 === 142) {
                context.push(types2.j_oTag);
              } else if (type3 === 143) {
                var out = context[context.length - 1];
                if (out === types2.j_oTag && prevType === 56 || out === types2.j_cTag) {
                  context.pop();
                  this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr;
                } else {
                  this.setContext(types2.j_expr);
                  this.state.canStartJSXElement = true;
                }
              } else {
                this.state.canStartJSXElement = tokenComesBeforeExpression(type3);
              }
            }
          }
        ]);
        return JSXParserMixin2;
      }(superClass);
      return JSXParserMixin;
    };
    var TypeScriptScope = /* @__PURE__ */ function(Scope5) {
      "use strict";
      _inherits(TypeScriptScope2, Scope5);
      var _super3 = _create_super(TypeScriptScope2);
      function TypeScriptScope2() {
        _class_call_check(this, TypeScriptScope2);
        var _this;
        _this = _super3.call.apply(_super3, [
          this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assert_this_initialized(_this), "types", /* @__PURE__ */ new Set());
        __publicField(_assert_this_initialized(_this), "enums", /* @__PURE__ */ new Set());
        __publicField(_assert_this_initialized(_this), "constEnums", /* @__PURE__ */ new Set());
        __publicField(_assert_this_initialized(_this), "classes", /* @__PURE__ */ new Set());
        __publicField(_assert_this_initialized(_this), "exportOnlyBindings", /* @__PURE__ */ new Set());
        return _this;
      }
      return TypeScriptScope2;
    }(Scope4);
    var TypeScriptScopeHandler = /* @__PURE__ */ function(ScopeHandler2) {
      "use strict";
      _inherits(TypeScriptScopeHandler2, ScopeHandler2);
      var _super3 = _create_super(TypeScriptScopeHandler2);
      function TypeScriptScopeHandler2() {
        _class_call_check(this, TypeScriptScopeHandler2);
        var _this;
        _this = _super3.call.apply(_super3, [
          this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assert_this_initialized(_this), "importsStack", []);
        return _this;
      }
      _create_class(TypeScriptScopeHandler2, [
        {
          key: "createScope",
          value: function createScope(flags) {
            this.importsStack.push(/* @__PURE__ */ new Set());
            return new TypeScriptScope(flags);
          }
        },
        {
          key: "enter",
          value: function enter(flags) {
            if (flags == 256) {
              this.importsStack.push(/* @__PURE__ */ new Set());
            }
            _get(_get_prototype_of(TypeScriptScopeHandler2.prototype), "enter", this).call(this, flags);
          }
        },
        {
          key: "exit",
          value: function exit2() {
            var flags = _get(_get_prototype_of(TypeScriptScopeHandler2.prototype), "exit", this).call(this);
            if (flags == 256) {
              this.importsStack.pop();
            }
            return flags;
          }
        },
        {
          key: "hasImport",
          value: function hasImport(name2, allowShadow) {
            var len = this.importsStack.length;
            if (this.importsStack[len - 1].has(name2)) {
              return true;
            }
            if (!allowShadow && len > 1) {
              for (var i2 = 0; i2 < len - 1; i2++) {
                if (this.importsStack[i2].has(name2))
                  return true;
              }
            }
            return false;
          }
        },
        {
          key: "declareName",
          value: function declareName(name2, bindingType, loc) {
            if (bindingType & 4096) {
              if (this.hasImport(name2, true)) {
                this.parser.raise(Errors.VarRedeclaration, {
                  at: loc,
                  identifierName: name2
                });
              }
              this.importsStack[this.importsStack.length - 1].add(name2);
              return;
            }
            var scope2 = this.currentScope();
            if (bindingType & 1024) {
              this.maybeExportDefined(scope2, name2);
              scope2.exportOnlyBindings.add(name2);
              return;
            }
            _get(_get_prototype_of(TypeScriptScopeHandler2.prototype), "declareName", this).call(this, name2, bindingType, loc);
            if (bindingType & 2) {
              if (!(bindingType & 1)) {
                this.checkRedeclarationInScope(scope2, name2, bindingType, loc);
                this.maybeExportDefined(scope2, name2);
              }
              scope2.types.add(name2);
            }
            if (bindingType & 256)
              scope2.enums.add(name2);
            if (bindingType & 512) {
              scope2.constEnums.add(name2);
            }
            if (bindingType & 128)
              scope2.classes.add(name2);
          }
        },
        {
          key: "isRedeclaredInScope",
          value: function isRedeclaredInScope(scope2, name2, bindingType) {
            if (scope2.enums.has(name2)) {
              if (bindingType & 256) {
                var isConst = !!(bindingType & 512);
                var wasConst = scope2.constEnums.has(name2);
                return isConst !== wasConst;
              }
              return true;
            }
            if (bindingType & 128 && scope2.classes.has(name2)) {
              if (scope2.lexical.has(name2)) {
                return !!(bindingType & 1);
              } else {
                return false;
              }
            }
            if (bindingType & 2 && scope2.types.has(name2)) {
              return true;
            }
            return _get(_get_prototype_of(TypeScriptScopeHandler2.prototype), "isRedeclaredInScope", this).call(this, scope2, name2, bindingType);
          }
        },
        {
          key: "checkLocalExport",
          value: function checkLocalExport(id) {
            var name2 = id.name;
            if (this.hasImport(name2))
              return;
            var len = this.scopeStack.length;
            for (var i2 = len - 1; i2 >= 0; i2--) {
              var scope2 = this.scopeStack[i2];
              if (scope2.types.has(name2) || scope2.exportOnlyBindings.has(name2))
                return;
            }
            _get(_get_prototype_of(TypeScriptScopeHandler2.prototype), "checkLocalExport", this).call(this, id);
          }
        }
      ]);
      return TypeScriptScopeHandler2;
    }(ScopeHandler);
    var getOwn$1 = function(object, key) {
      return Object.hasOwnProperty.call(object, key) && object[key];
    };
    var unwrapParenthesizedExpression = function(node2) {
      return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
    };
    var LValParser = /* @__PURE__ */ function(NodeUtils2) {
      "use strict";
      _inherits(LValParser2, NodeUtils2);
      var _super3 = _create_super(LValParser2);
      function LValParser2() {
        _class_call_check(this, LValParser2);
        return _super3.apply(this, arguments);
      }
      _create_class(LValParser2, [
        {
          key: "toAssignable",
          value: function toAssignable(node2) {
            var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var _node_extra;
            var parenthesized = void 0;
            if (node2.type === "ParenthesizedExpression" || ((_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.parenthesized)) {
              parenthesized = unwrapParenthesizedExpression(node2);
              if (isLHS) {
                if (parenthesized.type === "Identifier") {
                  this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                    at: node2
                  });
                } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
                  this.raise(Errors.InvalidParenthesizedAssignment, {
                    at: node2
                  });
                }
              } else {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node2
                });
              }
            }
            switch (node2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node2.type = "ObjectPattern";
                for (var i2 = 0, length = node2.properties.length, last2 = length - 1; i2 < length; i2++) {
                  var _node_extra1;
                  var prop = node2.properties[i2];
                  var isLast = i2 === last2;
                  this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                  if (isLast && prop.type === "RestElement" && ((_node_extra1 = node2.extra) === null || _node_extra1 === void 0 ? void 0 : _node_extra1.trailingCommaLoc)) {
                    this.raise(Errors.RestTrailingComma, {
                      at: node2.extra.trailingCommaLoc
                    });
                  }
                }
                break;
              case "ObjectProperty": {
                var key = node2.key, value1 = node2.value;
                if (this.isPrivateName(key)) {
                  this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                }
                this.toAssignable(value1, isLHS);
                break;
              }
              case "SpreadElement": {
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              }
              case "ArrayExpression":
                var _node_extra2;
                node2.type = "ArrayPattern";
                this.toAssignableList(node2.elements, (_node_extra2 = node2.extra) === null || _node_extra2 === void 0 ? void 0 : _node_extra2.trailingCommaLoc, isLHS);
                break;
              case "AssignmentExpression":
                if (node2.operator !== "=") {
                  this.raise(Errors.MissingEqInAssignment, {
                    at: node2.left.loc.end
                  });
                }
                node2.type = "AssignmentPattern";
                delete node2.operator;
                this.toAssignable(node2.left, isLHS);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
                break;
            }
          }
        },
        {
          key: "toAssignableObjectExpressionProp",
          value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
            if (prop.type === "ObjectMethod") {
              this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
                at: prop.key
              });
            } else if (prop.type === "SpreadElement") {
              prop.type = "RestElement";
              var arg = prop.argument;
              this.checkToRestConversion(arg, false);
              this.toAssignable(arg, isLHS);
              if (!isLast) {
                this.raise(Errors.RestTrailingComma, {
                  at: prop
                });
              }
            } else {
              this.toAssignable(prop, isLHS);
            }
          }
        },
        {
          key: "toAssignableList",
          value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
            var end = exprList.length - 1;
            for (var i2 = 0; i2 <= end; i2++) {
              var elt = exprList[i2];
              if (!elt)
                continue;
              if (elt.type === "SpreadElement") {
                elt.type = "RestElement";
                var arg = elt.argument;
                this.checkToRestConversion(arg, true);
                this.toAssignable(arg, isLHS);
              } else {
                this.toAssignable(elt, isLHS);
              }
              if (elt.type === "RestElement") {
                if (i2 < end) {
                  this.raise(Errors.RestTrailingComma, {
                    at: elt
                  });
                } else if (trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: trailingCommaLoc
                  });
                }
              }
            }
          }
        },
        {
          key: "isAssignable",
          value: function isAssignable(node2, isBinding3) {
            var _this = this;
            switch (node2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                var last2 = node2.properties.length - 1;
                return node2.properties.every(function(prop, i2) {
                  return prop.type !== "ObjectMethod" && (i2 === last2 || prop.type !== "SpreadElement") && _this.isAssignable(prop);
                });
              }
              case "ObjectProperty":
                return this.isAssignable(node2.value);
              case "SpreadElement":
                return this.isAssignable(node2.argument);
              case "ArrayExpression":
                return node2.elements.every(function(element2) {
                  return element2 === null || _this.isAssignable(element2);
                });
              case "AssignmentExpression":
                return node2.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(node2.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !isBinding3;
              default:
                return false;
            }
          }
        },
        {
          key: "toReferencedList",
          value: function toReferencedList(exprList, isParenthesizedExpr) {
            return exprList;
          }
        },
        {
          key: "toReferencedListDeep",
          value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
            this.toReferencedList(exprList, isParenthesizedExpr);
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = exprList[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var expr = _step8.value;
                if ((expr === null || expr === void 0 ? void 0 : expr.type) === "ArrayExpression") {
                  this.toReferencedListDeep(expr.elements);
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        {
          key: "parseSpread",
          value: function parseSpread(refExpressionErrors) {
            var node2 = this.startNode();
            this.next();
            node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
            return this.finishNode(node2, "SpreadElement");
          }
        },
        {
          key: "parseRestBinding",
          value: function parseRestBinding() {
            var node2 = this.startNode();
            this.next();
            node2.argument = this.parseBindingAtom();
            return this.finishNode(node2, "RestElement");
          }
        },
        {
          key: "parseBindingAtom",
          value: function parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                var node2 = this.startNode();
                this.next();
                node2.elements = this.parseBindingList(3, 93, 1);
                return this.finishNode(node2, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
        },
        {
          key: "parseBindingList",
          value: function parseBindingList(close, closeCharCode, flags) {
            var allowEmpty = flags & 1;
            var elts = [];
            var first = true;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(12);
              }
              if (allowEmpty && this.match(12)) {
                elts.push(null);
              } else if (this.eat(close)) {
                break;
              } else if (this.match(21)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
                if (!this.checkCommaAfterRest(closeCharCode)) {
                  this.expect(close);
                  break;
                }
              } else {
                var decorators = [];
                if (this.match(26) && this.hasPlugin("decorators")) {
                  this.raise(Errors.UnsupportedParameterDecorator, {
                    at: this.state.startLoc
                  });
                }
                while (this.match(26)) {
                  decorators.push(this.parseDecorator());
                }
                elts.push(this.parseAssignableListItem(flags, decorators));
              }
            }
            return elts;
          }
        },
        {
          key: "parseBindingRestProperty",
          value: function parseBindingRestProperty(prop) {
            this.next();
            prop.argument = this.parseIdentifier();
            this.checkCommaAfterRest(125);
            return this.finishNode(prop, "RestElement");
          }
        },
        {
          key: "parseBindingProperty",
          value: function parseBindingProperty() {
            var prop = this.startNode();
            var _this_state = this.state, type3 = _this_state.type, startLoc = _this_state.startLoc;
            if (type3 === 21) {
              return this.parseBindingRestProperty(prop);
            } else if (type3 === 138) {
              this.expectPlugin("destructuringPrivate", startLoc);
              this.classScope.usePrivateName(this.state.value, startLoc);
              prop.key = this.parsePrivateName();
            } else {
              this.parsePropertyName(prop);
            }
            prop.method = false;
            return this.parseObjPropValue(prop, startLoc, false, false, true, false);
          }
        },
        {
          key: "parseAssignableListItem",
          value: function parseAssignableListItem(flags, decorators) {
            var left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left, flags);
            var elt = this.parseMaybeDefault(left.loc.start, left);
            if (decorators.length) {
              left.decorators = decorators;
            }
            return elt;
          }
        },
        {
          key: "parseAssignableListItemTypes",
          value: function parseAssignableListItemTypes(param, flags) {
            return param;
          }
        },
        {
          key: "parseMaybeDefault",
          value: function parseMaybeDefault(startLoc, left) {
            startLoc !== null && startLoc !== void 0 ? startLoc : startLoc = this.state.startLoc;
            left = left !== null && left !== void 0 ? left : this.parseBindingAtom();
            if (!this.eat(29))
              return left;
            var node2 = this.startNodeAt(startLoc);
            node2.left = left;
            node2.right = this.parseMaybeAssignAllowIn();
            return this.finishNode(node2, "AssignmentPattern");
          }
        },
        {
          key: "isValidLVal",
          value: function isValidLVal(type3, isUnparenthesizedInAssign, binding) {
            return getOwn$1({
              AssignmentPattern: "left",
              RestElement: "argument",
              ObjectProperty: "value",
              ParenthesizedExpression: "expression",
              ArrayPattern: "elements",
              ObjectPattern: "properties"
            }, type3);
          }
        },
        {
          key: "isOptionalMemberExpression",
          value: function isOptionalMemberExpression3(expression2) {
            return expression2.type === "OptionalMemberExpression";
          }
        },
        {
          key: "checkLVal",
          value: function checkLVal(expression2, param) {
            var ancestor = param.in, _param_binding = param.binding, binding = _param_binding === void 0 ? 64 : _param_binding, _param_checkClashes = param.checkClashes, checkClashes = _param_checkClashes === void 0 ? false : _param_checkClashes, _param_strictModeChanged = param.strictModeChanged, strictModeChanged = _param_strictModeChanged === void 0 ? false : _param_strictModeChanged, _param_hasParenthesizedAncestor = param.hasParenthesizedAncestor, hasParenthesizedAncestor = _param_hasParenthesizedAncestor === void 0 ? false : _param_hasParenthesizedAncestor;
            var _expression2_extra;
            var type3 = expression2.type;
            if (this.isObjectMethod(expression2))
              return;
            var isOptionalMemberExpression3 = this.isOptionalMemberExpression(expression2);
            if (isOptionalMemberExpression3 || type3 === "MemberExpression") {
              if (isOptionalMemberExpression3) {
                this.expectPlugin("optionalChainingAssign", expression2.loc.start);
                if (ancestor.type !== "AssignmentExpression") {
                  this.raise(Errors.InvalidLhsOptionalChaining, {
                    at: expression2,
                    ancestor
                  });
                }
              }
              if (binding !== 64) {
                this.raise(Errors.InvalidPropertyBindingPattern, {
                  at: expression2
                });
              }
              return;
            }
            if (type3 === "Identifier") {
              this.checkIdentifier(expression2, binding, strictModeChanged);
              var name2 = expression2.name;
              if (checkClashes) {
                if (checkClashes.has(name2)) {
                  this.raise(Errors.ParamDupe, {
                    at: expression2
                  });
                } else {
                  checkClashes.add(name2);
                }
              }
              return;
            }
            var validity = this.isValidLVal(type3, !(hasParenthesizedAncestor || ((_expression2_extra = expression2.extra) === null || _expression2_extra === void 0 ? void 0 : _expression2_extra.parenthesized)) && ancestor.type === "AssignmentExpression", binding);
            if (validity === true)
              return;
            if (validity === false) {
              var ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
              this.raise(ParseErrorClass, {
                at: expression2,
                ancestor
              });
              return;
            }
            var _ref = _sliced_to_array(Array.isArray(validity) ? validity : [
              validity,
              type3 === "ParenthesizedExpression"
            ], 2), key = _ref[0], isParenthesizedExpression2 = _ref[1];
            var nextAncestor = type3 === "ArrayPattern" || type3 === "ObjectPattern" ? {
              type: type3
            } : ancestor;
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = [].concat(expression2[key])[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var child = _step8.value;
                if (child) {
                  this.checkLVal(child, {
                    in: nextAncestor,
                    binding,
                    checkClashes,
                    strictModeChanged,
                    hasParenthesizedAncestor: isParenthesizedExpression2
                  });
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        {
          key: "checkIdentifier",
          value: function checkIdentifier(at2, bindingType) {
            var strictModeChanged = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name))) {
              if (bindingType === 64) {
                this.raise(Errors.StrictEvalArguments, {
                  at: at2,
                  referenceName: at2.name
                });
              } else {
                this.raise(Errors.StrictEvalArgumentsBinding, {
                  at: at2,
                  bindingName: at2.name
                });
              }
            }
            if (bindingType & 8192 && at2.name === "let") {
              this.raise(Errors.LetInLexicalBinding, {
                at: at2
              });
            }
            if (!(bindingType & 64)) {
              this.declareNameFromIdentifier(at2, bindingType);
            }
          }
        },
        {
          key: "declareNameFromIdentifier",
          value: function declareNameFromIdentifier(identifier7, binding) {
            this.scope.declareName(identifier7.name, binding, identifier7.loc.start);
          }
        },
        {
          key: "checkToRestConversion",
          value: function checkToRestConversion(node2, allowPattern) {
            switch (node2.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(node2.expression, allowPattern);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (allowPattern)
                  break;
              default:
                this.raise(Errors.InvalidRestAssignmentPattern, {
                  at: node2
                });
            }
          }
        },
        {
          key: "checkCommaAfterRest",
          value: function checkCommaAfterRest(close) {
            if (!this.match(12)) {
              return false;
            }
            this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
              at: this.state.startLoc
            });
            return true;
          }
        }
      ]);
      return LValParser2;
    }(NodeUtils);
    var getOwn = function(object, key) {
      return Object.hasOwnProperty.call(object, key) && object[key];
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error("Unexpected ".concat(x, " value."));
      }
      return x;
    }
    function assert2(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum(_templateObject3())({
      AbstractMethodHasImplementation: function(param) {
        var methodName = param.methodName;
        return "Method '".concat(methodName, "' cannot have an implementation because it is marked abstract.");
      },
      AbstractPropertyHasInitializer: function(param) {
        var propertyName = param.propertyName;
        return "Property '".concat(propertyName, "' cannot have an initializer because it is marked abstract.");
      },
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: function(param) {
        var kind = param.kind;
        return "'declare' is not allowed in ".concat(kind, "ters.");
      },
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: function(param) {
        var modifier = param.modifier;
        return "Accessibility modifier already seen.";
      },
      DuplicateModifier: function(param) {
        var modifier = param.modifier;
        return "Duplicate modifier: '".concat(modifier, "'.");
      },
      EmptyHeritageClauseType: function(param) {
        var token = param.token;
        return "'".concat(token, "' list cannot be empty.");
      },
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: function(param) {
        var modifiers = param.modifiers;
        return "'".concat(modifiers[0], "' modifier cannot be used with '").concat(modifiers[1], "' modifier.");
      },
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: function(param) {
        var modifier = param.modifier;
        return "Index signatures cannot have an accessibility modifier ('".concat(modifier, "').");
      },
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: function(param) {
        var modifier = param.modifier;
        return "'".concat(modifier, "' modifier cannot appear on a type member.");
      },
      InvalidModifierOnTypeParameter: function(param) {
        var modifier = param.modifier;
        return "'".concat(modifier, "' modifier cannot appear on a type parameter.");
      },
      InvalidModifierOnTypeParameterPositions: function(param) {
        var modifier = param.modifier;
        return "'".concat(modifier, "' modifier can only appear on a type parameter of a class, interface or type alias.");
      },
      InvalidModifiersOrder: function(param) {
        var orderedModifiers = param.orderedModifiers;
        return "'".concat(orderedModifiers[0], "' modifier must precede '").concat(orderedModifiers[1], "' modifier.");
      },
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: function(param) {
        var modifier = param.modifier;
        return "Private elements cannot have an accessibility modifier ('".concat(modifier, "').");
      },
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: function(param) {
        var typeParameterName = param.typeParameterName;
        return "Single type parameter ".concat(typeParameterName, " should have a trailing comma. Example usage: <").concat(typeParameterName, ",>.");
      },
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: function(param) {
        var type3 = param.type;
        return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(type3, ".");
      }
    });
    function keywordTypeFromName(value1) {
      switch (value1) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = function(superClass) {
      var TypeScriptParserMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(TypeScriptParserMixin2, superClass2);
        var _super3 = _create_super(TypeScriptParserMixin2);
        function TypeScriptParserMixin2() {
          _class_call_check(this, TypeScriptParserMixin2);
          var _this;
          _this = _super3.call.apply(_super3, [
            this
          ].concat(Array.prototype.slice.call(arguments)));
          __publicField(_assert_this_initialized(_this), "tsParseInOutModifiers", _this.tsParseModifiers.bind(_assert_this_initialized(_this), {
            allowedModifiers: [
              "in",
              "out"
            ],
            disallowedModifiers: [
              "const",
              "public",
              "private",
              "protected",
              "readonly",
              "declare",
              "abstract",
              "override"
            ],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          }));
          __publicField(_assert_this_initialized(_this), "tsParseConstModifier", _this.tsParseModifiers.bind(_assert_this_initialized(_this), {
            allowedModifiers: [
              "const"
            ],
            disallowedModifiers: [
              "in",
              "out"
            ],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          }));
          __publicField(_assert_this_initialized(_this), "tsParseInOutConstModifiers", _this.tsParseModifiers.bind(_assert_this_initialized(_this), {
            allowedModifiers: [
              "in",
              "out",
              "const"
            ],
            disallowedModifiers: [
              "public",
              "private",
              "protected",
              "readonly",
              "declare",
              "abstract",
              "override"
            ],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          }));
          return _this;
        }
        _create_class(TypeScriptParserMixin2, [
          {
            key: "getScopeHandler",
            value: function getScopeHandler() {
              return TypeScriptScopeHandler;
            }
          },
          {
            key: "tsIsIdentifier",
            value: function tsIsIdentifier() {
              return tokenIsIdentifier(this.state.type);
            }
          },
          {
            key: "tsTokenCanFollowModifier",
            value: function tsTokenCanFollowModifier() {
              return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
          },
          {
            key: "tsNextTokenCanFollowModifier",
            value: function tsNextTokenCanFollowModifier() {
              this.next();
              return this.tsTokenCanFollowModifier();
            }
          },
          {
            key: "tsParseModifier",
            value: function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
              if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
                return void 0;
              }
              var modifier = this.state.value;
              if (allowedModifiers.indexOf(modifier) !== -1) {
                if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
                  return void 0;
                }
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                  return modifier;
                }
              }
              return void 0;
            }
          },
          {
            key: "tsParseModifiers",
            value: function tsParseModifiers(param, modified) {
              var allowedModifiers = param.allowedModifiers, disallowedModifiers = param.disallowedModifiers, stopOnStartOfClassStaticBlock = param.stopOnStartOfClassStaticBlock, _param_errorTemplate = param.errorTemplate, errorTemplate = _param_errorTemplate === void 0 ? TSErrors.InvalidModifierOnTypeMember : _param_errorTemplate;
              var _this = this;
              var enforceOrder = function(loc, modifier2, before, after) {
                if (modifier2 === before && modified[after]) {
                  _this.raise(TSErrors.InvalidModifiersOrder, {
                    at: loc,
                    orderedModifiers: [
                      before,
                      after
                    ]
                  });
                }
              };
              var incompatible = function(loc, modifier2, mod1, mod2) {
                if (modified[mod1] && modifier2 === mod2 || modified[mod2] && modifier2 === mod1) {
                  _this.raise(TSErrors.IncompatibleModifiers, {
                    at: loc,
                    modifiers: [
                      mod1,
                      mod2
                    ]
                  });
                }
              };
              for (; ; ) {
                var startLoc = this.state.startLoc;
                var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers !== null && disallowedModifiers !== void 0 ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
                if (!modifier)
                  break;
                if (tsIsAccessModifier(modifier)) {
                  if (modified.accessibility) {
                    this.raise(TSErrors.DuplicateAccessibilityModifier, {
                      at: startLoc,
                      modifier
                    });
                  } else {
                    enforceOrder(startLoc, modifier, modifier, "override");
                    enforceOrder(startLoc, modifier, modifier, "static");
                    enforceOrder(startLoc, modifier, modifier, "readonly");
                    modified.accessibility = modifier;
                  }
                } else if (tsIsVarianceAnnotations(modifier)) {
                  if (modified[modifier]) {
                    this.raise(TSErrors.DuplicateModifier, {
                      at: startLoc,
                      modifier
                    });
                  }
                  modified[modifier] = true;
                  enforceOrder(startLoc, modifier, "in", "out");
                } else {
                  if (Object.hasOwnProperty.call(modified, modifier)) {
                    this.raise(TSErrors.DuplicateModifier, {
                      at: startLoc,
                      modifier
                    });
                  } else {
                    enforceOrder(startLoc, modifier, "static", "readonly");
                    enforceOrder(startLoc, modifier, "static", "override");
                    enforceOrder(startLoc, modifier, "override", "readonly");
                    enforceOrder(startLoc, modifier, "abstract", "override");
                    incompatible(startLoc, modifier, "declare", "override");
                    incompatible(startLoc, modifier, "static", "abstract");
                  }
                  modified[modifier] = true;
                }
                if (disallowedModifiers === null || disallowedModifiers === void 0 ? void 0 : disallowedModifiers.includes(modifier)) {
                  this.raise(errorTemplate, {
                    at: startLoc,
                    modifier
                  });
                }
              }
            }
          },
          {
            key: "tsIsListTerminator",
            value: function tsIsListTerminator(kind) {
              switch (kind) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(8);
                case "HeritageClauseElement":
                  return this.match(5);
                case "TupleElementTypes":
                  return this.match(3);
                case "TypeParametersOrArguments":
                  return this.match(48);
              }
            }
          },
          {
            key: "tsParseList",
            value: function tsParseList(kind, parseElement) {
              var result = [];
              while (!this.tsIsListTerminator(kind)) {
                result.push(parseElement());
              }
              return result;
            }
          },
          {
            key: "tsParseDelimitedList",
            value: function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
              return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
            }
          },
          {
            key: "tsParseDelimitedListWorker",
            value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
              var result = [];
              var trailingCommaPos = -1;
              for (; ; ) {
                if (this.tsIsListTerminator(kind)) {
                  break;
                }
                trailingCommaPos = -1;
                var element2 = parseElement();
                if (element2 == null) {
                  return void 0;
                }
                result.push(element2);
                if (this.eat(12)) {
                  trailingCommaPos = this.state.lastTokStart;
                  continue;
                }
                if (this.tsIsListTerminator(kind)) {
                  break;
                }
                if (expectSuccess) {
                  this.expect(12);
                }
                return void 0;
              }
              if (refTrailingCommaPos) {
                refTrailingCommaPos.value = trailingCommaPos;
              }
              return result;
            }
          },
          {
            key: "tsParseBracketedList",
            value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
              if (!skipFirstToken) {
                if (bracket) {
                  this.expect(0);
                } else {
                  this.expect(47);
                }
              }
              var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
              if (bracket) {
                this.expect(3);
              } else {
                this.expect(48);
              }
              return result;
            }
          },
          {
            key: "tsParseImportType",
            value: function tsParseImportType() {
              var node2 = this.startNode();
              this.expect(83);
              this.expect(10);
              if (!this.match(133)) {
                this.raise(TSErrors.UnsupportedImportTypeArgument, {
                  at: this.state.startLoc
                });
              }
              node2.argument = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExprAtom", this).call(this);
              this.expect(11);
              if (this.eat(16)) {
                node2.qualifier = this.tsParseEntityName();
              }
              if (this.match(47)) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSImportType");
            }
          },
          {
            key: "tsParseEntityName",
            value: function tsParseEntityName() {
              var allowReservedWords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              var entity = this.parseIdentifier(allowReservedWords);
              while (this.eat(16)) {
                var node2 = this.startNodeAtNode(entity);
                node2.left = entity;
                node2.right = this.parseIdentifier(allowReservedWords);
                entity = this.finishNode(node2, "TSQualifiedName");
              }
              return entity;
            }
          },
          {
            key: "tsParseTypeReference",
            value: function tsParseTypeReference() {
              var node2 = this.startNode();
              node2.typeName = this.tsParseEntityName();
              if (!this.hasPrecedingLineBreak() && this.match(47)) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSTypeReference");
            }
          },
          {
            key: "tsParseThisTypePredicate",
            value: function tsParseThisTypePredicate(lhs) {
              this.next();
              var node2 = this.startNodeAtNode(lhs);
              node2.parameterName = lhs;
              node2.typeAnnotation = this.tsParseTypeAnnotation(false);
              node2.asserts = false;
              return this.finishNode(node2, "TSTypePredicate");
            }
          },
          {
            key: "tsParseThisTypeNode",
            value: function tsParseThisTypeNode() {
              var node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSThisType");
            }
          },
          {
            key: "tsParseTypeQuery",
            value: function tsParseTypeQuery() {
              var node2 = this.startNode();
              this.expect(87);
              if (this.match(83)) {
                node2.exprName = this.tsParseImportType();
              } else {
                node2.exprName = this.tsParseEntityName();
              }
              if (!this.hasPrecedingLineBreak() && this.match(47)) {
                node2.typeParameters = this.tsParseTypeArguments();
              }
              return this.finishNode(node2, "TSTypeQuery");
            }
          },
          {
            key: "tsParseTypeParameter",
            value: function tsParseTypeParameter(parseModifiers) {
              var node2 = this.startNode();
              parseModifiers(node2);
              node2.name = this.tsParseTypeParameterName();
              node2.constraint = this.tsEatThenParseType(81);
              node2.default = this.tsEatThenParseType(29);
              return this.finishNode(node2, "TSTypeParameter");
            }
          },
          {
            key: "tsTryParseTypeParameters",
            value: function tsTryParseTypeParameters(parseModifiers) {
              if (this.match(47)) {
                return this.tsParseTypeParameters(parseModifiers);
              }
            }
          },
          {
            key: "tsParseTypeParameters",
            value: function tsParseTypeParameters(parseModifiers) {
              var node2 = this.startNode();
              if (this.match(47) || this.match(142)) {
                this.next();
              } else {
                this.unexpected();
              }
              var refTrailingCommaPos = {
                value: -1
              };
              node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
              if (node2.params.length === 0) {
                this.raise(TSErrors.EmptyTypeParameters, {
                  at: node2
                });
              }
              if (refTrailingCommaPos.value !== -1) {
                this.addExtra(node2, "trailingComma", refTrailingCommaPos.value);
              }
              return this.finishNode(node2, "TSTypeParameterDeclaration");
            }
          },
          {
            key: "tsFillSignature",
            value: function tsFillSignature(returnToken, signature) {
              var returnTokenRequired = returnToken === 19;
              var paramsKey = "params";
              var returnTypeKey = "returnType";
              signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              this.expect(10);
              signature[paramsKey] = this.tsParseBindingListForSignature();
              if (returnTokenRequired) {
                signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
              } else if (this.match(returnToken)) {
                signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
              }
            }
          },
          {
            key: "tsParseBindingListForSignature",
            value: function tsParseBindingListForSignature() {
              var list3 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseBindingList", this).call(this, 11, 41, 2);
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = list3[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var pattern = _step8.value;
                  var type3 = pattern.type;
                  if (type3 === "AssignmentPattern" || type3 === "TSParameterProperty") {
                    this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                      at: pattern,
                      type: type3
                    });
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              return list3;
            }
          },
          {
            key: "tsParseTypeMemberSemicolon",
            value: function tsParseTypeMemberSemicolon() {
              if (!this.eat(12) && !this.isLineTerminator()) {
                this.expect(13);
              }
            }
          },
          {
            key: "tsParseSignatureMember",
            value: function tsParseSignatureMember(kind, node2) {
              this.tsFillSignature(14, node2);
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(node2, kind);
            }
          },
          {
            key: "tsIsUnambiguouslyIndexSignature",
            value: function tsIsUnambiguouslyIndexSignature() {
              this.next();
              if (tokenIsIdentifier(this.state.type)) {
                this.next();
                return this.match(14);
              }
              return false;
            }
          },
          {
            key: "tsTryParseIndexSignature",
            value: function tsTryParseIndexSignature(node2) {
              if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                return;
              }
              this.expect(0);
              var id = this.parseIdentifier();
              id.typeAnnotation = this.tsParseTypeAnnotation();
              this.resetEndLocation(id);
              this.expect(3);
              node2.parameters = [
                id
              ];
              var type3 = this.tsTryParseTypeAnnotation();
              if (type3)
                node2.typeAnnotation = type3;
              this.tsParseTypeMemberSemicolon();
              return this.finishNode(node2, "TSIndexSignature");
            }
          },
          {
            key: "tsParsePropertyOrMethodSignature",
            value: function tsParsePropertyOrMethodSignature(node2, readonly) {
              if (this.eat(17))
                node2.optional = true;
              var nodeAny = node2;
              if (this.match(10) || this.match(47)) {
                if (readonly) {
                  this.raise(TSErrors.ReadonlyForMethodSignature, {
                    at: node2
                  });
                }
                var method = nodeAny;
                if (method.kind && this.match(47)) {
                  this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                    at: this.state.curPosition()
                  });
                }
                this.tsFillSignature(14, method);
                this.tsParseTypeMemberSemicolon();
                var paramsKey = "params";
                var returnTypeKey = "returnType";
                if (method.kind === "get") {
                  if (method[paramsKey].length > 0) {
                    this.raise(Errors.BadGetterArity, {
                      at: this.state.curPosition()
                    });
                    if (this.isThisParam(method[paramsKey][0])) {
                      this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                        at: this.state.curPosition()
                      });
                    }
                  }
                } else if (method.kind === "set") {
                  if (method[paramsKey].length !== 1) {
                    this.raise(Errors.BadSetterArity, {
                      at: this.state.curPosition()
                    });
                  } else {
                    var firstParameter = method[paramsKey][0];
                    if (this.isThisParam(firstParameter)) {
                      this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                        at: this.state.curPosition()
                      });
                    }
                    if (firstParameter.type === "Identifier" && firstParameter.optional) {
                      this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                        at: this.state.curPosition()
                      });
                    }
                    if (firstParameter.type === "RestElement") {
                      this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                        at: this.state.curPosition()
                      });
                    }
                  }
                  if (method[returnTypeKey]) {
                    this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                      at: method[returnTypeKey]
                    });
                  }
                } else {
                  method.kind = "method";
                }
                return this.finishNode(method, "TSMethodSignature");
              } else {
                var property = nodeAny;
                if (readonly)
                  property.readonly = true;
                var type3 = this.tsTryParseTypeAnnotation();
                if (type3)
                  property.typeAnnotation = type3;
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(property, "TSPropertySignature");
              }
            }
          },
          {
            key: "tsParseTypeMember",
            value: function tsParseTypeMember() {
              var node2 = this.startNode();
              if (this.match(10) || this.match(47)) {
                return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
              }
              if (this.match(77)) {
                var id = this.startNode();
                this.next();
                if (this.match(10) || this.match(47)) {
                  return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
                } else {
                  node2.key = this.createIdentifier(id, "new");
                  return this.tsParsePropertyOrMethodSignature(node2, false);
                }
              }
              this.tsParseModifiers({
                allowedModifiers: [
                  "readonly"
                ],
                disallowedModifiers: [
                  "declare",
                  "abstract",
                  "private",
                  "protected",
                  "public",
                  "static",
                  "override"
                ]
              }, node2);
              var idx = this.tsTryParseIndexSignature(node2);
              if (idx) {
                return idx;
              }
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parsePropertyName", this).call(this, node2);
              if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
                node2.kind = node2.key.name;
                _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parsePropertyName", this).call(this, node2);
              }
              return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
            }
          },
          {
            key: "tsParseTypeLiteral",
            value: function tsParseTypeLiteral() {
              var node2 = this.startNode();
              node2.members = this.tsParseObjectTypeMembers();
              return this.finishNode(node2, "TSTypeLiteral");
            }
          },
          {
            key: "tsParseObjectTypeMembers",
            value: function tsParseObjectTypeMembers() {
              this.expect(5);
              var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              this.expect(8);
              return members;
            }
          },
          {
            key: "tsIsStartOfMappedType",
            value: function tsIsStartOfMappedType() {
              this.next();
              if (this.eat(53)) {
                return this.isContextual(122);
              }
              if (this.isContextual(122)) {
                this.next();
              }
              if (!this.match(0)) {
                return false;
              }
              this.next();
              if (!this.tsIsIdentifier()) {
                return false;
              }
              this.next();
              return this.match(58);
            }
          },
          {
            key: "tsParseMappedTypeParameter",
            value: function tsParseMappedTypeParameter() {
              var node2 = this.startNode();
              node2.name = this.tsParseTypeParameterName();
              node2.constraint = this.tsExpectThenParseType(58);
              return this.finishNode(node2, "TSTypeParameter");
            }
          },
          {
            key: "tsParseMappedType",
            value: function tsParseMappedType() {
              var node2 = this.startNode();
              this.expect(5);
              if (this.match(53)) {
                node2.readonly = this.state.value;
                this.next();
                this.expectContextual(122);
              } else if (this.eatContextual(122)) {
                node2.readonly = true;
              }
              this.expect(0);
              node2.typeParameter = this.tsParseMappedTypeParameter();
              node2.nameType = this.eatContextual(93) ? this.tsParseType() : null;
              this.expect(3);
              if (this.match(53)) {
                node2.optional = this.state.value;
                this.next();
                this.expect(17);
              } else if (this.eat(17)) {
                node2.optional = true;
              }
              node2.typeAnnotation = this.tsTryParseType();
              this.semicolon();
              this.expect(8);
              return this.finishNode(node2, "TSMappedType");
            }
          },
          {
            key: "tsParseTupleType",
            value: function tsParseTupleType() {
              var _this = this;
              var node2 = this.startNode();
              node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              var seenOptionalElement = false;
              node2.elementTypes.forEach(function(elementNode) {
                var type3 = elementNode.type;
                if (seenOptionalElement && type3 !== "TSRestType" && type3 !== "TSOptionalType" && !(type3 === "TSNamedTupleMember" && elementNode.optional)) {
                  _this.raise(TSErrors.OptionalTypeBeforeRequired, {
                    at: elementNode
                  });
                }
                seenOptionalElement || (seenOptionalElement = type3 === "TSNamedTupleMember" && elementNode.optional || type3 === "TSOptionalType");
              });
              return this.finishNode(node2, "TSTupleType");
            }
          },
          {
            key: "tsParseTupleElementType",
            value: function tsParseTupleElementType() {
              var startLoc = this.state.startLoc;
              var rest = this.eat(21);
              var labeled;
              var label;
              var optional;
              var type3;
              var isWord = tokenIsKeywordOrIdentifier(this.state.type);
              var chAfterWord = isWord ? this.lookaheadCharCode() : null;
              if (chAfterWord === 58) {
                labeled = true;
                optional = false;
                label = this.parseIdentifier(true);
                this.expect(14);
                type3 = this.tsParseType();
              } else if (chAfterWord === 63) {
                optional = true;
                var startLoc2 = this.state.startLoc;
                var wordName = this.state.value;
                var typeOrLabel = this.tsParseNonArrayType();
                if (this.lookaheadCharCode() === 58) {
                  labeled = true;
                  label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
                  this.expect(17);
                  this.expect(14);
                  type3 = this.tsParseType();
                } else {
                  labeled = false;
                  type3 = typeOrLabel;
                  this.expect(17);
                }
              } else {
                type3 = this.tsParseType();
                optional = this.eat(17);
                labeled = this.eat(14);
              }
              if (labeled) {
                var labeledNode;
                if (label) {
                  labeledNode = this.startNodeAtNode(label);
                  labeledNode.optional = optional;
                  labeledNode.label = label;
                  labeledNode.elementType = type3;
                  if (this.eat(17)) {
                    labeledNode.optional = true;
                    this.raise(TSErrors.TupleOptionalAfterType, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                } else {
                  labeledNode = this.startNodeAtNode(type3);
                  labeledNode.optional = optional;
                  this.raise(TSErrors.InvalidTupleMemberLabel, {
                    at: type3
                  });
                  labeledNode.label = type3;
                  labeledNode.elementType = this.tsParseType();
                }
                type3 = this.finishNode(labeledNode, "TSNamedTupleMember");
              } else if (optional) {
                var optionalTypeNode = this.startNodeAtNode(type3);
                optionalTypeNode.typeAnnotation = type3;
                type3 = this.finishNode(optionalTypeNode, "TSOptionalType");
              }
              if (rest) {
                var restNode = this.startNodeAt(startLoc);
                restNode.typeAnnotation = type3;
                type3 = this.finishNode(restNode, "TSRestType");
              }
              return type3;
            }
          },
          {
            key: "tsParseParenthesizedType",
            value: function tsParseParenthesizedType() {
              var node2 = this.startNode();
              this.expect(10);
              node2.typeAnnotation = this.tsParseType();
              this.expect(11);
              return this.finishNode(node2, "TSParenthesizedType");
            }
          },
          {
            key: "tsParseFunctionOrConstructorType",
            value: function tsParseFunctionOrConstructorType(type3, abstract) {
              var _this = this;
              var node2 = this.startNode();
              if (type3 === "TSConstructorType") {
                node2.abstract = !!abstract;
                if (abstract)
                  this.next();
                this.next();
              }
              this.tsInAllowConditionalTypesContext(function() {
                return _this.tsFillSignature(19, node2);
              });
              return this.finishNode(node2, type3);
            }
          },
          {
            key: "tsParseLiteralTypeNode",
            value: function tsParseLiteralTypeNode() {
              var node2 = this.startNode();
              switch (this.state.type) {
                case 134:
                case 135:
                case 133:
                case 85:
                case 86:
                  node2.literal = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExprAtom", this).call(this);
                  break;
                default:
                  this.unexpected();
              }
              return this.finishNode(node2, "TSLiteralType");
            }
          },
          {
            key: "tsParseTemplateLiteralType",
            value: function tsParseTemplateLiteralType() {
              var node2 = this.startNode();
              node2.literal = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseTemplate", this).call(this, false);
              return this.finishNode(node2, "TSLiteralType");
            }
          },
          {
            key: "parseTemplateSubstitution",
            value: function parseTemplateSubstitution() {
              if (this.state.inType)
                return this.tsParseType();
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseTemplateSubstitution", this).call(this);
            }
          },
          {
            key: "tsParseThisTypeOrThisTypePredicate",
            value: function tsParseThisTypeOrThisTypePredicate() {
              var thisKeyword = this.tsParseThisTypeNode();
              if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                return this.tsParseThisTypePredicate(thisKeyword);
              } else {
                return thisKeyword;
              }
            }
          },
          {
            key: "tsParseNonArrayType",
            value: function tsParseNonArrayType() {
              switch (this.state.type) {
                case 133:
                case 134:
                case 135:
                case 85:
                case 86:
                  return this.tsParseLiteralTypeNode();
                case 53:
                  if (this.state.value === "-") {
                    var node2 = this.startNode();
                    var nextToken = this.lookahead();
                    if (nextToken.type !== 134 && nextToken.type !== 135) {
                      this.unexpected();
                    }
                    node2.literal = this.parseMaybeUnary();
                    return this.finishNode(node2, "TSLiteralType");
                  }
                  break;
                case 78:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                  return this.tsParseTypeQuery();
                case 83:
                  return this.tsParseImportType();
                case 5:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                  return this.tsParseTupleType();
                case 10:
                  {
                    if (!this.options.createParenthesizedExpressions) {
                      var startLoc = this.state.startLoc;
                      this.next();
                      var type3 = this.tsParseType();
                      this.expect(11);
                      this.addExtra(type3, "parenthesized", true);
                      this.addExtra(type3, "parenStart", startLoc.index);
                      return type3;
                    }
                  }
                  return this.tsParseParenthesizedType();
                case 25:
                case 24:
                  return this.tsParseTemplateLiteralType();
                default: {
                  var type12 = this.state.type;
                  if (tokenIsIdentifier(type12) || type12 === 88 || type12 === 84) {
                    var nodeType = type12 === 88 ? "TSVoidKeyword" : type12 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                    if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                      var node1 = this.startNode();
                      this.next();
                      return this.finishNode(node1, nodeType);
                    }
                    return this.tsParseTypeReference();
                  }
                }
              }
              this.unexpected();
            }
          },
          {
            key: "tsParseArrayTypeOrHigher",
            value: function tsParseArrayTypeOrHigher() {
              var type3 = this.tsParseNonArrayType();
              while (!this.hasPrecedingLineBreak() && this.eat(0)) {
                if (this.match(3)) {
                  var node2 = this.startNodeAtNode(type3);
                  node2.elementType = type3;
                  this.expect(3);
                  type3 = this.finishNode(node2, "TSArrayType");
                } else {
                  var node1 = this.startNodeAtNode(type3);
                  node1.objectType = type3;
                  node1.indexType = this.tsParseType();
                  this.expect(3);
                  type3 = this.finishNode(node1, "TSIndexedAccessType");
                }
              }
              return type3;
            }
          },
          {
            key: "tsParseTypeOperator",
            value: function tsParseTypeOperator() {
              var node2 = this.startNode();
              var operator = this.state.value;
              this.next();
              node2.operator = operator;
              node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
              if (operator === "readonly") {
                this.tsCheckTypeAnnotationForReadOnly(node2);
              }
              return this.finishNode(node2, "TSTypeOperator");
            }
          },
          {
            key: "tsCheckTypeAnnotationForReadOnly",
            value: function tsCheckTypeAnnotationForReadOnly(node2) {
              switch (node2.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(TSErrors.UnexpectedReadonly, {
                    at: node2
                  });
              }
            }
          },
          {
            key: "tsParseInferType",
            value: function tsParseInferType() {
              var _this = this;
              var node2 = this.startNode();
              this.expectContextual(115);
              var typeParameter2 = this.startNode();
              typeParameter2.name = this.tsParseTypeParameterName();
              typeParameter2.constraint = this.tsTryParse(function() {
                return _this.tsParseConstraintForInferType();
              });
              node2.typeParameter = this.finishNode(typeParameter2, "TSTypeParameter");
              return this.finishNode(node2, "TSInferType");
            }
          },
          {
            key: "tsParseConstraintForInferType",
            value: function tsParseConstraintForInferType() {
              var _this = this;
              if (this.eat(81)) {
                var constraint = this.tsInDisallowConditionalTypesContext(function() {
                  return _this.tsParseType();
                });
                if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                  return constraint;
                }
              }
            }
          },
          {
            key: "tsParseTypeOperatorOrHigher",
            value: function tsParseTypeOperatorOrHigher() {
              var _this = this;
              var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
              return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function() {
                return _this.tsParseArrayTypeOrHigher();
              });
            }
          },
          {
            key: "tsParseUnionOrIntersectionType",
            value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
              var node2 = this.startNode();
              var hasLeadingOperator = this.eat(operator);
              var types22 = [];
              do {
                types22.push(parseConstituentType());
              } while (this.eat(operator));
              if (types22.length === 1 && !hasLeadingOperator) {
                return types22[0];
              }
              node2.types = types22;
              return this.finishNode(node2, kind);
            }
          },
          {
            key: "tsParseIntersectionTypeOrHigher",
            value: function tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
            }
          },
          {
            key: "tsParseUnionTypeOrHigher",
            value: function tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
            }
          },
          {
            key: "tsIsStartOfFunctionType",
            value: function tsIsStartOfFunctionType() {
              if (this.match(47)) {
                return true;
              }
              return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
          },
          {
            key: "tsSkipParameterStart",
            value: function tsSkipParameterStart() {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                this.next();
                return true;
              }
              if (this.match(5)) {
                var errors = this.state.errors;
                var previousErrorCount = errors.length;
                try {
                  this.parseObjectLike(8, true);
                  return errors.length === previousErrorCount;
                } catch (e) {
                  return false;
                }
              }
              if (this.match(0)) {
                this.next();
                var errors1 = this.state.errors;
                var previousErrorCount1 = errors1.length;
                try {
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseBindingList", this).call(this, 3, 93, 1);
                  return errors1.length === previousErrorCount1;
                } catch (e) {
                  return false;
                }
              }
              return false;
            }
          },
          {
            key: "tsIsUnambiguouslyStartOfFunctionType",
            value: function tsIsUnambiguouslyStartOfFunctionType() {
              this.next();
              if (this.match(11) || this.match(21)) {
                return true;
              }
              if (this.tsSkipParameterStart()) {
                if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                  return true;
                }
                if (this.match(11)) {
                  this.next();
                  if (this.match(19)) {
                    return true;
                  }
                }
              }
              return false;
            }
          },
          {
            key: "tsParseTypeOrTypePredicateAnnotation",
            value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
              var _this = this;
              return this.tsInType(function() {
                var t2 = _this.startNode();
                _this.expect(returnToken);
                var node2 = _this.startNode();
                var asserts = !!_this.tsTryParse(_this.tsParseTypePredicateAsserts.bind(_this));
                if (asserts && _this.match(78)) {
                  var thisTypePredicate = _this.tsParseThisTypeOrThisTypePredicate();
                  if (thisTypePredicate.type === "TSThisType") {
                    node2.parameterName = thisTypePredicate;
                    node2.asserts = true;
                    node2.typeAnnotation = null;
                    thisTypePredicate = _this.finishNode(node2, "TSTypePredicate");
                  } else {
                    _this.resetStartLocationFromNode(thisTypePredicate, node2);
                    thisTypePredicate.asserts = true;
                  }
                  t2.typeAnnotation = thisTypePredicate;
                  return _this.finishNode(t2, "TSTypeAnnotation");
                }
                var typePredicateVariable = _this.tsIsIdentifier() && _this.tsTryParse(_this.tsParseTypePredicatePrefix.bind(_this));
                if (!typePredicateVariable) {
                  if (!asserts) {
                    return _this.tsParseTypeAnnotation(false, t2);
                  }
                  node2.parameterName = _this.parseIdentifier();
                  node2.asserts = asserts;
                  node2.typeAnnotation = null;
                  t2.typeAnnotation = _this.finishNode(node2, "TSTypePredicate");
                  return _this.finishNode(t2, "TSTypeAnnotation");
                }
                var type3 = _this.tsParseTypeAnnotation(false);
                node2.parameterName = typePredicateVariable;
                node2.typeAnnotation = type3;
                node2.asserts = asserts;
                t2.typeAnnotation = _this.finishNode(node2, "TSTypePredicate");
                return _this.finishNode(t2, "TSTypeAnnotation");
              });
            }
          },
          {
            key: "tsTryParseTypeOrTypePredicateAnnotation",
            value: function tsTryParseTypeOrTypePredicateAnnotation() {
              if (this.match(14)) {
                return this.tsParseTypeOrTypePredicateAnnotation(14);
              }
            }
          },
          {
            key: "tsTryParseTypeAnnotation",
            value: function tsTryParseTypeAnnotation() {
              if (this.match(14)) {
                return this.tsParseTypeAnnotation();
              }
            }
          },
          {
            key: "tsTryParseType",
            value: function tsTryParseType() {
              return this.tsEatThenParseType(14);
            }
          },
          {
            key: "tsParseTypePredicatePrefix",
            value: function tsParseTypePredicatePrefix() {
              var id = this.parseIdentifier();
              if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                this.next();
                return id;
              }
            }
          },
          {
            key: "tsParseTypePredicateAsserts",
            value: function tsParseTypePredicateAsserts() {
              if (this.state.type !== 109) {
                return false;
              }
              var containsEsc = this.state.containsEsc;
              this.next();
              if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
                return false;
              }
              if (containsEsc) {
                this.raise(Errors.InvalidEscapedReservedWord, {
                  at: this.state.lastTokStartLoc,
                  reservedWord: "asserts"
                });
              }
              return true;
            }
          },
          {
            key: "tsParseTypeAnnotation",
            value: function tsParseTypeAnnotation() {
              var eatColon = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
              var _this = this;
              this.tsInType(function() {
                if (eatColon)
                  _this.expect(14);
                t2.typeAnnotation = _this.tsParseType();
              });
              return this.finishNode(t2, "TSTypeAnnotation");
            }
          },
          {
            key: "tsParseType",
            value: function tsParseType() {
              var _this = this;
              assert2(this.state.inType);
              var type3 = this.tsParseNonConditionalType();
              if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
                return type3;
              }
              var node2 = this.startNodeAtNode(type3);
              node2.checkType = type3;
              node2.extendsType = this.tsInDisallowConditionalTypesContext(function() {
                return _this.tsParseNonConditionalType();
              });
              this.expect(17);
              node2.trueType = this.tsInAllowConditionalTypesContext(function() {
                return _this.tsParseType();
              });
              this.expect(14);
              node2.falseType = this.tsInAllowConditionalTypesContext(function() {
                return _this.tsParseType();
              });
              return this.finishNode(node2, "TSConditionalType");
            }
          },
          {
            key: "isAbstractConstructorSignature",
            value: function isAbstractConstructorSignature() {
              return this.isContextual(124) && this.lookahead().type === 77;
            }
          },
          {
            key: "tsParseNonConditionalType",
            value: function tsParseNonConditionalType() {
              if (this.tsIsStartOfFunctionType()) {
                return this.tsParseFunctionOrConstructorType("TSFunctionType");
              }
              if (this.match(77)) {
                return this.tsParseFunctionOrConstructorType("TSConstructorType");
              } else if (this.isAbstractConstructorSignature()) {
                return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
              }
              return this.tsParseUnionTypeOrHigher();
            }
          },
          {
            key: "tsParseTypeAssertion",
            value: function tsParseTypeAssertion() {
              var _this = this;
              if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                this.raise(TSErrors.ReservedTypeAssertion, {
                  at: this.state.startLoc
                });
              }
              var node2 = this.startNode();
              node2.typeAnnotation = this.tsInType(function() {
                _this.next();
                return _this.match(75) ? _this.tsParseTypeReference() : _this.tsParseType();
              });
              this.expect(48);
              node2.expression = this.parseMaybeUnary();
              return this.finishNode(node2, "TSTypeAssertion");
            }
          },
          {
            key: "tsParseHeritageClause",
            value: function tsParseHeritageClause(token) {
              var _this = this;
              var originalStartLoc = this.state.startLoc;
              var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", function() {
                var node2 = _this.startNode();
                node2.expression = _this.tsParseEntityName();
                if (_this.match(47)) {
                  node2.typeParameters = _this.tsParseTypeArguments();
                }
                return _this.finishNode(node2, "TSExpressionWithTypeArguments");
              });
              if (!delimitedList.length) {
                this.raise(TSErrors.EmptyHeritageClauseType, {
                  at: originalStartLoc,
                  token
                });
              }
              return delimitedList;
            }
          },
          {
            key: "tsParseInterfaceDeclaration",
            value: function tsParseInterfaceDeclaration(node2) {
              var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.hasFollowingLineBreak())
                return null;
              this.expectContextual(129);
              if (properties.declare)
                node2.declare = true;
              if (tokenIsIdentifier(this.state.type)) {
                node2.id = this.parseIdentifier();
                this.checkIdentifier(node2.id, 130);
              } else {
                node2.id = null;
                this.raise(TSErrors.MissingInterfaceName, {
                  at: this.state.startLoc
                });
              }
              node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
              if (this.eat(81)) {
                node2.extends = this.tsParseHeritageClause("extends");
              }
              var body = this.startNode();
              body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
              node2.body = this.finishNode(body, "TSInterfaceBody");
              return this.finishNode(node2, "TSInterfaceDeclaration");
            }
          },
          {
            key: "tsParseTypeAliasDeclaration",
            value: function tsParseTypeAliasDeclaration(node2) {
              var _this = this;
              node2.id = this.parseIdentifier();
              this.checkIdentifier(node2.id, 2);
              node2.typeAnnotation = this.tsInType(function() {
                node2.typeParameters = _this.tsTryParseTypeParameters(_this.tsParseInOutModifiers);
                _this.expect(29);
                if (_this.isContextual(114) && _this.lookahead().type !== 16) {
                  var node22 = _this.startNode();
                  _this.next();
                  return _this.finishNode(node22, "TSIntrinsicKeyword");
                }
                return _this.tsParseType();
              });
              this.semicolon();
              return this.finishNode(node2, "TSTypeAliasDeclaration");
            }
          },
          {
            key: "tsInNoContext",
            value: function tsInNoContext(cb) {
              var oldContext = this.state.context;
              this.state.context = [
                oldContext[0]
              ];
              try {
                return cb();
              } finally {
                this.state.context = oldContext;
              }
            }
          },
          {
            key: "tsInType",
            value: function tsInType(cb) {
              var oldInType = this.state.inType;
              this.state.inType = true;
              try {
                return cb();
              } finally {
                this.state.inType = oldInType;
              }
            }
          },
          {
            key: "tsInDisallowConditionalTypesContext",
            value: function tsInDisallowConditionalTypesContext(cb) {
              var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = true;
              try {
                return cb();
              } finally {
                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
              }
            }
          },
          {
            key: "tsInAllowConditionalTypesContext",
            value: function tsInAllowConditionalTypesContext(cb) {
              var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = false;
              try {
                return cb();
              } finally {
                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
              }
            }
          },
          {
            key: "tsEatThenParseType",
            value: function tsEatThenParseType(token) {
              if (this.match(token)) {
                return this.tsNextThenParseType();
              }
            }
          },
          {
            key: "tsExpectThenParseType",
            value: function tsExpectThenParseType(token) {
              var _this = this;
              return this.tsInType(function() {
                _this.expect(token);
                return _this.tsParseType();
              });
            }
          },
          {
            key: "tsNextThenParseType",
            value: function tsNextThenParseType() {
              var _this = this;
              return this.tsInType(function() {
                _this.next();
                return _this.tsParseType();
              });
            }
          },
          {
            key: "tsParseEnumMember",
            value: function tsParseEnumMember() {
              var node2 = this.startNode();
              node2.id = this.match(133) ? _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseStringLiteral", this).call(this, this.state.value) : this.parseIdentifier(true);
              if (this.eat(29)) {
                node2.initializer = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeAssignAllowIn", this).call(this);
              }
              return this.finishNode(node2, "TSEnumMember");
            }
          },
          {
            key: "tsParseEnumDeclaration",
            value: function tsParseEnumDeclaration(node2) {
              var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (properties.const)
                node2.const = true;
              if (properties.declare)
                node2.declare = true;
              this.expectContextual(126);
              node2.id = this.parseIdentifier();
              this.checkIdentifier(node2.id, node2.const ? 8971 : 8459);
              this.expect(5);
              node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
              this.expect(8);
              return this.finishNode(node2, "TSEnumDeclaration");
            }
          },
          {
            key: "tsParseModuleBlock",
            value: function tsParseModuleBlock() {
              var node2 = this.startNode();
              this.scope.enter(0);
              this.expect(5);
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseBlockOrModuleBlockBody", this).call(this, node2.body = [], void 0, true, 8);
              this.scope.exit();
              return this.finishNode(node2, "TSModuleBlock");
            }
          },
          {
            key: "tsParseModuleOrNamespaceDeclaration",
            value: function tsParseModuleOrNamespaceDeclaration(node2) {
              var nested = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              node2.id = this.parseIdentifier();
              if (!nested) {
                this.checkIdentifier(node2.id, 1024);
              }
              if (this.eat(16)) {
                var inner = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(inner, true);
                node2.body = inner;
              } else {
                this.scope.enter(256);
                this.prodParam.enter(0);
                node2.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
              }
              return this.finishNode(node2, "TSModuleDeclaration");
            }
          },
          {
            key: "tsParseAmbientExternalModuleDeclaration",
            value: function tsParseAmbientExternalModuleDeclaration(node2) {
              if (this.isContextual(112)) {
                node2.global = true;
                node2.id = this.parseIdentifier();
              } else if (this.match(133)) {
                node2.id = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseStringLiteral", this).call(this, this.state.value);
              } else {
                this.unexpected();
              }
              if (this.match(5)) {
                this.scope.enter(256);
                this.prodParam.enter(0);
                node2.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
              } else {
                this.semicolon();
              }
              return this.finishNode(node2, "TSModuleDeclaration");
            }
          },
          {
            key: "tsParseImportEqualsDeclaration",
            value: function tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, isExport) {
              node2.isExport = isExport || false;
              node2.id = maybeDefaultIdentifier || this.parseIdentifier();
              this.checkIdentifier(node2.id, 4096);
              this.expect(29);
              var moduleReference = this.tsParseModuleReference();
              if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
                this.raise(TSErrors.ImportAliasHasImportType, {
                  at: moduleReference
                });
              }
              node2.moduleReference = moduleReference;
              this.semicolon();
              return this.finishNode(node2, "TSImportEqualsDeclaration");
            }
          },
          {
            key: "tsIsExternalModuleReference",
            value: function tsIsExternalModuleReference() {
              return this.isContextual(119) && this.lookaheadCharCode() === 40;
            }
          },
          {
            key: "tsParseModuleReference",
            value: function tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
          },
          {
            key: "tsParseExternalModuleReference",
            value: function tsParseExternalModuleReference() {
              var node2 = this.startNode();
              this.expectContextual(119);
              this.expect(10);
              if (!this.match(133)) {
                this.unexpected();
              }
              node2.expression = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExprAtom", this).call(this);
              this.expect(11);
              this.sawUnambiguousESM = true;
              return this.finishNode(node2, "TSExternalModuleReference");
            }
          },
          {
            key: "tsLookAhead",
            value: function tsLookAhead(f) {
              var state = this.state.clone();
              var res = f();
              this.state = state;
              return res;
            }
          },
          {
            key: "tsTryParseAndCatch",
            value: function tsTryParseAndCatch(f) {
              var result = this.tryParse(function(abort) {
                return f() || abort();
              });
              if (result.aborted || !result.node)
                return;
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          },
          {
            key: "tsTryParse",
            value: function tsTryParse(f) {
              var state = this.state.clone();
              var result = f();
              if (result !== void 0 && result !== false) {
                return result;
              }
              this.state = state;
            }
          },
          {
            key: "tsTryParseDeclare",
            value: function tsTryParseDeclare(nany) {
              var _this = this;
              if (this.isLineTerminator()) {
                return;
              }
              var startType = this.state.type;
              var kind;
              if (this.isContextual(100)) {
                startType = 74;
                kind = "let";
              }
              return this.tsInAmbientContext(function() {
                switch (startType) {
                  case 68:
                    nany.declare = true;
                    return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseFunctionStatement", _this).call(_this, nany, false, false);
                  case 80:
                    nany.declare = true;
                    return _this.parseClass(nany, true, false);
                  case 126:
                    return _this.tsParseEnumDeclaration(nany, {
                      declare: true
                    });
                  case 112:
                    return _this.tsParseAmbientExternalModuleDeclaration(nany);
                  case 75:
                  case 74:
                    if (!_this.match(75) || !_this.isLookaheadContextual("enum")) {
                      nany.declare = true;
                      return _this.parseVarStatement(nany, kind || _this.state.value, true);
                    }
                    _this.expect(75);
                    return _this.tsParseEnumDeclaration(nany, {
                      const: true,
                      declare: true
                    });
                  case 129: {
                    var result = _this.tsParseInterfaceDeclaration(nany, {
                      declare: true
                    });
                    if (result)
                      return result;
                  }
                  default:
                    if (tokenIsIdentifier(startType)) {
                      return _this.tsParseDeclaration(nany, _this.state.value, true, null);
                    }
                }
              });
            }
          },
          {
            key: "tsTryParseExportDeclaration",
            value: function tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
            }
          },
          {
            key: "tsParseExpressionStatement",
            value: function tsParseExpressionStatement(node2, expr, decorators) {
              switch (expr.name) {
                case "declare": {
                  var declaration = this.tsTryParseDeclare(node2);
                  if (declaration) {
                    declaration.declare = true;
                  }
                  return declaration;
                }
                case "global":
                  if (this.match(5)) {
                    this.scope.enter(256);
                    this.prodParam.enter(0);
                    var mod = node2;
                    mod.global = true;
                    mod.id = expr;
                    mod.body = this.tsParseModuleBlock();
                    this.scope.exit();
                    this.prodParam.exit();
                    return this.finishNode(mod, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(node2, expr.name, false, decorators);
              }
            }
          },
          {
            key: "tsParseDeclaration",
            value: function tsParseDeclaration(node2, value1, next, decorators) {
              switch (value1) {
                case "abstract":
                  if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                    return this.tsParseAbstractDeclaration(node2, decorators);
                  }
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(next)) {
                    if (this.match(133)) {
                      return this.tsParseAmbientExternalModuleDeclaration(node2);
                    } else if (tokenIsIdentifier(this.state.type)) {
                      return this.tsParseModuleOrNamespaceDeclaration(node2);
                    }
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                    return this.tsParseModuleOrNamespaceDeclaration(node2);
                  }
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                    return this.tsParseTypeAliasDeclaration(node2);
                  }
                  break;
              }
            }
          },
          {
            key: "tsCheckLineTerminator",
            value: function tsCheckLineTerminator(next) {
              if (next) {
                if (this.hasFollowingLineBreak())
                  return false;
                this.next();
                return true;
              }
              return !this.isLineTerminator();
            }
          },
          {
            key: "tsTryParseGenericAsyncArrowFunction",
            value: function tsTryParseGenericAsyncArrowFunction(startLoc) {
              var _this = this;
              if (!this.match(47))
                return;
              var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              var res = this.tsTryParseAndCatch(function() {
                var node2 = _this.startNodeAt(startLoc);
                node2.typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseFunctionParams", _this).call(_this, node2);
                node2.returnType = _this.tsTryParseTypeOrTypePredicateAnnotation();
                _this.expect(19);
                return node2;
              });
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              if (!res)
                return;
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseArrowExpression", this).call(this, res, null, true);
            }
          },
          {
            key: "tsParseTypeArgumentsInExpression",
            value: function tsParseTypeArgumentsInExpression() {
              if (this.reScan_lt() !== 47)
                return;
              return this.tsParseTypeArguments();
            }
          },
          {
            key: "tsParseTypeArguments",
            value: function tsParseTypeArguments() {
              var _this = this;
              var node2 = this.startNode();
              node2.params = this.tsInType(function() {
                return _this.tsInNoContext(function() {
                  _this.expect(47);
                  return _this.tsParseDelimitedList("TypeParametersOrArguments", _this.tsParseType.bind(_this));
                });
              });
              if (node2.params.length === 0) {
                this.raise(TSErrors.EmptyTypeArguments, {
                  at: node2
                });
              } else if (!this.state.inType && this.curContext() === types2.brace) {
                this.reScan_lt_gt();
              }
              this.expect(48);
              return this.finishNode(node2, "TSTypeParameterInstantiation");
            }
          },
          {
            key: "tsIsDeclarationStart",
            value: function tsIsDeclarationStart() {
              return tokenIsTSDeclarationStart(this.state.type);
            }
          },
          {
            key: "isExportDefaultSpecifier",
            value: function isExportDefaultSpecifier3() {
              if (this.tsIsDeclarationStart())
                return false;
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isExportDefaultSpecifier", this).call(this);
            }
          },
          {
            key: "parseAssignableListItem",
            value: function parseAssignableListItem(flags, decorators) {
              var startLoc = this.state.startLoc;
              var modified = {};
              this.tsParseModifiers({
                allowedModifiers: [
                  "public",
                  "private",
                  "protected",
                  "override",
                  "readonly"
                ]
              }, modified);
              var accessibility = modified.accessibility;
              var override = modified.override;
              var readonly = modified.readonly;
              if (!(flags & 4) && (accessibility || readonly || override)) {
                this.raise(TSErrors.UnexpectedParameterModifier, {
                  at: startLoc
                });
              }
              var left = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(left, flags);
              var elt = this.parseMaybeDefault(left.loc.start, left);
              if (accessibility || readonly || override) {
                var pp2 = this.startNodeAt(startLoc);
                if (decorators.length) {
                  pp2.decorators = decorators;
                }
                if (accessibility)
                  pp2.accessibility = accessibility;
                if (readonly)
                  pp2.readonly = readonly;
                if (override)
                  pp2.override = override;
                if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
                  this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                    at: pp2
                  });
                }
                pp2.parameter = elt;
                return this.finishNode(pp2, "TSParameterProperty");
              }
              if (decorators.length) {
                left.decorators = decorators;
              }
              return elt;
            }
          },
          {
            key: "isSimpleParameter",
            value: function isSimpleParameter(node2) {
              return node2.type === "TSParameterProperty" && _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isSimpleParameter", this).call(this, node2.parameter) || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isSimpleParameter", this).call(this, node2);
            }
          },
          {
            key: "tsDisallowOptionalPattern",
            value: function tsDisallowOptionalPattern(node2) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = node2.params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var param = _step8.value;
                  if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
                    this.raise(TSErrors.PatternIsOptional, {
                      at: param
                    });
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            }
          },
          {
            key: "setArrowFunctionParameters",
            value: function setArrowFunctionParameters(node2, params, trailingCommaLoc) {
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "setArrowFunctionParameters", this).call(this, node2, params, trailingCommaLoc);
              this.tsDisallowOptionalPattern(node2);
            }
          },
          {
            key: "parseFunctionBodyAndFinish",
            value: function parseFunctionBodyAndFinish(node2, type3) {
              var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              }
              var bodilessType = type3 === "FunctionDeclaration" ? "TSDeclareFunction" : type3 === "ClassMethod" || type3 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
              if (bodilessType && !this.match(5) && this.isLineTerminator()) {
                return this.finishNode(node2, bodilessType);
              }
              if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                this.raise(TSErrors.DeclareFunctionHasImplementation, {
                  at: node2
                });
                if (node2.declare) {
                  return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseFunctionBodyAndFinish", this).call(this, node2, bodilessType, isMethod3);
                }
              }
              this.tsDisallowOptionalPattern(node2);
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseFunctionBodyAndFinish", this).call(this, node2, type3, isMethod3);
            }
          },
          {
            key: "registerFunctionStatementId",
            value: function registerFunctionStatementId(node2) {
              if (!node2.body && node2.id) {
                this.checkIdentifier(node2.id, 1024);
              } else {
                _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "registerFunctionStatementId", this).call(this, node2);
              }
            }
          },
          {
            key: "tsCheckForInvalidTypeCasts",
            value: function tsCheckForInvalidTypeCasts(items) {
              var _this = this;
              items.forEach(function(node2) {
                if ((node2 === null || node2 === void 0 ? void 0 : node2.type) === "TSTypeCastExpression") {
                  _this.raise(TSErrors.UnexpectedTypeAnnotation, {
                    at: node2.typeAnnotation
                  });
                }
              });
            }
          },
          {
            key: "toReferencedList",
            value: function toReferencedList(exprList, isInParens) {
              this.tsCheckForInvalidTypeCasts(exprList);
              return exprList;
            }
          },
          {
            key: "parseArrayLike",
            value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
              var node2 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
              if (node2.type === "ArrayExpression") {
                this.tsCheckForInvalidTypeCasts(node2.elements);
              }
              return node2;
            }
          },
          {
            key: "parseSubscript",
            value: function parseSubscript(base, startLoc, noCalls, state) {
              var _this = this;
              if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false;
                this.next();
                var nonNullExpression = this.startNodeAt(startLoc);
                nonNullExpression.expression = base;
                return this.finishNode(nonNullExpression, "TSNonNullExpression");
              }
              var isOptionalCall = false;
              if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (noCalls) {
                  state.stop = true;
                  return base;
                }
                state.optionalChainMember = isOptionalCall = true;
                this.next();
              }
              if (this.match(47) || this.match(51)) {
                var missingParenErrorLoc;
                var result = this.tsTryParseAndCatch(function() {
                  if (!noCalls && _this.atPossibleAsyncArrow(base)) {
                    var asyncArrowFn = _this.tsTryParseGenericAsyncArrowFunction(startLoc);
                    if (asyncArrowFn) {
                      return asyncArrowFn;
                    }
                  }
                  var typeArguments = _this.tsParseTypeArgumentsInExpression();
                  if (!typeArguments)
                    return;
                  if (isOptionalCall && !_this.match(10)) {
                    missingParenErrorLoc = _this.state.curPosition();
                    return;
                  }
                  if (tokenIsTemplate(_this.state.type)) {
                    var result2 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseTaggedTemplateExpression", _this).call(_this, base, startLoc, state);
                    result2.typeParameters = typeArguments;
                    return result2;
                  }
                  if (!noCalls && _this.eat(10)) {
                    var node2 = _this.startNodeAt(startLoc);
                    node2.callee = base;
                    node2.arguments = _this.parseCallExpressionArguments(11, false);
                    _this.tsCheckForInvalidTypeCasts(node2.arguments);
                    node2.typeParameters = typeArguments;
                    if (state.optionalChainMember) {
                      node2.optional = isOptionalCall;
                    }
                    return _this.finishCallExpression(node2, state.optionalChainMember);
                  }
                  var tokenType = _this.state.type;
                  if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !_this.hasPrecedingLineBreak()) {
                    return;
                  }
                  var node3 = _this.startNodeAt(startLoc);
                  node3.expression = base;
                  node3.typeParameters = typeArguments;
                  return _this.finishNode(node3, "TSInstantiationExpression");
                });
                if (missingParenErrorLoc) {
                  this.unexpected(missingParenErrorLoc, 10);
                }
                if (result) {
                  if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                    this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                      at: this.state.startLoc
                    });
                  }
                  return result;
                }
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
            }
          },
          {
            key: "parseNewCallee",
            value: function parseNewCallee(node2) {
              var _callee_extra;
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseNewCallee", this).call(this, node2);
              var callee = node2.callee;
              if (callee.type === "TSInstantiationExpression" && !((_callee_extra = callee.extra) === null || _callee_extra === void 0 ? void 0 : _callee_extra.parenthesized)) {
                node2.typeParameters = callee.typeParameters;
                node2.callee = callee.expression;
              }
            }
          },
          {
            key: "parseExprOp",
            value: function parseExprOp(left, leftStartLoc, minPrec) {
              var _this = this;
              var isSatisfies;
              if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
                var node2 = this.startNodeAt(leftStartLoc);
                node2.expression = left;
                node2.typeAnnotation = this.tsInType(function() {
                  _this.next();
                  if (_this.match(75)) {
                    if (isSatisfies) {
                      _this.raise(Errors.UnexpectedKeyword, {
                        at: _this.state.startLoc,
                        keyword: "const"
                      });
                    }
                    return _this.tsParseTypeReference();
                  }
                  return _this.tsParseType();
                });
                this.finishNode(node2, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
                this.reScan_lt_gt();
                return this.parseExprOp(node2, leftStartLoc, minPrec);
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExprOp", this).call(this, left, leftStartLoc, minPrec);
            }
          },
          {
            key: "checkReservedWord",
            value: function checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
              if (!this.state.isAmbientContext) {
                _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding3);
              }
            }
          },
          {
            key: "checkImportReflection",
            value: function checkImportReflection(node2) {
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "checkImportReflection", this).call(this, node2);
              if (node2.module && node2.importKind !== "value") {
                this.raise(TSErrors.ImportReflectionHasImportType, {
                  at: node2.specifiers[0].loc.start
                });
              }
            }
          },
          {
            key: "checkDuplicateExports",
            value: function checkDuplicateExports() {
            }
          },
          {
            key: "isPotentialImportPhase",
            value: function isPotentialImportPhase(isExport) {
              if (_get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isPotentialImportPhase", this).call(this, isExport))
                return true;
              if (this.isContextual(130)) {
                var ch = this.lookaheadCharCode();
                return isExport ? ch === 123 || ch === 42 : ch !== 61;
              }
              return !isExport && this.isContextual(87);
            }
          },
          {
            key: "applyImportPhase",
            value: function applyImportPhase(node2, isExport, phase, loc) {
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "applyImportPhase", this).call(this, node2, isExport, phase, loc);
              if (isExport) {
                node2.exportKind = phase === "type" ? "type" : "value";
              } else {
                node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
              }
            }
          },
          {
            key: "parseImport",
            value: function parseImport(node2) {
              if (this.match(133)) {
                node2.importKind = "value";
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseImport", this).call(this, node2);
              }
              var importNode;
              if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                node2.importKind = "value";
                return this.tsParseImportEqualsDeclaration(node2);
              } else if (this.isContextual(130)) {
                var maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
                if (this.lookaheadCharCode() === 61) {
                  return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier);
                } else {
                  importNode = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseImportSpecifiersAndAfter", this).call(this, node2, maybeDefaultIdentifier);
                }
              } else {
                importNode = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseImport", this).call(this, node2);
              }
              if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
                this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
                  at: importNode
                });
              }
              return importNode;
            }
          },
          {
            key: "parseExport",
            value: function parseExport(node2, decorators) {
              if (this.match(83)) {
                this.next();
                var maybeDefaultIdentifier = null;
                if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
                  maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
                } else {
                  node2.importKind = "value";
                }
                return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, true);
              } else if (this.eat(29)) {
                var assign = node2;
                assign.expression = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExpression", this).call(this);
                this.semicolon();
                this.sawUnambiguousESM = true;
                return this.finishNode(assign, "TSExportAssignment");
              } else if (this.eatContextual(93)) {
                var decl = node2;
                this.expectContextual(128);
                decl.id = this.parseIdentifier();
                this.semicolon();
                return this.finishNode(decl, "TSNamespaceExportDeclaration");
              } else {
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExport", this).call(this, node2, decorators);
              }
            }
          },
          {
            key: "isAbstractClass",
            value: function isAbstractClass() {
              return this.isContextual(124) && this.lookahead().type === 80;
            }
          },
          {
            key: "parseExportDefaultExpression",
            value: function parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                var cls = this.startNode();
                this.next();
                cls.abstract = true;
                return this.parseClass(cls, true, true);
              }
              if (this.match(129)) {
                var result = this.tsParseInterfaceDeclaration(this.startNode());
                if (result)
                  return result;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExportDefaultExpression", this).call(this);
            }
          },
          {
            key: "parseVarStatement",
            value: function parseVarStatement(node2, kind) {
              var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var isAmbientContext = this.state.isAmbientContext;
              var declaration = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseVarStatement", this).call(this, node2, kind, allowMissingInitializer || isAmbientContext);
              if (!isAmbientContext)
                return declaration;
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = declaration.declarations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var _step_value = _step8.value, id = _step_value.id, init = _step_value.init;
                  if (!init)
                    continue;
                  if (kind !== "const" || !!id.typeAnnotation) {
                    this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                      at: init
                    });
                  } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
                    this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                      at: init
                    });
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              return declaration;
            }
          },
          {
            key: "parseStatementContent",
            value: function parseStatementContent(flags, decorators) {
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                var node2 = this.startNode();
                this.expect(75);
                return this.tsParseEnumDeclaration(node2, {
                  const: true
                });
              }
              if (this.isContextual(126)) {
                return this.tsParseEnumDeclaration(this.startNode());
              }
              if (this.isContextual(129)) {
                var result = this.tsParseInterfaceDeclaration(this.startNode());
                if (result)
                  return result;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseStatementContent", this).call(this, flags, decorators);
            }
          },
          {
            key: "parseAccessModifier",
            value: function parseAccessModifier() {
              return this.tsParseModifier([
                "public",
                "protected",
                "private"
              ]);
            }
          },
          {
            key: "tsHasSomeModifiers",
            value: function tsHasSomeModifiers(member, modifiers) {
              return modifiers.some(function(modifier) {
                if (tsIsAccessModifier(modifier)) {
                  return member.accessibility === modifier;
                }
                return !!member[modifier];
              });
            }
          },
          {
            key: "tsIsStartOfStaticBlocks",
            value: function tsIsStartOfStaticBlocks() {
              return this.isContextual(106) && this.lookaheadCharCode() === 123;
            }
          },
          {
            key: "parseClassMember",
            value: function parseClassMember(classBody2, member, state) {
              var _this = this;
              var modifiers = [
                "declare",
                "private",
                "public",
                "protected",
                "override",
                "abstract",
                "readonly",
                "static"
              ];
              this.tsParseModifiers({
                allowedModifiers: modifiers,
                disallowedModifiers: [
                  "in",
                  "out"
                ],
                stopOnStartOfClassStaticBlock: true,
                errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
              }, member);
              var callParseClassMemberWithIsStatic = function() {
                if (_this.tsIsStartOfStaticBlocks()) {
                  _this.next();
                  _this.next();
                  if (_this.tsHasSomeModifiers(member, modifiers)) {
                    _this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                      at: _this.state.curPosition()
                    });
                  }
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassStaticBlock", _this).call(_this, classBody2, member);
                } else {
                  _this.parseClassMemberWithIsStatic(classBody2, member, state, !!member.static);
                }
              };
              if (member.declare) {
                this.tsInAmbientContext(callParseClassMemberWithIsStatic);
              } else {
                callParseClassMemberWithIsStatic();
              }
            }
          },
          {
            key: "parseClassMemberWithIsStatic",
            value: function parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
              var idx = this.tsTryParseIndexSignature(member);
              if (idx) {
                classBody2.body.push(idx);
                if (member.abstract) {
                  this.raise(TSErrors.IndexSignatureHasAbstract, {
                    at: member
                  });
                }
                if (member.accessibility) {
                  this.raise(TSErrors.IndexSignatureHasAccessibility, {
                    at: member,
                    modifier: member.accessibility
                  });
                }
                if (member.declare) {
                  this.raise(TSErrors.IndexSignatureHasDeclare, {
                    at: member
                  });
                }
                if (member.override) {
                  this.raise(TSErrors.IndexSignatureHasOverride, {
                    at: member
                  });
                }
                return;
              }
              if (!this.state.inAbstractClass && member.abstract) {
                this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
                  at: member
                });
              }
              if (member.override) {
                if (!state.hadSuperClass) {
                  this.raise(TSErrors.OverrideNotInSubClass, {
                    at: member
                  });
                }
              }
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody2, member, state, isStatic2);
            }
          },
          {
            key: "parsePostMemberNameModifiers",
            value: function parsePostMemberNameModifiers(methodOrProp) {
              var optional = this.eat(17);
              if (optional)
                methodOrProp.optional = true;
              if (methodOrProp.readonly && this.match(10)) {
                this.raise(TSErrors.ClassMethodHasReadonly, {
                  at: methodOrProp
                });
              }
              if (methodOrProp.declare && this.match(10)) {
                this.raise(TSErrors.ClassMethodHasDeclare, {
                  at: methodOrProp
                });
              }
            }
          },
          {
            key: "parseExpressionStatement",
            value: function parseExpressionStatement(node2, expr, decorators) {
              var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr, decorators) : void 0;
              return decl || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExpressionStatement", this).call(this, node2, expr, decorators);
            }
          },
          {
            key: "shouldParseExportDeclaration",
            value: function shouldParseExportDeclaration() {
              if (this.tsIsDeclarationStart())
                return true;
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "shouldParseExportDeclaration", this).call(this);
            }
          },
          {
            key: "parseConditional",
            value: function parseConditional(expr, startLoc, refExpressionErrors) {
              var _this = this;
              if (!this.state.maybeInArrowParameters || !this.match(17)) {
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseConditional", this).call(this, expr, startLoc, refExpressionErrors);
              }
              var result = this.tryParse(function() {
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseConditional", _this).call(_this, expr, startLoc);
              });
              if (!result.node) {
                if (result.error) {
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "setOptionalParametersError", this).call(this, refExpressionErrors, result.error);
                }
                return expr;
              }
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          },
          {
            key: "parseParenItem",
            value: function parseParenItem(node2, startLoc) {
              node2 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseParenItem", this).call(this, node2, startLoc);
              if (this.eat(17)) {
                node2.optional = true;
                this.resetEndLocation(node2);
              }
              if (this.match(14)) {
                var typeCastNode = this.startNodeAt(startLoc);
                typeCastNode.expression = node2;
                typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TSTypeCastExpression");
              }
              return node2;
            }
          },
          {
            key: "parseExportDeclaration",
            value: function parseExportDeclaration(node2) {
              var _this = this;
              if (!this.state.isAmbientContext && this.isContextual(125)) {
                return this.tsInAmbientContext(function() {
                  return _this.parseExportDeclaration(node2);
                });
              }
              var startLoc = this.state.startLoc;
              var isDeclare = this.eatContextual(125);
              if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
                throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
                  at: this.state.startLoc
                });
              }
              var isIdentifier6 = tokenIsIdentifier(this.state.type);
              var declaration = isIdentifier6 && this.tsTryParseExportDeclaration() || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExportDeclaration", this).call(this, node2);
              if (!declaration)
                return null;
              if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
                node2.exportKind = "type";
              }
              if (isDeclare) {
                this.resetStartLocation(declaration, startLoc);
                declaration.declare = true;
              }
              return declaration;
            }
          },
          {
            key: "parseClassId",
            value: function parseClassId(node2, isStatement5, optionalId, bindingType) {
              if ((!isStatement5 || optionalId) && this.isContextual(113)) {
                return;
              }
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassId", this).call(this, node2, isStatement5, optionalId, node2.declare ? 1024 : 8331);
              var typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
              if (typeParameters)
                node2.typeParameters = typeParameters;
            }
          },
          {
            key: "parseClassPropertyAnnotation",
            value: function parseClassPropertyAnnotation(node2) {
              if (!node2.optional) {
                if (this.eat(35)) {
                  node2.definite = true;
                } else if (this.eat(17)) {
                  node2.optional = true;
                }
              }
              var type3 = this.tsTryParseTypeAnnotation();
              if (type3)
                node2.typeAnnotation = type3;
            }
          },
          {
            key: "parseClassProperty",
            value: function parseClassProperty(node2) {
              this.parseClassPropertyAnnotation(node2);
              if (this.state.isAmbientContext && !(node2.readonly && !node2.typeAnnotation) && this.match(29)) {
                this.raise(TSErrors.DeclareClassFieldHasInitializer, {
                  at: this.state.startLoc
                });
              }
              if (node2.abstract && this.match(29)) {
                var key = node2.key;
                this.raise(TSErrors.AbstractPropertyHasInitializer, {
                  at: this.state.startLoc,
                  propertyName: key.type === "Identifier" && !node2.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]")
                });
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassProperty", this).call(this, node2);
            }
          },
          {
            key: "parseClassPrivateProperty",
            value: function parseClassPrivateProperty(node2) {
              if (node2.abstract) {
                this.raise(TSErrors.PrivateElementHasAbstract, {
                  at: node2
                });
              }
              if (node2.accessibility) {
                this.raise(TSErrors.PrivateElementHasAccessibility, {
                  at: node2,
                  modifier: node2.accessibility
                });
              }
              this.parseClassPropertyAnnotation(node2);
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassPrivateProperty", this).call(this, node2);
            }
          },
          {
            key: "parseClassAccessorProperty",
            value: function parseClassAccessorProperty(node2) {
              this.parseClassPropertyAnnotation(node2);
              if (node2.optional) {
                this.raise(TSErrors.AccessorCannotBeOptional, {
                  at: node2
                });
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassAccessorProperty", this).call(this, node2);
            }
          },
          {
            key: "pushClassMethod",
            value: function pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
              var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              if (typeParameters && isConstructor) {
                this.raise(TSErrors.ConstructorHasTypeParameters, {
                  at: typeParameters
                });
              }
              var _method_declare = method.declare, declare = _method_declare === void 0 ? false : _method_declare, kind = method.kind;
              if (declare && (kind === "get" || kind === "set")) {
                this.raise(TSErrors.DeclareAccessor, {
                  at: method,
                  kind
                });
              }
              if (typeParameters)
                method.typeParameters = typeParameters;
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "pushClassMethod", this).call(this, classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
            }
          },
          {
            key: "pushClassPrivateMethod",
            value: function pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
              var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              if (typeParameters)
                method.typeParameters = typeParameters;
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "pushClassPrivateMethod", this).call(this, classBody2, method, isGenerator, isAsync);
            }
          },
          {
            key: "declareClassPrivateMethodInScope",
            value: function declareClassPrivateMethodInScope(node2, kind) {
              if (node2.type === "TSDeclareMethod")
                return;
              if (node2.type === "MethodDefinition" && !node2.value.body)
                return;
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "declareClassPrivateMethodInScope", this).call(this, node2, kind);
            }
          },
          {
            key: "parseClassSuper",
            value: function parseClassSuper(node2) {
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClassSuper", this).call(this, node2);
              if (node2.superClass && (this.match(47) || this.match(51))) {
                node2.superTypeParameters = this.tsParseTypeArgumentsInExpression();
              }
              if (this.eatContextual(113)) {
                node2.implements = this.tsParseHeritageClause("implements");
              }
            }
          },
          {
            key: "parseObjPropValue",
            value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
              var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              if (typeParameters)
                prop.typeParameters = typeParameters;
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors);
            }
          },
          {
            key: "parseFunctionParams",
            value: function parseFunctionParams(node2, isConstructor) {
              var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              if (typeParameters)
                node2.typeParameters = typeParameters;
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseFunctionParams", this).call(this, node2, isConstructor);
            }
          },
          {
            key: "parseVarId",
            value: function parseVarId(decl, kind) {
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseVarId", this).call(this, decl, kind);
              if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
                decl.definite = true;
              }
              var type3 = this.tsTryParseTypeAnnotation();
              if (type3) {
                decl.id.typeAnnotation = type3;
                this.resetEndLocation(decl.id);
              }
            }
          },
          {
            key: "parseAsyncArrowFromCallExpression",
            value: function parseAsyncArrowFromCallExpression(node2, call2) {
              if (this.match(14)) {
                node2.returnType = this.tsParseTypeAnnotation();
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node2, call2);
            }
          },
          {
            key: "parseMaybeAssign",
            value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
              var _this = this;
              var state;
              var jsx22;
              var typeCast;
              if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
                state = this.state.clone();
                jsx22 = this.tryParse(function() {
                  return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                }, state);
                if (!jsx22.error)
                  return jsx22.node;
                var context = this.state.context;
                var currentContext = context[context.length - 1];
                if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
                  context.pop();
                }
              }
              if (!(jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.error) && !this.match(47)) {
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
              }
              if (!state || state === this.state)
                state = this.state.clone();
              var typeParameters;
              var arrow = this.tryParse(function(abort) {
                var _expr_extra;
                typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                var expr = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                if (expr.type !== "ArrowFunctionExpression" || ((_expr_extra = expr.extra) === null || _expr_extra === void 0 ? void 0 : _expr_extra.parenthesized)) {
                  abort();
                }
                if ((typeParameters === null || typeParameters === void 0 ? void 0 : typeParameters.params.length) !== 0) {
                  _this.resetStartLocationFromNode(expr, typeParameters);
                }
                expr.typeParameters = typeParameters;
                {
                  var _expr_typeParameters_extra;
                  if (_this.hasPlugin("jsx") && expr.typeParameters.params.length === 1 && !((_expr_typeParameters_extra = expr.typeParameters.extra) === null || _expr_typeParameters_extra === void 0 ? void 0 : _expr_typeParameters_extra.trailingComma)) {
                    var parameter = expr.typeParameters.params[0];
                    if (!parameter.constraint) {
                      _this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, {
                        at: createPositionWithColumnOffset(parameter.loc.end, 1),
                        typeParameterName: parameter.name.name
                      });
                    }
                  }
                }
                return expr;
              }, state);
              if (!arrow.error && !arrow.aborted) {
                if (typeParameters)
                  this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
              }
              if (!jsx22) {
                assert2(!this.hasPlugin("jsx"));
                typeCast = this.tryParse(function() {
                  return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                }, state);
                if (!typeCast.error)
                  return typeCast.node;
              }
              if (jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.node) {
                this.state = jsx22.failState;
                return jsx22.node;
              }
              if (arrow.node) {
                this.state = arrow.failState;
                if (typeParameters)
                  this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
              }
              if (typeCast === null || typeCast === void 0 ? void 0 : typeCast.node) {
                this.state = typeCast.failState;
                return typeCast.node;
              }
              throw (jsx22 === null || jsx22 === void 0 ? void 0 : jsx22.error) || arrow.error || (typeCast === null || typeCast === void 0 ? void 0 : typeCast.error);
            }
          },
          {
            key: "reportReservedArrowTypeParam",
            value: function reportReservedArrowTypeParam(node2) {
              var _node_extra;
              if (node2.params.length === 1 && !node2.params[0].constraint && !((_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                this.raise(TSErrors.ReservedArrowTypeParam, {
                  at: node2
                });
              }
            }
          },
          {
            key: "parseMaybeUnary",
            value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
              if (!this.hasPlugin("jsx") && this.match(47)) {
                return this.tsParseTypeAssertion();
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeUnary", this).call(this, refExpressionErrors, sawUnary);
            }
          },
          {
            key: "parseArrow",
            value: function parseArrow(node2) {
              var _this = this;
              if (this.match(14)) {
                var result = this.tryParse(function(abort) {
                  var returnType = _this.tsParseTypeOrTypePredicateAnnotation(14);
                  if (_this.canInsertSemicolon() || !_this.match(19))
                    abort();
                  return returnType;
                });
                if (result.aborted)
                  return;
                if (!result.thrown) {
                  if (result.error)
                    this.state = result.failState;
                  node2.returnType = result.node;
                }
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseArrow", this).call(this, node2);
            }
          },
          {
            key: "parseAssignableListItemTypes",
            value: function parseAssignableListItemTypes(param, flags) {
              if (!(flags & 2))
                return param;
              if (this.eat(17)) {
                param.optional = true;
              }
              var type3 = this.tsTryParseTypeAnnotation();
              if (type3)
                param.typeAnnotation = type3;
              this.resetEndLocation(param);
              return param;
            }
          },
          {
            key: "isAssignable",
            value: function isAssignable(node2, isBinding3) {
              switch (node2.type) {
                case "TSTypeCastExpression":
                  return this.isAssignable(node2.expression, isBinding3);
                case "TSParameterProperty":
                  return true;
                default:
                  return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isAssignable", this).call(this, node2, isBinding3);
              }
            }
          },
          {
            key: "toAssignable",
            value: function toAssignable(node2) {
              var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              switch (node2.type) {
                case "ParenthesizedExpression":
                  this.toAssignableParenthesizedExpression(node2, isLHS);
                  break;
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  if (isLHS) {
                    this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                      at: node2
                    });
                  } else {
                    this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                      at: node2
                    });
                  }
                  this.toAssignable(node2.expression, isLHS);
                  break;
                case "AssignmentExpression":
                  if (!isLHS && node2.left.type === "TSTypeCastExpression") {
                    node2.left = this.typeCastToParameter(node2.left);
                  }
                default:
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "toAssignable", this).call(this, node2, isLHS);
              }
            }
          },
          {
            key: "toAssignableParenthesizedExpression",
            value: function toAssignableParenthesizedExpression(node2, isLHS) {
              switch (node2.expression.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  this.toAssignable(node2.expression, isLHS);
                  break;
                default:
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "toAssignable", this).call(this, node2, isLHS);
              }
            }
          },
          {
            key: "checkToRestConversion",
            value: function checkToRestConversion(node2, allowPattern) {
              switch (node2.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                  this.checkToRestConversion(node2.expression, false);
                  break;
                default:
                  _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "checkToRestConversion", this).call(this, node2, allowPattern);
              }
            }
          },
          {
            key: "isValidLVal",
            value: function isValidLVal(type3, isUnparenthesizedInAssign, binding) {
              return getOwn({
                TSTypeCastExpression: true,
                TSParameterProperty: "parameter",
                TSNonNullExpression: "expression",
                TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [
                  "expression",
                  true
                ],
                TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [
                  "expression",
                  true
                ],
                TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && [
                  "expression",
                  true
                ]
              }, type3) || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isValidLVal", this).call(this, type3, isUnparenthesizedInAssign, binding);
            }
          },
          {
            key: "parseBindingAtom",
            value: function parseBindingAtom() {
              if (this.state.type === 78) {
                return this.parseIdentifier(true);
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseBindingAtom", this).call(this);
            }
          },
          {
            key: "parseMaybeDecoratorArguments",
            value: function parseMaybeDecoratorArguments(expr) {
              if (this.match(47) || this.match(51)) {
                var typeArguments = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                  var call2 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
                  call2.typeParameters = typeArguments;
                  return call2;
                }
                this.unexpected(null, 10);
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
            }
          },
          {
            key: "checkCommaAfterRest",
            value: function checkCommaAfterRest(close) {
              if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
                this.next();
                return false;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "checkCommaAfterRest", this).call(this, close);
            }
          },
          {
            key: "isClassMethod",
            value: function isClassMethod2() {
              return this.match(47) || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isClassMethod", this).call(this);
            }
          },
          {
            key: "isClassProperty",
            value: function isClassProperty2() {
              return this.match(35) || this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "isClassProperty", this).call(this);
            }
          },
          {
            key: "parseMaybeDefault",
            value: function parseMaybeDefault(startLoc, left) {
              var node2 = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
              if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
                this.raise(TSErrors.TypeAnnotationAfterAssign, {
                  at: node2.typeAnnotation
                });
              }
              return node2;
            }
          },
          {
            key: "getTokenFromCode",
            value: function getTokenFromCode(code22) {
              if (this.state.inType) {
                if (code22 === 62) {
                  this.finishOp(48, 1);
                  return;
                }
                if (code22 === 60) {
                  this.finishOp(47, 1);
                  return;
                }
              }
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "getTokenFromCode", this).call(this, code22);
            }
          },
          {
            key: "reScan_lt_gt",
            value: function reScan_lt_gt() {
              var type3 = this.state.type;
              if (type3 === 47) {
                this.state.pos -= 1;
                this.readToken_lt();
              } else if (type3 === 48) {
                this.state.pos -= 1;
                this.readToken_gt();
              }
            }
          },
          {
            key: "reScan_lt",
            value: function reScan_lt() {
              var type3 = this.state.type;
              if (type3 === 51) {
                this.state.pos -= 2;
                this.finishOp(47, 1);
                return 47;
              }
              return type3;
            }
          },
          {
            key: "toAssignableList",
            value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
              for (var i2 = 0; i2 < exprList.length; i2++) {
                var expr = exprList[i2];
                if ((expr === null || expr === void 0 ? void 0 : expr.type) === "TSTypeCastExpression") {
                  exprList[i2] = this.typeCastToParameter(expr);
                }
              }
              _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
            }
          },
          {
            key: "typeCastToParameter",
            value: function typeCastToParameter(node2) {
              node2.expression.typeAnnotation = node2.typeAnnotation;
              this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
              return node2.expression;
            }
          },
          {
            key: "shouldParseArrow",
            value: function shouldParseArrow(params) {
              var _this = this;
              if (this.match(14)) {
                return params.every(function(expr) {
                  return _this.isAssignable(expr, true);
                });
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "shouldParseArrow", this).call(this, params);
            }
          },
          {
            key: "shouldParseAsyncArrow",
            value: function shouldParseAsyncArrow() {
              return this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "shouldParseAsyncArrow", this).call(this);
            }
          },
          {
            key: "canHaveLeadingDecorator",
            value: function canHaveLeadingDecorator() {
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
            }
          },
          {
            key: "jsxParseOpeningElementAfterName",
            value: function jsxParseOpeningElementAfterName(node2) {
              var _this = this;
              if (this.match(47) || this.match(51)) {
                var typeArguments = this.tsTryParseAndCatch(function() {
                  return _this.tsParseTypeArgumentsInExpression();
                });
                if (typeArguments)
                  node2.typeParameters = typeArguments;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "jsxParseOpeningElementAfterName", this).call(this, node2);
            }
          },
          {
            key: "getGetterSetterExpectedParamCount",
            value: function getGetterSetterExpectedParamCount(method) {
              var baseCount = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);
              var params = this.getObjectOrClassMethodParams(method);
              var firstParam = params[0];
              var hasContextParam = firstParam && this.isThisParam(firstParam);
              return hasContextParam ? baseCount + 1 : baseCount;
            }
          },
          {
            key: "parseCatchClauseParam",
            value: function parseCatchClauseParam() {
              var param = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseCatchClauseParam", this).call(this);
              var type3 = this.tsTryParseTypeAnnotation();
              if (type3) {
                param.typeAnnotation = type3;
                this.resetEndLocation(param);
              }
              return param;
            }
          },
          {
            key: "tsInAmbientContext",
            value: function tsInAmbientContext(cb) {
              var oldIsAmbientContext = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return cb();
              } finally {
                this.state.isAmbientContext = oldIsAmbientContext;
              }
            }
          },
          {
            key: "parseClass",
            value: function parseClass(node2, isStatement5, optionalId) {
              var oldInAbstractClass = this.state.inAbstractClass;
              this.state.inAbstractClass = !!node2.abstract;
              try {
                return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseClass", this).call(this, node2, isStatement5, optionalId);
              } finally {
                this.state.inAbstractClass = oldInAbstractClass;
              }
            }
          },
          {
            key: "tsParseAbstractDeclaration",
            value: function tsParseAbstractDeclaration(node2, decorators) {
              if (this.match(80)) {
                node2.abstract = true;
                return this.maybeTakeDecorators(decorators, this.parseClass(node2, true, false));
              } else if (this.isContextual(129)) {
                if (!this.hasFollowingLineBreak()) {
                  node2.abstract = true;
                  this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                    at: node2
                  });
                  return this.tsParseInterfaceDeclaration(node2);
                }
              } else {
                this.unexpected(null, 80);
              }
            }
          },
          {
            key: "parseMethod",
            value: function parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type3, inClassScope) {
              var method = _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseMethod", this).call(this, node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type3, inClassScope);
              if (method.abstract) {
                var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                if (hasBody) {
                  var key = method.key;
                  this.raise(TSErrors.AbstractMethodHasImplementation, {
                    at: method,
                    methodName: key.type === "Identifier" && !method.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]")
                  });
                }
              }
              return method;
            }
          },
          {
            key: "tsParseTypeParameterName",
            value: function tsParseTypeParameterName() {
              var typeName = this.parseIdentifier();
              return typeName;
            }
          },
          {
            key: "shouldParseAsAmbientContext",
            value: function shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
          },
          {
            key: "parse",
            value: function parse5() {
              if (this.shouldParseAsAmbientContext()) {
                this.state.isAmbientContext = true;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parse", this).call(this);
            }
          },
          {
            key: "getExpression",
            value: function getExpression() {
              if (this.shouldParseAsAmbientContext()) {
                this.state.isAmbientContext = true;
              }
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "getExpression", this).call(this);
            }
          },
          {
            key: "parseExportSpecifier",
            value: function parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
              if (!isString && isMaybeTypeOnly) {
                this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport);
                return this.finishNode(node2, "ExportSpecifier");
              }
              node2.exportKind = "value";
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseExportSpecifier", this).call(this, node2, isString, isInTypeExport, isMaybeTypeOnly);
            }
          },
          {
            key: "parseImportSpecifier",
            value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
              if (!importedIsString && isMaybeTypeOnly) {
                this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
                return this.finishNode(specifier, "ImportSpecifier");
              }
              specifier.importKind = "value";
              return _get(_get_prototype_of(TypeScriptParserMixin2.prototype), "parseImportSpecifier", this).call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
            }
          },
          {
            key: "parseTypeOnlyImportExportSpecifier",
            value: function parseTypeOnlyImportExportSpecifier(node2, isImport2, isInTypeOnlyImportExport) {
              var leftOfAsKey = isImport2 ? "imported" : "local";
              var rightOfAsKey = isImport2 ? "local" : "exported";
              var leftOfAs = node2[leftOfAsKey];
              var rightOfAs;
              var hasTypeSpecifier = false;
              var canParseAsKeyword = true;
              var loc = leftOfAs.loc.start;
              if (this.isContextual(93)) {
                var firstAs = this.parseIdentifier();
                if (this.isContextual(93)) {
                  var secondAs = this.parseIdentifier();
                  if (tokenIsKeywordOrIdentifier(this.state.type)) {
                    hasTypeSpecifier = true;
                    leftOfAs = firstAs;
                    rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
                    canParseAsKeyword = false;
                  } else {
                    rightOfAs = secondAs;
                    canParseAsKeyword = false;
                  }
                } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                  canParseAsKeyword = false;
                  rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
                } else {
                  hasTypeSpecifier = true;
                  leftOfAs = firstAs;
                }
              } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                if (isImport2) {
                  leftOfAs = this.parseIdentifier(true);
                  if (!this.isContextual(93)) {
                    this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                  }
                } else {
                  leftOfAs = this.parseModuleExportName();
                }
              }
              if (hasTypeSpecifier && isInTypeOnlyImportExport) {
                this.raise(isImport2 ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
                  at: loc
                });
              }
              node2[leftOfAsKey] = leftOfAs;
              node2[rightOfAsKey] = rightOfAs;
              var kindKey = isImport2 ? "importKind" : "exportKind";
              node2[kindKey] = hasTypeSpecifier ? "type" : "value";
              if (canParseAsKeyword && this.eatContextual(93)) {
                node2[rightOfAsKey] = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
              }
              if (!node2[rightOfAsKey]) {
                node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey]);
              }
              if (isImport2) {
                this.checkIdentifier(node2[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
              }
            }
          }
        ]);
        return TypeScriptParserMixin2;
      }(superClass);
      return TypeScriptParserMixin;
    };
    function isPossiblyLiteralEnum(expression2) {
      if (expression2.type !== "MemberExpression")
        return false;
      var computed = expression2.computed, property = expression2.property;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression2.object);
    }
    function isValidAmbientConstInitializer(expression2, estree2) {
      var _expression2_extra;
      var type3 = expression2.type;
      if ((_expression2_extra = expression2.extra) === null || _expression2_extra === void 0 ? void 0 : _expression2_extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type3 === "Literal") {
          var value1 = expression2.value;
          if (typeof value1 === "string" || typeof value1 === "boolean") {
            return true;
          }
        }
      } else {
        if (type3 === "StringLiteral" || type3 === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression2, estree2) || isNegativeNumber(expression2, estree2)) {
        return true;
      }
      if (type3 === "TemplateLiteral" && expression2.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression2)) {
        return true;
      }
      return false;
    }
    function isNumber(expression2, estree2) {
      if (estree2) {
        return expression2.type === "Literal" && (typeof expression2.value === "number" || "bigint" in expression2);
      }
      return expression2.type === "NumericLiteral" || expression2.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression2, estree2) {
      if (expression2.type === "UnaryExpression") {
        var operator = expression2.operator, argument = expression2.argument;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression2) {
      if (expression2.type === "Identifier")
        return true;
      if (expression2.type !== "MemberExpression" || expression2.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression2.object);
    }
    var PlaceholderErrors = ParseErrorEnum(_templateObject4())({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = function(superClass) {
      var PlaceholdersParserMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(PlaceholdersParserMixin2, superClass2);
        var _super3 = _create_super(PlaceholdersParserMixin2);
        function PlaceholdersParserMixin2() {
          _class_call_check(this, PlaceholdersParserMixin2);
          return _super3.apply(this, arguments);
        }
        _create_class(PlaceholdersParserMixin2, [
          {
            key: "parsePlaceholder",
            value: function parsePlaceholder(expectedNode) {
              if (this.match(144)) {
                var node2 = this.startNode();
                this.next();
                this.assertNoSpace();
                node2.name = _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseIdentifier", this).call(this, true);
                this.assertNoSpace();
                this.expect(144);
                return this.finishPlaceholder(node2, expectedNode);
              }
            }
          },
          {
            key: "finishPlaceholder",
            value: function finishPlaceholder(node2, expectedNode) {
              var isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
              node2.expectedNode = expectedNode;
              return isFinished ? node2 : this.finishNode(node2, "Placeholder");
            }
          },
          {
            key: "getTokenFromCode",
            value: function getTokenFromCode(code22) {
              if (code22 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                this.finishOp(144, 2);
              } else {
                _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "getTokenFromCode", this).call(this, code22);
              }
            }
          },
          {
            key: "parseExprAtom",
            value: function parseExprAtom(refExpressionErrors) {
              return this.parsePlaceholder("Expression") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
            }
          },
          {
            key: "parseIdentifier",
            value: function parseIdentifier(liberal) {
              return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseIdentifier", this).call(this, liberal);
            }
          },
          {
            key: "checkReservedWord",
            value: function checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
              if (word !== void 0) {
                _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding3);
              }
            }
          },
          {
            key: "parseBindingAtom",
            value: function parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseBindingAtom", this).call(this);
            }
          },
          {
            key: "isValidLVal",
            value: function isValidLVal(type3, isParenthesized, binding) {
              return type3 === "Placeholder" || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "isValidLVal", this).call(this, type3, isParenthesized, binding);
            }
          },
          {
            key: "toAssignable",
            value: function toAssignable(node2, isLHS) {
              if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
                node2.expectedNode = "Pattern";
              } else {
                _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "toAssignable", this).call(this, node2, isLHS);
              }
            }
          },
          {
            key: "chStartsBindingIdentifier",
            value: function chStartsBindingIdentifier(ch, pos) {
              if (_get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "chStartsBindingIdentifier", this).call(this, ch, pos)) {
                return true;
              }
              var nextToken = this.lookahead();
              if (nextToken.type === 144) {
                return true;
              }
              return false;
            }
          },
          {
            key: "verifyBreakContinue",
            value: function verifyBreakContinue(node2, isBreak) {
              if (node2.label && node2.label.type === "Placeholder")
                return;
              _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "verifyBreakContinue", this).call(this, node2, isBreak);
            }
          },
          {
            key: "parseExpressionStatement",
            value: function parseExpressionStatement(node2, expr) {
              var _expr_extra;
              if (expr.type !== "Placeholder" || ((_expr_extra = expr.extra) === null || _expr_extra === void 0 ? void 0 : _expr_extra.parenthesized)) {
                return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseExpressionStatement", this).call(this, node2, expr);
              }
              if (this.match(14)) {
                var stmt = node2;
                stmt.label = this.finishPlaceholder(expr, "Identifier");
                this.next();
                stmt.body = _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseStatementOrSloppyAnnexBFunctionDeclaration", this).call(this);
                return this.finishNode(stmt, "LabeledStatement");
              }
              this.semicolon();
              node2.name = expr.name;
              return this.finishPlaceholder(node2, "Statement");
            }
          },
          {
            key: "parseBlock",
            value: function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
              return this.parsePlaceholder("BlockStatement") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseBlock", this).call(this, allowDirectives, createNewLexicalScope, afterBlockParse);
            }
          },
          {
            key: "parseFunctionId",
            value: function parseFunctionId(requireId) {
              return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseFunctionId", this).call(this, requireId);
            }
          },
          {
            key: "parseClass",
            value: function parseClass(node2, isStatement5, optionalId) {
              var type3 = isStatement5 ? "ClassDeclaration" : "ClassExpression";
              this.next();
              var oldStrict = this.state.strict;
              var placeholder2 = this.parsePlaceholder("Identifier");
              if (placeholder2) {
                if (this.match(81) || this.match(144) || this.match(5)) {
                  node2.id = placeholder2;
                } else if (optionalId || !isStatement5) {
                  node2.id = null;
                  node2.body = this.finishPlaceholder(placeholder2, "ClassBody");
                  return this.finishNode(node2, type3);
                } else {
                  throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                    at: this.state.startLoc
                  });
                }
              } else {
                this.parseClassId(node2, isStatement5, optionalId);
              }
              _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseClassSuper", this).call(this, node2);
              node2.body = this.parsePlaceholder("ClassBody") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseClassBody", this).call(this, !!node2.superClass, oldStrict);
              return this.finishNode(node2, type3);
            }
          },
          {
            key: "parseExport",
            value: function parseExport(node2, decorators) {
              var placeholder2 = this.parsePlaceholder("Identifier");
              if (!placeholder2)
                return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseExport", this).call(this, node2, decorators);
              if (!this.isContextual(98) && !this.match(12)) {
                node2.specifiers = [];
                node2.source = null;
                node2.declaration = this.finishPlaceholder(placeholder2, "Declaration");
                return this.finishNode(node2, "ExportNamedDeclaration");
              }
              this.expectPlugin("exportDefaultFrom");
              var specifier = this.startNode();
              specifier.exported = placeholder2;
              node2.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
              ];
              return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseExport", this).call(this, node2, decorators);
            }
          },
          {
            key: "isExportDefaultSpecifier",
            value: function isExportDefaultSpecifier3() {
              if (this.match(65)) {
                var next = this.nextTokenStart();
                if (this.isUnparsedContextual(next, "from")) {
                  if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
                    return true;
                  }
                }
              }
              return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "isExportDefaultSpecifier", this).call(this);
            }
          },
          {
            key: "maybeParseExportDefaultSpecifier",
            value: function maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
              var _node_specifiers;
              if ((_node_specifiers = node2.specifiers) === null || _node_specifiers === void 0 ? void 0 : _node_specifiers.length) {
                return true;
              }
              return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "maybeParseExportDefaultSpecifier", this).call(this, node2, maybeDefaultIdentifier);
            }
          },
          {
            key: "checkExport",
            value: function checkExport(node2) {
              var specifiers = node2.specifiers;
              if (specifiers === null || specifiers === void 0 ? void 0 : specifiers.length) {
                node2.specifiers = specifiers.filter(function(node22) {
                  return node22.exported.type === "Placeholder";
                });
              }
              _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "checkExport", this).call(this, node2);
              node2.specifiers = specifiers;
            }
          },
          {
            key: "parseImport",
            value: function parseImport(node2) {
              var placeholder2 = this.parsePlaceholder("Identifier");
              if (!placeholder2)
                return _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseImport", this).call(this, node2);
              node2.specifiers = [];
              if (!this.isContextual(98) && !this.match(12)) {
                node2.source = this.finishPlaceholder(placeholder2, "StringLiteral");
                this.semicolon();
                return this.finishNode(node2, "ImportDeclaration");
              }
              var specifier = this.startNodeAtNode(placeholder2);
              specifier.local = placeholder2;
              node2.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
              if (this.eat(12)) {
                var hasStarImport = this.maybeParseStarImportSpecifier(node2);
                if (!hasStarImport)
                  this.parseNamedImportSpecifiers(node2);
              }
              this.expectContextual(98);
              node2.source = this.parseImportSource();
              this.semicolon();
              return this.finishNode(node2, "ImportDeclaration");
            }
          },
          {
            key: "parseImportSource",
            value: function parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || _get(_get_prototype_of(PlaceholdersParserMixin2.prototype), "parseImportSource", this).call(this);
            }
          },
          {
            key: "assertNoSpace",
            value: function assertNoSpace() {
              if (this.state.start > this.state.lastTokEndLoc.index) {
                this.raise(PlaceholderErrors.UnexpectedSpace, {
                  at: this.state.lastTokEndLoc
                });
              }
            }
          }
        ]);
        return PlaceholdersParserMixin2;
      }(superClass);
      return PlaceholdersParserMixin;
    };
    var v8intrinsic = function(superClass) {
      var V8IntrinsicMixin = /* @__PURE__ */ function(superClass2) {
        "use strict";
        _inherits(V8IntrinsicMixin2, superClass2);
        var _super3 = _create_super(V8IntrinsicMixin2);
        function V8IntrinsicMixin2() {
          _class_call_check(this, V8IntrinsicMixin2);
          return _super3.apply(this, arguments);
        }
        _create_class(V8IntrinsicMixin2, [
          {
            key: "parseV8Intrinsic",
            value: function parseV8Intrinsic() {
              if (this.match(54)) {
                var v8IntrinsicStartLoc = this.state.startLoc;
                var node2 = this.startNode();
                this.next();
                if (tokenIsIdentifier(this.state.type)) {
                  var name2 = this.parseIdentifierName();
                  var identifier7 = this.createIdentifier(node2, name2);
                  identifier7.type = "V8IntrinsicIdentifier";
                  if (this.match(10)) {
                    return identifier7;
                  }
                }
                this.unexpected(v8IntrinsicStartLoc);
              }
            }
          },
          {
            key: "parseExprAtom",
            value: function parseExprAtom(refExpressionErrors) {
              return this.parseV8Intrinsic() || _get(_get_prototype_of(V8IntrinsicMixin2.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
            }
          }
        ]);
        return V8IntrinsicMixin2;
      }(superClass);
      return V8IntrinsicMixin;
    };
    function hasPlugin(plugins, expectedConfig) {
      var _ref = _sliced_to_array(typeof expectedConfig === "string" ? [
        expectedConfig,
        {}
      ] : expectedConfig, 2), expectedName = _ref[0], expectedOptions = _ref[1];
      var expectedKeys = Object.keys(expectedOptions);
      var expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some(function(p) {
        if (typeof p === "string") {
          return expectedOptionsIsEmpty && p === expectedName;
        } else {
          var _p = _sliced_to_array(p, 2), pluginName = _p[0], pluginOptions = _p[1];
          if (pluginName !== expectedName) {
            return false;
          }
          var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
          try {
            for (var _iterator8 = expectedKeys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var key = _step8.value;
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name2, option) {
      var plugin2 = plugins.find(function(plugin22) {
        if (Array.isArray(plugin22)) {
          return plugin22[0] === name2;
        } else {
          return plugin22 === name2;
        }
      });
      if (plugin2 && Array.isArray(plugin2) && plugin2.length > 1) {
        return plugin2[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = [
      "minimal",
      "fsharp",
      "hack",
      "smart"
    ];
    var TOPIC_TOKENS = [
      "^^",
      "@@",
      "^",
      "%",
      "#"
    ];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = [
      "hash",
      "bar"
    ];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        var allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        var proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          var proposalList = PIPELINE_PROPOSALS.map(function(p) {
            return '"'.concat(p, '"');
          }).join(", ");
          throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(proposalList, "."));
        }
        var tupleSyntaxIsHash = hasPlugin(plugins, [
          "recordAndTuple",
          {
            syntaxType: "hash"
          }
        ]);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          var topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            var tokenList = TOPIC_TOKENS.map(function(t2) {
              return '"'.concat(t2, '"');
            }).join(", ");
            throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(tokenList, "."));
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          throw new Error("`moduleAttributes` has been removed in Babel 8, please use `importAttributes` parser plugin, or `@babel/plugin-syntax-import-attributes`.");
        }
      }
      if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
        throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      }
      if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function(p) {
          return "'".concat(p, "'");
        }).join(", "));
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx: jsx2,
      flow: flow3,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions2 = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createImportExpressions: true,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
    function getOptions2(opts) {
      if (opts == null) {
        return Object.assign({}, defaultOptions2);
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      var options = {};
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(defaultOptions2)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          var _opts_key;
          options[key] = (_opts_key = opts[key]) !== null && _opts_key !== void 0 ? _opts_key : defaultOptions2[key];
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return options;
    }
    var ExpressionParser = /* @__PURE__ */ function(LValParser2) {
      "use strict";
      _inherits(ExpressionParser2, LValParser2);
      var _super3 = _create_super(ExpressionParser2);
      function ExpressionParser2() {
        _class_call_check(this, ExpressionParser2);
        return _super3.apply(this, arguments);
      }
      _create_class(ExpressionParser2, [
        {
          key: "checkProto",
          value: function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
            if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
              return;
            }
            var key = prop.key;
            var name2 = key.type === "Identifier" ? key.name : key.value;
            if (name2 === "__proto__") {
              if (isRecord) {
                this.raise(Errors.RecordNoProto, {
                  at: key
                });
                return;
              }
              if (protoRef.used) {
                if (refExpressionErrors) {
                  if (refExpressionErrors.doubleProtoLoc === null) {
                    refExpressionErrors.doubleProtoLoc = key.loc.start;
                  }
                } else {
                  this.raise(Errors.DuplicateProto, {
                    at: key
                  });
                }
              }
              protoRef.used = true;
            }
          }
        },
        {
          key: "shouldExitDescending",
          value: function shouldExitDescending(expr, potentialArrowAt) {
            return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
          }
        },
        {
          key: "getExpression",
          value: function getExpression() {
            this.enterInitialScopes();
            this.nextToken();
            var expr = this.parseExpression();
            if (!this.match(139)) {
              this.unexpected();
            }
            this.finalizeRemainingComments();
            expr.comments = this.state.comments;
            expr.errors = this.state.errors;
            if (this.options.tokens) {
              expr.tokens = this.tokens;
            }
            return expr;
          }
        },
        {
          key: "parseExpression",
          value: function parseExpression2(disallowIn, refExpressionErrors) {
            var _this = this;
            if (disallowIn) {
              return this.disallowInAnd(function() {
                return _this.parseExpressionBase(refExpressionErrors);
              });
            }
            return this.allowInAnd(function() {
              return _this.parseExpressionBase(refExpressionErrors);
            });
          }
        },
        {
          key: "parseExpressionBase",
          value: function parseExpressionBase(refExpressionErrors) {
            var startLoc = this.state.startLoc;
            var expr = this.parseMaybeAssign(refExpressionErrors);
            if (this.match(12)) {
              var node2 = this.startNodeAt(startLoc);
              node2.expressions = [
                expr
              ];
              while (this.eat(12)) {
                node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
              }
              this.toReferencedList(node2.expressions);
              return this.finishNode(node2, "SequenceExpression");
            }
            return expr;
          }
        },
        {
          key: "parseMaybeAssignDisallowIn",
          value: function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
            var _this = this;
            return this.disallowInAnd(function() {
              return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            });
          }
        },
        {
          key: "parseMaybeAssignAllowIn",
          value: function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
            var _this = this;
            return this.allowInAnd(function() {
              return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            });
          }
        },
        {
          key: "setOptionalParametersError",
          value: function setOptionalParametersError(refExpressionErrors, resultError) {
            var _resultError_loc;
            refExpressionErrors.optionalParametersLoc = (_resultError_loc = resultError === null || resultError === void 0 ? void 0 : resultError.loc) !== null && _resultError_loc !== void 0 ? _resultError_loc : this.state.startLoc;
          }
        },
        {
          key: "parseMaybeAssign",
          value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var startLoc = this.state.startLoc;
            if (this.isContextual(108)) {
              if (this.prodParam.hasYield) {
                var left2 = this.parseYield();
                if (afterLeftParse) {
                  left2 = afterLeftParse.call(this, left2, startLoc);
                }
                return left2;
              }
            }
            var ownExpressionErrors;
            if (refExpressionErrors) {
              ownExpressionErrors = false;
            } else {
              refExpressionErrors = new ExpressionErrors();
              ownExpressionErrors = true;
            }
            var type3 = this.state.type;
            if (type3 === 10 || tokenIsIdentifier(type3)) {
              this.state.potentialArrowAt = this.state.start;
            }
            var left = this.parseMaybeConditional(refExpressionErrors);
            if (afterLeftParse) {
              left = afterLeftParse.call(this, left, startLoc);
            }
            if (tokenIsAssignment(this.state.type)) {
              var node2 = this.startNodeAt(startLoc);
              var operator = this.state.value;
              node2.operator = operator;
              if (this.match(29)) {
                this.toAssignable(left, true);
                node2.left = left;
                var startIndex = startLoc.index;
                if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                  refExpressionErrors.doubleProtoLoc = null;
                }
                if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                  refExpressionErrors.shorthandAssignLoc = null;
                }
                if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                  this.checkDestructuringPrivate(refExpressionErrors);
                  refExpressionErrors.privateKeyLoc = null;
                }
              } else {
                node2.left = left;
              }
              this.next();
              node2.right = this.parseMaybeAssign();
              this.checkLVal(left, {
                in: this.finishNode(node2, "AssignmentExpression")
              });
              return node2;
            } else if (ownExpressionErrors) {
              this.checkExpressionErrors(refExpressionErrors, true);
            }
            return left;
          }
        },
        {
          key: "parseMaybeConditional",
          value: function parseMaybeConditional(refExpressionErrors) {
            var startLoc = this.state.startLoc;
            var potentialArrowAt = this.state.potentialArrowAt;
            var expr = this.parseExprOps(refExpressionErrors);
            if (this.shouldExitDescending(expr, potentialArrowAt)) {
              return expr;
            }
            return this.parseConditional(expr, startLoc, refExpressionErrors);
          }
        },
        {
          key: "parseConditional",
          value: function parseConditional(expr, startLoc, refExpressionErrors) {
            if (this.eat(17)) {
              var node2 = this.startNodeAt(startLoc);
              node2.test = expr;
              node2.consequent = this.parseMaybeAssignAllowIn();
              this.expect(14);
              node2.alternate = this.parseMaybeAssign();
              return this.finishNode(node2, "ConditionalExpression");
            }
            return expr;
          }
        },
        {
          key: "parseMaybeUnaryOrPrivate",
          value: function parseMaybeUnaryOrPrivate(refExpressionErrors) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
          }
        },
        {
          key: "parseExprOps",
          value: function parseExprOps(refExpressionErrors) {
            var startLoc = this.state.startLoc;
            var potentialArrowAt = this.state.potentialArrowAt;
            var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
            if (this.shouldExitDescending(expr, potentialArrowAt)) {
              return expr;
            }
            return this.parseExprOp(expr, startLoc, -1);
          }
        },
        {
          key: "parseExprOp",
          value: function parseExprOp(left, leftStartLoc, minPrec) {
            if (this.isPrivateName(left)) {
              var value1 = this.getPrivateNameSV(left);
              if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                this.raise(Errors.PrivateInExpectedIn, {
                  at: left,
                  identifierName: value1
                });
              }
              this.classScope.usePrivateName(value1, left.loc.start);
            }
            var op = this.state.type;
            if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
              var prec = tokenOperatorPrecedence(op);
              if (prec > minPrec) {
                if (op === 39) {
                  this.expectPlugin("pipelineOperator");
                  if (this.state.inFSharpPipelineDirectBody) {
                    return left;
                  }
                  this.checkPipelineAtInfixOperator(left, leftStartLoc);
                }
                var node2 = this.startNodeAt(leftStartLoc);
                node2.left = left;
                node2.operator = this.state.value;
                var logical = op === 41 || op === 42;
                var coalesce = op === 40;
                if (coalesce) {
                  prec = tokenOperatorPrecedence(42);
                }
                this.next();
                if (op === 39 && this.hasPlugin([
                  "pipelineOperator",
                  {
                    proposal: "minimal"
                  }
                ])) {
                  if (this.state.type === 96 && this.prodParam.hasAwait) {
                    throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                      at: this.state.startLoc
                    });
                  }
                }
                node2.right = this.parseExprOpRightExpr(op, prec);
                var finishedNode = this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                var nextOp = this.state.type;
                if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                  throw this.raise(Errors.MixingCoalesceWithLogical, {
                    at: this.state.startLoc
                  });
                }
                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
              }
            }
            return left;
          }
        },
        {
          key: "parseExprOpRightExpr",
          value: function parseExprOpRightExpr(op, prec) {
            var _this = this;
            var startLoc = this.state.startLoc;
            switch (op) {
              case 39:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "hack":
                    return this.withTopicBindingContext(function() {
                      return _this.parseHackPipeBody();
                    });
                  case "smart":
                    return this.withTopicBindingContext(function() {
                      if (_this.prodParam.hasYield && _this.isContextual(108)) {
                        throw _this.raise(Errors.PipeBodyIsTighter, {
                          at: _this.state.startLoc
                        });
                      }
                      return _this.parseSmartPipelineBodyInStyle(_this.parseExprOpBaseRightExpr(op, prec), startLoc);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(function() {
                      return _this.parseFSharpPipelineBody(prec);
                    });
                }
              default:
                return this.parseExprOpBaseRightExpr(op, prec);
            }
          }
        },
        {
          key: "parseExprOpBaseRightExpr",
          value: function parseExprOpBaseRightExpr(op, prec) {
            var startLoc = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
          }
        },
        {
          key: "parseHackPipeBody",
          value: function parseHackPipeBody() {
            var _body_extra;
            var startLoc = this.state.startLoc;
            var body = this.parseMaybeAssign();
            var requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
            if (requiredParentheses && !((_body_extra = body.extra) === null || _body_extra === void 0 ? void 0 : _body_extra.parenthesized)) {
              this.raise(Errors.PipeUnparenthesizedBody, {
                at: startLoc,
                type: body.type
              });
            }
            if (!this.topicReferenceWasUsedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnused, {
                at: startLoc
              });
            }
            return body;
          }
        },
        {
          key: "checkExponentialAfterUnary",
          value: function checkExponentialAfterUnary(node2) {
            if (this.match(57)) {
              this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
                at: node2.argument
              });
            }
          }
        },
        {
          key: "parseMaybeUnary",
          value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
            var startLoc = this.state.startLoc;
            var isAwait = this.isContextual(96);
            if (isAwait && this.isAwaitAllowed()) {
              this.next();
              var expr2 = this.parseAwait(startLoc);
              if (!sawUnary)
                this.checkExponentialAfterUnary(expr2);
              return expr2;
            }
            var update = this.match(34);
            var node2 = this.startNode();
            if (tokenIsPrefix(this.state.type)) {
              node2.operator = this.state.value;
              node2.prefix = true;
              if (this.match(72)) {
                this.expectPlugin("throwExpressions");
              }
              var isDelete = this.match(89);
              this.next();
              node2.argument = this.parseMaybeUnary(null, true);
              this.checkExpressionErrors(refExpressionErrors, true);
              if (this.state.strict && isDelete) {
                var arg = node2.argument;
                if (arg.type === "Identifier") {
                  this.raise(Errors.StrictDelete, {
                    at: node2
                  });
                } else if (this.hasPropertyAsPrivateName(arg)) {
                  this.raise(Errors.DeletePrivateField, {
                    at: node2
                  });
                }
              }
              if (!update) {
                if (!sawUnary) {
                  this.checkExponentialAfterUnary(node2);
                }
                return this.finishNode(node2, "UnaryExpression");
              }
            }
            var expr = this.parseUpdate(node2, update, refExpressionErrors);
            if (isAwait) {
              var type3 = this.state.type;
              var startsExpr22 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type3) : tokenCanStartExpression(type3) && !this.match(54);
              if (startsExpr22 && !this.isAmbiguousAwait()) {
                this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                  at: startLoc
                });
                return this.parseAwait(startLoc);
              }
            }
            return expr;
          }
        },
        {
          key: "parseUpdate",
          value: function parseUpdate(node2, update, refExpressionErrors) {
            if (update) {
              var updateExpressionNode = node2;
              this.checkLVal(updateExpressionNode.argument, {
                in: this.finishNode(updateExpressionNode, "UpdateExpression")
              });
              return node2;
            }
            var startLoc = this.state.startLoc;
            var expr = this.parseExprSubscripts(refExpressionErrors);
            if (this.checkExpressionErrors(refExpressionErrors, false))
              return expr;
            while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
              var node22 = this.startNodeAt(startLoc);
              node22.operator = this.state.value;
              node22.prefix = false;
              node22.argument = expr;
              this.next();
              this.checkLVal(expr, {
                in: expr = this.finishNode(node22, "UpdateExpression")
              });
            }
            return expr;
          }
        },
        {
          key: "parseExprSubscripts",
          value: function parseExprSubscripts(refExpressionErrors) {
            var startLoc = this.state.startLoc;
            var potentialArrowAt = this.state.potentialArrowAt;
            var expr = this.parseExprAtom(refExpressionErrors);
            if (this.shouldExitDescending(expr, potentialArrowAt)) {
              return expr;
            }
            return this.parseSubscripts(expr, startLoc);
          }
        },
        {
          key: "parseSubscripts",
          value: function parseSubscripts(base, startLoc, noCalls) {
            var state = {
              optionalChainMember: false,
              maybeAsyncArrow: this.atPossibleAsyncArrow(base),
              stop: false
            };
            do {
              base = this.parseSubscript(base, startLoc, noCalls, state);
              state.maybeAsyncArrow = false;
            } while (!state.stop);
            return base;
          }
        },
        {
          key: "parseSubscript",
          value: function parseSubscript(base, startLoc, noCalls, state) {
            var type3 = this.state.type;
            if (!noCalls && type3 === 15) {
              return this.parseBind(base, startLoc, noCalls, state);
            } else if (tokenIsTemplate(type3)) {
              return this.parseTaggedTemplateExpression(base, startLoc, state);
            }
            var optional = false;
            if (type3 === 18) {
              if (noCalls) {
                this.raise(Errors.OptionalChainingNoNew, {
                  at: this.state.startLoc
                });
                if (this.lookaheadCharCode() === 40) {
                  state.stop = true;
                  return base;
                }
              }
              state.optionalChainMember = optional = true;
              this.next();
            }
            if (!noCalls && this.match(10)) {
              return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
            } else {
              var computed = this.eat(0);
              if (computed || optional || this.eat(16)) {
                return this.parseMember(base, startLoc, state, computed, optional);
              } else {
                state.stop = true;
                return base;
              }
            }
          }
        },
        {
          key: "parseMember",
          value: function parseMember(base, startLoc, state, computed, optional) {
            var node2 = this.startNodeAt(startLoc);
            node2.object = base;
            node2.computed = computed;
            if (computed) {
              node2.property = this.parseExpression();
              this.expect(3);
            } else if (this.match(138)) {
              if (base.type === "Super") {
                this.raise(Errors.SuperPrivateField, {
                  at: startLoc
                });
              }
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              node2.property = this.parsePrivateName();
            } else {
              node2.property = this.parseIdentifier(true);
            }
            if (state.optionalChainMember) {
              node2.optional = optional;
              return this.finishNode(node2, "OptionalMemberExpression");
            } else {
              return this.finishNode(node2, "MemberExpression");
            }
          }
        },
        {
          key: "parseBind",
          value: function parseBind(base, startLoc, noCalls, state) {
            var node2 = this.startNodeAt(startLoc);
            node2.object = base;
            this.next();
            node2.callee = this.parseNoCallExpr();
            state.stop = true;
            return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startLoc, noCalls);
          }
        },
        {
          key: "parseCoverCallAndAsyncArrowHead",
          value: function parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            var refExpressionErrors = null;
            this.state.maybeInArrowParameters = true;
            this.next();
            var node2 = this.startNodeAt(startLoc);
            node2.callee = base;
            var maybeAsyncArrow = state.maybeAsyncArrow, optionalChainMember = state.optionalChainMember;
            if (maybeAsyncArrow) {
              this.expressionScope.enter(newAsyncArrowScope());
              refExpressionErrors = new ExpressionErrors();
            }
            if (optionalChainMember) {
              node2.optional = optional;
            }
            if (optional) {
              node2.arguments = this.parseCallExpressionArguments(11);
            } else {
              node2.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node2, refExpressionErrors);
            }
            var finishedNode = this.finishCallExpression(node2, optionalChainMember);
            if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
              state.stop = true;
              this.checkDestructuringPrivate(refExpressionErrors);
              this.expressionScope.validateAsPattern();
              this.expressionScope.exit();
              finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
            } else {
              if (maybeAsyncArrow) {
                this.checkExpressionErrors(refExpressionErrors, true);
                this.expressionScope.exit();
              }
              this.toReferencedArguments(finishedNode);
            }
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return finishedNode;
          }
        },
        {
          key: "toReferencedArguments",
          value: function toReferencedArguments(node2, isParenthesizedExpr) {
            this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
          }
        },
        {
          key: "parseTaggedTemplateExpression",
          value: function parseTaggedTemplateExpression(base, startLoc, state) {
            var node2 = this.startNodeAt(startLoc);
            node2.tag = base;
            node2.quasi = this.parseTemplate(true);
            if (state.optionalChainMember) {
              this.raise(Errors.OptionalChainingNoTemplate, {
                at: startLoc
              });
            }
            return this.finishNode(node2, "TaggedTemplateExpression");
          }
        },
        {
          key: "atPossibleAsyncArrow",
          value: function atPossibleAsyncArrow(base) {
            return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
          }
        },
        {
          key: "expectImportAttributesPlugin",
          value: function expectImportAttributesPlugin() {
            if (!this.hasPlugin("importAssertions")) {
              this.expectPlugin("importAttributes");
            }
          }
        },
        {
          key: "finishCallExpression",
          value: function finishCallExpression(node2, optional) {
            if (node2.callee.type === "Import") {
              if (node2.arguments.length === 2) {
                {
                  this.expectImportAttributesPlugin();
                }
              }
              if (node2.arguments.length === 0 || node2.arguments.length > 2) {
                this.raise(Errors.ImportCallArity, {
                  at: node2,
                  maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
                });
              } else {
                var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
                try {
                  for (var _iterator8 = node2.arguments[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var arg = _step8.value;
                    if (arg.type === "SpreadElement") {
                      this.raise(Errors.ImportCallSpreadArgument, {
                        at: arg
                      });
                    }
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }
              }
            }
            return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
          }
        },
        {
          key: "parseCallExpressionArguments",
          value: function parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
            var elts = [];
            var first = true;
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(12);
                if (this.match(close)) {
                  if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                    this.raise(Errors.ImportCallArgumentTrailingComma, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                  if (nodeForExtra) {
                    this.addTrailingCommaExtraToNode(nodeForExtra);
                  }
                  this.next();
                  break;
                }
              }
              elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
            }
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return elts;
          }
        },
        {
          key: "shouldParseAsyncArrow",
          value: function shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
        },
        {
          key: "parseAsyncArrowFromCallExpression",
          value: function parseAsyncArrowFromCallExpression(node2, call2) {
            var _call2_extra;
            this.resetPreviousNodeTrailingComments(call2);
            this.expect(19);
            this.parseArrowExpression(node2, call2.arguments, true, (_call2_extra = call2.extra) === null || _call2_extra === void 0 ? void 0 : _call2_extra.trailingCommaLoc);
            if (call2.innerComments) {
              setInnerComments(node2, call2.innerComments);
            }
            if (call2.callee.trailingComments) {
              setInnerComments(node2, call2.callee.trailingComments);
            }
            return node2;
          }
        },
        {
          key: "parseNoCallExpr",
          value: function parseNoCallExpr() {
            var startLoc = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
          }
        },
        {
          key: "parseExprAtom",
          value: function parseExprAtom(refExpressionErrors) {
            var node2;
            var decorators = null;
            var type3 = this.state.type;
            switch (type3) {
              case 79:
                return this.parseSuper();
              case 83:
                node2 = this.startNode();
                this.next();
                if (this.match(16)) {
                  return this.parseImportMetaProperty(node2);
                }
                if (this.match(10)) {
                  if (this.options.createImportExpressions) {
                    return this.parseImportCall(node2);
                  } else {
                    return this.finishNode(node2, "Import");
                  }
                } else {
                  this.raise(Errors.UnsupportedImport, {
                    at: this.state.lastTokStartLoc
                  });
                  return this.finishNode(node2, "Import");
                }
              case 78:
                node2 = this.startNode();
                this.next();
                return this.finishNode(node2, "ThisExpression");
              case 90: {
                return this.parseDo(this.startNode(), false);
              }
              case 56:
              case 31: {
                this.readRegexp();
                return this.parseRegExpLiteral(this.state.value);
              }
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                var canBeArrow = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(canBeArrow);
              }
              case 2:
              case 1: {
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              }
              case 0: {
                return this.parseArrayLike(3, true, false, refExpressionErrors);
              }
              case 6:
              case 7: {
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              }
              case 5: {
                return this.parseObjectLike(8, false, false, refExpressionErrors);
              }
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                decorators = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                node2 = this.startNode();
                this.next();
                node2.object = null;
                var callee = node2.callee = this.parseNoCallExpr();
                if (callee.type === "MemberExpression") {
                  return this.finishNode(node2, "BindExpression");
                } else {
                  throw this.raise(Errors.UnsupportedBind, {
                    at: callee
                  });
                }
              }
              case 138: {
                this.raise(Errors.PrivateInExpectedIn, {
                  at: this.state.startLoc,
                  identifierName: this.state.value
                });
                return this.parsePrivateName();
              }
              case 33: {
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              }
              case 32: {
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              }
              case 37:
              case 38: {
                return this.parseTopicReference("hack");
              }
              case 44:
              case 54:
              case 27: {
                var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                if (pipeProposal) {
                  return this.parseTopicReference(pipeProposal);
                }
                this.unexpected();
                break;
              }
              case 47: {
                var lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                if (isIdentifierStart22(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin([
                    "jsx",
                    "flow",
                    "typescript"
                  ]);
                } else {
                  this.unexpected();
                }
                break;
              }
              default:
                if (tokenIsIdentifier(type3)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                    return this.parseModuleExpression();
                  }
                  var canBeArrow1 = this.state.potentialArrowAt === this.state.start;
                  var containsEsc = this.state.containsEsc;
                  var id = this.parseIdentifier();
                  if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                    var _this_state = this.state, type22 = _this_state.type;
                    if (type22 === 68) {
                      this.resetPreviousNodeTrailingComments(id);
                      this.next();
                      return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                    } else if (tokenIsIdentifier(type22)) {
                      if (this.lookaheadCharCode() === 61) {
                        return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                      } else {
                        return id;
                      }
                    } else if (type22 === 90) {
                      this.resetPreviousNodeTrailingComments(id);
                      return this.parseDo(this.startNodeAtNode(id), true);
                    }
                  }
                  if (canBeArrow1 && this.match(19) && !this.canInsertSemicolon()) {
                    this.next();
                    return this.parseArrowExpression(this.startNodeAtNode(id), [
                      id
                    ], false);
                  }
                  return id;
                } else {
                  this.unexpected();
                }
            }
          }
        },
        {
          key: "parseTopicReferenceThenEqualsSign",
          value: function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
            var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              this.state.type = topicTokenType;
              this.state.value = topicTokenValue;
              this.state.pos--;
              this.state.end--;
              this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
              return this.parseTopicReference(pipeProposal);
            } else {
              this.unexpected();
            }
          }
        },
        {
          key: "parseTopicReference",
          value: function parseTopicReference(pipeProposal) {
            var node2 = this.startNode();
            var startLoc = this.state.startLoc;
            var tokenType = this.state.type;
            this.next();
            return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
          }
        },
        {
          key: "finishTopicReference",
          value: function finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
            if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
              var nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              if (!this.topicReferenceIsAllowedInCurrentContext()) {
                this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                  at: startLoc
                });
              }
              this.registerTopicReference();
              return this.finishNode(node2, nodeType);
            } else {
              throw this.raise(Errors.PipeTopicUnconfiguredToken, {
                at: startLoc,
                token: tokenLabelName(tokenType)
              });
            }
          }
        },
        {
          key: "testTopicReferenceConfiguration",
          value: function testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
            switch (pipeProposal) {
              case "hack": {
                return this.hasPlugin([
                  "pipelineOperator",
                  {
                    topicToken: tokenLabelName(tokenType)
                  }
                ]);
              }
              case "smart":
                return tokenType === 27;
              default:
                throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                  at: startLoc
                });
            }
          }
        },
        {
          key: "parseAsyncArrowUnaryFunction",
          value: function parseAsyncArrowUnaryFunction(node2) {
            this.prodParam.enter(functionFlags2(true, this.prodParam.hasYield));
            var params = [
              this.parseIdentifier()
            ];
            this.prodParam.exit();
            if (this.hasPrecedingLineBreak()) {
              this.raise(Errors.LineTerminatorBeforeArrow, {
                at: this.state.curPosition()
              });
            }
            this.expect(19);
            return this.parseArrowExpression(node2, params, true);
          }
        },
        {
          key: "parseDo",
          value: function parseDo(node2, isAsync) {
            this.expectPlugin("doExpressions");
            if (isAsync) {
              this.expectPlugin("asyncDoExpressions");
            }
            node2.async = isAsync;
            this.next();
            var oldLabels = this.state.labels;
            this.state.labels = [];
            if (isAsync) {
              this.prodParam.enter(2);
              node2.body = this.parseBlock();
              this.prodParam.exit();
            } else {
              node2.body = this.parseBlock();
            }
            this.state.labels = oldLabels;
            return this.finishNode(node2, "DoExpression");
          }
        },
        {
          key: "parseSuper",
          value: function parseSuper() {
            var node2 = this.startNode();
            this.next();
            if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(Errors.SuperNotAllowed, {
                at: node2
              });
            } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(Errors.UnexpectedSuper, {
                at: node2
              });
            }
            if (!this.match(10) && !this.match(0) && !this.match(16)) {
              this.raise(Errors.UnsupportedSuper, {
                at: node2
              });
            }
            return this.finishNode(node2, "Super");
          }
        },
        {
          key: "parsePrivateName",
          value: function parsePrivateName() {
            var node2 = this.startNode();
            var id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
            var name2 = this.state.value;
            this.next();
            node2.id = this.createIdentifier(id, name2);
            return this.finishNode(node2, "PrivateName");
          }
        },
        {
          key: "parseFunctionOrFunctionSent",
          value: function parseFunctionOrFunctionSent() {
            var node2 = this.startNode();
            this.next();
            if (this.prodParam.hasYield && this.match(16)) {
              var meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
              this.next();
              if (this.match(103)) {
                this.expectPlugin("functionSent");
              } else if (!this.hasPlugin("functionSent")) {
                this.unexpected();
              }
              return this.parseMetaProperty(node2, meta, "sent");
            }
            return this.parseFunction(node2);
          }
        },
        {
          key: "parseMetaProperty",
          value: function parseMetaProperty(node2, meta, propertyName) {
            node2.meta = meta;
            var containsEsc = this.state.containsEsc;
            node2.property = this.parseIdentifier(true);
            if (node2.property.name !== propertyName || containsEsc) {
              this.raise(Errors.UnsupportedMetaProperty, {
                at: node2.property,
                target: meta.name,
                onlyValidPropertyName: propertyName
              });
            }
            return this.finishNode(node2, "MetaProperty");
          }
        },
        {
          key: "parseImportMetaProperty",
          value: function parseImportMetaProperty(node2) {
            var id = this.createIdentifier(this.startNodeAtNode(node2), "import");
            this.next();
            if (this.isContextual(101)) {
              if (!this.inModule) {
                this.raise(Errors.ImportMetaOutsideModule, {
                  at: id
                });
              }
              this.sawUnambiguousESM = true;
            } else if (this.isContextual(105) || this.isContextual(97)) {
              var isSource = this.isContextual(105);
              if (!isSource)
                this.unexpected();
              this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
              if (!this.options.createImportExpressions) {
                throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
                  at: this.state.startLoc,
                  phase: this.state.value
                });
              }
              this.next();
              node2.phase = isSource ? "source" : "defer";
              return this.parseImportCall(node2);
            }
            return this.parseMetaProperty(node2, id, "meta");
          }
        },
        {
          key: "parseLiteralAtNode",
          value: function parseLiteralAtNode(value1, type3, node2) {
            this.addExtra(node2, "rawValue", value1);
            this.addExtra(node2, "raw", this.input.slice(node2.start, this.state.end));
            node2.value = value1;
            this.next();
            return this.finishNode(node2, type3);
          }
        },
        {
          key: "parseLiteral",
          value: function parseLiteral(value1, type3) {
            var node2 = this.startNode();
            return this.parseLiteralAtNode(value1, type3, node2);
          }
        },
        {
          key: "parseStringLiteral",
          value: function parseStringLiteral(value1) {
            return this.parseLiteral(value1, "StringLiteral");
          }
        },
        {
          key: "parseNumericLiteral",
          value: function parseNumericLiteral(value1) {
            return this.parseLiteral(value1, "NumericLiteral");
          }
        },
        {
          key: "parseBigIntLiteral",
          value: function parseBigIntLiteral(value1) {
            return this.parseLiteral(value1, "BigIntLiteral");
          }
        },
        {
          key: "parseDecimalLiteral",
          value: function parseDecimalLiteral(value1) {
            return this.parseLiteral(value1, "DecimalLiteral");
          }
        },
        {
          key: "parseRegExpLiteral",
          value: function parseRegExpLiteral(value1) {
            var node2 = this.parseLiteral(value1.value, "RegExpLiteral");
            node2.pattern = value1.pattern;
            node2.flags = value1.flags;
            return node2;
          }
        },
        {
          key: "parseBooleanLiteral",
          value: function parseBooleanLiteral(value1) {
            var node2 = this.startNode();
            node2.value = value1;
            this.next();
            return this.finishNode(node2, "BooleanLiteral");
          }
        },
        {
          key: "parseNullLiteral",
          value: function parseNullLiteral() {
            var node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "NullLiteral");
          }
        },
        {
          key: "parseParenAndDistinguishExpression",
          value: function parseParenAndDistinguishExpression(canBeArrow) {
            var startLoc = this.state.startLoc;
            var val;
            this.next();
            this.expressionScope.enter(newArrowHeadScope());
            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true;
            this.state.inFSharpPipelineDirectBody = false;
            var innerStartLoc = this.state.startLoc;
            var exprList = [];
            var refExpressionErrors = new ExpressionErrors();
            var first = true;
            var spreadStartLoc;
            var optionalCommaStartLoc;
            while (!this.match(11)) {
              if (first) {
                first = false;
              } else {
                this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                if (this.match(11)) {
                  optionalCommaStartLoc = this.state.startLoc;
                  break;
                }
              }
              if (this.match(21)) {
                var spreadNodeStartLoc = this.state.startLoc;
                spreadStartLoc = this.state.startLoc;
                exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
                if (!this.checkCommaAfterRest(41)) {
                  break;
                }
              } else {
                exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
              }
            }
            var innerEndLoc = this.state.lastTokEndLoc;
            this.expect(11);
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            var arrowNode = this.startNodeAt(startLoc);
            if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
              this.checkDestructuringPrivate(refExpressionErrors);
              this.expressionScope.validateAsPattern();
              this.expressionScope.exit();
              this.parseArrowExpression(arrowNode, exprList, false);
              return arrowNode;
            }
            this.expressionScope.exit();
            if (!exprList.length) {
              this.unexpected(this.state.lastTokStartLoc);
            }
            if (optionalCommaStartLoc)
              this.unexpected(optionalCommaStartLoc);
            if (spreadStartLoc)
              this.unexpected(spreadStartLoc);
            this.checkExpressionErrors(refExpressionErrors, true);
            this.toReferencedListDeep(exprList, true);
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartLoc);
              val.expressions = exprList;
              this.finishNode(val, "SequenceExpression");
              this.resetEndLocation(val, innerEndLoc);
            } else {
              val = exprList[0];
            }
            return this.wrapParenthesis(startLoc, val);
          }
        },
        {
          key: "wrapParenthesis",
          value: function wrapParenthesis(startLoc, expression2) {
            if (!this.options.createParenthesizedExpressions) {
              this.addExtra(expression2, "parenthesized", true);
              this.addExtra(expression2, "parenStart", startLoc.index);
              this.takeSurroundingComments(expression2, startLoc.index, this.state.lastTokEndLoc.index);
              return expression2;
            }
            var parenExpression = this.startNodeAt(startLoc);
            parenExpression.expression = expression2;
            return this.finishNode(parenExpression, "ParenthesizedExpression");
          }
        },
        {
          key: "shouldParseArrow",
          value: function shouldParseArrow(params) {
            return !this.canInsertSemicolon();
          }
        },
        {
          key: "parseArrow",
          value: function parseArrow(node2) {
            if (this.eat(19)) {
              return node2;
            }
          }
        },
        {
          key: "parseParenItem",
          value: function parseParenItem(node2, startLoc) {
            return node2;
          }
        },
        {
          key: "parseNewOrNewTarget",
          value: function parseNewOrNewTarget() {
            var node2 = this.startNode();
            this.next();
            if (this.match(16)) {
              var meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
              this.next();
              var metaProp = this.parseMetaProperty(node2, meta, "target");
              if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
                this.raise(Errors.UnexpectedNewTarget, {
                  at: metaProp
                });
              }
              return metaProp;
            }
            return this.parseNew(node2);
          }
        },
        {
          key: "parseNew",
          value: function parseNew(node2) {
            this.parseNewCallee(node2);
            if (this.eat(10)) {
              var args = this.parseExprList(11);
              this.toReferencedList(args);
              node2.arguments = args;
            } else {
              node2.arguments = [];
            }
            return this.finishNode(node2, "NewExpression");
          }
        },
        {
          key: "parseNewCallee",
          value: function parseNewCallee(node2) {
            var isImport2 = this.match(83);
            var callee = this.parseNoCallExpr();
            node2.callee = callee;
            if (isImport2 && (callee.type === "Import" || callee.type === "ImportExpression")) {
              this.raise(Errors.ImportCallNotNewExpression, {
                at: callee
              });
            }
          }
        },
        {
          key: "parseTemplateElement",
          value: function parseTemplateElement(isTagged) {
            var _this_state = this.state, start2 = _this_state.start, startLoc = _this_state.startLoc, end = _this_state.end, value1 = _this_state.value;
            var elemStart = start2 + 1;
            var elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
            if (value1 === null) {
              if (!isTagged) {
                this.raise(Errors.InvalidEscapeSequenceTemplate, {
                  at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
                });
              }
            }
            var isTail = this.match(24);
            var endOffset = isTail ? -1 : -2;
            var elemEnd = end + endOffset;
            elem.value = {
              raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
              cooked: value1 === null ? null : value1.slice(1, endOffset)
            };
            elem.tail = isTail;
            this.next();
            var finishedNode = this.finishNode(elem, "TemplateElement");
            this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
            return finishedNode;
          }
        },
        {
          key: "parseTemplate",
          value: function parseTemplate(isTagged) {
            var node2 = this.startNode();
            node2.expressions = [];
            var curElt = this.parseTemplateElement(isTagged);
            node2.quasis = [
              curElt
            ];
            while (!curElt.tail) {
              node2.expressions.push(this.parseTemplateSubstitution());
              this.readTemplateContinuation();
              node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
            }
            return this.finishNode(node2, "TemplateLiteral");
          }
        },
        {
          key: "parseTemplateSubstitution",
          value: function parseTemplateSubstitution() {
            return this.parseExpression();
          }
        },
        {
          key: "parseObjectLike",
          value: function parseObjectLike(close, isPattern2, isRecord, refExpressionErrors) {
            if (isRecord) {
              this.expectPlugin("recordAndTuple");
            }
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            var propHash = /* @__PURE__ */ Object.create(null);
            var first = true;
            var node2 = this.startNode();
            node2.properties = [];
            this.next();
            while (!this.match(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(12);
                if (this.match(close)) {
                  this.addTrailingCommaExtraToNode(node2);
                  break;
                }
              }
              var prop = void 0;
              if (isPattern2) {
                prop = this.parseBindingProperty();
              } else {
                prop = this.parsePropertyDefinition(refExpressionErrors);
                this.checkProto(prop, isRecord, propHash, refExpressionErrors);
              }
              if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
                this.raise(Errors.InvalidRecordProperty, {
                  at: prop
                });
              }
              if (prop.shorthand) {
                this.addExtra(prop, "shorthand", true);
              }
              node2.properties.push(prop);
            }
            this.next();
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            var type3 = "ObjectExpression";
            if (isPattern2) {
              type3 = "ObjectPattern";
            } else if (isRecord) {
              type3 = "RecordExpression";
            }
            return this.finishNode(node2, type3);
          }
        },
        {
          key: "addTrailingCommaExtraToNode",
          value: function addTrailingCommaExtraToNode(node2) {
            this.addExtra(node2, "trailingComma", this.state.lastTokStart);
            this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
        },
        {
          key: "maybeAsyncOrAccessorProp",
          value: function maybeAsyncOrAccessorProp(prop) {
            return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
        },
        {
          key: "parsePropertyDefinition",
          value: function parsePropertyDefinition(refExpressionErrors) {
            var decorators = [];
            if (this.match(26)) {
              if (this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedPropertyDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
            }
            var prop = this.startNode();
            var isAsync = false;
            var isAccessor2 = false;
            var startLoc;
            if (this.match(21)) {
              if (decorators.length)
                this.unexpected();
              return this.parseSpread();
            }
            if (decorators.length) {
              prop.decorators = decorators;
              decorators = [];
            }
            prop.method = false;
            if (refExpressionErrors) {
              startLoc = this.state.startLoc;
            }
            var isGenerator = this.eat(55);
            this.parsePropertyNamePrefixOperator(prop);
            var containsEsc = this.state.containsEsc;
            var key = this.parsePropertyName(prop, refExpressionErrors);
            if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
              var keyName = key.name;
              if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                this.resetPreviousNodeTrailingComments(key);
                isGenerator = this.eat(55);
                this.parsePropertyName(prop);
              }
              if (keyName === "get" || keyName === "set") {
                isAccessor2 = true;
                this.resetPreviousNodeTrailingComments(key);
                prop.kind = keyName;
                if (this.match(55)) {
                  isGenerator = true;
                  this.raise(Errors.AccessorIsGenerator, {
                    at: this.state.curPosition(),
                    kind: keyName
                  });
                  this.next();
                }
                this.parsePropertyName(prop);
              }
            }
            return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor2, refExpressionErrors);
          }
        },
        {
          key: "getGetterSetterExpectedParamCount",
          value: function getGetterSetterExpectedParamCount(method) {
            return method.kind === "get" ? 0 : 1;
          }
        },
        {
          key: "getObjectOrClassMethodParams",
          value: function getObjectOrClassMethodParams(method) {
            return method.params;
          }
        },
        {
          key: "checkGetterSetterParams",
          value: function checkGetterSetterParams(method) {
            var _params_;
            var paramCount = this.getGetterSetterExpectedParamCount(method);
            var params = this.getObjectOrClassMethodParams(method);
            if (params.length !== paramCount) {
              this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
                at: method
              });
            }
            if (method.kind === "set" && ((_params_ = params[params.length - 1]) === null || _params_ === void 0 ? void 0 : _params_.type) === "RestElement") {
              this.raise(Errors.BadSetterRestParameter, {
                at: method
              });
            }
          }
        },
        {
          key: "parseObjectMethod",
          value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
            if (isAccessor2) {
              var finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
              this.checkGetterSetterParams(finishedProp);
              return finishedProp;
            }
            if (isAsync || isGenerator || this.match(10)) {
              if (isPattern2)
                this.unexpected();
              prop.kind = "method";
              prop.method = true;
              return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
            }
          }
        },
        {
          key: "parseObjectProperty",
          value: function parseObjectProperty(prop, startLoc, isPattern2, refExpressionErrors) {
            prop.shorthand = false;
            if (this.eat(14)) {
              prop.value = isPattern2 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
              return this.finishNode(prop, "ObjectProperty");
            }
            if (!prop.computed && prop.key.type === "Identifier") {
              this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
              if (isPattern2) {
                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
              } else if (this.match(29)) {
                var shorthandAssignLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.shorthandAssignLoc === null) {
                    refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                  }
                } else {
                  this.raise(Errors.InvalidCoverInitializedName, {
                    at: shorthandAssignLoc
                  });
                }
                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
              } else {
                prop.value = cloneIdentifier(prop.key);
              }
              prop.shorthand = true;
              return this.finishNode(prop, "ObjectProperty");
            }
          }
        },
        {
          key: "parseObjPropValue",
          value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
            var node2 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) || this.parseObjectProperty(prop, startLoc, isPattern2, refExpressionErrors);
            if (!node2)
              this.unexpected();
            return node2;
          }
        },
        {
          key: "parsePropertyName",
          value: function parsePropertyName(prop, refExpressionErrors) {
            if (this.eat(0)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssignAllowIn();
              this.expect(3);
            } else {
              var _this_state = this.state, type3 = _this_state.type, value1 = _this_state.value;
              var key;
              if (tokenIsKeywordOrIdentifier(type3)) {
                key = this.parseIdentifier(true);
              } else {
                switch (type3) {
                  case 134:
                    key = this.parseNumericLiteral(value1);
                    break;
                  case 133:
                    key = this.parseStringLiteral(value1);
                    break;
                  case 135:
                    key = this.parseBigIntLiteral(value1);
                    break;
                  case 136:
                    key = this.parseDecimalLiteral(value1);
                    break;
                  case 138: {
                    var privateKeyLoc = this.state.startLoc;
                    if (refExpressionErrors != null) {
                      if (refExpressionErrors.privateKeyLoc === null) {
                        refExpressionErrors.privateKeyLoc = privateKeyLoc;
                      }
                    } else {
                      this.raise(Errors.UnexpectedPrivateField, {
                        at: privateKeyLoc
                      });
                    }
                    key = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
              }
              prop.key = key;
              if (type3 !== 138) {
                prop.computed = false;
              }
            }
            return prop.key;
          }
        },
        {
          key: "initFunction",
          value: function initFunction(node2, isAsync) {
            node2.id = null;
            node2.generator = false;
            node2.async = isAsync;
          }
        },
        {
          key: "parseMethod",
          value: function parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type3) {
            var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
            this.initFunction(node2, isAsync);
            node2.generator = isGenerator;
            this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
            this.prodParam.enter(functionFlags2(isAsync, node2.generator));
            this.parseFunctionParams(node2, isConstructor);
            var finishedNode = this.parseFunctionBodyAndFinish(node2, type3, true);
            this.prodParam.exit();
            this.scope.exit();
            return finishedNode;
          }
        },
        {
          key: "parseArrayLike",
          value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            if (isTuple) {
              this.expectPlugin("recordAndTuple");
            }
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
          }
        },
        {
          key: "parseArrowExpression",
          value: function parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
            this.scope.enter(2 | 4);
            var flags = functionFlags2(isAsync, false);
            if (!this.match(5) && this.prodParam.hasIn) {
              flags |= 8;
            }
            this.prodParam.enter(flags);
            this.initFunction(node2, isAsync);
            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            if (params) {
              this.state.maybeInArrowParameters = true;
              this.setArrowFunctionParameters(node2, params, trailingCommaLoc);
            }
            this.state.maybeInArrowParameters = false;
            this.parseFunctionBody(node2, true);
            this.prodParam.exit();
            this.scope.exit();
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return this.finishNode(node2, "ArrowFunctionExpression");
          }
        },
        {
          key: "setArrowFunctionParameters",
          value: function setArrowFunctionParameters(node2, params, trailingCommaLoc) {
            this.toAssignableList(params, trailingCommaLoc, false);
            node2.params = params;
          }
        },
        {
          key: "parseFunctionBodyAndFinish",
          value: function parseFunctionBodyAndFinish(node2, type3) {
            var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            this.parseFunctionBody(node2, false, isMethod3);
            return this.finishNode(node2, type3);
          }
        },
        {
          key: "parseFunctionBody",
          value: function parseFunctionBody(node2, allowExpression) {
            var isMethod3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var _this = this;
            var isExpression3 = allowExpression && !this.match(5);
            this.expressionScope.enter(newExpressionScope());
            if (isExpression3) {
              node2.body = this.parseMaybeAssign();
              this.checkParams(node2, false, allowExpression, false);
            } else {
              var oldStrict = this.state.strict;
              var oldLabels = this.state.labels;
              this.state.labels = [];
              this.prodParam.enter(this.prodParam.currentFlags() | 4);
              node2.body = this.parseBlock(true, false, function(hasStrictModeDirective) {
                var nonSimple = !_this.isSimpleParamList(node2.params);
                if (hasStrictModeDirective && nonSimple) {
                  _this.raise(Errors.IllegalLanguageModeDirective, {
                    at: (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.loc.end : node2
                  });
                }
                var strictModeChanged = !oldStrict && _this.state.strict;
                _this.checkParams(node2, !_this.state.strict && !allowExpression && !isMethod3 && !nonSimple, allowExpression, strictModeChanged);
                if (_this.state.strict && node2.id) {
                  _this.checkIdentifier(node2.id, 65, strictModeChanged);
                }
              });
              this.prodParam.exit();
              this.state.labels = oldLabels;
            }
            this.expressionScope.exit();
          }
        },
        {
          key: "isSimpleParameter",
          value: function isSimpleParameter(node2) {
            return node2.type === "Identifier";
          }
        },
        {
          key: "isSimpleParamList",
          value: function isSimpleParamList(params) {
            for (var i2 = 0, len = params.length; i2 < len; i2++) {
              if (!this.isSimpleParameter(params[i2]))
                return false;
            }
            return true;
          }
        },
        {
          key: "checkParams",
          value: function checkParams(node2, allowDuplicates, isArrowFunction) {
            var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
            var checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
            var formalParameters = {
              type: "FormalParameters"
            };
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = node2.params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var param = _step8.value;
                this.checkLVal(param, {
                  in: formalParameters,
                  binding: 5,
                  checkClashes,
                  strictModeChanged
                });
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        {
          key: "parseExprList",
          value: function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
            var elts = [];
            var first = true;
            while (!this.eat(close)) {
              if (first) {
                first = false;
              } else {
                this.expect(12);
                if (this.match(close)) {
                  if (nodeForExtra) {
                    this.addTrailingCommaExtraToNode(nodeForExtra);
                  }
                  this.next();
                  break;
                }
              }
              elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
            }
            return elts;
          }
        },
        {
          key: "parseExprListItem",
          value: function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
            var elt;
            if (this.match(12)) {
              if (!allowEmpty) {
                this.raise(Errors.UnexpectedToken, {
                  at: this.state.curPosition(),
                  unexpected: ","
                });
              }
              elt = null;
            } else if (this.match(21)) {
              var spreadNodeStartLoc = this.state.startLoc;
              elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication");
              if (!allowPlaceholder) {
                this.raise(Errors.UnexpectedArgumentPlaceholder, {
                  at: this.state.startLoc
                });
              }
              var node2 = this.startNode();
              this.next();
              elt = this.finishNode(node2, "ArgumentPlaceholder");
            } else {
              elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
            }
            return elt;
          }
        },
        {
          key: "parseIdentifier",
          value: function parseIdentifier(liberal) {
            var node2 = this.startNode();
            var name2 = this.parseIdentifierName(liberal);
            return this.createIdentifier(node2, name2);
          }
        },
        {
          key: "createIdentifier",
          value: function createIdentifier(node2, name2) {
            node2.name = name2;
            node2.loc.identifierName = name2;
            return this.finishNode(node2, "Identifier");
          }
        },
        {
          key: "parseIdentifierName",
          value: function parseIdentifierName(liberal) {
            var name2;
            var _this_state = this.state, startLoc = _this_state.startLoc, type3 = _this_state.type;
            if (tokenIsKeywordOrIdentifier(type3)) {
              name2 = this.state.value;
            } else {
              this.unexpected();
            }
            var tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type3);
            if (liberal) {
              if (tokenIsKeyword2) {
                this.replaceToken(132);
              }
            } else {
              this.checkReservedWord(name2, startLoc, tokenIsKeyword2, false);
            }
            this.next();
            return name2;
          }
        },
        {
          key: "checkReservedWord",
          value: function checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
            if (word.length > 10) {
              return;
            }
            if (!canBeReservedWord(word)) {
              return;
            }
            if (checkKeywords && isKeyword2(word)) {
              this.raise(Errors.UnexpectedKeyword, {
                at: startLoc,
                keyword: word
              });
              return;
            }
            var reservedTest = !this.state.strict ? isReservedWord2 : isBinding3 ? isStrictBindReservedWord : isStrictReservedWord2;
            if (reservedTest(word, this.inModule)) {
              this.raise(Errors.UnexpectedReservedWord, {
                at: startLoc,
                reservedWord: word
              });
              return;
            } else if (word === "yield") {
              if (this.prodParam.hasYield) {
                this.raise(Errors.YieldBindingIdentifier, {
                  at: startLoc
                });
                return;
              }
            } else if (word === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(Errors.AwaitBindingIdentifier, {
                  at: startLoc
                });
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                  at: startLoc
                });
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError({
                at: startLoc
              });
            } else if (word === "arguments") {
              if (this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(Errors.ArgumentsInClass, {
                  at: startLoc
                });
                return;
              }
            }
          }
        },
        {
          key: "isAwaitAllowed",
          value: function isAwaitAllowed() {
            if (this.prodParam.hasAwait)
              return true;
            if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
              return true;
            }
            return false;
          }
        },
        {
          key: "parseAwait",
          value: function parseAwait(startLoc) {
            var node2 = this.startNodeAt(startLoc);
            this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
              at: node2
            });
            if (this.eat(55)) {
              this.raise(Errors.ObsoleteAwaitStar, {
                at: node2
              });
            }
            if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
              if (this.isAmbiguousAwait()) {
                this.ambiguousScriptDifferentAst = true;
              } else {
                this.sawUnambiguousESM = true;
              }
            }
            if (!this.state.soloAwait) {
              node2.argument = this.parseMaybeUnary(null, true);
            }
            return this.finishNode(node2, "AwaitExpression");
          }
        },
        {
          key: "isAmbiguousAwait",
          value: function isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return true;
            var type3 = this.state.type;
            return type3 === 53 || type3 === 10 || type3 === 0 || tokenIsTemplate(type3) || type3 === 102 && !this.state.containsEsc || type3 === 137 || type3 === 56 || this.hasPlugin("v8intrinsic") && type3 === 54;
          }
        },
        {
          key: "parseYield",
          value: function parseYield() {
            var node2 = this.startNode();
            this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
              at: node2
            });
            this.next();
            var delegating = false;
            var argument = null;
            if (!this.hasPrecedingLineBreak()) {
              delegating = this.eat(55);
              switch (this.state.type) {
                case 13:
                case 139:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!delegating)
                    break;
                default:
                  argument = this.parseMaybeAssign();
              }
            }
            node2.delegate = delegating;
            node2.argument = argument;
            return this.finishNode(node2, "YieldExpression");
          }
        },
        {
          key: "parseImportCall",
          value: function parseImportCall(node2) {
            this.next();
            node2.source = this.parseMaybeAssignAllowIn();
            if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
              node2.options = null;
            }
            if (this.eat(12)) {
              this.expectImportAttributesPlugin();
              if (!this.match(11)) {
                node2.options = this.parseMaybeAssignAllowIn();
                this.eat(12);
              }
            }
            this.expect(11);
            return this.finishNode(node2, "ImportExpression");
          }
        },
        {
          key: "checkPipelineAtInfixOperator",
          value: function checkPipelineAtInfixOperator(left, leftStartLoc) {
            if (this.hasPlugin([
              "pipelineOperator",
              {
                proposal: "smart"
              }
            ])) {
              if (left.type === "SequenceExpression") {
                this.raise(Errors.PipelineHeadSequenceExpression, {
                  at: leftStartLoc
                });
              }
            }
          }
        },
        {
          key: "parseSmartPipelineBodyInStyle",
          value: function parseSmartPipelineBodyInStyle(childExpr, startLoc) {
            if (this.isSimpleReference(childExpr)) {
              var bodyNode = this.startNodeAt(startLoc);
              bodyNode.callee = childExpr;
              return this.finishNode(bodyNode, "PipelineBareFunction");
            } else {
              var bodyNode1 = this.startNodeAt(startLoc);
              this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
              bodyNode1.expression = childExpr;
              return this.finishNode(bodyNode1, "PipelineTopicExpression");
            }
          }
        },
        {
          key: "isSimpleReference",
          value: function isSimpleReference(expression2) {
            switch (expression2.type) {
              case "MemberExpression":
                return !expression2.computed && this.isSimpleReference(expression2.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
        },
        {
          key: "checkSmartPipeTopicBodyEarlyErrors",
          value: function checkSmartPipeTopicBodyEarlyErrors(startLoc) {
            if (this.match(19)) {
              throw this.raise(Errors.PipelineBodyNoArrow, {
                at: this.state.startLoc
              });
            }
            if (!this.topicReferenceWasUsedInCurrentContext()) {
              this.raise(Errors.PipelineTopicUnused, {
                at: startLoc
              });
            }
          }
        },
        {
          key: "withTopicBindingContext",
          value: function withTopicBindingContext(callback) {
            var outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 1,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
        },
        {
          key: "withSmartMixTopicForbiddingContext",
          value: function withSmartMixTopicForbiddingContext(callback) {
            if (this.hasPlugin([
              "pipelineOperator",
              {
                proposal: "smart"
              }
            ])) {
              var outerContextTopicState = this.state.topicContext;
              this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
              };
              try {
                return callback();
              } finally {
                this.state.topicContext = outerContextTopicState;
              }
            } else {
              return callback();
            }
          }
        },
        {
          key: "withSoloAwaitPermittingContext",
          value: function withSoloAwaitPermittingContext(callback) {
            var outerContextSoloAwaitState = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return callback();
            } finally {
              this.state.soloAwait = outerContextSoloAwaitState;
            }
          }
        },
        {
          key: "allowInAnd",
          value: function allowInAnd(callback) {
            var flags = this.prodParam.currentFlags();
            var prodParamToSet = 8 & ~flags;
            if (prodParamToSet) {
              this.prodParam.enter(flags | 8);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
        },
        {
          key: "disallowInAnd",
          value: function disallowInAnd(callback) {
            var flags = this.prodParam.currentFlags();
            var prodParamToClear = 8 & flags;
            if (prodParamToClear) {
              this.prodParam.enter(flags & ~8);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
        },
        {
          key: "registerTopicReference",
          value: function registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
        },
        {
          key: "topicReferenceIsAllowedInCurrentContext",
          value: function topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
        },
        {
          key: "topicReferenceWasUsedInCurrentContext",
          value: function topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
        },
        {
          key: "parseFSharpPipelineBody",
          value: function parseFSharpPipelineBody(prec) {
            var startLoc = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return ret;
          }
        },
        {
          key: "parseModuleExpression",
          value: function parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            var node2 = this.startNode();
            this.next();
            if (!this.match(5)) {
              this.unexpected(null, 5);
            }
            var program3 = this.startNodeAt(this.state.endLoc);
            this.next();
            var revertScopes = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              node2.body = this.parseProgram(program3, 8, "module");
            } finally {
              revertScopes();
            }
            return this.finishNode(node2, "ModuleExpression");
          }
        },
        {
          key: "parsePropertyNamePrefixOperator",
          value: function parsePropertyNamePrefixOperator(prop) {
          }
        }
      ]);
      return ExpressionParser2;
    }(LValParser);
    var loopLabel2 = {
      kind: "loop"
    };
    var switchLabel2 = {
      kind: "switch"
    };
    var loneSurrogate2 = RegExp("[\uD800-\uDFFF]", "u");
    var keywordRelationalOperator2 = RegExp("in(?:stanceof)?", "y");
    function babel7CompatTokens(tokens, input) {
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token = tokens[i2];
        var type3 = token.type;
        if (typeof type3 === "number") {
          token.type = getExportedToken(type3);
        }
      }
      return tokens;
    }
    var StatementParser = /* @__PURE__ */ function(ExpressionParser2) {
      "use strict";
      _inherits(StatementParser2, ExpressionParser2);
      var _super3 = _create_super(StatementParser2);
      function StatementParser2() {
        _class_call_check(this, StatementParser2);
        return _super3.apply(this, arguments);
      }
      _create_class(StatementParser2, [
        {
          key: "parseTopLevel",
          value: function parseTopLevel(file2, program3) {
            file2.program = this.parseProgram(program3);
            file2.comments = this.state.comments;
            if (this.options.tokens) {
              file2.tokens = babel7CompatTokens(this.tokens, this.input);
            }
            return this.finishNode(file2, "File");
          }
        },
        {
          key: "parseProgram",
          value: function parseProgram(program3) {
            var end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 139, sourceType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
            program3.sourceType = sourceType;
            program3.interpreter = this.parseInterpreterDirective();
            this.parseBlockBody(program3, true, true, end);
            if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = Array.from(this.scope.undefinedExports)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var _step_value = _sliced_to_array(_step8.value, 2), localName = _step_value[0], at2 = _step_value[1];
                  this.raise(Errors.ModuleExportUndefined, {
                    at: at2,
                    localName
                  });
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            }
            var finishedProgram;
            if (end === 139) {
              finishedProgram = this.finishNode(program3, "Program");
            } else {
              finishedProgram = this.finishNodeAt(program3, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
            }
            return finishedProgram;
          }
        },
        {
          key: "stmtToDirective",
          value: function stmtToDirective(stmt) {
            var directive2 = stmt;
            directive2.type = "Directive";
            directive2.value = directive2.expression;
            delete directive2.expression;
            var directiveLiteral2 = directive2.value;
            var expressionValue = directiveLiteral2.value;
            var raw = this.input.slice(directiveLiteral2.start, directiveLiteral2.end);
            var val = directiveLiteral2.value = raw.slice(1, -1);
            this.addExtra(directiveLiteral2, "raw", raw);
            this.addExtra(directiveLiteral2, "rawValue", val);
            this.addExtra(directiveLiteral2, "expressionValue", expressionValue);
            directiveLiteral2.type = "DirectiveLiteral";
            return directive2;
          }
        },
        {
          key: "parseInterpreterDirective",
          value: function parseInterpreterDirective() {
            if (!this.match(28)) {
              return null;
            }
            var node2 = this.startNode();
            node2.value = this.state.value;
            this.next();
            return this.finishNode(node2, "InterpreterDirective");
          }
        },
        {
          key: "isLet",
          value: function isLet2() {
            if (!this.isContextual(100)) {
              return false;
            }
            return this.hasFollowingBindingAtom();
          }
        },
        {
          key: "chStartsBindingIdentifier",
          value: function chStartsBindingIdentifier(ch, pos) {
            if (isIdentifierStart22(ch)) {
              keywordRelationalOperator2.lastIndex = pos;
              if (keywordRelationalOperator2.test(this.input)) {
                var endCh = this.codePointAtPos(keywordRelationalOperator2.lastIndex);
                if (!isIdentifierChar22(endCh) && endCh !== 92) {
                  return false;
                }
              }
              return true;
            } else if (ch === 92) {
              return true;
            } else {
              return false;
            }
          }
        },
        {
          key: "chStartsBindingPattern",
          value: function chStartsBindingPattern(ch) {
            return ch === 91 || ch === 123;
          }
        },
        {
          key: "hasFollowingBindingAtom",
          value: function hasFollowingBindingAtom() {
            var next = this.nextTokenStart();
            var nextCh = this.codePointAtPos(next);
            return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
          }
        },
        {
          key: "hasInLineFollowingBindingIdentifier",
          value: function hasInLineFollowingBindingIdentifier() {
            var next = this.nextTokenInLineStart();
            var nextCh = this.codePointAtPos(next);
            return this.chStartsBindingIdentifier(nextCh, next);
          }
        },
        {
          key: "startsUsingForOf",
          value: function startsUsingForOf() {
            var _this_lookahead = this.lookahead(), type3 = _this_lookahead.type, containsEsc = _this_lookahead.containsEsc;
            if (type3 === 102 && !containsEsc) {
              return false;
            } else if (tokenIsIdentifier(type3) && !this.hasFollowingLineBreak()) {
              this.expectPlugin("explicitResourceManagement");
              return true;
            }
          }
        },
        {
          key: "startsAwaitUsing",
          value: function startsAwaitUsing() {
            var next = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(next, "using")) {
              next = this.nextTokenInLineStartSince(next + 5);
              var nextCh = this.codePointAtPos(next);
              if (this.chStartsBindingIdentifier(nextCh, next)) {
                this.expectPlugin("explicitResourceManagement");
                return true;
              }
            }
            return false;
          }
        },
        {
          key: "parseModuleItem",
          value: function parseModuleItem() {
            return this.parseStatementLike(1 | 2 | 4 | 8);
          }
        },
        {
          key: "parseStatementListItem",
          value: function parseStatementListItem() {
            return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
        },
        {
          key: "parseStatementOrSloppyAnnexBFunctionDeclaration",
          value: function parseStatementOrSloppyAnnexBFunctionDeclaration() {
            var allowLabeledFunction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            var flags = 0;
            if (this.options.annexB && !this.state.strict) {
              flags |= 4;
              if (allowLabeledFunction) {
                flags |= 8;
              }
            }
            return this.parseStatementLike(flags);
          }
        },
        {
          key: "parseStatement",
          value: function parseStatement() {
            return this.parseStatementLike(0);
          }
        },
        {
          key: "parseStatementLike",
          value: function parseStatementLike(flags) {
            var decorators = null;
            if (this.match(26)) {
              decorators = this.parseDecorators(true);
            }
            return this.parseStatementContent(flags, decorators);
          }
        },
        {
          key: "parseStatementContent",
          value: function parseStatementContent(flags, decorators) {
            var starttype = this.state.type;
            var node2 = this.startNode();
            var allowDeclaration = !!(flags & 2);
            var allowFunctionDeclaration = !!(flags & 4);
            var topLevel = flags & 1;
            switch (starttype) {
              case 60:
                return this.parseBreakContinueStatement(node2, true);
              case 63:
                return this.parseBreakContinueStatement(node2, false);
              case 64:
                return this.parseDebuggerStatement(node2);
              case 90:
                return this.parseDoWhileStatement(node2);
              case 91:
                return this.parseForStatement(node2);
              case 68:
                if (this.lookaheadCharCode() === 46)
                  break;
                if (!allowFunctionDeclaration) {
                  this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
                return this.parseFunctionStatement(node2, false, !allowDeclaration && allowFunctionDeclaration);
              case 80:
                if (!allowDeclaration)
                  this.unexpected();
                return this.parseClass(this.maybeTakeDecorators(decorators, node2), true);
              case 69:
                return this.parseIfStatement(node2);
              case 70:
                return this.parseReturnStatement(node2);
              case 71:
                return this.parseSwitchStatement(node2);
              case 72:
                return this.parseThrowStatement(node2);
              case 73:
                return this.parseTryStatement(node2);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) {
                  if (!this.isAwaitAllowed()) {
                    this.raise(Errors.AwaitUsingNotInAsyncContext, {
                      at: node2
                    });
                  } else if (!allowDeclaration) {
                    this.raise(Errors.UnexpectedLexicalDeclaration, {
                      at: node2
                    });
                  }
                  this.next();
                  return this.parseVarStatement(node2, "await using");
                }
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
                  break;
                }
                this.expectPlugin("explicitResourceManagement");
                if (!this.scope.inModule && this.scope.inTopLevel) {
                  this.raise(Errors.UnexpectedUsingDeclaration, {
                    at: this.state.startLoc
                  });
                } else if (!allowDeclaration) {
                  this.raise(Errors.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc
                  });
                }
                return this.parseVarStatement(node2, "using");
              case 100: {
                if (this.state.containsEsc) {
                  break;
                }
                var next = this.nextTokenStart();
                var nextCh = this.codePointAtPos(next);
                if (nextCh !== 91) {
                  if (!allowDeclaration && this.hasFollowingLineBreak())
                    break;
                  if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                    break;
                  }
                }
              }
              case 75: {
                if (!allowDeclaration) {
                  this.raise(Errors.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc
                  });
                }
              }
              case 74: {
                var kind = this.state.value;
                return this.parseVarStatement(node2, kind);
              }
              case 92:
                return this.parseWhileStatement(node2);
              case 76:
                return this.parseWithStatement(node2);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(node2);
              case 83: {
                var nextTokenCharCode = this.lookaheadCharCode();
                if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                  break;
                }
              }
              case 82: {
                if (!this.options.allowImportExportEverywhere && !topLevel) {
                  this.raise(Errors.UnexpectedImportExport, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                var result;
                if (starttype === 83) {
                  result = this.parseImport(node2);
                  if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                    this.sawUnambiguousESM = true;
                  }
                } else {
                  result = this.parseExport(node2, decorators);
                  if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                    this.sawUnambiguousESM = true;
                  }
                }
                this.assertModuleNodeAllowed(result);
                return result;
              }
              default: {
                if (this.isAsyncFunction()) {
                  if (!allowDeclaration) {
                    this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                      at: this.state.startLoc
                    });
                  }
                  this.next();
                  return this.parseFunctionStatement(node2, true, !allowDeclaration && allowFunctionDeclaration);
                }
              }
            }
            var maybeName = this.state.value;
            var expr = this.parseExpression();
            if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
              return this.parseLabeledStatement(node2, maybeName, expr, flags);
            } else {
              return this.parseExpressionStatement(node2, expr, decorators);
            }
          }
        },
        {
          key: "assertModuleNodeAllowed",
          value: function assertModuleNodeAllowed(node2) {
            if (!this.options.allowImportExportEverywhere && !this.inModule) {
              this.raise(Errors.ImportOutsideModule, {
                at: node2
              });
            }
          }
        },
        {
          key: "decoratorsEnabledBeforeExport",
          value: function decoratorsEnabledBeforeExport() {
            if (this.hasPlugin("decorators-legacy"))
              return true;
            return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
        },
        {
          key: "maybeTakeDecorators",
          value: function maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
            if (maybeDecorators) {
              if (classNode.decorators && classNode.decorators.length > 0) {
                var _classNode_decorators;
                if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                  this.raise(Errors.DecoratorsBeforeAfterExport, {
                    at: classNode.decorators[0]
                  });
                }
                (_classNode_decorators = classNode.decorators).unshift.apply(_classNode_decorators, _to_consumable_array(maybeDecorators));
              } else {
                classNode.decorators = maybeDecorators;
              }
              this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
              if (exportNode)
                this.resetStartLocationFromNode(exportNode, classNode);
            }
            return classNode;
          }
        },
        {
          key: "canHaveLeadingDecorator",
          value: function canHaveLeadingDecorator() {
            return this.match(80);
          }
        },
        {
          key: "parseDecorators",
          value: function parseDecorators(allowExport) {
            var decorators = [];
            do {
              decorators.push(this.parseDecorator());
            } while (this.match(26));
            if (this.match(82)) {
              if (!allowExport) {
                this.unexpected();
              }
              if (!this.decoratorsEnabledBeforeExport()) {
                this.raise(Errors.DecoratorExportClass, {
                  at: this.state.startLoc
                });
              }
            } else if (!this.canHaveLeadingDecorator()) {
              throw this.raise(Errors.UnexpectedLeadingDecorator, {
                at: this.state.startLoc
              });
            }
            return decorators;
          }
        },
        {
          key: "parseDecorator",
          value: function parseDecorator() {
            this.expectOnePlugin([
              "decorators",
              "decorators-legacy"
            ]);
            var node2 = this.startNode();
            this.next();
            if (this.hasPlugin("decorators")) {
              var startLoc = this.state.startLoc;
              var expr;
              if (this.match(10)) {
                var startLoc2 = this.state.startLoc;
                this.next();
                expr = this.parseExpression();
                this.expect(11);
                expr = this.wrapParenthesis(startLoc2, expr);
                var paramsStartLoc = this.state.startLoc;
                node2.expression = this.parseMaybeDecoratorArguments(expr);
                if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node2.expression !== expr) {
                  this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                    at: paramsStartLoc
                  });
                }
              } else {
                expr = this.parseIdentifier(false);
                while (this.eat(16)) {
                  var node22 = this.startNodeAt(startLoc);
                  node22.object = expr;
                  if (this.match(138)) {
                    this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                    node22.property = this.parsePrivateName();
                  } else {
                    node22.property = this.parseIdentifier(true);
                  }
                  node22.computed = false;
                  expr = this.finishNode(node22, "MemberExpression");
                }
                node2.expression = this.parseMaybeDecoratorArguments(expr);
              }
            } else {
              node2.expression = this.parseExprSubscripts();
            }
            return this.finishNode(node2, "Decorator");
          }
        },
        {
          key: "parseMaybeDecoratorArguments",
          value: function parseMaybeDecoratorArguments(expr) {
            if (this.eat(10)) {
              var node2 = this.startNodeAtNode(expr);
              node2.callee = expr;
              node2.arguments = this.parseCallExpressionArguments(11, false);
              this.toReferencedList(node2.arguments);
              return this.finishNode(node2, "CallExpression");
            }
            return expr;
          }
        },
        {
          key: "parseBreakContinueStatement",
          value: function parseBreakContinueStatement(node2, isBreak) {
            this.next();
            if (this.isLineTerminator()) {
              node2.label = null;
            } else {
              node2.label = this.parseIdentifier();
              this.semicolon();
            }
            this.verifyBreakContinue(node2, isBreak);
            return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
          }
        },
        {
          key: "verifyBreakContinue",
          value: function verifyBreakContinue(node2, isBreak) {
            var i2;
            for (i2 = 0; i2 < this.state.labels.length; ++i2) {
              var lab = this.state.labels[i2];
              if (node2.label == null || lab.name === node2.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop"))
                  break;
                if (node2.label && isBreak)
                  break;
              }
            }
            if (i2 === this.state.labels.length) {
              var type3 = isBreak ? "BreakStatement" : "ContinueStatement";
              this.raise(Errors.IllegalBreakContinue, {
                at: node2,
                type: type3
              });
            }
          }
        },
        {
          key: "parseDebuggerStatement",
          value: function parseDebuggerStatement(node2) {
            this.next();
            this.semicolon();
            return this.finishNode(node2, "DebuggerStatement");
          }
        },
        {
          key: "parseHeaderExpression",
          value: function parseHeaderExpression() {
            this.expect(10);
            var val = this.parseExpression();
            this.expect(11);
            return val;
          }
        },
        {
          key: "parseDoWhileStatement",
          value: function parseDoWhileStatement(node2) {
            var _this = this;
            this.next();
            this.state.labels.push(loopLabel2);
            node2.body = this.withSmartMixTopicForbiddingContext(function() {
              return _this.parseStatement();
            });
            this.state.labels.pop();
            this.expect(92);
            node2.test = this.parseHeaderExpression();
            this.eat(13);
            return this.finishNode(node2, "DoWhileStatement");
          }
        },
        {
          key: "parseForStatement",
          value: function parseForStatement(node2) {
            this.next();
            this.state.labels.push(loopLabel2);
            var awaitAt = null;
            if (this.isAwaitAllowed() && this.eatContextual(96)) {
              awaitAt = this.state.lastTokStartLoc;
            }
            this.scope.enter(0);
            this.expect(10);
            if (this.match(13)) {
              if (awaitAt !== null) {
                this.unexpected(awaitAt);
              }
              return this.parseFor(node2, null);
            }
            var startsWithLet = this.isContextual(100);
            {
              var startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
              var starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
              var isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
              if (this.match(74) || this.match(75) || isLetOrUsing) {
                var initNode = this.startNode();
                var kind;
                if (startsWithAwaitUsing) {
                  kind = "await using";
                  if (!this.isAwaitAllowed()) {
                    this.raise(Errors.AwaitUsingNotInAsyncContext, {
                      at: this.state.startLoc
                    });
                  }
                  this.next();
                } else {
                  kind = this.state.value;
                }
                this.next();
                this.parseVar(initNode, true, kind);
                var init2 = this.finishNode(initNode, "VariableDeclaration");
                var isForIn = this.match(58);
                if (isForIn && starsWithUsingDeclaration) {
                  this.raise(Errors.ForInUsing, {
                    at: init2
                  });
                }
                if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
                  return this.parseForIn(node2, init2, awaitAt);
                }
                if (awaitAt !== null) {
                  this.unexpected(awaitAt);
                }
                return this.parseFor(node2, init2);
              }
            }
            var startsWithAsync = this.isContextual(95);
            var refExpressionErrors = new ExpressionErrors();
            var init = this.parseExpression(true, refExpressionErrors);
            var isForOf = this.isContextual(102);
            if (isForOf) {
              if (startsWithLet) {
                this.raise(Errors.ForOfLet, {
                  at: init
                });
              }
              if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
                this.raise(Errors.ForOfAsync, {
                  at: init
                });
              }
            }
            if (isForOf || this.match(58)) {
              this.checkDestructuringPrivate(refExpressionErrors);
              this.toAssignable(init, true);
              var type3 = isForOf ? "ForOfStatement" : "ForInStatement";
              this.checkLVal(init, {
                in: {
                  type: type3
                }
              });
              return this.parseForIn(node2, init, awaitAt);
            } else {
              this.checkExpressionErrors(refExpressionErrors, true);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node2, init);
          }
        },
        {
          key: "parseFunctionStatement",
          value: function parseFunctionStatement(node2, isAsync, isHangingDeclaration) {
            this.next();
            return this.parseFunction(node2, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
          }
        },
        {
          key: "parseIfStatement",
          value: function parseIfStatement(node2) {
            this.next();
            node2.test = this.parseHeaderExpression();
            node2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
            node2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
            return this.finishNode(node2, "IfStatement");
          }
        },
        {
          key: "parseReturnStatement",
          value: function parseReturnStatement(node2) {
            if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
              this.raise(Errors.IllegalReturn, {
                at: this.state.startLoc
              });
            }
            this.next();
            if (this.isLineTerminator()) {
              node2.argument = null;
            } else {
              node2.argument = this.parseExpression();
              this.semicolon();
            }
            return this.finishNode(node2, "ReturnStatement");
          }
        },
        {
          key: "parseSwitchStatement",
          value: function parseSwitchStatement(node2) {
            this.next();
            node2.discriminant = this.parseHeaderExpression();
            var cases = node2.cases = [];
            this.expect(5);
            this.state.labels.push(switchLabel2);
            this.scope.enter(0);
            var cur;
            for (var sawDefault; !this.match(8); ) {
              if (this.match(61) || this.match(65)) {
                var isCase = this.match(61);
                if (cur)
                  this.finishNode(cur, "SwitchCase");
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) {
                  cur.test = this.parseExpression();
                } else {
                  if (sawDefault) {
                    this.raise(Errors.MultipleDefaultsInSwitch, {
                      at: this.state.lastTokStartLoc
                    });
                  }
                  sawDefault = true;
                  cur.test = null;
                }
                this.expect(14);
              } else {
                if (cur) {
                  cur.consequent.push(this.parseStatementListItem());
                } else {
                  this.unexpected();
                }
              }
            }
            this.scope.exit();
            if (cur)
              this.finishNode(cur, "SwitchCase");
            this.next();
            this.state.labels.pop();
            return this.finishNode(node2, "SwitchStatement");
          }
        },
        {
          key: "parseThrowStatement",
          value: function parseThrowStatement(node2) {
            this.next();
            if (this.hasPrecedingLineBreak()) {
              this.raise(Errors.NewlineAfterThrow, {
                at: this.state.lastTokEndLoc
              });
            }
            node2.argument = this.parseExpression();
            this.semicolon();
            return this.finishNode(node2, "ThrowStatement");
          }
        },
        {
          key: "parseCatchClauseParam",
          value: function parseCatchClauseParam() {
            var param = this.parseBindingAtom();
            this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
            this.checkLVal(param, {
              in: {
                type: "CatchClause"
              },
              binding: 9
            });
            return param;
          }
        },
        {
          key: "parseTryStatement",
          value: function parseTryStatement(node2) {
            var _this = this;
            this.next();
            node2.block = this.parseBlock();
            node2.handler = null;
            if (this.match(62)) {
              var clause = this.startNode();
              this.next();
              if (this.match(10)) {
                this.expect(10);
                clause.param = this.parseCatchClauseParam();
                this.expect(11);
              } else {
                clause.param = null;
                this.scope.enter(0);
              }
              clause.body = this.withSmartMixTopicForbiddingContext(function() {
                return _this.parseBlock(false, false);
              });
              this.scope.exit();
              node2.handler = this.finishNode(clause, "CatchClause");
            }
            node2.finalizer = this.eat(67) ? this.parseBlock() : null;
            if (!node2.handler && !node2.finalizer) {
              this.raise(Errors.NoCatchOrFinally, {
                at: node2
              });
            }
            return this.finishNode(node2, "TryStatement");
          }
        },
        {
          key: "parseVarStatement",
          value: function parseVarStatement(node2, kind) {
            var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            this.next();
            this.parseVar(node2, false, kind, allowMissingInitializer);
            this.semicolon();
            return this.finishNode(node2, "VariableDeclaration");
          }
        },
        {
          key: "parseWhileStatement",
          value: function parseWhileStatement(node2) {
            var _this = this;
            this.next();
            node2.test = this.parseHeaderExpression();
            this.state.labels.push(loopLabel2);
            node2.body = this.withSmartMixTopicForbiddingContext(function() {
              return _this.parseStatement();
            });
            this.state.labels.pop();
            return this.finishNode(node2, "WhileStatement");
          }
        },
        {
          key: "parseWithStatement",
          value: function parseWithStatement(node2) {
            var _this = this;
            if (this.state.strict) {
              this.raise(Errors.StrictWith, {
                at: this.state.startLoc
              });
            }
            this.next();
            node2.object = this.parseHeaderExpression();
            node2.body = this.withSmartMixTopicForbiddingContext(function() {
              return _this.parseStatement();
            });
            return this.finishNode(node2, "WithStatement");
          }
        },
        {
          key: "parseEmptyStatement",
          value: function parseEmptyStatement(node2) {
            this.next();
            return this.finishNode(node2, "EmptyStatement");
          }
        },
        {
          key: "parseLabeledStatement",
          value: function parseLabeledStatement(node2, maybeName, expr, flags) {
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = this.state.labels[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var label = _step8.value;
                if (label.name === maybeName) {
                  this.raise(Errors.LabelRedeclaration, {
                    at: expr,
                    labelName: maybeName
                  });
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            var kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
            for (var i2 = this.state.labels.length - 1; i2 >= 0; i2--) {
              var label1 = this.state.labels[i2];
              if (label1.statementStart === node2.start) {
                label1.statementStart = this.state.start;
                label1.kind = kind;
              } else {
                break;
              }
            }
            this.state.labels.push({
              name: maybeName,
              kind,
              statementStart: this.state.start
            });
            node2.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
            this.state.labels.pop();
            node2.label = expr;
            return this.finishNode(node2, "LabeledStatement");
          }
        },
        {
          key: "parseExpressionStatement",
          value: function parseExpressionStatement(node2, expr, decorators) {
            node2.expression = expr;
            this.semicolon();
            return this.finishNode(node2, "ExpressionStatement");
          }
        },
        {
          key: "parseBlock",
          value: function parseBlock() {
            var allowDirectives = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, createNewLexicalScope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, afterBlockParse = arguments.length > 2 ? arguments[2] : void 0;
            var node2 = this.startNode();
            if (allowDirectives) {
              this.state.strictErrors.clear();
            }
            this.expect(5);
            if (createNewLexicalScope) {
              this.scope.enter(0);
            }
            this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse);
            if (createNewLexicalScope) {
              this.scope.exit();
            }
            return this.finishNode(node2, "BlockStatement");
          }
        },
        {
          key: "isValidDirective",
          value: function isValidDirective(stmt) {
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
          }
        },
        {
          key: "parseBlockBody",
          value: function parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
            var body = node2.body = [];
            var directives = node2.directives = [];
            this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
          }
        },
        {
          key: "parseBlockOrModuleBlockBody",
          value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
            var oldStrict = this.state.strict;
            var hasStrictModeDirective = false;
            var parsedNonDirective = false;
            while (!this.match(end)) {
              var stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
              if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                  var directive2 = this.stmtToDirective(stmt);
                  directives.push(directive2);
                  if (!hasStrictModeDirective && directive2.value.value === "use strict") {
                    hasStrictModeDirective = true;
                    this.setStrict(true);
                  }
                  continue;
                }
                parsedNonDirective = true;
                this.state.strictErrors.clear();
              }
              body.push(stmt);
            }
            afterBlockParse === null || afterBlockParse === void 0 ? void 0 : afterBlockParse.call(this, hasStrictModeDirective);
            if (!oldStrict) {
              this.setStrict(false);
            }
            this.next();
          }
        },
        {
          key: "parseFor",
          value: function parseFor(node2, init) {
            var _this = this;
            node2.init = init;
            this.semicolon(false);
            node2.test = this.match(13) ? null : this.parseExpression();
            this.semicolon(false);
            node2.update = this.match(11) ? null : this.parseExpression();
            this.expect(11);
            node2.body = this.withSmartMixTopicForbiddingContext(function() {
              return _this.parseStatement();
            });
            this.scope.exit();
            this.state.labels.pop();
            return this.finishNode(node2, "ForStatement");
          }
        },
        {
          key: "parseForIn",
          value: function parseForIn(node2, init, awaitAt) {
            var _this = this;
            var isForIn = this.match(58);
            this.next();
            if (isForIn) {
              if (awaitAt !== null)
                this.unexpected(awaitAt);
            } else {
              node2.await = awaitAt !== null;
            }
            if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
              this.raise(Errors.ForInOfLoopInitializer, {
                at: init,
                type: isForIn ? "ForInStatement" : "ForOfStatement"
              });
            }
            if (init.type === "AssignmentPattern") {
              this.raise(Errors.InvalidLhs, {
                at: init,
                ancestor: {
                  type: "ForStatement"
                }
              });
            }
            node2.left = init;
            node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
            this.expect(11);
            node2.body = this.withSmartMixTopicForbiddingContext(function() {
              return _this.parseStatement();
            });
            this.scope.exit();
            this.state.labels.pop();
            return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
          }
        },
        {
          key: "parseVar",
          value: function parseVar(node2, isFor3, kind) {
            var allowMissingInitializer = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var declarations = node2.declarations = [];
            node2.kind = kind;
            for (; ; ) {
              var decl = this.startNode();
              this.parseVarId(decl, kind);
              decl.init = !this.eat(29) ? null : isFor3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
              if (decl.init === null && !allowMissingInitializer) {
                if (decl.id.type !== "Identifier" && !(isFor3 && (this.match(58) || this.isContextual(102)))) {
                  this.raise(Errors.DeclarationMissingInitializer, {
                    at: this.state.lastTokEndLoc,
                    kind: "destructuring"
                  });
                } else if (kind === "const" && !(this.match(58) || this.isContextual(102))) {
                  this.raise(Errors.DeclarationMissingInitializer, {
                    at: this.state.lastTokEndLoc,
                    kind: "const"
                  });
                }
              }
              declarations.push(this.finishNode(decl, "VariableDeclarator"));
              if (!this.eat(12))
                break;
            }
            return node2;
          }
        },
        {
          key: "parseVarId",
          value: function parseVarId(decl, kind) {
            var id = this.parseBindingAtom();
            this.checkLVal(id, {
              in: {
                type: "VariableDeclarator"
              },
              binding: kind === "var" ? 5 : 8201
            });
            decl.id = id;
          }
        },
        {
          key: "parseAsyncFunctionExpression",
          value: function parseAsyncFunctionExpression(node2) {
            return this.parseFunction(node2, 8);
          }
        },
        {
          key: "parseFunction",
          value: function parseFunction(node2) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var _this = this;
            var hangingDeclaration = flags & 2;
            var isDeclaration3 = !!(flags & 1);
            var requireId = isDeclaration3 && !(flags & 4);
            var isAsync = !!(flags & 8);
            this.initFunction(node2, isAsync);
            if (this.match(55)) {
              if (hangingDeclaration) {
                this.raise(Errors.GeneratorInSingleStatementContext, {
                  at: this.state.startLoc
                });
              }
              this.next();
              node2.generator = true;
            }
            if (isDeclaration3) {
              node2.id = this.parseFunctionId(requireId);
            }
            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = false;
            this.scope.enter(2);
            this.prodParam.enter(functionFlags2(isAsync, node2.generator));
            if (!isDeclaration3) {
              node2.id = this.parseFunctionId();
            }
            this.parseFunctionParams(node2, false);
            this.withSmartMixTopicForbiddingContext(function() {
              _this.parseFunctionBodyAndFinish(node2, isDeclaration3 ? "FunctionDeclaration" : "FunctionExpression");
            });
            this.prodParam.exit();
            this.scope.exit();
            if (isDeclaration3 && !hangingDeclaration) {
              this.registerFunctionStatementId(node2);
            }
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            return node2;
          }
        },
        {
          key: "parseFunctionId",
          value: function parseFunctionId(requireId) {
            return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
          }
        },
        {
          key: "parseFunctionParams",
          value: function parseFunctionParams(node2, isConstructor) {
            this.expect(10);
            this.expressionScope.enter(newParameterDeclarationScope());
            node2.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
            this.expressionScope.exit();
          }
        },
        {
          key: "registerFunctionStatementId",
          value: function registerFunctionStatementId(node2) {
            if (!node2.id)
              return;
            this.scope.declareName(node2.id.name, !this.options.annexB || this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node2.id.loc.start);
          }
        },
        {
          key: "parseClass",
          value: function parseClass(node2, isStatement5, optionalId) {
            this.next();
            var oldStrict = this.state.strict;
            this.state.strict = true;
            this.parseClassId(node2, isStatement5, optionalId);
            this.parseClassSuper(node2);
            node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
            return this.finishNode(node2, isStatement5 ? "ClassDeclaration" : "ClassExpression");
          }
        },
        {
          key: "isClassProperty",
          value: function isClassProperty2() {
            return this.match(29) || this.match(13) || this.match(8);
          }
        },
        {
          key: "isClassMethod",
          value: function isClassMethod2() {
            return this.match(10);
          }
        },
        {
          key: "isNonstaticConstructor",
          value: function isNonstaticConstructor(method) {
            return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
          }
        },
        {
          key: "parseClassBody",
          value: function parseClassBody(hadSuperClass, oldStrict) {
            var _this = this;
            this.classScope.enter();
            var state = {
              hadConstructor: false,
              hadSuperClass
            };
            var decorators = [];
            var classBody2 = this.startNode();
            classBody2.body = [];
            this.expect(5);
            this.withSmartMixTopicForbiddingContext(function() {
              while (!_this.match(8)) {
                if (_this.eat(13)) {
                  if (decorators.length > 0) {
                    throw _this.raise(Errors.DecoratorSemicolon, {
                      at: _this.state.lastTokEndLoc
                    });
                  }
                  continue;
                }
                if (_this.match(26)) {
                  decorators.push(_this.parseDecorator());
                  continue;
                }
                var member = _this.startNode();
                if (decorators.length) {
                  member.decorators = decorators;
                  _this.resetStartLocationFromNode(member, decorators[0]);
                  decorators = [];
                }
                _this.parseClassMember(classBody2, member, state);
                if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                  _this.raise(Errors.DecoratorConstructor, {
                    at: member
                  });
                }
              }
            });
            this.state.strict = oldStrict;
            this.next();
            if (decorators.length) {
              throw this.raise(Errors.TrailingDecorator, {
                at: this.state.startLoc
              });
            }
            this.classScope.exit();
            return this.finishNode(classBody2, "ClassBody");
          }
        },
        {
          key: "parseClassMemberFromModifier",
          value: function parseClassMemberFromModifier(classBody2, member) {
            var key = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              var method = member;
              method.kind = "method";
              method.computed = false;
              method.key = key;
              method.static = false;
              this.pushClassMethod(classBody2, method, false, false, false, false);
              return true;
            } else if (this.isClassProperty()) {
              var prop = member;
              prop.computed = false;
              prop.key = key;
              prop.static = false;
              classBody2.body.push(this.parseClassProperty(prop));
              return true;
            }
            this.resetPreviousNodeTrailingComments(key);
            return false;
          }
        },
        {
          key: "parseClassMember",
          value: function parseClassMember(classBody2, member, state) {
            var isStatic2 = this.isContextual(106);
            if (isStatic2) {
              if (this.parseClassMemberFromModifier(classBody2, member)) {
                return;
              }
              if (this.eat(5)) {
                this.parseClassStaticBlock(classBody2, member);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2);
          }
        },
        {
          key: "parseClassMemberWithIsStatic",
          value: function parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
            var publicMethod = member;
            var privateMethod = member;
            var publicProp = member;
            var privateProp = member;
            var accessorProp = member;
            var method = publicMethod;
            var publicMember = publicMethod;
            member.static = isStatic2;
            this.parsePropertyNamePrefixOperator(member);
            if (this.eat(55)) {
              method.kind = "method";
              var isPrivateName3 = this.match(138);
              this.parseClassElementName(method);
              if (isPrivateName3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, true, false);
                return;
              }
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsGenerator, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody2, publicMethod, true, false, false, false);
              return;
            }
            var isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
            var isPrivate2 = this.match(138);
            var key = this.parseClassElementName(member);
            var maybeQuestionTokenStartLoc = this.state.startLoc;
            this.parsePostMemberNameModifiers(publicMember);
            if (this.isClassMethod()) {
              method.kind = "method";
              if (isPrivate2) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
                return;
              }
              var isConstructor = this.isNonstaticConstructor(publicMethod);
              var allowsDirectSuper = false;
              if (isConstructor) {
                publicMethod.kind = "constructor";
                if (state.hadConstructor && !this.hasPlugin("typescript")) {
                  this.raise(Errors.DuplicateConstructor, {
                    at: key
                  });
                }
                if (isConstructor && this.hasPlugin("typescript") && member.override) {
                  this.raise(Errors.OverrideOnConstructor, {
                    at: key
                  });
                }
                state.hadConstructor = true;
                allowsDirectSuper = state.hadSuperClass;
              }
              this.pushClassMethod(classBody2, publicMethod, false, false, isConstructor, allowsDirectSuper);
            } else if (this.isClassProperty()) {
              if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
              } else {
                this.pushClassProperty(classBody2, publicProp);
              }
            } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(key);
              var isGenerator = this.eat(55);
              if (publicMember.optional) {
                this.unexpected(maybeQuestionTokenStartLoc);
              }
              method.kind = "method";
              var isPrivate3 = this.match(138);
              this.parseClassElementName(method);
              this.parsePostMemberNameModifiers(publicMember);
              if (isPrivate3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, isGenerator, true);
              } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(Errors.ConstructorIsAsync, {
                    at: publicMethod.key
                  });
                }
                this.pushClassMethod(classBody2, publicMethod, isGenerator, true, false, false);
              }
            } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
              this.resetPreviousNodeTrailingComments(key);
              method.kind = key.name;
              var isPrivate31 = this.match(138);
              this.parseClassElementName(publicMethod);
              if (isPrivate31) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
              } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(Errors.ConstructorIsAccessor, {
                    at: publicMethod.key
                  });
                }
                this.pushClassMethod(classBody2, publicMethod, false, false, false, false);
              }
              this.checkGetterSetterParams(publicMethod);
            } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors");
              this.resetPreviousNodeTrailingComments(key);
              var isPrivate32 = this.match(138);
              this.parseClassElementName(publicProp);
              this.pushClassAccessorProperty(classBody2, accessorProp, isPrivate32);
            } else if (this.isLineTerminator()) {
              if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
              } else {
                this.pushClassProperty(classBody2, publicProp);
              }
            } else {
              this.unexpected();
            }
          }
        },
        {
          key: "parseClassElementName",
          value: function parseClassElementName(member) {
            var _this_state = this.state, type3 = _this_state.type, value1 = _this_state.value;
            if ((type3 === 132 || type3 === 133) && member.static && value1 === "prototype") {
              this.raise(Errors.StaticPrototype, {
                at: this.state.startLoc
              });
            }
            if (type3 === 138) {
              if (value1 === "constructor") {
                this.raise(Errors.ConstructorClassPrivateField, {
                  at: this.state.startLoc
                });
              }
              var key = this.parsePrivateName();
              member.key = key;
              return key;
            }
            return this.parsePropertyName(member);
          }
        },
        {
          key: "parseClassStaticBlock",
          value: function parseClassStaticBlock(classBody2, member) {
            var _member_decorators;
            this.scope.enter(64 | 128 | 16);
            var oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(0);
            var body = member.body = [];
            this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
            this.prodParam.exit();
            this.scope.exit();
            this.state.labels = oldLabels;
            classBody2.body.push(this.finishNode(member, "StaticBlock"));
            if ((_member_decorators = member.decorators) === null || _member_decorators === void 0 ? void 0 : _member_decorators.length) {
              this.raise(Errors.DecoratorStaticBlock, {
                at: member
              });
            }
          }
        },
        {
          key: "pushClassProperty",
          value: function pushClassProperty(classBody2, prop) {
            if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
              this.raise(Errors.ConstructorClassField, {
                at: prop.key
              });
            }
            classBody2.body.push(this.parseClassProperty(prop));
          }
        },
        {
          key: "pushClassPrivateProperty",
          value: function pushClassPrivateProperty(classBody2, prop) {
            var node2 = this.parseClassPrivateProperty(prop);
            classBody2.body.push(node2);
            this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
          }
        },
        {
          key: "pushClassAccessorProperty",
          value: function pushClassAccessorProperty(classBody2, prop, isPrivate2) {
            if (!isPrivate2 && !prop.computed) {
              var key = prop.key;
              if (key.name === "constructor" || key.value === "constructor") {
                this.raise(Errors.ConstructorClassField, {
                  at: key
                });
              }
            }
            var node2 = this.parseClassAccessorProperty(prop);
            classBody2.body.push(node2);
            if (isPrivate2) {
              this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
            }
          }
        },
        {
          key: "pushClassMethod",
          value: function pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            classBody2.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
          }
        },
        {
          key: "pushClassPrivateMethod",
          value: function pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
            var node2 = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
            classBody2.body.push(node2);
            var kind = node2.kind === "get" ? node2.static ? 6 : 2 : node2.kind === "set" ? node2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(node2, kind);
          }
        },
        {
          key: "declareClassPrivateMethodInScope",
          value: function declareClassPrivateMethodInScope(node2, kind) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start);
          }
        },
        {
          key: "parsePostMemberNameModifiers",
          value: function parsePostMemberNameModifiers(methodOrProp) {
          }
        },
        {
          key: "parseClassPrivateProperty",
          value: function parseClassPrivateProperty(node2) {
            this.parseInitializer(node2);
            this.semicolon();
            return this.finishNode(node2, "ClassPrivateProperty");
          }
        },
        {
          key: "parseClassProperty",
          value: function parseClassProperty(node2) {
            this.parseInitializer(node2);
            this.semicolon();
            return this.finishNode(node2, "ClassProperty");
          }
        },
        {
          key: "parseClassAccessorProperty",
          value: function parseClassAccessorProperty(node2) {
            this.parseInitializer(node2);
            this.semicolon();
            return this.finishNode(node2, "ClassAccessorProperty");
          }
        },
        {
          key: "parseInitializer",
          value: function parseInitializer(node2) {
            this.scope.enter(64 | 16);
            this.expressionScope.enter(newExpressionScope());
            this.prodParam.enter(0);
            node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
            this.expressionScope.exit();
            this.prodParam.exit();
            this.scope.exit();
          }
        },
        {
          key: "parseClassId",
          value: function parseClassId(node2, isStatement5, optionalId) {
            var bindingType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 8331;
            if (tokenIsIdentifier(this.state.type)) {
              node2.id = this.parseIdentifier();
              if (isStatement5) {
                this.declareNameFromIdentifier(node2.id, bindingType);
              }
            } else {
              if (optionalId || !isStatement5) {
                node2.id = null;
              } else {
                throw this.raise(Errors.MissingClassName, {
                  at: this.state.startLoc
                });
              }
            }
          }
        },
        {
          key: "parseClassSuper",
          value: function parseClassSuper(node2) {
            node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
        },
        {
          key: "parseExport",
          value: function parseExport(node2, decorators) {
            var maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, true);
            var hasDefault = this.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
            var parseAfterDefault = !hasDefault || this.eat(12);
            var hasStar = parseAfterDefault && this.eatExportStar(node2);
            var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
            var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
            var isFromRequired = hasDefault || hasStar;
            if (hasStar && !hasNamespace) {
              if (hasDefault)
                this.unexpected();
              if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, {
                  at: node2
                });
              }
              this.parseExportFrom(node2, true);
              return this.finishNode(node2, "ExportAllDeclaration");
            }
            var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
            if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
              this.unexpected(null, 5);
            }
            if (hasNamespace && parseAfterNamespace) {
              this.unexpected(null, 98);
            }
            var hasDeclaration;
            if (isFromRequired || hasSpecifiers) {
              hasDeclaration = false;
              if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, {
                  at: node2
                });
              }
              this.parseExportFrom(node2, isFromRequired);
            } else {
              hasDeclaration = this.maybeParseExportDeclaration(node2);
            }
            if (isFromRequired || hasSpecifiers || hasDeclaration) {
              var _node2_declaration;
              var node22 = node2;
              this.checkExport(node22, true, false, !!node22.source);
              if (((_node2_declaration = node22.declaration) === null || _node2_declaration === void 0 ? void 0 : _node2_declaration.type) === "ClassDeclaration") {
                this.maybeTakeDecorators(decorators, node22.declaration, node22);
              } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, {
                  at: node2
                });
              }
              return this.finishNode(node22, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              var node21 = node2;
              var decl = this.parseExportDefaultExpression();
              node21.declaration = decl;
              if (decl.type === "ClassDeclaration") {
                this.maybeTakeDecorators(decorators, decl, node21);
              } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, {
                  at: node2
                });
              }
              this.checkExport(node21, true, true);
              return this.finishNode(node21, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
        },
        {
          key: "eatExportStar",
          value: function eatExportStar(node2) {
            return this.eat(55);
          }
        },
        {
          key: "maybeParseExportDefaultSpecifier",
          value: function maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
            if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier === null || maybeDefaultIdentifier === void 0 ? void 0 : maybeDefaultIdentifier.loc.start);
              var id = maybeDefaultIdentifier || this.parseIdentifier(true);
              var specifier = this.startNodeAtNode(id);
              specifier.exported = id;
              node2.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
              ];
              return true;
            }
            return false;
          }
        },
        {
          key: "maybeParseExportNamespaceSpecifier",
          value: function maybeParseExportNamespaceSpecifier(node2) {
            if (this.isContextual(93)) {
              if (!node2.specifiers)
                node2.specifiers = [];
              var specifier = this.startNodeAt(this.state.lastTokStartLoc);
              this.next();
              specifier.exported = this.parseModuleExportName();
              node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
              return true;
            }
            return false;
          }
        },
        {
          key: "maybeParseExportNamedSpecifiers",
          value: function maybeParseExportNamedSpecifiers(node2) {
            if (this.match(5)) {
              var _node_specifiers;
              if (!node2.specifiers)
                node2.specifiers = [];
              var isTypeExport = node2.exportKind === "type";
              (_node_specifiers = node2.specifiers).push.apply(_node_specifiers, _to_consumable_array(this.parseExportSpecifiers(isTypeExport)));
              node2.source = null;
              node2.declaration = null;
              if (this.hasPlugin("importAssertions")) {
                node2.assertions = [];
              }
              return true;
            }
            return false;
          }
        },
        {
          key: "maybeParseExportDeclaration",
          value: function maybeParseExportDeclaration(node2) {
            if (this.shouldParseExportDeclaration()) {
              node2.specifiers = [];
              node2.source = null;
              if (this.hasPlugin("importAssertions")) {
                node2.assertions = [];
              }
              node2.declaration = this.parseExportDeclaration(node2);
              return true;
            }
            return false;
          }
        },
        {
          key: "isAsyncFunction",
          value: function isAsyncFunction() {
            if (!this.isContextual(95))
              return false;
            var next = this.nextTokenInLineStart();
            return this.isUnparsedContextual(next, "function");
          }
        },
        {
          key: "parseExportDefaultExpression",
          value: function parseExportDefaultExpression() {
            var expr = this.startNode();
            if (this.match(68)) {
              this.next();
              return this.parseFunction(expr, 1 | 4);
            } else if (this.isAsyncFunction()) {
              this.next();
              this.next();
              return this.parseFunction(expr, 1 | 4 | 8);
            }
            if (this.match(80)) {
              return this.parseClass(expr, true, true);
            }
            if (this.match(26)) {
              if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            }
            if (this.match(75) || this.match(74) || this.isLet()) {
              throw this.raise(Errors.UnsupportedDefaultExport, {
                at: this.state.startLoc
              });
            }
            var res = this.parseMaybeAssignAllowIn();
            this.semicolon();
            return res;
          }
        },
        {
          key: "parseExportDeclaration",
          value: function parseExportDeclaration(node2) {
            if (this.match(80)) {
              var node22 = this.parseClass(this.startNode(), true, false);
              return node22;
            }
            return this.parseStatementListItem();
          }
        },
        {
          key: "isExportDefaultSpecifier",
          value: function isExportDefaultSpecifier3() {
            var type3 = this.state.type;
            if (tokenIsIdentifier(type3)) {
              if (type3 === 95 && !this.state.containsEsc || type3 === 100) {
                return false;
              }
              if ((type3 === 130 || type3 === 129) && !this.state.containsEsc) {
                var _this_lookahead = this.lookahead(), nextType = _this_lookahead.type;
                if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
                  this.expectOnePlugin([
                    "flow",
                    "typescript"
                  ]);
                  return false;
                }
              }
            } else if (!this.match(65)) {
              return false;
            }
            var next = this.nextTokenStart();
            var hasFrom = this.isUnparsedContextual(next, "from");
            if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
              return true;
            }
            if (this.match(65) && hasFrom) {
              var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
              return nextAfterFrom === 34 || nextAfterFrom === 39;
            }
            return false;
          }
        },
        {
          key: "parseExportFrom",
          value: function parseExportFrom(node2, expect) {
            if (this.eatContextual(98)) {
              node2.source = this.parseImportSource();
              this.checkExport(node2);
              this.maybeParseImportAttributes(node2);
              this.checkJSONModuleImport(node2);
            } else if (expect) {
              this.unexpected();
            }
            this.semicolon();
          }
        },
        {
          key: "shouldParseExportDeclaration",
          value: function shouldParseExportDeclaration() {
            var type3 = this.state.type;
            if (type3 === 26) {
              this.expectOnePlugin([
                "decorators",
                "decorators-legacy"
              ]);
              if (this.hasPlugin("decorators")) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                  this.raise(Errors.DecoratorBeforeExport, {
                    at: this.state.startLoc
                  });
                }
                return true;
              }
            }
            return type3 === 74 || type3 === 75 || type3 === 68 || type3 === 80 || this.isLet() || this.isAsyncFunction();
          }
        },
        {
          key: "checkExport",
          value: function checkExport(node2, checkNames, isDefault, isFrom) {
            if (checkNames) {
              var _node_specifiers;
              if (isDefault) {
                this.checkDuplicateExports(node2, "default");
                if (this.hasPlugin("exportDefaultFrom")) {
                  var _declaration_extra;
                  var declaration = node2.declaration;
                  if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration_extra = declaration.extra) === null || _declaration_extra === void 0 ? void 0 : _declaration_extra.parenthesized)) {
                    this.raise(Errors.ExportDefaultFromAsIdentifier, {
                      at: declaration
                    });
                  }
                }
              } else if ((_node_specifiers = node2.specifiers) === null || _node_specifiers === void 0 ? void 0 : _node_specifiers.length) {
                var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
                try {
                  for (var _iterator8 = node2.specifiers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var specifier = _step8.value;
                    var exported = specifier.exported;
                    var exportName = exported.type === "Identifier" ? exported.name : exported.value;
                    this.checkDuplicateExports(specifier, exportName);
                    if (!isFrom && specifier.local) {
                      var local = specifier.local;
                      if (local.type !== "Identifier") {
                        this.raise(Errors.ExportBindingIsString, {
                          at: specifier,
                          localName: local.value,
                          exportName
                        });
                      } else {
                        this.checkReservedWord(local.name, local.loc.start, true, false);
                        this.scope.checkLocalExport(local);
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }
              } else if (node2.declaration) {
                if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
                  var id = node2.declaration.id;
                  if (!id)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(node2, id.name);
                } else if (node2.declaration.type === "VariableDeclaration") {
                  var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                  try {
                    for (var _iterator12 = node2.declaration.declarations[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                      var declaration1 = _step12.value;
                      this.checkDeclaration(declaration1.id);
                    }
                  } catch (err) {
                    _didIteratorError12 = true;
                    _iteratorError12 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                        _iterator12.return();
                      }
                    } finally {
                      if (_didIteratorError12) {
                        throw _iteratorError12;
                      }
                    }
                  }
                }
              }
            }
          }
        },
        {
          key: "checkDeclaration",
          value: function checkDeclaration(node2) {
            if (node2.type === "Identifier") {
              this.checkDuplicateExports(node2, node2.name);
            } else if (node2.type === "ObjectPattern") {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = node2.properties[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var prop = _step8.value;
                  this.checkDeclaration(prop);
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            } else if (node2.type === "ArrayPattern") {
              var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
              try {
                for (var _iterator12 = node2.elements[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                  var elem = _step12.value;
                  if (elem) {
                    this.checkDeclaration(elem);
                  }
                }
              } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                    _iterator12.return();
                  }
                } finally {
                  if (_didIteratorError12) {
                    throw _iteratorError12;
                  }
                }
              }
            } else if (node2.type === "ObjectProperty") {
              this.checkDeclaration(node2.value);
            } else if (node2.type === "RestElement") {
              this.checkDeclaration(node2.argument);
            } else if (node2.type === "AssignmentPattern") {
              this.checkDeclaration(node2.left);
            }
          }
        },
        {
          key: "checkDuplicateExports",
          value: function checkDuplicateExports(node2, exportName) {
            if (this.exportedIdentifiers.has(exportName)) {
              if (exportName === "default") {
                this.raise(Errors.DuplicateDefaultExport, {
                  at: node2
                });
              } else {
                this.raise(Errors.DuplicateExport, {
                  at: node2,
                  exportName
                });
              }
            }
            this.exportedIdentifiers.add(exportName);
          }
        },
        {
          key: "parseExportSpecifiers",
          value: function parseExportSpecifiers(isInTypeExport) {
            var nodes2 = [];
            var first = true;
            this.expect(5);
            while (!this.eat(8)) {
              if (first) {
                first = false;
              } else {
                this.expect(12);
                if (this.eat(8))
                  break;
              }
              var isMaybeTypeOnly = this.isContextual(130);
              var isString = this.match(133);
              var node2 = this.startNode();
              node2.local = this.parseModuleExportName();
              nodes2.push(this.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly));
            }
            return nodes2;
          }
        },
        {
          key: "parseExportSpecifier",
          value: function parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
            if (this.eatContextual(93)) {
              node2.exported = this.parseModuleExportName();
            } else if (isString) {
              node2.exported = cloneStringLiteral(node2.local);
            } else if (!node2.exported) {
              node2.exported = cloneIdentifier(node2.local);
            }
            return this.finishNode(node2, "ExportSpecifier");
          }
        },
        {
          key: "parseModuleExportName",
          value: function parseModuleExportName() {
            if (this.match(133)) {
              var result = this.parseStringLiteral(this.state.value);
              var surrogate = result.value.match(loneSurrogate2);
              if (surrogate) {
                this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                  at: result,
                  surrogateCharCode: surrogate[0].charCodeAt(0)
                });
              }
              return result;
            }
            return this.parseIdentifier(true);
          }
        },
        {
          key: "isJSONModuleImport",
          value: function isJSONModuleImport(node2) {
            if (node2.assertions != null) {
              return node2.assertions.some(function(param) {
                var key = param.key, value1 = param.value;
                return value1.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
              });
            }
            return false;
          }
        },
        {
          key: "checkImportReflection",
          value: function checkImportReflection(node2) {
            var specifiers = node2.specifiers;
            var singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
            if (node2.phase === "source") {
              if (singleBindingType !== "ImportDefaultSpecifier") {
                this.raise(Errors.SourcePhaseImportRequiresDefault, {
                  at: specifiers[0].loc.start
                });
              }
            } else if (node2.phase === "defer") {
              if (singleBindingType !== "ImportNamespaceSpecifier") {
                this.raise(Errors.DeferImportRequiresNamespace, {
                  at: specifiers[0].loc.start
                });
              }
            } else if (node2.module) {
              var _node_assertions;
              if (singleBindingType !== "ImportDefaultSpecifier") {
                this.raise(Errors.ImportReflectionNotBinding, {
                  at: specifiers[0].loc.start
                });
              }
              if (((_node_assertions = node2.assertions) === null || _node_assertions === void 0 ? void 0 : _node_assertions.length) > 0) {
                this.raise(Errors.ImportReflectionHasAssertion, {
                  at: node2.specifiers[0].loc.start
                });
              }
            }
          }
        },
        {
          key: "checkJSONModuleImport",
          value: function checkJSONModuleImport(node2) {
            if (this.isJSONModuleImport(node2) && node2.type !== "ExportAllDeclaration") {
              var specifiers = node2.specifiers;
              if (specifiers != null) {
                var nonDefaultNamedSpecifier = specifiers.find(function(specifier) {
                  var imported;
                  if (specifier.type === "ExportSpecifier") {
                    imported = specifier.local;
                  } else if (specifier.type === "ImportSpecifier") {
                    imported = specifier.imported;
                  }
                  if (imported !== void 0) {
                    return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                  }
                });
                if (nonDefaultNamedSpecifier !== void 0) {
                  this.raise(Errors.ImportJSONBindingNotDefault, {
                    at: nonDefaultNamedSpecifier.loc.start
                  });
                }
              }
            }
          }
        },
        {
          key: "isPotentialImportPhase",
          value: function isPotentialImportPhase(isExport) {
            if (isExport)
              return false;
            return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
          }
        },
        {
          key: "applyImportPhase",
          value: function applyImportPhase(node2, isExport, phase, loc) {
            if (isExport) {
              return;
            }
            if (phase === "module") {
              this.expectPlugin("importReflection", loc);
              node2.module = true;
            } else if (this.hasPlugin("importReflection")) {
              node2.module = false;
            }
            if (phase === "source") {
              this.expectPlugin("sourcePhaseImports", loc);
              node2.phase = "source";
            } else if (phase === "defer") {
              this.expectPlugin("deferredImportEvaluation", loc);
              node2.phase = "defer";
            } else if (this.hasPlugin("sourcePhaseImports")) {
              node2.phase = null;
            }
          }
        },
        {
          key: "parseMaybeImportPhase",
          value: function parseMaybeImportPhase(node2, isExport) {
            if (!this.isPotentialImportPhase(isExport)) {
              this.applyImportPhase(node2, isExport, null);
              return null;
            }
            var phaseIdentifier = this.parseIdentifier(true);
            var type3 = this.state.type;
            var isImportPhase = tokenIsKeywordOrIdentifier(type3) ? type3 !== 98 || this.lookaheadCharCode() === 102 : type3 !== 12;
            if (isImportPhase) {
              this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
              this.applyImportPhase(node2, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
              return null;
            } else {
              this.applyImportPhase(node2, isExport, null);
              return phaseIdentifier;
            }
          }
        },
        {
          key: "isPrecedingIdImportPhase",
          value: function isPrecedingIdImportPhase(phase) {
            var type3 = this.state.type;
            return tokenIsIdentifier(type3) ? type3 !== 98 || this.lookaheadCharCode() === 102 : type3 !== 12;
          }
        },
        {
          key: "parseImport",
          value: function parseImport(node2) {
            if (this.match(133)) {
              return this.parseImportSourceAndAttributes(node2);
            }
            return this.parseImportSpecifiersAndAfter(node2, this.parseMaybeImportPhase(node2, false));
          }
        },
        {
          key: "parseImportSpecifiersAndAfter",
          value: function parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier) {
            node2.specifiers = [];
            var hasDefault = this.maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier);
            var parseNext = !hasDefault || this.eat(12);
            var hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
            if (parseNext && !hasStar)
              this.parseNamedImportSpecifiers(node2);
            this.expectContextual(98);
            return this.parseImportSourceAndAttributes(node2);
          }
        },
        {
          key: "parseImportSourceAndAttributes",
          value: function parseImportSourceAndAttributes(node2) {
            var _node_specifiers;
            (_node_specifiers = node2.specifiers) !== null && _node_specifiers !== void 0 ? _node_specifiers : node2.specifiers = [];
            node2.source = this.parseImportSource();
            this.maybeParseImportAttributes(node2);
            this.checkImportReflection(node2);
            this.checkJSONModuleImport(node2);
            this.semicolon();
            return this.finishNode(node2, "ImportDeclaration");
          }
        },
        {
          key: "parseImportSource",
          value: function parseImportSource() {
            if (!this.match(133))
              this.unexpected();
            return this.parseExprAtom();
          }
        },
        {
          key: "parseImportSpecifierLocal",
          value: function parseImportSpecifierLocal(node2, specifier, type3) {
            specifier.local = this.parseIdentifier();
            node2.specifiers.push(this.finishImportSpecifier(specifier, type3));
          }
        },
        {
          key: "finishImportSpecifier",
          value: function finishImportSpecifier(specifier, type3) {
            var bindingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 8201;
            this.checkLVal(specifier.local, {
              in: {
                type: type3
              },
              binding: bindingType
            });
            return this.finishNode(specifier, type3);
          }
        },
        {
          key: "parseImportAttributes",
          value: function parseImportAttributes() {
            this.expect(5);
            var attrs = [];
            var attrNames = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) {
                break;
              }
              var node2 = this.startNode();
              var keyName = this.state.value;
              if (attrNames.has(keyName)) {
                this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                  at: this.state.startLoc,
                  key: keyName
                });
              }
              attrNames.add(keyName);
              if (this.match(133)) {
                node2.key = this.parseStringLiteral(keyName);
              } else {
                node2.key = this.parseIdentifier(true);
              }
              this.expect(14);
              if (!this.match(133)) {
                throw this.raise(Errors.ModuleAttributeInvalidValue, {
                  at: this.state.startLoc
                });
              }
              node2.value = this.parseStringLiteral(this.state.value);
              attrs.push(this.finishNode(node2, "ImportAttribute"));
            } while (this.eat(12));
            this.expect(8);
            return attrs;
          }
        },
        {
          key: "parseModuleAttributes",
          value: function parseModuleAttributes() {
            var attrs = [];
            var attributes = /* @__PURE__ */ new Set();
            do {
              var node2 = this.startNode();
              node2.key = this.parseIdentifier(true);
              if (node2.key.name !== "type") {
                this.raise(Errors.ModuleAttributeDifferentFromType, {
                  at: node2.key
                });
              }
              if (attributes.has(node2.key.name)) {
                this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                  at: node2.key,
                  key: node2.key.name
                });
              }
              attributes.add(node2.key.name);
              this.expect(14);
              if (!this.match(133)) {
                throw this.raise(Errors.ModuleAttributeInvalidValue, {
                  at: this.state.startLoc
                });
              }
              node2.value = this.parseStringLiteral(this.state.value);
              attrs.push(this.finishNode(node2, "ImportAttribute"));
            } while (this.eat(12));
            return attrs;
          }
        },
        {
          key: "maybeParseImportAttributes",
          value: function maybeParseImportAttributes(node2) {
            var attributes;
            var useWith = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                return;
              }
              this.next();
              {
                this.expectImportAttributesPlugin();
                attributes = this.parseImportAttributes();
              }
              useWith = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
              if (this.hasPlugin("importAttributes")) {
                if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
                  this.raise(Errors.ImportAttributesUseAssert, {
                    at: this.state.startLoc
                  });
                }
                this.addExtra(node2, "deprecatedAssertSyntax", true);
              } else {
                this.expectOnePlugin([
                  "importAttributes",
                  "importAssertions"
                ]);
              }
              this.next();
              attributes = this.parseImportAttributes();
            } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
              attributes = [];
            } else
              return;
            if (!useWith && this.hasPlugin("importAssertions")) {
              node2.assertions = attributes;
            } else {
              node2.attributes = attributes;
            }
          }
        },
        {
          key: "maybeParseDefaultImportSpecifier",
          value: function maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier) {
            if (maybeDefaultIdentifier) {
              var specifier = this.startNodeAtNode(maybeDefaultIdentifier);
              specifier.local = maybeDefaultIdentifier;
              node2.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
              return true;
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier");
              return true;
            }
            return false;
          }
        },
        {
          key: "maybeParseStarImportSpecifier",
          value: function maybeParseStarImportSpecifier(node2) {
            if (this.match(55)) {
              var specifier = this.startNode();
              this.next();
              this.expectContextual(93);
              this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier");
              return true;
            }
            return false;
          }
        },
        {
          key: "parseNamedImportSpecifiers",
          value: function parseNamedImportSpecifiers(node2) {
            var first = true;
            this.expect(5);
            while (!this.eat(8)) {
              if (first) {
                first = false;
              } else {
                if (this.eat(14)) {
                  throw this.raise(Errors.DestructureNamedImport, {
                    at: this.state.startLoc
                  });
                }
                this.expect(12);
                if (this.eat(8))
                  break;
              }
              var specifier = this.startNode();
              var importedIsString = this.match(133);
              var isMaybeTypeOnly = this.isContextual(130);
              specifier.imported = this.parseModuleExportName();
              var importSpecifier2 = this.parseImportSpecifier(specifier, importedIsString, node2.importKind === "type" || node2.importKind === "typeof", isMaybeTypeOnly, void 0);
              node2.specifiers.push(importSpecifier2);
            }
          }
        },
        {
          key: "parseImportSpecifier",
          value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              var imported = specifier.imported;
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: imported.value
                });
              }
              this.checkReservedWord(imported.name, specifier.loc.start, true, true);
              if (!specifier.local) {
                specifier.local = cloneIdentifier(imported);
              }
            }
            return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
          }
        },
        {
          key: "isThisParam",
          value: function isThisParam(param) {
            return param.type === "Identifier" && param.name === "this";
          }
        }
      ]);
      return StatementParser2;
    }(ExpressionParser);
    var Parser3 = /* @__PURE__ */ function(StatementParser2) {
      "use strict";
      _inherits(Parser4, StatementParser2);
      var _super3 = _create_super(Parser4);
      function Parser4(options, input) {
        _class_call_check(this, Parser4);
        var _this;
        options = getOptions2(options);
        _this = _super3.call(this, options, input);
        _this.options = options;
        _this.initializeScopes();
        _this.plugins = pluginsMap(_this.options.plugins);
        _this.filename = options.sourceFilename;
        return _this;
      }
      _create_class(Parser4, [
        {
          key: "getScopeHandler",
          value: function getScopeHandler() {
            return ScopeHandler;
          }
        },
        {
          key: "parse",
          value: function parse5() {
            this.enterInitialScopes();
            var file2 = this.startNode();
            var program3 = this.startNode();
            this.nextToken();
            file2.errors = null;
            this.parseTopLevel(file2, program3);
            file2.errors = this.state.errors;
            return file2;
          }
        }
      ]);
      return Parser4;
    }(StatementParser);
    function pluginsMap(plugins) {
      var pluginMap = /* @__PURE__ */ new Map();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = plugins[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var plugin2 = _step8.value;
          var _ref = _sliced_to_array(Array.isArray(plugin2) ? plugin2 : [
            plugin2,
            {}
          ], 2), name2 = _ref[0], options = _ref[1];
          if (!pluginMap.has(name2))
            pluginMap.set(name2, options || {});
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return pluginMap;
    }
    function parse4(input, options) {
      if ((options === null || options === void 0 ? void 0 : options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          var parser = getParser(options, input);
          var ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (e) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (e) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      var parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      var tokenTypes2 = {};
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(internalTokenTypes)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var typeName = _step8.value;
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      var cls = Parser3;
      if (options === null || options === void 0 ? void 0 : options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      var pluginList = mixinPluginNames.filter(function(name2) {
        return hasPlugin(pluginsFromOptions, name2);
      });
      var key = pluginList.join("/");
      var cls = parserClassCache[key];
      if (!cls) {
        cls = Parser3;
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = pluginList[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var plugin2 = _step8.value;
            cls = mixinPlugins[plugin2](cls);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    var import_js_tokens = __toESM2(require_js_tokens2(), 1);
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi16 = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(code22) {
        return "\x1B[".concat(code22 + offset2, "m");
      };
    };
    var wrapAnsi256 = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(code22) {
        return "\x1B[".concat(38 + offset2, ";5;").concat(code22, "m");
      };
    };
    var wrapAnsi16m = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(red, green, blue) {
        return "\x1B[".concat(38 + offset2, ";2;").concat(red, ";").concat(green, ";").concat(blue, "m");
      };
    };
    var styles = {
      modifier: {
        reset: [
          0,
          0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
          1,
          22
        ],
        dim: [
          2,
          22
        ],
        italic: [
          3,
          23
        ],
        underline: [
          4,
          24
        ],
        overline: [
          53,
          55
        ],
        inverse: [
          7,
          27
        ],
        hidden: [
          8,
          28
        ],
        strikethrough: [
          9,
          29
        ]
      },
      color: {
        black: [
          30,
          39
        ],
        red: [
          31,
          39
        ],
        green: [
          32,
          39
        ],
        yellow: [
          33,
          39
        ],
        blue: [
          34,
          39
        ],
        magenta: [
          35,
          39
        ],
        cyan: [
          36,
          39
        ],
        white: [
          37,
          39
        ],
        // Bright color
        blackBright: [
          90,
          39
        ],
        gray: [
          90,
          39
        ],
        // Alias of `blackBright`
        grey: [
          90,
          39
        ],
        // Alias of `blackBright`
        redBright: [
          91,
          39
        ],
        greenBright: [
          92,
          39
        ],
        yellowBright: [
          93,
          39
        ],
        blueBright: [
          94,
          39
        ],
        magentaBright: [
          95,
          39
        ],
        cyanBright: [
          96,
          39
        ],
        whiteBright: [
          97,
          39
        ]
      },
      bgColor: {
        bgBlack: [
          40,
          49
        ],
        bgRed: [
          41,
          49
        ],
        bgGreen: [
          42,
          49
        ],
        bgYellow: [
          43,
          49
        ],
        bgBlue: [
          44,
          49
        ],
        bgMagenta: [
          45,
          49
        ],
        bgCyan: [
          46,
          49
        ],
        bgWhite: [
          47,
          49
        ],
        // Bright color
        bgBlackBright: [
          100,
          49
        ],
        bgGray: [
          100,
          49
        ],
        // Alias of `bgBlackBright`
        bgGrey: [
          100,
          49
        ],
        // Alias of `bgBlackBright`
        bgRedBright: [
          101,
          49
        ],
        bgGreenBright: [
          102,
          49
        ],
        bgYellowBright: [
          103,
          49
        ],
        bgBlueBright: [
          104,
          49
        ],
        bgMagentaBright: [
          105,
          49
        ],
        bgCyanBright: [
          106,
          49
        ],
        bgWhiteBright: [
          107,
          49
        ]
      }
    };
    var modifierNames = Object.keys(styles.modifier);
    var foregroundColorNames = Object.keys(styles.color);
    var backgroundColorNames = Object.keys(styles.bgColor);
    var colorNames = _to_consumable_array(foregroundColorNames).concat(_to_consumable_array(backgroundColorNames));
    function assembleStyles() {
      var _styles;
      var codes = /* @__PURE__ */ new Map();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.entries(styles)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step_value = _sliced_to_array(_step8.value, 2), groupName = _step_value[0], group = _step_value[1];
          var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = Object.entries(group)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var _step_value1 = _sliced_to_array(_step12.value, 2), styleName = _step_value1[0], style = _step_value1[1];
              styles[styleName] = {
                open: "\x1B[".concat(style[0], "m"),
                close: "\x1B[".concat(style[1], "m")
              };
              group[styleName] = styles[styleName];
              codes.set(style[0], style[1]);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = wrapAnsi16();
      styles.color.ansi256 = wrapAnsi256();
      styles.color.ansi16m = wrapAnsi16m();
      styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
      styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles, {
        rgbToAnsi256: {
          value: function value1(red, green, blue) {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: function value1(hex) {
            var matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
            if (!matches) {
              return [
                0,
                0,
                0
              ];
            }
            var _matches = _sliced_to_array(matches, 1), colorString = _matches[0];
            if (colorString.length === 3) {
              colorString = _to_consumable_array(colorString).map(function(character) {
                return character + character;
              }).join("");
            }
            var integer = Number.parseInt(colorString, 16);
            return [
              /* eslint-disable no-bitwise */
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: function(hex) {
            return (_styles = styles).rgbToAnsi256.apply(_styles, _to_consumable_array(styles.hexToRgb(hex)));
          },
          enumerable: false
        },
        ansi256ToAnsi: {
          value: function value1(code22) {
            if (code22 < 8) {
              return 30 + code22;
            }
            if (code22 < 16) {
              return 90 + (code22 - 8);
            }
            var red;
            var green;
            var blue;
            if (code22 >= 232) {
              red = ((code22 - 232) * 10 + 8) / 255;
              green = red;
              blue = red;
            } else {
              code22 -= 16;
              var remainder = code22 % 36;
              red = Math.floor(code22 / 36) / 5;
              green = Math.floor(remainder / 6) / 5;
              blue = remainder % 6 / 5;
            }
            var value12 = Math.max(red, green, blue) * 2;
            if (value12 === 0) {
              return 30;
            }
            var result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
            if (value12 === 2) {
              result += 60;
            }
            return result;
          },
          enumerable: false
        },
        rgbToAnsi: {
          value: function(red, green, blue) {
            return styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue));
          },
          enumerable: false
        },
        hexToAnsi: {
          value: function(hex) {
            return styles.ansi256ToAnsi(styles.hexToAnsi256(hex));
          },
          enumerable: false
        }
      });
      return styles;
    }
    var ansiStyles = assembleStyles();
    var ansi_styles_default = ansiStyles;
    var import_node_process2 = __toESM2(require("process"), 1);
    var import_node_os = __toESM2(require("os"), 1);
    var import_node_tty = __toESM2(require("tty"), 1);
    function hasFlag(flag) {
      var argv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis.Deno ? globalThis.Deno.args : import_node_process2.default.argv;
      var prefix2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      var position3 = argv.indexOf(prefix2 + flag);
      var terminatorPosition = argv.indexOf("--");
      return position3 !== -1 && (terminatorPosition === -1 || position3 < terminatorPosition);
    }
    var env2 = import_node_process2.default.env;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env2) {
        if (env2.FORCE_COLOR === "true") {
          return 1;
        }
        if (env2.FORCE_COLOR === "false") {
          return 0;
        }
        return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function _supportsColor(haveStream) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, streamIsTTY = _ref.streamIsTTY, _ref_sniffFlags = _ref.sniffFlags, sniffFlags = _ref_sniffFlags === void 0 ? true : _ref_sniffFlags;
      var noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      var forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if ("TF_BUILD" in env2 && "AGENT_NAME" in env2) {
        return 1;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      var min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (import_node_process2.default.platform === "win32") {
        var osRelease = import_node_os.default.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if ("GITHUB_ACTIONS" in env2 || "GITEA_ACTIONS" in env2) {
          return 3;
        }
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "BUILDKITE",
          "DRONE"
        ].some(function(sign) {
          return sign in env2;
        }) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if (env2.TERM === "xterm-kitty") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        var version2 = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app": {
            return version2 >= 3 ? 3 : 2;
          }
          case "Apple_Terminal": {
            return 2;
          }
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function createSupportsColor(stream) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var level = _supportsColor(stream, _object_spread({
        streamIsTTY: stream && stream.isTTY
      }, options));
      return translateLevel(level);
    }
    var supportsColor = {
      stdout: createSupportsColor({
        isTTY: import_node_tty.default.isatty(1)
      }),
      stderr: createSupportsColor({
        isTTY: import_node_tty.default.isatty(2)
      })
    };
    var supports_color_default = supportsColor;
    function stringReplaceAll(string3, substring, replacer) {
      var index3 = string3.indexOf(substring);
      if (index3 === -1) {
        return string3;
      }
      var substringLength = substring.length;
      var endIndex = 0;
      var returnValue = "";
      do {
        returnValue += string3.slice(endIndex, index3) + substring + replacer;
        endIndex = index3 + substringLength;
        index3 = string3.indexOf(substring, endIndex);
      } while (index3 !== -1);
      returnValue += string3.slice(endIndex);
      return returnValue;
    }
    function stringEncaseCRLFWithFirstIndex(string3, prefix2, postfix2, index3) {
      var endIndex = 0;
      var returnValue = "";
      do {
        var gotCR = string3[index3 - 1] === "\r";
        returnValue += string3.slice(endIndex, gotCR ? index3 - 1 : index3) + prefix2 + (gotCR ? "\r\n" : "\n") + postfix2;
        endIndex = index3 + 1;
        index3 = string3.indexOf("\n", endIndex);
      } while (index3 !== -1);
      returnValue += string3.slice(endIndex);
      return returnValue;
    }
    var stdoutColor = supports_color_default.stdout;
    var stderrColor = supports_color_default.stderr;
    var GENERATOR2 = Symbol("GENERATOR");
    var STYLER = Symbol("STYLER");
    var IS_EMPTY = Symbol("IS_EMPTY");
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles2 = /* @__PURE__ */ Object.create(null);
    var applyOptions = function(object) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      var colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var Chalk = function Chalk3(options) {
      "use strict";
      _class_call_check(this, Chalk3);
      return chalkFactory(options);
    };
    var chalkFactory = function(options) {
      var chalk3 = function() {
        for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
          strings[_key] = arguments[_key];
        }
        return strings.join(" ");
      };
      applyOptions(chalk3, options);
      Object.setPrototypeOf(chalk3, createChalk.prototype);
      return chalk3;
    };
    function createChalk(options) {
      return chalkFactory(options);
    }
    Object.setPrototypeOf(createChalk.prototype, Function.prototype);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = void 0;
    try {
      _loop = function() {
        var _step_value = _sliced_to_array(_step2.value, 2), styleName = _step_value[0], style = _step_value[1];
        styles2[styleName] = {
          get: function get3() {
            var builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
              value: builder
            });
            return builder;
          }
        };
      };
      for (_iterator2 = Object.entries(ansi_styles_default)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
        _loop();
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
    var _loop;
    var _iterator2;
    var _step2;
    styles2.visible = {
      get: function get3() {
        var builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, "visible", {
          value: builder
        });
        return builder;
      }
    };
    var getModelAnsi = function(model, level, type3) {
      for (var _len = arguments.length, arguments_ = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        arguments_[_key - 3] = arguments[_key];
      }
      var _ansi_styles_default_type;
      if (model === "rgb") {
        var _ansi_styles_default;
        if (level === "ansi16m") {
          var _ansi_styles_default_type1;
          return (_ansi_styles_default_type1 = ansi_styles_default[type3]).ansi16m.apply(_ansi_styles_default_type1, _to_consumable_array(arguments_));
        }
        if (level === "ansi256") {
          var _ansi_styles_default1;
          return ansi_styles_default[type3].ansi256((_ansi_styles_default1 = ansi_styles_default).rgbToAnsi256.apply(_ansi_styles_default1, _to_consumable_array(arguments_)));
        }
        return ansi_styles_default[type3].ansi((_ansi_styles_default = ansi_styles_default).rgbToAnsi.apply(_ansi_styles_default, _to_consumable_array(arguments_)));
      }
      if (model === "hex") {
        var _ansi_styles_default2;
        return getModelAnsi.apply(void 0, [
          "rgb",
          level,
          type3
        ].concat(_to_consumable_array((_ansi_styles_default2 = ansi_styles_default).hexToRgb.apply(_ansi_styles_default2, _to_consumable_array(arguments_)))));
      }
      return (_ansi_styles_default_type = ansi_styles_default[type3])[model].apply(_ansi_styles_default_type, _to_consumable_array(arguments_));
    };
    var usedModels = [
      "rgb",
      "hex",
      "ansi256"
    ];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = void 0;
    try {
      _loop1 = function() {
        var model = _step3.value;
        styles2[model] = {
          get: function get3() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
                arguments_[_key] = arguments[_key];
              }
              var styler = createStyler(getModelAnsi.apply(void 0, [
                model,
                levelMapping[level],
                "color"
              ].concat(_to_consumable_array(arguments_))), ansi_styles_default.color.close, this[STYLER]);
              return createBuilder(this, styler, this[IS_EMPTY]);
            };
          }
        };
        var bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles2[bgModel] = {
          get: function get3() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
                arguments_[_key] = arguments[_key];
              }
              var styler = createStyler(getModelAnsi.apply(void 0, [
                model,
                levelMapping[level],
                "bgColor"
              ].concat(_to_consumable_array(arguments_))), ansi_styles_default.bgColor.close, this[STYLER]);
              return createBuilder(this, styler, this[IS_EMPTY]);
            };
          }
        };
      };
      for (_iterator3 = usedModels[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true)
        _loop1();
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
    var _loop1;
    var _iterator3;
    var _step3;
    var proto = Object.defineProperties(function() {
    }, _object_spread_props(_object_spread({}, styles2), {
      level: {
        enumerable: true,
        get: function get3() {
          return this[GENERATOR2].level;
        },
        set: function set(level) {
          this[GENERATOR2].level = level;
        }
      }
    }));
    var createStyler = function(open, close, parent) {
      var openAll;
      var closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = function(self2, _styler, _isEmpty) {
      var builder = function() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder[GENERATOR2] = self2;
      builder[STYLER] = _styler;
      builder[IS_EMPTY] = _isEmpty;
      return builder;
    };
    var applyStyle = function(self2, string3) {
      if (self2.level <= 0 || !string3) {
        return self2[IS_EMPTY] ? "" : string3;
      }
      var styler = self2[STYLER];
      if (styler === void 0) {
        return string3;
      }
      var openAll = styler.openAll, closeAll = styler.closeAll;
      if (string3.includes("\x1B")) {
        while (styler !== void 0) {
          string3 = stringReplaceAll(string3, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      var lfIndex = string3.indexOf("\n");
      if (lfIndex !== -1) {
        string3 = stringEncaseCRLFWithFirstIndex(string3, closeAll, openAll, lfIndex);
      }
      return openAll + string3 + closeAll;
    };
    Object.defineProperties(createChalk.prototype, styles2);
    var chalk = createChalk();
    var chalkStderr = createChalk({
      level: stderrColor ? stderrColor.level : 0
    });
    var source_default = chalk;
    var sometimesKeywords = /* @__PURE__ */ new Set([
      "as",
      "async",
      "from",
      "get",
      "of",
      "set"
    ]);
    function getDefs(chalk3) {
      return {
        keyword: chalk3.cyan,
        capitalized: chalk3.yellow,
        jsxIdentifier: chalk3.yellow,
        punctuator: chalk3.yellow,
        number: chalk3.magenta,
        string: chalk3.green,
        regex: chalk3.magenta,
        comment: chalk3.grey,
        invalid: chalk3.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      getTokenType = function getTokenType2(token) {
        if (token.type === "IdentifierName") {
          if (isKeyword(token.value) || isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "Punctuator" && BRACKET.test(token.value)) {
          return "uncolored";
        }
        if (token.type === "Invalid" && token.value === "@") {
          return "punctuator";
        }
        switch (token.type) {
          case "NumericLiteral":
            return "number";
          case "StringLiteral":
          case "JSXString":
          case "NoSubstitutionTemplate":
            return "string";
          case "RegularExpressionLiteral":
            return "regex";
          case "Punctuator":
          case "JSXPunctuator":
            return "punctuator";
          case "MultiLineComment":
          case "SingleLineComment":
            return "comment";
          case "Invalid":
          case "JSXInvalid":
            return "invalid";
          case "JSXIdentifier":
            return "jsxIdentifier";
          default:
            return "uncolored";
        }
      };
      tokenize = function tokenize2(text5) {
        var _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, token, _, err;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                17,
                18,
                19
              ]);
              _iterator8 = (0, import_js_tokens.default)(text5, {
                jsx: true
              })[Symbol.iterator]();
              _state.label = 2;
            case 2:
              if (!!(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done))
                return [
                  3,
                  16
                ];
              token = _step8.value;
              _ = token.type;
              switch (_) {
                case "TemplateHead":
                  return [
                    3,
                    3
                  ];
                case "TemplateMiddle":
                  return [
                    3,
                    6
                  ];
                case "TemplateTail":
                  return [
                    3,
                    10
                  ];
              }
              return [
                3,
                13
              ];
            case 3:
              return [
                4,
                {
                  type: "string",
                  value: token.value.slice(0, -2)
                }
              ];
            case 4:
              _state.sent();
              return [
                4,
                {
                  type: "punctuator",
                  value: "${"
                }
              ];
            case 5:
              _state.sent();
              return [
                3,
                15
              ];
            case 6:
              return [
                4,
                {
                  type: "punctuator",
                  value: "}"
                }
              ];
            case 7:
              _state.sent();
              return [
                4,
                {
                  type: "string",
                  value: token.value.slice(1, -2)
                }
              ];
            case 8:
              _state.sent();
              return [
                4,
                {
                  type: "punctuator",
                  value: "${"
                }
              ];
            case 9:
              _state.sent();
              return [
                3,
                15
              ];
            case 10:
              return [
                4,
                {
                  type: "punctuator",
                  value: "}"
                }
              ];
            case 11:
              _state.sent();
              return [
                4,
                {
                  type: "string",
                  value: token.value.slice(1)
                }
              ];
            case 12:
              _state.sent();
              return [
                3,
                15
              ];
            case 13:
              return [
                4,
                {
                  type: getTokenType(token),
                  value: token.value
                }
              ];
            case 14:
              _state.sent();
              _state.label = 15;
            case 15:
              _iteratorNormalCompletion8 = true;
              return [
                3,
                2
              ];
            case 16:
              return [
                3,
                19
              ];
            case 17:
              err = _state.sent();
              _didIteratorError8 = true;
              _iteratorError8 = err;
              return [
                3,
                19
              ];
            case 18:
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
              return [
                7
              ];
            case 19:
              return [
                2
              ];
          }
        });
      };
    }
    var getTokenType;
    function highlightTokens(defs, text5) {
      var highlighted = "";
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        var _loop5 = function() {
          var _step_value = _step8.value, type3 = _step_value.type, value1 = _step_value.value;
          var colorize = defs[type3];
          if (colorize) {
            highlighted += value1.split(NEWLINE).map(function(str) {
              return colorize(str);
            }).join("\n");
          } else {
            highlighted += value1;
          }
        };
        for (var _iterator8 = tokenize(text5)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true)
          _loop5();
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return source_default.level > 0 || options.forceColor;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        chalkWithForcedColor !== null && chalkWithForcedColor !== void 0 ? chalkWithForcedColor : chalkWithForcedColor = new Chalk({
          level: 1
        });
        return chalkWithForcedColor;
      }
      return source_default;
    }
    function highlight(code22) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (code22 !== "" && shouldHighlight(options)) {
        var defs = getDefs(getChalk(options.forceColor));
        return highlightTokens(defs, code22);
      } else {
        return code22;
      }
    }
    var ANSI_BACKGROUND_OFFSET2 = 10;
    var wrapAnsi162 = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(code22) {
        return "\x1B[".concat(code22 + offset2, "m");
      };
    };
    var wrapAnsi2562 = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(code22) {
        return "\x1B[".concat(38 + offset2, ";5;").concat(code22, "m");
      };
    };
    var wrapAnsi16m2 = function() {
      var offset2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(red, green, blue) {
        return "\x1B[".concat(38 + offset2, ";2;").concat(red, ";").concat(green, ";").concat(blue, "m");
      };
    };
    var styles3 = {
      modifier: {
        reset: [
          0,
          0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
          1,
          22
        ],
        dim: [
          2,
          22
        ],
        italic: [
          3,
          23
        ],
        underline: [
          4,
          24
        ],
        overline: [
          53,
          55
        ],
        inverse: [
          7,
          27
        ],
        hidden: [
          8,
          28
        ],
        strikethrough: [
          9,
          29
        ]
      },
      color: {
        black: [
          30,
          39
        ],
        red: [
          31,
          39
        ],
        green: [
          32,
          39
        ],
        yellow: [
          33,
          39
        ],
        blue: [
          34,
          39
        ],
        magenta: [
          35,
          39
        ],
        cyan: [
          36,
          39
        ],
        white: [
          37,
          39
        ],
        // Bright color
        blackBright: [
          90,
          39
        ],
        gray: [
          90,
          39
        ],
        // Alias of `blackBright`
        grey: [
          90,
          39
        ],
        // Alias of `blackBright`
        redBright: [
          91,
          39
        ],
        greenBright: [
          92,
          39
        ],
        yellowBright: [
          93,
          39
        ],
        blueBright: [
          94,
          39
        ],
        magentaBright: [
          95,
          39
        ],
        cyanBright: [
          96,
          39
        ],
        whiteBright: [
          97,
          39
        ]
      },
      bgColor: {
        bgBlack: [
          40,
          49
        ],
        bgRed: [
          41,
          49
        ],
        bgGreen: [
          42,
          49
        ],
        bgYellow: [
          43,
          49
        ],
        bgBlue: [
          44,
          49
        ],
        bgMagenta: [
          45,
          49
        ],
        bgCyan: [
          46,
          49
        ],
        bgWhite: [
          47,
          49
        ],
        // Bright color
        bgBlackBright: [
          100,
          49
        ],
        bgGray: [
          100,
          49
        ],
        // Alias of `bgBlackBright`
        bgGrey: [
          100,
          49
        ],
        // Alias of `bgBlackBright`
        bgRedBright: [
          101,
          49
        ],
        bgGreenBright: [
          102,
          49
        ],
        bgYellowBright: [
          103,
          49
        ],
        bgBlueBright: [
          104,
          49
        ],
        bgMagentaBright: [
          105,
          49
        ],
        bgCyanBright: [
          106,
          49
        ],
        bgWhiteBright: [
          107,
          49
        ]
      }
    };
    var modifierNames2 = Object.keys(styles3.modifier);
    var foregroundColorNames2 = Object.keys(styles3.color);
    var backgroundColorNames2 = Object.keys(styles3.bgColor);
    var colorNames2 = _to_consumable_array(foregroundColorNames2).concat(_to_consumable_array(backgroundColorNames2));
    function assembleStyles2() {
      var _styles3;
      var codes = /* @__PURE__ */ new Map();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.entries(styles3)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step_value = _sliced_to_array(_step8.value, 2), groupName = _step_value[0], group = _step_value[1];
          var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = Object.entries(group)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var _step_value1 = _sliced_to_array(_step12.value, 2), styleName = _step_value1[0], style = _step_value1[1];
              styles3[styleName] = {
                open: "\x1B[".concat(style[0], "m"),
                close: "\x1B[".concat(style[1], "m")
              };
              group[styleName] = styles3[styleName];
              codes.set(style[0], style[1]);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
          Object.defineProperty(styles3, groupName, {
            value: group,
            enumerable: false
          });
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "\x1B[39m";
      styles3.bgColor.close = "\x1B[49m";
      styles3.color.ansi = wrapAnsi162();
      styles3.color.ansi256 = wrapAnsi2562();
      styles3.color.ansi16m = wrapAnsi16m2();
      styles3.bgColor.ansi = wrapAnsi162(ANSI_BACKGROUND_OFFSET2);
      styles3.bgColor.ansi256 = wrapAnsi2562(ANSI_BACKGROUND_OFFSET2);
      styles3.bgColor.ansi16m = wrapAnsi16m2(ANSI_BACKGROUND_OFFSET2);
      Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: function value1(red, green, blue) {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: function value1(hex) {
            var matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
            if (!matches) {
              return [
                0,
                0,
                0
              ];
            }
            var _matches = _sliced_to_array(matches, 1), colorString = _matches[0];
            if (colorString.length === 3) {
              colorString = _to_consumable_array(colorString).map(function(character) {
                return character + character;
              }).join("");
            }
            var integer = Number.parseInt(colorString, 16);
            return [
              /* eslint-disable no-bitwise */
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: function(hex) {
            return (_styles3 = styles3).rgbToAnsi256.apply(_styles3, _to_consumable_array(styles3.hexToRgb(hex)));
          },
          enumerable: false
        },
        ansi256ToAnsi: {
          value: function value1(code22) {
            if (code22 < 8) {
              return 30 + code22;
            }
            if (code22 < 16) {
              return 90 + (code22 - 8);
            }
            var red;
            var green;
            var blue;
            if (code22 >= 232) {
              red = ((code22 - 232) * 10 + 8) / 255;
              green = red;
              blue = red;
            } else {
              code22 -= 16;
              var remainder = code22 % 36;
              red = Math.floor(code22 / 36) / 5;
              green = Math.floor(remainder / 6) / 5;
              blue = remainder % 6 / 5;
            }
            var value12 = Math.max(red, green, blue) * 2;
            if (value12 === 0) {
              return 30;
            }
            var result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
            if (value12 === 2) {
              result += 60;
            }
            return result;
          },
          enumerable: false
        },
        rgbToAnsi: {
          value: function(red, green, blue) {
            return styles3.ansi256ToAnsi(styles3.rgbToAnsi256(red, green, blue));
          },
          enumerable: false
        },
        hexToAnsi: {
          value: function(hex) {
            return styles3.ansi256ToAnsi(styles3.hexToAnsi256(hex));
          },
          enumerable: false
        }
      });
      return styles3;
    }
    var ansiStyles2 = assembleStyles2();
    var ansi_styles_default2 = ansiStyles2;
    var import_node_process22 = __toESM2(require("process"), 1);
    var import_node_os2 = __toESM2(require("os"), 1);
    var import_node_tty2 = __toESM2(require("tty"), 1);
    function hasFlag2(flag) {
      var argv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis.Deno ? globalThis.Deno.args : import_node_process22.default.argv;
      var prefix2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      var position3 = argv.indexOf(prefix2 + flag);
      var terminatorPosition = argv.indexOf("--");
      return position3 !== -1 && (terminatorPosition === -1 || position3 < terminatorPosition);
    }
    var _import_node_process2_default = import_node_process22.default;
    var env22 = _import_node_process2_default.env;
    var flagForceColor2;
    if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
      flagForceColor2 = 0;
    } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
      flagForceColor2 = 1;
    }
    function envForceColor2() {
      if ("FORCE_COLOR" in env22) {
        if (env22.FORCE_COLOR === "true") {
          return 1;
        }
        if (env22.FORCE_COLOR === "false") {
          return 0;
        }
        return env22.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env22.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel2(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function _supportsColor2(haveStream) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, streamIsTTY = _ref.streamIsTTY, _ref_sniffFlags = _ref.sniffFlags, sniffFlags = _ref_sniffFlags === void 0 ? true : _ref_sniffFlags;
      var noFlagForceColor = envForceColor2();
      if (noFlagForceColor !== void 0) {
        flagForceColor2 = noFlagForceColor;
      }
      var forceColor = sniffFlags ? flagForceColor2 : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
          return 3;
        }
        if (hasFlag2("color=256")) {
          return 2;
        }
      }
      if ("TF_BUILD" in env22 && "AGENT_NAME" in env22) {
        return 1;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      var min = forceColor || 0;
      if (env22.TERM === "dumb") {
        return min;
      }
      if (import_node_process22.default.platform === "win32") {
        var osRelease = import_node_os2.default.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env22) {
        if ("GITHUB_ACTIONS" in env22 || "GITEA_ACTIONS" in env22) {
          return 3;
        }
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "BUILDKITE",
          "DRONE"
        ].some(function(sign) {
          return sign in env22;
        }) || env22.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env22) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env22.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env22.COLORTERM === "truecolor") {
        return 3;
      }
      if (env22.TERM === "xterm-kitty") {
        return 3;
      }
      if ("TERM_PROGRAM" in env22) {
        var version2 = Number.parseInt((env22.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env22.TERM_PROGRAM) {
          case "iTerm.app": {
            return version2 >= 3 ? 3 : 2;
          }
          case "Apple_Terminal": {
            return 2;
          }
        }
      }
      if (/-256(color)?$/i.test(env22.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env22.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env22) {
        return 1;
      }
      return min;
    }
    function createSupportsColor2(stream) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var level = _supportsColor2(stream, _object_spread({
        streamIsTTY: stream && stream.isTTY
      }, options));
      return translateLevel2(level);
    }
    var supportsColor2 = {
      stdout: createSupportsColor2({
        isTTY: import_node_tty2.default.isatty(1)
      }),
      stderr: createSupportsColor2({
        isTTY: import_node_tty2.default.isatty(2)
      })
    };
    var supports_color_default2 = supportsColor2;
    function stringReplaceAll2(string3, substring, replacer) {
      var index3 = string3.indexOf(substring);
      if (index3 === -1) {
        return string3;
      }
      var substringLength = substring.length;
      var endIndex = 0;
      var returnValue = "";
      do {
        returnValue += string3.slice(endIndex, index3) + substring + replacer;
        endIndex = index3 + substringLength;
        index3 = string3.indexOf(substring, endIndex);
      } while (index3 !== -1);
      returnValue += string3.slice(endIndex);
      return returnValue;
    }
    function stringEncaseCRLFWithFirstIndex2(string3, prefix2, postfix2, index3) {
      var endIndex = 0;
      var returnValue = "";
      do {
        var gotCR = string3[index3 - 1] === "\r";
        returnValue += string3.slice(endIndex, gotCR ? index3 - 1 : index3) + prefix2 + (gotCR ? "\r\n" : "\n") + postfix2;
        endIndex = index3 + 1;
        index3 = string3.indexOf("\n", endIndex);
      } while (index3 !== -1);
      returnValue += string3.slice(endIndex);
      return returnValue;
    }
    var stdoutColor2 = supports_color_default2.stdout;
    var stderrColor2 = supports_color_default2.stderr;
    var GENERATOR22 = Symbol("GENERATOR");
    var STYLER2 = Symbol("STYLER");
    var IS_EMPTY2 = Symbol("IS_EMPTY");
    var levelMapping2 = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles4 = /* @__PURE__ */ Object.create(null);
    var applyOptions2 = function(object) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      var colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var Chalk2 = function Chalk22(options) {
      "use strict";
      _class_call_check(this, Chalk22);
      return chalkFactory2(options);
    };
    var chalkFactory2 = function(options) {
      var chalk3 = function() {
        for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
          strings[_key] = arguments[_key];
        }
        return strings.join(" ");
      };
      applyOptions2(chalk3, options);
      Object.setPrototypeOf(chalk3, createChalk2.prototype);
      return chalk3;
    };
    function createChalk2(options) {
      return chalkFactory2(options);
    }
    Object.setPrototypeOf(createChalk2.prototype, Function.prototype);
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = void 0;
    try {
      _loop2 = function() {
        var _step_value = _sliced_to_array(_step4.value, 2), styleName = _step_value[0], style = _step_value[1];
        styles4[styleName] = {
          get: function get3() {
            var builder = createBuilder2(this, createStyler2(style.open, style.close, this[STYLER2]), this[IS_EMPTY2]);
            Object.defineProperty(this, styleName, {
              value: builder
            });
            return builder;
          }
        };
      };
      for (_iterator4 = Object.entries(ansi_styles_default2)[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true)
        _loop2();
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
    var _loop2;
    var _iterator4;
    var _step4;
    styles4.visible = {
      get: function get3() {
        var builder = createBuilder2(this, this[STYLER2], true);
        Object.defineProperty(this, "visible", {
          value: builder
        });
        return builder;
      }
    };
    var getModelAnsi2 = function(model, level, type3) {
      for (var _len = arguments.length, arguments_ = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        arguments_[_key - 3] = arguments[_key];
      }
      var _ansi_styles_default2_type;
      if (model === "rgb") {
        var _ansi_styles_default2;
        if (level === "ansi16m") {
          var _ansi_styles_default2_type1;
          return (_ansi_styles_default2_type1 = ansi_styles_default2[type3]).ansi16m.apply(_ansi_styles_default2_type1, _to_consumable_array(arguments_));
        }
        if (level === "ansi256") {
          var _ansi_styles_default21;
          return ansi_styles_default2[type3].ansi256((_ansi_styles_default21 = ansi_styles_default2).rgbToAnsi256.apply(_ansi_styles_default21, _to_consumable_array(arguments_)));
        }
        return ansi_styles_default2[type3].ansi((_ansi_styles_default2 = ansi_styles_default2).rgbToAnsi.apply(_ansi_styles_default2, _to_consumable_array(arguments_)));
      }
      if (model === "hex") {
        var _ansi_styles_default22;
        return getModelAnsi2.apply(void 0, [
          "rgb",
          level,
          type3
        ].concat(_to_consumable_array((_ansi_styles_default22 = ansi_styles_default2).hexToRgb.apply(_ansi_styles_default22, _to_consumable_array(arguments_)))));
      }
      return (_ansi_styles_default2_type = ansi_styles_default2[type3])[model].apply(_ansi_styles_default2_type, _to_consumable_array(arguments_));
    };
    var usedModels2 = [
      "rgb",
      "hex",
      "ansi256"
    ];
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = void 0;
    try {
      _loop3 = function() {
        var model = _step5.value;
        styles4[model] = {
          get: function get3() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
                arguments_[_key] = arguments[_key];
              }
              var styler = createStyler2(getModelAnsi2.apply(void 0, [
                model,
                levelMapping2[level],
                "color"
              ].concat(_to_consumable_array(arguments_))), ansi_styles_default2.color.close, this[STYLER2]);
              return createBuilder2(this, styler, this[IS_EMPTY2]);
            };
          }
        };
        var bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles4[bgModel] = {
          get: function get3() {
            var level = this.level;
            return function() {
              for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
                arguments_[_key] = arguments[_key];
              }
              var styler = createStyler2(getModelAnsi2.apply(void 0, [
                model,
                levelMapping2[level],
                "bgColor"
              ].concat(_to_consumable_array(arguments_))), ansi_styles_default2.bgColor.close, this[STYLER2]);
              return createBuilder2(this, styler, this[IS_EMPTY2]);
            };
          }
        };
      };
      for (_iterator5 = usedModels2[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true)
        _loop3();
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
    var _loop3;
    var _iterator5;
    var _step5;
    var proto2 = Object.defineProperties(function() {
    }, _object_spread_props(_object_spread({}, styles4), {
      level: {
        enumerable: true,
        get: function get3() {
          return this[GENERATOR22].level;
        },
        set: function set(level) {
          this[GENERATOR22].level = level;
        }
      }
    }));
    var createStyler2 = function(open, close, parent) {
      var openAll;
      var closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder2 = function(self2, _styler, _isEmpty) {
      var builder = function() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        return applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto2);
      builder[GENERATOR22] = self2;
      builder[STYLER2] = _styler;
      builder[IS_EMPTY2] = _isEmpty;
      return builder;
    };
    var applyStyle2 = function(self2, string3) {
      if (self2.level <= 0 || !string3) {
        return self2[IS_EMPTY2] ? "" : string3;
      }
      var styler = self2[STYLER2];
      if (styler === void 0) {
        return string3;
      }
      var openAll = styler.openAll, closeAll = styler.closeAll;
      if (string3.includes("\x1B")) {
        while (styler !== void 0) {
          string3 = stringReplaceAll2(string3, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      var lfIndex = string3.indexOf("\n");
      if (lfIndex !== -1) {
        string3 = stringEncaseCRLFWithFirstIndex2(string3, closeAll, openAll, lfIndex);
      }
      return openAll + string3 + closeAll;
    };
    Object.defineProperties(createChalk2.prototype, styles4);
    var chalk2 = createChalk2();
    var chalkStderr2 = createChalk2({
      level: stderrColor2 ? stderrColor2.level : 0
    });
    var source_default2 = chalk2;
    var chalkWithForcedColor2 = void 0;
    function getChalk2(forceColor) {
      if (forceColor) {
        chalkWithForcedColor2 !== null && chalkWithForcedColor2 !== void 0 ? chalkWithForcedColor2 : chalkWithForcedColor2 = new Chalk2({
          level: 1
        });
        return chalkWithForcedColor2;
      }
      return source_default2;
    }
    function getDefs2(chalk3) {
      return {
        gutter: chalk3.grey,
        marker: chalk3.red.bold,
        message: chalk3.red.bold
      };
    }
    var NEWLINE2 = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      var startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      var endLoc = Object.assign({}, startLoc, loc.end);
      var _ref = opts || {}, _ref_linesAbove = _ref.linesAbove, linesAbove = _ref_linesAbove === void 0 ? 2 : _ref_linesAbove, _ref_linesBelow = _ref.linesBelow, linesBelow = _ref_linesBelow === void 0 ? 3 : _ref_linesBelow;
      var startLine = startLoc.line;
      var startColumn = startLoc.column;
      var endLine = endLoc.line;
      var endColumn = endLoc.column;
      var start2 = Math.max(startLine - (linesAbove + 1), 0);
      var end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start2 = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      var lineDiff = endLine - startLine;
      var markerLines = {};
      if (lineDiff) {
        for (var i2 = 0; i2 <= lineDiff; i2++) {
          var lineNumber = i2 + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i2 === 0) {
            var sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [
              startColumn,
              sourceLength - startColumn + 1
            ];
          } else if (i2 === lineDiff) {
            markerLines[lineNumber] = [
              0,
              endColumn
            ];
          } else {
            var sourceLength1 = source[lineNumber - i2].length;
            markerLines[lineNumber] = [
              0,
              sourceLength1
            ];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [
              startColumn,
              0
            ];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [
            startColumn,
            endColumn - startColumn
          ];
        }
      }
      return {
        start: start2,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
      var chalk3 = getChalk2(opts.forceColor);
      var defs = getDefs2(chalk3);
      var maybeHighlight = function(chalkFn, string3) {
        return highlighted ? chalkFn(string3) : string3;
      };
      var lines = rawLines.split(NEWLINE2);
      var _getMarkerLines = getMarkerLines(loc, lines, opts), start2 = _getMarkerLines.start, end = _getMarkerLines.end, markerLines = _getMarkerLines.markerLines;
      var hasColumns = loc.start && typeof loc.start.column === "number";
      var numberMaxWidth = String(end).length;
      var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
      var frame = highlightedLines.split(NEWLINE2, end).slice(start2, end).map(function(line, index3) {
        var number2 = start2 + 1 + index3;
        var paddedNumber = " ".concat(number2).slice(-numberMaxWidth);
        var gutter = " ".concat(paddedNumber, " |");
        var hasMarker = markerLines[number2];
        var lastMarkerLine = !markerLines[number2 + 1];
        if (hasMarker) {
          var markerLine = "";
          if (Array.isArray(hasMarker)) {
            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            var numberOfMarkers = hasMarker[1] || 1;
            markerLine = [
              "\n ",
              maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")),
              " ",
              markerSpacing,
              maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)
            ].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [
            maybeHighlight(defs.marker, ">"),
            maybeHighlight(defs.gutter, gutter),
            line.length > 0 ? " ".concat(line) : "",
            markerLine
          ].join("");
        } else {
          return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line.length > 0 ? " ".concat(line) : "");
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
      }
      if (highlighted) {
        return chalk3.reset(frame);
      } else {
        return frame;
      }
    }
    var assertExpressionStatement2 = lib_exports.assertExpressionStatement;
    function makeStatementFormatter(fn) {
      return {
        code: function(str) {
          return "/* @babel/template */;\n".concat(str);
        },
        validate: function() {
        },
        unwrap: function(ast) {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart$1 = makeStatementFormatter(function(body) {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements$1 = makeStatementFormatter(function(body) {
      return body;
    });
    var statement$1 = makeStatementFormatter(function(body) {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    var expression$1 = {
      code: function(str) {
        return "(\n".concat(str, "\n)");
      },
      validate: function(ast) {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression$1.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: function(param) {
        var program3 = param.program;
        var _program3_body = _sliced_to_array(program3.body, 1), stmt = _program3_body[0];
        assertExpressionStatement2(stmt);
        return stmt.expression;
      }
    };
    var program$1 = {
      code: function(str) {
        return str;
      },
      validate: function() {
      },
      unwrap: function(ast) {
        return ast.program;
      }
    };
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var _excluded3 = [
      "placeholderWhitelist",
      "placeholderPattern",
      "preserveComments",
      "syntacticPlaceholders"
    ];
    function merge2(a, b) {
      var _b_placeholderWhitelist = b.placeholderWhitelist, placeholderWhitelist = _b_placeholderWhitelist === void 0 ? a.placeholderWhitelist : _b_placeholderWhitelist, _b_placeholderPattern = b.placeholderPattern, placeholderPattern = _b_placeholderPattern === void 0 ? a.placeholderPattern : _b_placeholderPattern, _b_preserveComments = b.preserveComments, preserveComments = _b_preserveComments === void 0 ? a.preserveComments : _b_preserveComments, _b_syntacticPlaceholders = b.syntacticPlaceholders, syntacticPlaceholders = _b_syntacticPlaceholders === void 0 ? a.syntacticPlaceholders : _b_syntacticPlaceholders;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate$12(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      var _ref = opts || {}, placeholderWhitelist = _ref.placeholderWhitelist, placeholderPattern = _ref.placeholderPattern, preserveComments = _ref.preserveComments, syntacticPlaceholders = _ref.syntacticPlaceholders, parser = _objectWithoutPropertiesLoose2(_ref, _excluded3);
      if (placeholderWhitelist != null && !_instanceof(placeholderWhitelist, Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !_instanceof(placeholderPattern, RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce(function(acc, replacement, i2) {
          acc["$" + i2] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
    var isCallExpression2 = lib_exports.isCallExpression;
    var isExpressionStatement22 = lib_exports.isExpressionStatement;
    var isFunction2 = lib_exports.isFunction;
    var isIdentifier22 = lib_exports.isIdentifier;
    var isJSXIdentifier22 = lib_exports.isJSXIdentifier;
    var isNewExpression2 = lib_exports.isNewExpression;
    var isPlaceholder2 = lib_exports.isPlaceholder;
    var isStatement$1 = lib_exports.isStatement;
    var isStringLiteral$1 = lib_exports.isStringLiteral;
    var removePropertiesDeep2 = lib_exports.removePropertiesDeep;
    var traverse2 = lib_exports.traverse;
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code22, opts) {
      var placeholderWhitelist = opts.placeholderWhitelist, placeholderPattern = opts.placeholderPattern, preserveComments = opts.preserveComments, syntacticPlaceholders = opts.syntacticPlaceholders;
      var ast = parseWithCodeFrame(code22, opts.parser, syntacticPlaceholders);
      removePropertiesDeep2(ast, {
        preserveComments
      });
      formatter.validate(ast);
      var state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      traverse2(ast, placeholderVisitorHandler, state);
      return Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node2, ancestors, state) {
      var _state_placeholderWhitelist;
      var name2;
      var hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder2(node2)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        }
        name2 = node2.name.name;
        hasSyntacticPlaceholders = true;
      } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier22(node2) || isJSXIdentifier22(node2)) {
        name2 = node2.name;
      } else if (isStringLiteral$1(node2)) {
        name2 = node2.value;
      } else {
        return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name2)) && !((_state_placeholderWhitelist = state.placeholderWhitelist) === null || _state_placeholderWhitelist === void 0 ? void 0 : _state_placeholderWhitelist.has(name2))) {
        return;
      }
      ancestors = ancestors.slice();
      var _ancestors_ = ancestors[ancestors.length - 1], parent = _ancestors_.node, key = _ancestors_.key;
      var type3;
      if (isStringLiteral$1(node2) || isPlaceholder2(node2, {
        expectedNode: "StringLiteral"
      })) {
        type3 = "string";
      } else if (isNewExpression2(parent) && key === "arguments" || isCallExpression2(parent) && key === "arguments" || isFunction2(parent) && key === "params") {
        type3 = "param";
      } else if (isExpressionStatement22(parent) && !isPlaceholder2(node2)) {
        type3 = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement$1(node2) && isPlaceholder2(node2)) {
        type3 = "statement";
      } else {
        type3 = "other";
      }
      var _ref = !hasSyntacticPlaceholders ? state.legacy : state.syntactic, placeholders2 = _ref.placeholders, placeholderNames = _ref.placeholderNames;
      placeholders2.push({
        name: name2,
        type: type3,
        resolve: function(ast) {
          return resolveAncestors(ast, ancestors);
        },
        isDuplicate: placeholderNames.has(name2)
      });
      placeholderNames.add(name2);
    }
    function resolveAncestors(ast, ancestors) {
      var parent = ast;
      for (var i2 = 0; i2 < ancestors.length - 1; i2++) {
        var _ancestors_i = ancestors[i2], key2 = _ancestors_i.key, index4 = _ancestors_i.index;
        if (index4 === void 0) {
          parent = parent[key2];
        } else {
          parent = parent[key2][index4];
        }
      }
      var _ancestors_ = ancestors[ancestors.length - 1], key = _ancestors_.key, index3 = _ancestors_.index;
      return {
        parent,
        key,
        index: index3
      };
    }
    function parseWithCodeFrame(code22, parserOpts, syntacticPlaceholders) {
      var plugins = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
      }
      parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return parse4(code22, parserOpts);
      } catch (err) {
        var loc = err.loc;
        if (loc) {
          err.message += "\n" + codeFrameColumns(code22, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
    var blockStatement2 = lib_exports.blockStatement;
    var cloneNode2 = lib_exports.cloneNode;
    var emptyStatement2 = lib_exports.emptyStatement;
    var expressionStatement2 = lib_exports.expressionStatement;
    var identifier2 = lib_exports.identifier;
    var isStatement2 = lib_exports.isStatement;
    var isStringLiteral22 = lib_exports.isStringLiteral;
    var stringLiteral2 = lib_exports.stringLiteral;
    var validate2 = lib_exports.validate;
    function populatePlaceholders(metadata, replacements) {
      var ast = cloneNode2(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach(function(placeholder2) {
          if (!Object.prototype.hasOwnProperty.call(replacements, placeholder2.name)) {
            var placeholderName = placeholder2.name;
            throw new Error('Error: No substitution given for "'.concat(placeholderName, `". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['`).concat(placeholderName, "'])}\n            - { placeholderPattern: /^").concat(placeholderName, "$/ }"));
          }
        });
        Object.keys(replacements).forEach(function(key) {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error('Unknown substitution "'.concat(key, '" given'));
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach(function(placeholder2) {
        try {
          applyReplacement(placeholder2, ast, replacements && replacements[placeholder2.name] || null);
        } catch (e) {
          e.message = '@babel/template placeholder "'.concat(placeholder2.name, '": ').concat(e.message);
          throw e;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder2, ast, replacement) {
      if (placeholder2.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map(function(node2) {
            return cloneNode2(node2);
          });
        } else if (typeof replacement === "object") {
          replacement = cloneNode2(replacement);
        }
      }
      var _placeholder2_resolve = placeholder2.resolve(ast), parent = _placeholder2_resolve.parent, key = _placeholder2_resolve.key, index3 = _placeholder2_resolve.index;
      if (placeholder2.type === "string") {
        if (typeof replacement === "string") {
          replacement = stringLiteral2(replacement);
        }
        if (!replacement || !isStringLiteral22(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder2.type === "statement") {
        if (index3 === void 0) {
          if (!replacement) {
            replacement = emptyStatement2();
          } else if (Array.isArray(replacement)) {
            replacement = blockStatement2(replacement);
          } else if (typeof replacement === "string") {
            replacement = expressionStatement2(identifier2(replacement));
          } else if (!isStatement2(replacement)) {
            replacement = expressionStatement2(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = identifier2(replacement);
            }
            if (!isStatement2(replacement)) {
              replacement = expressionStatement2(replacement);
            }
          }
        }
      } else if (placeholder2.type === "param") {
        if (typeof replacement === "string") {
          replacement = identifier2(replacement);
        }
        if (index3 === void 0)
          throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = identifier2(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      if (index3 === void 0) {
        validate2(parent, key, replacement);
        parent[key] = replacement;
      } else {
        var items = parent[key].slice();
        if (placeholder2.type === "statement" || placeholder2.type === "param") {
          if (replacement == null) {
            items.splice(index3, 1);
          } else if (Array.isArray(replacement)) {
            var _items;
            (_items = items).splice.apply(_items, [
              index3,
              1
            ].concat(_to_consumable_array(replacement)));
          } else {
            items[index3] = replacement;
          }
        } else {
          items[index3] = replacement;
        }
        validate2(parent, key, items);
        parent[key] = items;
      }
    }
    function stringTemplate(formatter, code22, opts) {
      code22 = formatter.code(code22);
      var metadata;
      return function(arg) {
        var replacements = normalizeReplacements(arg);
        if (!metadata)
          metadata = parseAndBuildMetadata(formatter, code22, opts);
        return formatter.unwrap(populatePlaceholders(metadata, replacements));
      };
    }
    function literalTemplate(formatter, tpl, opts) {
      var _buildLiteralData = buildLiteralData(formatter, tpl, opts), metadata = _buildLiteralData.metadata, names = _buildLiteralData.names;
      return function(arg) {
        var defaultReplacements = {};
        arg.forEach(function(replacement, i2) {
          defaultReplacements[names[i2]] = replacement;
        });
        return function(arg2) {
          var replacements = normalizeReplacements(arg2);
          if (replacements) {
            Object.keys(replacements).forEach(function(key) {
              if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      var prefix2 = "BABEL_TPL$";
      var raw = tpl.join("");
      do {
        prefix2 = "$$" + prefix2;
      } while (raw.includes(prefix2));
      var _buildTemplateCode = buildTemplateCode(tpl, prefix2), names = _buildTemplateCode.names, code22 = _buildTemplateCode.code;
      var metadata = parseAndBuildMetadata(formatter, formatter.code(code22), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix2) {
      var names = [];
      var code22 = tpl[0];
      for (var i2 = 1; i2 < tpl.length; i2++) {
        var value1 = "".concat(prefix2).concat(i2 - 1);
        names.push(value1);
        code22 += value1 + tpl[i2];
      }
      return {
        names,
        code: code22
      };
    }
    var NO_PLACEHOLDER = validate$12({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      var templateFnCache = /* @__PURE__ */ new WeakMap();
      var templateAstCache = /* @__PURE__ */ new WeakMap();
      var cachedOpts = defaultOpts || validate$12(null);
      return Object.assign(function(tpl) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (typeof tpl === "string") {
          if (args.length > 1)
            throw new Error("Unexpected extra params.");
          return extendedTrace(stringTemplate(formatter, tpl, merge2(cachedOpts, validate$12(args[0]))));
        } else if (Array.isArray(tpl)) {
          var builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = literalTemplate(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0)
            throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, merge2(cachedOpts, validate$12(tpl)));
        }
        throw new Error("Unexpected template param ".concat(typeof tpl === "undefined" ? "undefined" : _type_of(tpl)));
      }, {
        ast: function(tpl) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (typeof tpl === "string") {
            if (args.length > 1)
              throw new Error("Unexpected extra params.");
            return stringTemplate(formatter, tpl, merge2(merge2(cachedOpts, validate$12(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            var builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = literalTemplate(formatter, tpl, merge2(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error("Unexpected template param ".concat(typeof tpl === "undefined" ? "undefined" : _type_of(tpl)));
        }
      });
    }
    function extendedTrace(fn) {
      var rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return function(arg) {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += "\n    =============\n".concat(rootStack);
          throw err;
        }
      };
    }
    var smart = createTemplateBuilder(smart$1);
    var statement = createTemplateBuilder(statement$1);
    var statements = createTemplateBuilder(statements$1);
    var expression = createTemplateBuilder(expression$1);
    var program2 = createTemplateBuilder(program$1);
    var index2 = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program: program2,
      ast: smart.ast
    });
    var get;
    var put;
    var pop;
    var SetArray = function SetArray2() {
      "use strict";
      _class_call_check(this, SetArray2);
      this._indexes = {
        __proto__: null
      };
      this.array = [];
    };
    (function() {
      get = function(strarr, key) {
        return strarr._indexes[key];
      };
      put = function(strarr, key) {
        var index3 = get(strarr, key);
        if (index3 !== void 0)
          return index3;
        var array = strarr.array, indexes = strarr._indexes;
        return indexes[key] = array.push(key) - 1;
      };
      pop = function(strarr) {
        var array = strarr.array, indexes = strarr._indexes;
        if (array.length === 0)
          return;
        var last2 = array.pop();
        indexes[last2] = void 0;
      };
    })();
    var comma = ",".charCodeAt(0);
    var semicolon = ";".charCodeAt(0);
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var intToChar = new Uint8Array(64);
    var charToInt = new Uint8Array(128);
    for (i = 0; i < chars.length; i++) {
      c = chars.charCodeAt(i);
      intToChar[i] = c;
      charToInt[c] = i;
    }
    var c;
    var i;
    var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
      decode: function decode3(buf) {
        var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
      }
    } : {
      decode: function decode3(buf) {
        var out = "";
        for (var i2 = 0; i2 < buf.length; i2++) {
          out += String.fromCharCode(buf[i2]);
        }
        return out;
      }
    };
    function decode2(mappings) {
      var state = new Int32Array(5);
      var decoded = [];
      var index3 = 0;
      do {
        var semi = indexOf(mappings, index3);
        var line = [];
        var sorted = true;
        var lastCol = 0;
        state[0] = 0;
        for (var i2 = index3; i2 < semi; i2++) {
          var seg = void 0;
          i2 = decodeInteger(mappings, i2, state, 0);
          var col = state[0];
          if (col < lastCol)
            sorted = false;
          lastCol = col;
          if (hasMoreVlq(mappings, i2, semi)) {
            i2 = decodeInteger(mappings, i2, state, 1);
            i2 = decodeInteger(mappings, i2, state, 2);
            i2 = decodeInteger(mappings, i2, state, 3);
            if (hasMoreVlq(mappings, i2, semi)) {
              i2 = decodeInteger(mappings, i2, state, 4);
              seg = [
                col,
                state[1],
                state[2],
                state[3],
                state[4]
              ];
            } else {
              seg = [
                col,
                state[1],
                state[2],
                state[3]
              ];
            }
          } else {
            seg = [
              col
            ];
          }
          line.push(seg);
        }
        if (!sorted)
          sort(line);
        decoded.push(line);
        index3 = semi + 1;
      } while (index3 <= mappings.length);
      return decoded;
    }
    function indexOf(mappings, index3) {
      var idx = mappings.indexOf(";", index3);
      return idx === -1 ? mappings.length : idx;
    }
    function decodeInteger(mappings, pos, state, j) {
      var value1 = 0;
      var shift = 0;
      var integer = 0;
      do {
        var c2 = mappings.charCodeAt(pos++);
        integer = charToInt[c2];
        value1 |= (integer & 31) << shift;
        shift += 5;
      } while (integer & 32);
      var shouldNegate = value1 & 1;
      value1 >>>= 1;
      if (shouldNegate) {
        value1 = -2147483648 | -value1;
      }
      state[j] += value1;
      return pos;
    }
    function hasMoreVlq(mappings, i2, length) {
      if (i2 >= length)
        return false;
      return mappings.charCodeAt(i2) !== comma;
    }
    function sort(line) {
      line.sort(sortComparator);
    }
    function sortComparator(a, b) {
      return a[0] - b[0];
    }
    function encode(decoded) {
      var state = new Int32Array(5);
      var bufLength = 1024 * 16;
      var subLength = bufLength - 36;
      var buf = new Uint8Array(bufLength);
      var sub = buf.subarray(0, subLength);
      var pos = 0;
      var out = "";
      for (var i2 = 0; i2 < decoded.length; i2++) {
        var line = decoded[i2];
        if (i2 > 0) {
          if (pos === bufLength) {
            out += td.decode(buf);
            pos = 0;
          }
          buf[pos++] = semicolon;
        }
        if (line.length === 0)
          continue;
        state[0] = 0;
        for (var j = 0; j < line.length; j++) {
          var segment = line[j];
          if (pos > subLength) {
            out += td.decode(sub);
            buf.copyWithin(0, subLength, pos);
            pos -= subLength;
          }
          if (j > 0)
            buf[pos++] = comma;
          pos = encodeInteger(buf, pos, state, segment, 0);
          if (segment.length === 1)
            continue;
          pos = encodeInteger(buf, pos, state, segment, 1);
          pos = encodeInteger(buf, pos, state, segment, 2);
          pos = encodeInteger(buf, pos, state, segment, 3);
          if (segment.length === 4)
            continue;
          pos = encodeInteger(buf, pos, state, segment, 4);
        }
      }
      return out + td.decode(buf.subarray(0, pos));
    }
    function encodeInteger(buf, pos, state, segment, j) {
      var next = segment[j];
      var num = next - state[j];
      state[j] = next;
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0)
          clamped |= 32;
        buf[pos++] = intToChar[clamped];
      } while (num > 0);
      return pos;
    }
    var schemeRegex = /^[\w+.-]+:\/\//;
    var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var UrlType;
    (function(UrlType2) {
      UrlType2[UrlType2["Empty"] = 1] = "Empty";
      UrlType2[UrlType2["Hash"] = 2] = "Hash";
      UrlType2[UrlType2["Query"] = 3] = "Query";
      UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
      UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
      UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
      UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
    })(UrlType || (UrlType = {}));
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function isAbsolutePath(input) {
      return input.startsWith("/");
    }
    function isFileUrl(input) {
      return input.startsWith("file:");
    }
    function isRelative(input) {
      return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
      var match = urlRegex.exec(input);
      return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
    }
    function parseFileUrl(input) {
      var match = fileRegex.exec(input);
      var path = match[2];
      return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
      return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: UrlType.Absolute
      };
    }
    function parseUrl(input) {
      if (isSchemeRelativeUrl(input)) {
        var url2 = parseAbsoluteUrl("http:" + input);
        url2.scheme = "";
        url2.type = UrlType.SchemeRelative;
        return url2;
      }
      if (isAbsolutePath(input)) {
        var url21 = parseAbsoluteUrl("http://foo.com" + input);
        url21.scheme = "";
        url21.host = "";
        url21.type = UrlType.AbsolutePath;
        return url21;
      }
      if (isFileUrl(input))
        return parseFileUrl(input);
      if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
      var url = parseAbsoluteUrl("http://foo.com/" + input);
      url.scheme = "";
      url.host = "";
      url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
      return url;
    }
    function stripPathFilename(path) {
      if (path.endsWith("/.."))
        return path;
      var index3 = path.lastIndexOf("/");
      return path.slice(0, index3 + 1);
    }
    function mergePaths(url, base) {
      normalizePath(base, base.type);
      if (url.path === "/") {
        url.path = base.path;
      } else {
        url.path = stripPathFilename(base.path) + url.path;
      }
    }
    function normalizePath(url, type3) {
      var rel = type3 <= UrlType.RelativePath;
      var pieces = url.path.split("/");
      var pointer = 1;
      var positive = 0;
      var addTrailingSlash = false;
      for (var i2 = 1; i2 < pieces.length; i2++) {
        var piece = pieces[i2];
        if (!piece) {
          addTrailingSlash = true;
          continue;
        }
        addTrailingSlash = false;
        if (piece === ".")
          continue;
        if (piece === "..") {
          if (positive) {
            addTrailingSlash = true;
            positive--;
            pointer--;
          } else if (rel) {
            pieces[pointer++] = piece;
          }
          continue;
        }
        pieces[pointer++] = piece;
        positive++;
      }
      var path = "";
      for (var i1 = 1; i1 < pointer; i1++) {
        path += "/" + pieces[i1];
      }
      if (!path || addTrailingSlash && !path.endsWith("/..")) {
        path += "/";
      }
      url.path = path;
    }
    function resolve(input, base) {
      if (!input && !base)
        return "";
      var url = parseUrl(input);
      var inputType = url.type;
      if (base && inputType !== UrlType.Absolute) {
        var baseUrl = parseUrl(base);
        var baseType = baseUrl.type;
        switch (inputType) {
          case UrlType.Empty:
            url.hash = baseUrl.hash;
          case UrlType.Hash:
            url.query = baseUrl.query;
          case UrlType.Query:
          case UrlType.RelativePath:
            mergePaths(url, baseUrl);
          case UrlType.AbsolutePath:
            url.user = baseUrl.user;
            url.host = baseUrl.host;
            url.port = baseUrl.port;
          case UrlType.SchemeRelative:
            url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
          inputType = baseType;
      }
      normalizePath(url, inputType);
      var queryHash = url.query + url.hash;
      switch (inputType) {
        case UrlType.Hash:
        case UrlType.Query:
          return queryHash;
        case UrlType.RelativePath: {
          var path = url.path.slice(1);
          if (!path)
            return queryHash || ".";
          if (isRelative(base || input) && !isRelative(path)) {
            return "./" + path + queryHash;
          }
          return path + queryHash;
        }
        case UrlType.AbsolutePath:
          return url.path + queryHash;
        default:
          return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
      }
    }
    function resolve2(input, base) {
      if (base && !base.endsWith("/"))
        base += "/";
      return resolve(input, base);
    }
    function stripFilename(path) {
      if (!path)
        return "";
      var index3 = path.lastIndexOf("/");
      return path.slice(0, index3 + 1);
    }
    var COLUMN = 0;
    var SOURCES_INDEX = 1;
    var SOURCE_LINE = 2;
    var SOURCE_COLUMN = 3;
    var NAMES_INDEX = 4;
    var REV_GENERATED_LINE = 1;
    var REV_GENERATED_COLUMN = 2;
    function maybeSort(mappings, owned) {
      var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
      if (unsortedIndex === mappings.length)
        return mappings;
      if (!owned)
        mappings = mappings.slice();
      for (var i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
        mappings[i2] = sortSegments(mappings[i2], owned);
      }
      return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start2) {
      for (var i2 = start2; i2 < mappings.length; i2++) {
        if (!isSorted(mappings[i2]))
          return i2;
      }
      return mappings.length;
    }
    function isSorted(line) {
      for (var j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
          return false;
        }
      }
      return true;
    }
    function sortSegments(line, owned) {
      if (!owned)
        line = line.slice();
      return line.sort(sortComparator2);
    }
    function sortComparator2(a, b) {
      return a[COLUMN] - b[COLUMN];
    }
    var found = false;
    function binarySearch(haystack, needle, low, high) {
      while (low <= high) {
        var mid = low + (high - low >> 1);
        var cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
          found = true;
          return mid;
        }
        if (cmp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      found = false;
      return low - 1;
    }
    function upperBound(haystack, needle, index3) {
      for (var i2 = index3 + 1; i2 < haystack.length; index3 = i2++) {
        if (haystack[i2][COLUMN] !== needle)
          break;
      }
      return index3;
    }
    function lowerBound(haystack, needle, index3) {
      for (var i2 = index3 - 1; i2 >= 0; index3 = i2--) {
        if (haystack[i2][COLUMN] !== needle)
          break;
      }
      return index3;
    }
    function memoizedState() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function memoizedBinarySearch(haystack, needle, state, key) {
      var lastKey = state.lastKey, lastNeedle = state.lastNeedle, lastIndex = state.lastIndex;
      var low = 0;
      var high = haystack.length - 1;
      if (key === lastKey) {
        if (needle === lastNeedle) {
          found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
          return lastIndex;
        }
        if (needle >= lastNeedle) {
          low = lastIndex === -1 ? 0 : lastIndex;
        } else {
          high = lastIndex;
        }
      }
      state.lastKey = key;
      state.lastNeedle = needle;
      return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    function buildBySources(decoded, memos) {
      var sources = memos.map(buildNullArray);
      for (var i2 = 0; i2 < decoded.length; i2++) {
        var line = decoded[i2];
        for (var j = 0; j < line.length; j++) {
          var seg = line[j];
          if (seg.length === 1)
            continue;
          var sourceIndex = seg[SOURCES_INDEX];
          var sourceLine = seg[SOURCE_LINE];
          var sourceColumn = seg[SOURCE_COLUMN];
          var originalSource = sources[sourceIndex];
          var originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
          var memo = memos[sourceIndex];
          var index3 = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
          insert(originalLine, memo.lastIndex = index3 + 1, [
            sourceColumn,
            i2,
            seg[COLUMN]
          ]);
        }
      }
      return sources;
    }
    function insert(array, index3, value1) {
      for (var i2 = array.length; i2 > index3; i2--) {
        array[i2] = array[i2 - 1];
      }
      array[index3] = value1;
    }
    function buildNullArray() {
      return {
        __proto__: null
      };
    }
    var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
    var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
    var LEAST_UPPER_BOUND = -1;
    var GREATEST_LOWER_BOUND = 1;
    var encodedMappings;
    var decodedMappings;
    var traceSegment;
    var originalPositionFor;
    var generatedPositionFor;
    var allGeneratedPositionsFor;
    var eachMapping;
    var sourceContentFor;
    var presortedDecodedMap;
    var decodedMap;
    var encodedMap;
    var TraceMap = function TraceMap2(map, mapUrl) {
      "use strict";
      _class_call_check(this, TraceMap2);
      var isString = typeof map === "string";
      if (!isString && map._decodedMemo)
        return map;
      var parsed = isString ? JSON.parse(map) : map;
      var version2 = parsed.version, file2 = parsed.file, names = parsed.names, sourceRoot = parsed.sourceRoot, sources = parsed.sources, sourcesContent = parsed.sourcesContent;
      this.version = version2;
      this.file = file2;
      this.names = names || [];
      this.sourceRoot = sourceRoot;
      this.sources = sources;
      this.sourcesContent = sourcesContent;
      var from = resolve2(sourceRoot || "", stripFilename(mapUrl));
      this.resolvedSources = sources.map(function(s) {
        return resolve2(s || "", from);
      });
      var mappings = parsed.mappings;
      if (typeof mappings === "string") {
        this._encoded = mappings;
        this._decoded = void 0;
      } else {
        this._encoded = void 0;
        this._decoded = maybeSort(mappings, isString);
      }
      this._decodedMemo = memoizedState();
      this._bySources = void 0;
      this._bySourceMemos = void 0;
    };
    (function() {
      var generatedPosition = function generatedPosition2(map, source, line, column, bias, all3) {
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        var sources = map.sources, resolvedSources = map.resolvedSources;
        var sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1)
          sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1)
          return all3 ? [] : GMapping(null, null);
        var generated = map._bySources || (map._bySources = buildBySources(decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
        var segments = generated[sourceIndex][line];
        if (segments == null)
          return all3 ? [] : GMapping(null, null);
        var memo = map._bySourceMemos[sourceIndex];
        if (all3)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        var index3 = traceSegmentInternal(segments, memo, line, column, bias);
        if (index3 === -1)
          return GMapping(null, null);
        var segment = segments[index3];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      };
      encodedMappings = function(map) {
        var _a;
        return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = encode(map._decoded);
      };
      decodedMappings = function(map) {
        return map._decoded || (map._decoded = decode2(map._encoded));
      };
      traceSegment = function(map, line, column) {
        var decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        var segments = decoded[line];
        var index3 = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index3 === -1 ? null : segments[index3];
      };
      originalPositionFor = function(map, param) {
        var line = param.line, column = param.column, bias = param.bias;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        var decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        var segments = decoded[line];
        var index3 = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index3 === -1)
          return OMapping(null, null, null, null);
        var segment = segments[index3];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        var names = map.names, resolvedSources = map.resolvedSources;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      };
      allGeneratedPositionsFor = function(map, param) {
        var source = param.source, line = param.line, column = param.column, bias = param.bias;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      };
      generatedPositionFor = function(map, param) {
        var source = param.source, line = param.line, column = param.column, bias = param.bias;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      };
      eachMapping = function(map, cb) {
        var decoded = decodedMappings(map);
        var names = map.names, resolvedSources = map.resolvedSources;
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            var generatedLine = i2 + 1;
            var generatedColumn = seg[0];
            var source = null;
            var originalLine = null;
            var originalColumn = null;
            var name2 = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name2 = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name: name2
            });
          }
        }
      };
      sourceContentFor = function(map, source) {
        var sources = map.sources, resolvedSources = map.resolvedSources, sourcesContent = map.sourcesContent;
        if (sourcesContent == null)
          return null;
        var index3 = sources.indexOf(source);
        if (index3 === -1)
          index3 = resolvedSources.indexOf(source);
        return index3 === -1 ? null : sourcesContent[index3];
      };
      presortedDecodedMap = function(map, mapUrl) {
        var tracer = new TraceMap(clone2(map, []), mapUrl);
        tracer._decoded = map.mappings;
        return tracer;
      };
      decodedMap = function(map) {
        return clone2(map, decodedMappings(map));
      };
      encodedMap = function(map) {
        return clone2(map, encodedMappings(map));
      };
    })();
    function clone2(map, mappings) {
      return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings
      };
    }
    function OMapping(source, line, column, name2) {
      return {
        source,
        line,
        column,
        name: name2
      };
    }
    function GMapping(line, column) {
      return {
        line,
        column
      };
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
      var index3 = memoizedBinarySearch(segments, column, memo, line);
      if (found) {
        index3 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index3);
      } else if (bias === LEAST_UPPER_BOUND)
        index3++;
      if (index3 === -1 || index3 === segments.length)
        return -1;
      return index3;
    }
    function sliceGeneratedPositions(segments, memo, line, column, bias) {
      var min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
      if (!found && bias === LEAST_UPPER_BOUND)
        min++;
      if (min === -1 || min === segments.length)
        return [];
      var matchedColumn = found ? column : segments[min][COLUMN];
      if (!found)
        min = lowerBound(segments, matchedColumn, min);
      var max = upperBound(segments, matchedColumn, min);
      var result = [];
      for (; min <= max; min++) {
        var segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
      }
      return result;
    }
    var COLUMN2 = 0;
    var SOURCES_INDEX2 = 1;
    var SOURCE_LINE2 = 2;
    var SOURCE_COLUMN2 = 3;
    var NAMES_INDEX2 = 4;
    var NO_NAME = -1;
    var addSegment;
    var addMapping;
    var maybeAddSegment;
    var maybeAddMapping;
    var setSourceContent;
    var toDecodedMap;
    var toEncodedMap;
    var fromMap;
    var allMappings;
    var addSegmentInternal;
    var GenMapping = function GenMapping2() {
      "use strict";
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, file2 = _ref.file, sourceRoot = _ref.sourceRoot;
      _class_call_check(this, GenMapping2);
      this._names = new SetArray();
      this._sources = new SetArray();
      this._sourcesContent = [];
      this._mappings = [];
      this.file = file2;
      this.sourceRoot = sourceRoot;
    };
    (function() {
      addSegment = function(map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3);
      };
      maybeAddSegment = function(map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3);
      };
      addMapping = function(map, mapping) {
        return addMappingInternal(false, map, mapping);
      };
      maybeAddMapping = function(map, mapping) {
        return addMappingInternal(true, map, mapping);
      };
      setSourceContent = function(map, source, content3) {
        var sources = map._sources, sourcesContent = map._sourcesContent;
        sourcesContent[put(sources, source)] = content3;
      };
      toDecodedMap = function(map) {
        var file2 = map.file, sourceRoot = map.sourceRoot, mappings = map._mappings, sources = map._sources, sourcesContent = map._sourcesContent, names = map._names;
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: file2 || void 0,
          names: names.array,
          sourceRoot: sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings
        };
      };
      toEncodedMap = function(map) {
        var decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), {
          mappings: encode(decoded.mappings)
        });
      };
      allMappings = function(map) {
        var out = [];
        var mappings = map._mappings, sources = map._sources, names = map._names;
        for (var i2 = 0; i2 < mappings.length; i2++) {
          var line = mappings[i2];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            var generated = {
              line: i2 + 1,
              column: seg[COLUMN2]
            };
            var source = void 0;
            var original = void 0;
            var name2 = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX2]];
              original = {
                line: seg[SOURCE_LINE2] + 1,
                column: seg[SOURCE_COLUMN2]
              };
              if (seg.length === 5)
                name2 = names.array[seg[NAMES_INDEX2]];
            }
            out.push({
              generated,
              source,
              original,
              name: name2
            });
          }
        }
        return out;
      };
      fromMap = function(input) {
        var map = new TraceMap(input);
        var gen = new GenMapping({
          file: map.file,
          sourceRoot: map.sourceRoot
        });
        putAll(gen._names, map.names);
        putAll(gen._sources, map.sources);
        gen._sourcesContent = map.sourcesContent || map.sources.map(function() {
          return null;
        });
        gen._mappings = decodedMappings(map);
        return gen;
      };
      addSegmentInternal = function(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) {
        var mappings = map._mappings, sources = map._sources, sourcesContent = map._sourcesContent, names = map._names;
        var line = getLine(mappings, genLine);
        var index3 = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index3))
            return;
          return insert2(line, index3, [
            genColumn
          ]);
        }
        var sourcesIndex = put(sources, source);
        var namesIndex = name2 ? put(names, name2) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content3 !== null && content3 !== void 0 ? content3 : null;
        if (skipable && skipSource(line, index3, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert2(line, index3, name2 ? [
          genColumn,
          sourcesIndex,
          sourceLine,
          sourceColumn,
          namesIndex
        ] : [
          genColumn,
          sourcesIndex,
          sourceLine,
          sourceColumn
        ]);
      };
    })();
    function getLine(mappings, index3) {
      for (var i2 = mappings.length; i2 <= index3; i2++) {
        mappings[i2] = [];
      }
      return mappings[index3];
    }
    function getColumnIndex(line, genColumn) {
      var index3 = line.length;
      for (var i2 = index3 - 1; i2 >= 0; index3 = i2--) {
        var current2 = line[i2];
        if (genColumn >= current2[COLUMN2])
          break;
      }
      return index3;
    }
    function insert2(array, index3, value1) {
      for (var i2 = array.length; i2 > index3; i2--) {
        array[i2] = array[i2 - 1];
      }
      array[index3] = value1;
    }
    function removeEmptyFinalLines(mappings) {
      var length = mappings.length;
      var len = length;
      for (var i2 = len - 1; i2 >= 0; len = i2, i2--) {
        if (mappings[i2].length > 0)
          break;
      }
      if (len < length)
        mappings.length = len;
    }
    function putAll(strarr, array) {
      for (var i2 = 0; i2 < array.length; i2++)
        put(strarr, array[i2]);
    }
    function skipSourceless(line, index3) {
      if (index3 === 0)
        return true;
      var prev = line[index3 - 1];
      return prev.length === 1;
    }
    function skipSource(line, index3, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
      if (index3 === 0)
        return false;
      var prev = line[index3 - 1];
      if (prev.length === 1)
        return false;
      return sourcesIndex === prev[SOURCES_INDEX2] && sourceLine === prev[SOURCE_LINE2] && sourceColumn === prev[SOURCE_COLUMN2] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
    }
    function addMappingInternal(skipable, map, mapping) {
      var generated = mapping.generated, source = mapping.source, original = mapping.original, name2 = mapping.name, content3 = mapping.content;
      if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
      }
      var s = source;
      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name2, content3);
    }
    var import_jsesc = __toESM2(require_jsesc2(), 1);
    var SourceMap = /* @__PURE__ */ function() {
      "use strict";
      function SourceMap2(opts, code22) {
        _class_call_check(this, SourceMap2);
        var _opts_sourceFileName;
        __publicField(this, "_map");
        __publicField(this, "_rawMappings");
        __publicField(this, "_sourceFileName");
        __publicField(this, "_lastGenLine", 0);
        __publicField(this, "_lastSourceLine", 0);
        __publicField(this, "_lastSourceColumn", 0);
        __publicField(this, "_inputMap");
        var map = this._map = new GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts_sourceFileName = opts.sourceFileName) === null || _opts_sourceFileName === void 0 ? void 0 : _opts_sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new TraceMap(opts.inputSourceMap);
          var resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (var i2 = 0; i2 < resolvedSources.length; i2++) {
              var _this__inputMap_sourcesContent;
              setSourceContent(map, resolvedSources[i2], (_this__inputMap_sourcesContent = this._inputMap.sourcesContent) === null || _this__inputMap_sourcesContent === void 0 ? void 0 : _this__inputMap_sourcesContent[i2]);
            }
          }
        }
        if (typeof code22 === "string" && !opts.inputSourceMap) {
          setSourceContent(map, this._sourceFileName, code22);
        } else if (typeof code22 === "object") {
          var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
          try {
            for (var _iterator8 = Object.keys(code22)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var sourceFileName = _step8.value;
              setSourceContent(map, sourceFileName.replace(/\\/g, "/"), code22[sourceFileName]);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }
      _create_class(SourceMap2, [
        {
          key: "get",
          value: function get3() {
            return toEncodedMap(this._map);
          }
        },
        {
          key: "getDecoded",
          value: function getDecoded() {
            return toDecodedMap(this._map);
          }
        },
        {
          key: "getRawMappings",
          value: function getRawMappings() {
            return this._rawMappings || (this._rawMappings = allMappings(this._map));
          }
        },
        {
          key: "mark",
          value: function mark2(generated, line, column, identifierName, identifierNamePos, filename) {
            this._rawMappings = void 0;
            var originalMapping;
            if (line != null) {
              if (this._inputMap) {
                originalMapping = originalPositionFor(this._inputMap, {
                  line,
                  column
                });
                if (!originalMapping.name && identifierNamePos) {
                  var originalIdentifierMapping = originalPositionFor(this._inputMap, identifierNamePos);
                  if (originalIdentifierMapping.name) {
                    identifierName = originalIdentifierMapping.name;
                  }
                }
              } else {
                originalMapping = {
                  source: (filename === null || filename === void 0 ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
                  line,
                  column
                };
              }
            }
            maybeAddMapping(this._map, {
              name: identifierName,
              generated,
              source: originalMapping === null || originalMapping === void 0 ? void 0 : originalMapping.source,
              original: originalMapping
            });
          }
        }
      ]);
      return SourceMap2;
    }();
    var Buffer2 = /* @__PURE__ */ function() {
      "use strict";
      function Buffer22(map, indentChar) {
        _class_call_check(this, Buffer22);
        __publicField(this, "_map", null);
        __publicField(this, "_buf", "");
        __publicField(this, "_str", "");
        __publicField(this, "_appendCount", 0);
        __publicField(this, "_last", 0);
        __publicField(this, "_queue", []);
        __publicField(this, "_queueCursor", 0);
        __publicField(this, "_canMarkIdName", true);
        __publicField(this, "_indentChar", "");
        __publicField(this, "_fastIndentations", []);
        __publicField(this, "_position", {
          line: 1,
          column: 0
        });
        __publicField(this, "_sourcePosition", {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        });
        this._map = map;
        this._indentChar = indentChar;
        for (var i2 = 0; i2 < 64; i2++) {
          this._fastIndentations.push(indentChar.repeat(i2));
        }
        this._allocQueue();
      }
      _create_class(Buffer22, [
        {
          key: "_allocQueue",
          value: function _allocQueue() {
            var queue = this._queue;
            for (var i2 = 0; i2 < 16; i2++) {
              queue.push({
                char: 0,
                repeat: 1,
                line: void 0,
                column: void 0,
                identifierName: void 0,
                identifierNamePos: void 0,
                filename: ""
              });
            }
          }
        },
        {
          key: "_pushQueue",
          value: function _pushQueue(char, repeat, line, column, filename) {
            var cursor = this._queueCursor;
            if (cursor === this._queue.length) {
              this._allocQueue();
            }
            var item = this._queue[cursor];
            item.char = char;
            item.repeat = repeat;
            item.line = line;
            item.column = column;
            item.filename = filename;
            this._queueCursor++;
          }
        },
        {
          key: "_popQueue",
          value: function _popQueue() {
            if (this._queueCursor === 0) {
              throw new Error("Cannot pop from empty queue");
            }
            return this._queue[--this._queueCursor];
          }
        },
        {
          key: "get",
          value: function get3() {
            this._flush();
            var map = this._map;
            var result = {
              code: (this._buf + this._str).trimRight(),
              decodedMap: map === null || map === void 0 ? void 0 : map.getDecoded(),
              get __mergedMap() {
                return this.map;
              },
              get map() {
                var resultMap = map ? map.get() : null;
                result.map = resultMap;
                return resultMap;
              },
              set map(value) {
                Object.defineProperty(result, "map", {
                  value,
                  writable: true
                });
              },
              get rawMappings() {
                var mappings = map === null || map === void 0 ? void 0 : map.getRawMappings();
                result.rawMappings = mappings;
                return mappings;
              },
              set rawMappings(value) {
                Object.defineProperty(result, "rawMappings", {
                  value,
                  writable: true
                });
              }
            };
            return result;
          }
        },
        {
          key: "append",
          value: function append(str, maybeNewline) {
            this._flush();
            this._append(str, this._sourcePosition, maybeNewline);
          }
        },
        {
          key: "appendChar",
          value: function appendChar(char) {
            this._flush();
            this._appendChar(char, 1, this._sourcePosition);
          }
        },
        {
          key: "queue",
          value: function queue(char) {
            if (char === 10) {
              while (this._queueCursor !== 0) {
                var char2 = this._queue[this._queueCursor - 1].char;
                if (char2 !== 32 && char2 !== 9) {
                  break;
                }
                this._queueCursor--;
              }
            }
            var sourcePosition = this._sourcePosition;
            this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
          }
        },
        {
          key: "queueIndentation",
          value: function queueIndentation(repeat) {
            if (repeat === 0)
              return;
            this._pushQueue(-1, repeat, void 0, void 0, void 0);
          }
        },
        {
          key: "_flush",
          value: function _flush() {
            var queueCursor = this._queueCursor;
            var queue = this._queue;
            for (var i2 = 0; i2 < queueCursor; i2++) {
              var item = queue[i2];
              this._appendChar(item.char, item.repeat, item);
            }
            this._queueCursor = 0;
          }
        },
        {
          key: "_appendChar",
          value: function _appendChar(char, repeat, sourcePos) {
            this._last = char;
            if (char === -1) {
              var fastIndentation = this._fastIndentations[repeat];
              if (fastIndentation !== void 0) {
                this._str += fastIndentation;
              } else {
                this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
              }
            } else {
              this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
            }
            if (char !== 10) {
              this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
              this._position.column += repeat;
            } else {
              this._position.line++;
              this._position.column = 0;
            }
            if (this._canMarkIdName) {
              sourcePos.identifierName = void 0;
              sourcePos.identifierNamePos = void 0;
            }
          }
        },
        {
          key: "_append",
          value: function _append(str, sourcePos, maybeNewline) {
            var len = str.length;
            var position3 = this._position;
            this._last = str.charCodeAt(len - 1);
            if (++this._appendCount > 4096) {
              +this._str;
              this._buf += this._str;
              this._str = str;
              this._appendCount = 0;
            } else {
              this._str += str;
            }
            if (!maybeNewline && !this._map) {
              position3.column += len;
              return;
            }
            var column = sourcePos.column, identifierName = sourcePos.identifierName, identifierNamePos = sourcePos.identifierNamePos, filename = sourcePos.filename;
            var line = sourcePos.line;
            if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
              sourcePos.identifierName = void 0;
              sourcePos.identifierNamePos = void 0;
            }
            var i2 = str.indexOf("\n");
            var last2 = 0;
            if (i2 !== 0) {
              this._mark(line, column, identifierName, identifierNamePos, filename);
            }
            while (i2 !== -1) {
              position3.line++;
              position3.column = 0;
              last2 = i2 + 1;
              if (last2 < len && line !== void 0) {
                this._mark(++line, 0, null, null, filename);
              }
              i2 = str.indexOf("\n", last2);
            }
            position3.column += len - last2;
          }
        },
        {
          key: "_mark",
          value: function _mark(line, column, identifierName, identifierNamePos, filename) {
            var _this__map;
            (_this__map = this._map) === null || _this__map === void 0 ? void 0 : _this__map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
          }
        },
        {
          key: "removeTrailingNewline",
          value: function removeTrailingNewline() {
            var queueCursor = this._queueCursor;
            if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
              this._queueCursor--;
            }
          }
        },
        {
          key: "removeLastSemicolon",
          value: function removeLastSemicolon() {
            var queueCursor = this._queueCursor;
            if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
              this._queueCursor--;
            }
          }
        },
        {
          key: "getLastChar",
          value: function getLastChar() {
            var queueCursor = this._queueCursor;
            return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
          }
        },
        {
          key: "getNewlineCount",
          value: function getNewlineCount() {
            var queueCursor = this._queueCursor;
            var count = 0;
            if (queueCursor === 0)
              return this._last === 10 ? 1 : 0;
            for (var i2 = queueCursor - 1; i2 >= 0; i2--) {
              if (this._queue[i2].char !== 10) {
                break;
              }
              count++;
            }
            return count === queueCursor && this._last === 10 ? count + 1 : count;
          }
        },
        {
          key: "endsWithCharAndNewline",
          value: function endsWithCharAndNewline() {
            var queue = this._queue;
            var queueCursor = this._queueCursor;
            if (queueCursor !== 0) {
              var lastCp = queue[queueCursor - 1].char;
              if (lastCp !== 10)
                return;
              if (queueCursor > 1) {
                return queue[queueCursor - 2].char;
              } else {
                return this._last;
              }
            }
          }
        },
        {
          key: "hasContent",
          value: function hasContent() {
            return this._queueCursor !== 0 || !!this._last;
          }
        },
        {
          key: "exactSource",
          value: function exactSource(loc, cb) {
            if (!this._map) {
              cb();
              return;
            }
            this.source("start", loc);
            var identifierName = loc.identifierName;
            var sourcePos = this._sourcePosition;
            if (identifierName) {
              this._canMarkIdName = false;
              sourcePos.identifierName = identifierName;
            }
            cb();
            if (identifierName) {
              this._canMarkIdName = true;
              sourcePos.identifierName = void 0;
              sourcePos.identifierNamePos = void 0;
            }
            this.source("end", loc);
          }
        },
        {
          key: "source",
          value: function source(prop, loc) {
            if (!this._map)
              return;
            this._normalizePosition(prop, loc, 0);
          }
        },
        {
          key: "sourceWithOffset",
          value: function sourceWithOffset(prop, loc, columnOffset) {
            if (!this._map)
              return;
            this._normalizePosition(prop, loc, columnOffset);
          }
        },
        {
          key: "withSource",
          value: function withSource(prop, loc, cb) {
            if (this._map) {
              this.source(prop, loc);
            }
            cb();
          }
        },
        {
          key: "_normalizePosition",
          value: function _normalizePosition(prop, loc, columnOffset) {
            var pos = loc[prop];
            var target = this._sourcePosition;
            if (pos) {
              target.line = pos.line;
              target.column = Math.max(pos.column + columnOffset, 0);
              target.filename = loc.filename;
            }
          }
        },
        {
          key: "getCurrentColumn",
          value: function getCurrentColumn() {
            var queue = this._queue;
            var queueCursor = this._queueCursor;
            var lastIndex = -1;
            var len = 0;
            for (var i2 = 0; i2 < queueCursor; i2++) {
              var item = queue[i2];
              if (item.char === 10) {
                lastIndex = len;
              }
              len += item.repeat;
            }
            return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
          }
        },
        {
          key: "getCurrentLine",
          value: function getCurrentLine() {
            var count = 0;
            var queue = this._queue;
            for (var i2 = 0; i2 < this._queueCursor; i2++) {
              if (queue[i2].char === 10) {
                count++;
              }
            }
            return this._position.line + count;
          }
        }
      ]);
      return Buffer22;
    }();
    var FLIPPED_ALIAS_KEYS$1 = lib_exports.FLIPPED_ALIAS_KEYS;
    var isArrayExpression22 = lib_exports.isArrayExpression;
    var isAssignmentExpression2 = lib_exports.isAssignmentExpression;
    var isBinary2 = lib_exports.isBinary;
    var isBlockStatement2 = lib_exports.isBlockStatement;
    var isCallExpression$3 = lib_exports.isCallExpression;
    var isFunction$1 = lib_exports.isFunction;
    var isIdentifier$2 = lib_exports.isIdentifier;
    var isLiteral$1 = lib_exports.isLiteral;
    var isMemberExpression$3 = lib_exports.isMemberExpression;
    var isObjectExpression2 = lib_exports.isObjectExpression;
    var isOptionalCallExpression2 = lib_exports.isOptionalCallExpression;
    var isOptionalMemberExpression$1 = lib_exports.isOptionalMemberExpression;
    var isStringLiteral3 = lib_exports.isStringLiteral;
    function crawlInternal(node2, state) {
      if (!node2)
        return state;
      if (isMemberExpression$3(node2) || isOptionalMemberExpression$1(node2)) {
        crawlInternal(node2.object, state);
        if (node2.computed)
          crawlInternal(node2.property, state);
      } else if (isBinary2(node2) || isAssignmentExpression2(node2)) {
        crawlInternal(node2.left, state);
        crawlInternal(node2.right, state);
      } else if (isCallExpression$3(node2) || isOptionalCallExpression2(node2)) {
        state.hasCall = true;
        crawlInternal(node2.callee, state);
      } else if (isFunction$1(node2)) {
        state.hasFunction = true;
      } else if (isIdentifier$2(node2)) {
        state.hasHelper = state.hasHelper || node2.callee && isHelper(node2.callee);
      }
      return state;
    }
    function crawl(node2) {
      return crawlInternal(node2, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node2) {
      if (!node2)
        return false;
      if (isMemberExpression$3(node2)) {
        return isHelper(node2.object) || isHelper(node2.property);
      } else if (isIdentifier$2(node2)) {
        return node2.name === "require" || node2.name.charCodeAt(0) === 95;
      } else if (isCallExpression$3(node2)) {
        return isHelper(node2.callee);
      } else if (isBinary2(node2) || isAssignmentExpression2(node2)) {
        return isIdentifier$2(node2.left) && isHelper(node2.left) || isHelper(node2.right);
      } else {
        return false;
      }
    }
    function isType2(node2) {
      return isLiteral$1(node2) || isObjectExpression2(node2) || isArrayExpression22(node2) || isIdentifier$2(node2) || isMemberExpression$3(node2);
    }
    var nodes = {
      AssignmentExpression: function AssignmentExpression3(node2) {
        var state = crawl(node2.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase: function SwitchCase2(node2, parent) {
        return (!!node2.consequent.length || parent.cases[0] === node2 ? 1 : 0) | (!node2.consequent.length && parent.cases[parent.cases.length - 1] === node2 ? 2 : 0);
      },
      LogicalExpression: function LogicalExpression3(node2) {
        if (isFunction$1(node2.left) || isFunction$1(node2.right)) {
          return 2;
        }
      },
      Literal: function Literal(node2) {
        if (isStringLiteral3(node2) && node2.value === "use strict") {
          return 2;
        }
      },
      CallExpression: function CallExpression3(node2) {
        if (isFunction$1(node2.callee) || isHelper(node2)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression: function OptionalCallExpression2(node2) {
        if (isFunction$1(node2.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration: function VariableDeclaration2(node2) {
        for (var i2 = 0; i2 < node2.declarations.length; i2++) {
          var declar = node2.declarations[i2];
          var enabled = isHelper(declar.id) && !isType2(declar.init);
          if (!enabled && declar.init) {
            var state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement: function IfStatement2(node2) {
        if (isBlockStatement2(node2.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node2, parent) {
      if (parent.properties[0] === node2) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node2, parent) {
      var _parent_properties;
      if (parent.callProperties[0] === node2 && !((_parent_properties = parent.properties) === null || _parent_properties === void 0 ? void 0 : _parent_properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node2, parent) {
      var _parent_properties, _parent_callProperties;
      if (parent.indexers[0] === node2 && !((_parent_properties = parent.properties) === null || _parent_properties === void 0 ? void 0 : _parent_properties.length) && !((_parent_callProperties = parent.callProperties) === null || _parent_callProperties === void 0 ? void 0 : _parent_callProperties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node2, parent) {
      var _parent_properties, _parent_callProperties, _parent_indexers;
      if (parent.internalSlots[0] === node2 && !((_parent_properties = parent.properties) === null || _parent_properties === void 0 ? void 0 : _parent_properties.length) && !((_parent_callProperties = parent.callProperties) === null || _parent_callProperties === void 0 ? void 0 : _parent_callProperties.length) && !((_parent_indexers = parent.indexers) === null || _parent_indexers === void 0 ? void 0 : _parent_indexers.length)) {
        return 1;
      }
    };
    [
      [
        "Function",
        true
      ],
      [
        "Class",
        true
      ],
      [
        "Loop",
        true
      ],
      [
        "LabeledStatement",
        true
      ],
      [
        "SwitchStatement",
        true
      ],
      [
        "TryStatement",
        true
      ]
    ].forEach(function(param) {
      var _$_param = _sliced_to_array(param, 2), type3 = _$_param[0], amounts = _$_param[1];
      [
        type3
      ].concat(FLIPPED_ALIAS_KEYS$1[type3] || []).forEach(function(type22) {
        var ret = amounts ? 1 | 2 : 0;
        nodes[type22] = function() {
          return ret;
        };
      });
    });
    var isArrayTypeAnnotation2 = lib_exports.isArrayTypeAnnotation;
    var isArrowFunctionExpression2 = lib_exports.isArrowFunctionExpression;
    var isBinaryExpression2 = lib_exports.isBinaryExpression;
    var isCallExpression$2 = lib_exports.isCallExpression;
    var isExportDeclaration2 = lib_exports.isExportDeclaration;
    var isForOfStatement2 = lib_exports.isForOfStatement;
    var isIndexedAccessType2 = lib_exports.isIndexedAccessType;
    var isMemberExpression$2 = lib_exports.isMemberExpression;
    var isObjectPattern2 = lib_exports.isObjectPattern;
    var isOptionalMemberExpression2 = lib_exports.isOptionalMemberExpression;
    var isYieldExpression2 = lib_exports.isYieldExpression;
    var PRECEDENCE = /* @__PURE__ */ new Map([
      [
        "||",
        0
      ],
      [
        "??",
        0
      ],
      [
        "|>",
        0
      ],
      [
        "&&",
        1
      ],
      [
        "|",
        2
      ],
      [
        "^",
        3
      ],
      [
        "&",
        4
      ],
      [
        "==",
        5
      ],
      [
        "===",
        5
      ],
      [
        "!=",
        5
      ],
      [
        "!==",
        5
      ],
      [
        "<",
        6
      ],
      [
        ">",
        6
      ],
      [
        "<=",
        6
      ],
      [
        ">=",
        6
      ],
      [
        "in",
        6
      ],
      [
        "instanceof",
        6
      ],
      [
        ">>",
        7
      ],
      [
        "<<",
        7
      ],
      [
        ">>>",
        7
      ],
      [
        "+",
        8
      ],
      [
        "-",
        8
      ],
      [
        "*",
        9
      ],
      [
        "/",
        9
      ],
      [
        "%",
        9
      ],
      [
        "**",
        10
      ]
    ]);
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = function(node2, parent) {
      var parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node2;
    };
    var hasPostfixPart = function(node2, parent) {
      var parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node2 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node2 || parentType === "TaggedTemplateExpression" && parent.tag === node2 || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation$1(node2, parent) {
      return isArrayTypeAnnotation2(parent);
    }
    function FunctionTypeAnnotation$1(node2, parent, printStack) {
      if (printStack.length < 3)
        return;
      var parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || parentType === "TypeAnnotation" && isArrowFunctionExpression2(printStack[printStack.length - 3]);
    }
    function UpdateExpression$1(node2, parent) {
      return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent);
    }
    function ObjectExpression$1(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 2);
    }
    function DoExpression$1(node2, parent, printStack) {
      return !node2.async && isFirstInContext(printStack, 1);
    }
    function Binary(node2, parent) {
      var parentType = parent.type;
      if (node2.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node2;
      }
      if (isClassExtendsClause(node2, parent)) {
        return true;
      }
      if (hasPostfixPart(node2, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      if (parentType === "BinaryExpression" || parentType === "LogicalExpression") {
        var parentPos = PRECEDENCE.get(parent.operator);
        var nodePos = PRECEDENCE.get(node2.operator);
        if (parentPos === nodePos && parent.right === node2 && parentType !== "LogicalExpression" || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation$1(node2, parent) {
      var parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType$1(node2, parent) {
      return isIndexedAccessType2(parent) && parent.objectType === node2;
    }
    function TSAsExpression() {
      return true;
    }
    function TSUnionType$1(node2, parent) {
      var parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSOptionalType" || parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSRestType";
    }
    function TSInferType$1(node2, parent) {
      var parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression$1(node2, parent) {
      var parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function BinaryExpression2(node2, parent) {
      if (node2.operator === "in") {
        var parentType = parent.type;
        return parentType === "VariableDeclarator" || parentType === "ForStatement" || parentType === "ForInStatement" || parentType === "ForOfStatement";
      }
      return false;
    }
    function SequenceExpression$1(node2, parent) {
      var parentType = parent.type;
      if (parentType === "ForStatement" || parentType === "ThrowStatement" || parentType === "ReturnStatement" || parentType === "IfStatement" && parent.test === node2 || parentType === "WhileStatement" && parent.test === node2 || parentType === "ForInStatement" && parent.right === node2 || parentType === "SwitchStatement" && parent.discriminant === node2 || parentType === "ExpressionStatement" && parent.expression === node2) {
        return false;
      }
      return true;
    }
    function YieldExpression$1(node2, parent) {
      var parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node2, parent) || parentType === "AwaitExpression" && isYieldExpression2(node2) || parentType === "ConditionalExpression" && node2 === parent.test || isClassExtendsClause(node2, parent);
    }
    function ClassExpression(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 4);
    }
    function UnaryLike(node2, parent) {
      return hasPostfixPart(node2, parent) || isBinaryExpression2(parent) && parent.operator === "**" && parent.left === node2 || isClassExtendsClause(node2, parent);
    }
    function FunctionExpression$1(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 4);
    }
    function ArrowFunctionExpression$1(node2, parent) {
      return isExportDeclaration2(parent) || ConditionalExpression$1(node2, parent);
    }
    function ConditionalExpression$1(node2, parent) {
      var parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node2 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node2, parent);
    }
    function OptionalMemberExpression$1(node2, parent) {
      return isCallExpression$2(parent) && parent.callee === node2 || isMemberExpression$2(parent) && parent.object === node2;
    }
    function AssignmentExpression$1(node2, parent) {
      if (isObjectPattern2(node2.left)) {
        return true;
      } else {
        return ConditionalExpression$1(node2, parent);
      }
    }
    function LogicalExpression(node2, parent) {
      var parentType = parent.type;
      if (isTSTypeExpression(parentType))
        return true;
      if (parentType !== "LogicalExpression")
        return false;
      switch (node2.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier$1(node2, parent, printStack) {
      var _node_extra;
      var parentType = parent.type;
      if (((_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.parenthesized) && parentType === "AssignmentExpression" && parent.left === node2) {
        var rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (node2.name === "let") {
        var isFollowedByBracket = isMemberExpression$2(parent, {
          object: node2,
          computed: true
        }) || isOptionalMemberExpression2(parent, {
          object: node2,
          computed: true,
          optional: false
        });
        return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
      }
      return node2.name === "async" && isForOfStatement2(parent) && node2 === parent.left;
    }
    function isFirstInContext(printStack, checkParam) {
      var expressionStatement5 = checkParam & 1;
      var arrowBody = checkParam & 2;
      var exportDefault = checkParam & 4;
      var forHead = checkParam & 8;
      var forInHead = checkParam & 16;
      var forOfHead = checkParam & 32;
      var i2 = printStack.length - 1;
      if (i2 <= 0)
        return;
      var node2 = printStack[i2];
      i2--;
      var parent = printStack[i2];
      while (i2 >= 0) {
        var parentType = parent.type;
        if (expressionStatement5 && parentType === "ExpressionStatement" && parent.expression === node2 || exportDefault && parentType === "ExportDefaultDeclaration" && node2 === parent.declaration || arrowBody && parentType === "ArrowFunctionExpression" && parent.body === node2 || forHead && parentType === "ForStatement" && parent.init === node2 || forInHead && parentType === "ForInStatement" && parent.left === node2 || forOfHead && parentType === "ForOfStatement" && parent.left === node2) {
          return true;
        }
        if (i2 > 0 && (hasPostfixPart(node2, parent) && parentType !== "NewExpression" || parentType === "SequenceExpression" && parent.expressions[0] === node2 || parentType === "UpdateExpression" && !parent.prefix || parentType === "ConditionalExpression" && parent.test === node2 || (parentType === "BinaryExpression" || parentType === "LogicalExpression") && parent.left === node2 || parentType === "AssignmentExpression" && parent.left === node2)) {
          node2 = parent;
          i2--;
          parent = printStack[i2];
        } else {
          return false;
        }
      }
      return false;
    }
    var parens = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArrowFunctionExpression: ArrowFunctionExpression$1,
      AssignmentExpression: AssignmentExpression$1,
      AwaitExpression: YieldExpression$1,
      Binary,
      BinaryExpression: BinaryExpression2,
      ClassExpression,
      ConditionalExpression: ConditionalExpression$1,
      DoExpression: DoExpression$1,
      FunctionExpression: FunctionExpression$1,
      FunctionTypeAnnotation: FunctionTypeAnnotation$1,
      Identifier: Identifier$1,
      IntersectionTypeAnnotation: UnionTypeAnnotation$1,
      LogicalExpression,
      NullableTypeAnnotation: NullableTypeAnnotation$1,
      ObjectExpression: ObjectExpression$1,
      OptionalCallExpression: OptionalMemberExpression$1,
      OptionalIndexedAccessType: OptionalIndexedAccessType$1,
      OptionalMemberExpression: OptionalMemberExpression$1,
      SequenceExpression: SequenceExpression$1,
      TSAsExpression,
      TSInferType: TSInferType$1,
      TSInstantiationExpression: TSInstantiationExpression$1,
      TSIntersectionType: TSUnionType$1,
      TSSatisfiesExpression: TSAsExpression,
      TSTypeAssertion: TSAsExpression,
      TSUnionType: TSUnionType$1,
      UnaryLike,
      UnionTypeAnnotation: UnionTypeAnnotation$1,
      UpdateExpression: UpdateExpression$1,
      YieldExpression: YieldExpression$1
    });
    var FLIPPED_ALIAS_KEYS2 = lib_exports.FLIPPED_ALIAS_KEYS;
    var isCallExpression$1 = lib_exports.isCallExpression;
    var isExpressionStatement3 = lib_exports.isExpressionStatement;
    var isMemberExpression$1 = lib_exports.isMemberExpression;
    var isNewExpression$1 = lib_exports.isNewExpression;
    function expandAliases(obj) {
      var map = /* @__PURE__ */ new Map();
      function add(type4, func) {
        var fn = map.get(type4);
        map.set(type4, fn ? function(node2, parent, stack) {
          var _fn;
          return (_fn = fn(node2, parent, stack)) !== null && _fn !== void 0 ? _fn : func(node2, parent, stack);
        } : func);
      }
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(obj)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var type3 = _step8.value;
          var aliases = FLIPPED_ALIAS_KEYS2[type3];
          if (aliases) {
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = aliases[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var alias2 = _step12.value;
                add(alias2, obj[type3]);
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          } else {
            add(type3, obj[type3]);
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(nodes);
    function isOrHasCallExpression(node2) {
      if (isCallExpression$1(node2)) {
        return true;
      }
      return isMemberExpression$1(node2) && isOrHasCallExpression(node2.object);
    }
    function needsWhitespace(node2, parent, type3) {
      var _expandedWhitespaceNodes_get;
      if (!node2)
        return false;
      if (isExpressionStatement3(node2)) {
        node2 = node2.expression;
      }
      var flag = (_expandedWhitespaceNodes_get = expandedWhitespaceNodes.get(node2.type)) === null || _expandedWhitespaceNodes_get === void 0 ? void 0 : _expandedWhitespaceNodes_get(node2, parent);
      if (typeof flag === "number") {
        return (flag & type3) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node2, parent) {
      return needsWhitespace(node2, parent, 1);
    }
    function needsWhitespaceAfter(node2, parent) {
      return needsWhitespace(node2, parent, 2);
    }
    function needsParens$1(node2, parent, printStack) {
      var _expandedParens_get;
      if (!parent)
        return false;
      if (isNewExpression$1(parent) && parent.callee === node2) {
        if (isOrHasCallExpression(node2))
          return true;
      }
      return (_expandedParens_get = expandedParens.get(node2.type)) === null || _expandedParens_get === void 0 ? void 0 : _expandedParens_get(node2, parent, printStack);
    }
    var n = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      needsParens: needsParens$1,
      needsWhitespace,
      needsWhitespaceAfter,
      needsWhitespaceBefore
    });
    function TaggedTemplateExpression(node2) {
      this.print(node2.tag, node2);
      this.print(node2.typeParameters, node2);
      this.print(node2.quasi, node2);
    }
    function TemplateElement(node2, parent) {
      var isFirst = parent.quasis[0] === node2;
      var isLast = parent.quasis[parent.quasis.length - 1] === node2;
      var value1 = (isFirst ? "`" : "}") + node2.value.raw + (isLast ? "`" : "${");
      this.token(value1, true);
    }
    function TemplateLiteral(node2) {
      var quasis = node2.quasis;
      for (var i2 = 0; i2 < quasis.length; i2++) {
        this.print(quasis[i2], node2);
        if (i2 + 1 < quasis.length) {
          this.print(node2.expressions[i2], node2);
        }
      }
    }
    var isCallExpression3 = lib_exports.isCallExpression;
    var isLiteral2 = lib_exports.isLiteral;
    var isMemberExpression2 = lib_exports.isMemberExpression;
    var isNewExpression3 = lib_exports.isNewExpression;
    function UnaryExpression(node2) {
      var operator = node2.operator;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node2.argument, node2);
    }
    function DoExpression(node2) {
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node2.body, node2);
    }
    function ParenthesizedExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression, node2);
      this.rightParens(node2);
    }
    function UpdateExpression(node2) {
      if (node2.prefix) {
        this.token(node2.operator);
        this.print(node2.argument, node2);
      } else {
        this.printTerminatorless(node2.argument, node2, true);
        this.token(node2.operator);
      }
    }
    function ConditionalExpression(node2) {
      this.print(node2.test, node2);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node2.consequent, node2);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node2.alternate, node2);
    }
    function NewExpression(node2, parent) {
      this.word("new");
      this.space();
      this.print(node2.callee, node2);
      if (this.format.minified && node2.arguments.length === 0 && !node2.optional && !isCallExpression3(parent, {
        callee: node2
      }) && !isMemberExpression2(parent) && !isNewExpression3(parent)) {
        return;
      }
      this.print(node2.typeArguments, node2);
      this.print(node2.typeParameters, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function SequenceExpression(node2) {
      this.printList(node2.expressions, node2);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function isDecoratorMemberExpression(node2) {
      switch (node2.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node2.computed && node2.property.type === "Identifier" && isDecoratorMemberExpression(node2.object);
        default:
          return false;
      }
    }
    function shouldParenthesizeDecoratorExpression(node2) {
      if (node2.type === "ParenthesizedExpression") {
        return false;
      }
      return !isDecoratorMemberExpression(node2.type === "CallExpression" ? node2.callee : node2);
    }
    function _shouldPrintDecoratorsBeforeExport(node2) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node2.start === "number" && node2.start === node2.declaration.start;
    }
    function Decorator(node2) {
      this.tokenChar(64);
      var expression2 = node2.expression;
      if (shouldParenthesizeDecoratorExpression(expression2)) {
        this.tokenChar(40);
        this.print(expression2, node2);
        this.tokenChar(41);
      } else {
        this.print(expression2, node2);
      }
      this.newline();
    }
    function OptionalMemberExpression(node2) {
      var computed = node2.computed;
      var optional = node2.optional, property = node2.property;
      this.print(node2.object, node2);
      if (!computed && isMemberExpression2(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral2(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property, node2);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property, node2);
      }
    }
    function OptionalCallExpression(node2) {
      this.print(node2.callee, node2);
      this.print(node2.typeParameters, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.print(node2.typeArguments, node2);
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function CallExpression(node2) {
      this.print(node2.callee, node2);
      this.print(node2.typeArguments, node2);
      this.print(node2.typeParameters, node2);
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node2) {
      this.word("await");
      if (node2.argument) {
        this.space();
        this.printTerminatorless(node2.argument, node2, false);
      }
    }
    function YieldExpression(node2) {
      this.word("yield", true);
      if (node2.delegate) {
        this.tokenChar(42);
        if (node2.argument) {
          this.space();
          this.print(node2.argument, node2);
        }
      } else {
        if (node2.argument) {
          this.space();
          this.printTerminatorless(node2.argument, node2, false);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node2) {
      this.print(node2.expression, node2);
      this.semicolon();
    }
    function AssignmentPattern(node2) {
      this.print(node2.left, node2);
      if (node2.left.optional)
        this.tokenChar(63);
      this.print(node2.left.typeAnnotation, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right, node2);
    }
    function AssignmentExpression(node2, parent) {
      var parens2 = this.inForStatementInitCounter && node2.operator === "in" && !needsParens$1(node2, parent);
      if (parens2) {
        this.tokenChar(40);
      }
      this.print(node2.left, node2);
      this.space();
      if (node2.operator === "in" || node2.operator === "instanceof") {
        this.word(node2.operator);
      } else {
        this.token(node2.operator);
      }
      this.space();
      this.print(node2.right, node2);
      if (parens2) {
        this.tokenChar(41);
      }
    }
    function BindExpression(node2) {
      this.print(node2.object, node2);
      this.token("::");
      this.print(node2.callee, node2);
    }
    function MemberExpression(node2) {
      this.print(node2.object, node2);
      if (!node2.computed && isMemberExpression2(node2.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      var computed = node2.computed;
      if (isLiteral2(node2.property) && typeof node2.property.value === "number") {
        computed = true;
      }
      if (computed) {
        this.tokenChar(91);
        this.print(node2.property, node2);
        this.tokenChar(93);
      } else {
        this.tokenChar(46);
        this.print(node2.property, node2);
      }
    }
    function MetaProperty(node2) {
      this.print(node2.meta, node2);
      this.tokenChar(46);
      this.print(node2.property, node2);
    }
    function PrivateName(node2) {
      this.tokenChar(35);
      this.print(node2.id, node2);
    }
    function V8IntrinsicIdentifier(node2) {
      this.tokenChar(37);
      this.word(node2.name);
    }
    function ModuleExpression(node2) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      var body = node2.body;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body, node2);
      this.dedent();
      this.rightBrace(node2);
    }
    var isFor2 = lib_exports.isFor;
    var isForStatement2 = lib_exports.isForStatement;
    var isIfStatement2 = lib_exports.isIfStatement;
    var isStatement$3 = lib_exports.isStatement;
    function WithStatement(node2) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node2.object, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function IfStatement(node2) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.space();
      var needsBlock = node2.alternate && isIfStatement2(getLastStatement(node2.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node2.consequent, node2);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node2.alternate) {
        if (this.endsWith(125))
          this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node2.alternate, node2);
      }
    }
    function getLastStatement(statement2) {
      var body = statement2.body;
      if (isStatement$3(body) === false) {
        return statement2;
      }
      return getLastStatement(body);
    }
    function ForStatement(node2) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      this.inForStatementInitCounter++;
      this.print(node2.init, node2);
      this.inForStatementInitCounter--;
      this.tokenChar(59);
      if (node2.test) {
        this.space();
        this.print(node2.test, node2);
      }
      this.tokenChar(59);
      if (node2.update) {
        this.space();
        this.print(node2.update, node2);
      }
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function WhileStatement(node2) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function ForXStatement(node2) {
      this.word("for");
      this.space();
      var isForOf = node2.type === "ForOfStatement";
      if (isForOf && node2.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      this.print(node2.left, node2);
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node2.right, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    var ForInStatement2 = ForXStatement;
    var ForOfStatement = ForXStatement;
    function DoWhileStatement(node2) {
      this.word("do");
      this.space();
      this.print(node2.body, node2);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node2, parent, isLabel) {
      if (node2) {
        printer.space();
        printer.printTerminatorless(node2, parent, isLabel);
      }
      printer.semicolon();
    }
    function BreakStatement(node2) {
      this.word("break");
      printStatementAfterKeyword(this, node2.label, node2, true);
    }
    function ContinueStatement(node2) {
      this.word("continue");
      printStatementAfterKeyword(this, node2.label, node2, true);
    }
    function ReturnStatement(node2) {
      this.word("return");
      printStatementAfterKeyword(this, node2.argument, node2, false);
    }
    function ThrowStatement(node2) {
      this.word("throw");
      printStatementAfterKeyword(this, node2.argument, node2, false);
    }
    function LabeledStatement(node2) {
      this.print(node2.label, node2);
      this.tokenChar(58);
      this.space();
      this.print(node2.body, node2);
    }
    function TryStatement(node2) {
      this.word("try");
      this.space();
      this.print(node2.block, node2);
      this.space();
      if (node2.handlers) {
        this.print(node2.handlers[0], node2);
      } else {
        this.print(node2.handler, node2);
      }
      if (node2.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node2.finalizer, node2);
      }
    }
    function CatchClause(node2) {
      this.word("catch");
      this.space();
      if (node2.param) {
        this.tokenChar(40);
        this.print(node2.param, node2);
        this.print(node2.param.typeAnnotation, node2);
        this.tokenChar(41);
        this.space();
      }
      this.print(node2.body, node2);
    }
    function SwitchStatement(node2) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node2.discriminant, node2);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node2.cases, node2, {
        indent: true,
        addNewlines: function addNewlines(leading, cas) {
          if (!leading && node2.cases[node2.cases.length - 1] === cas)
            return -1;
        }
      });
      this.rightBrace(node2);
    }
    function SwitchCase(node2) {
      if (node2.test) {
        this.word("case");
        this.space();
        this.print(node2.test, node2);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node2.consequent.length) {
        this.newline();
        this.printSequence(node2.consequent, node2, {
          indent: true
        });
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node2, parent) {
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      var kind = node2.kind;
      this.word(kind, kind === "using" || kind === "await using");
      this.space();
      var hasInits = false;
      if (!isFor2(parent)) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = node2.declarations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var declar = _step8.value;
            if (declar.init) {
              hasInits = true;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      this.printList(node2.declarations, node2, {
        separator: hasInits ? function() {
          this.tokenChar(44);
          this.newline();
        } : void 0,
        indent: node2.declarations.length > 1 ? true : false
      });
      if (isFor2(parent)) {
        if (isForStatement2(parent)) {
          if (parent.init === node2)
            return;
        } else {
          if (parent.left === node2)
            return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node2) {
      this.print(node2.id, node2);
      if (node2.definite)
        this.tokenChar(33);
      this.print(node2.id.typeAnnotation, node2);
      if (node2.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.init, node2);
      }
    }
    var isExportDefaultDeclaration2 = lib_exports.isExportDefaultDeclaration;
    var isExportNamedDeclaration2 = lib_exports.isExportNamedDeclaration;
    function ClassDeclaration(node2, parent) {
      var inExport = isExportDefaultDeclaration2(parent) || isExportNamedDeclaration2(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node2.decorators, node2);
      }
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node2.id) {
        this.space();
        this.print(node2.id, node2);
      }
      this.print(node2.typeParameters, node2);
      if (node2.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node2.superClass, node2);
        this.print(node2.superTypeParameters, node2);
      }
      if (node2.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node2.implements, node2);
      }
      this.space();
      this.print(node2.body, node2);
    }
    function ClassBody(node2) {
      this.tokenChar(123);
      if (node2.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node2.body, node2, {
          indent: true
        });
        if (!this.endsWith(10))
          this.newline();
        this.rightBrace(node2);
      }
    }
    function ClassProperty(node2) {
      var _node_key_loc_end, _node_key_loc;
      this.printJoin(node2.decorators, node2);
      var endLine = (_node_key_loc = node2.key.loc) === null || _node_key_loc === void 0 ? void 0 : (_node_key_loc_end = _node_key_loc.end) === null || _node_key_loc_end === void 0 ? void 0 : _node_key_loc_end.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        this._variance(node2);
        this.print(node2.key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      if (node2.definite) {
        this.tokenChar(33);
      }
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node2) {
      var _node_key_loc_end, _node_key_loc;
      this.printJoin(node2.decorators, node2);
      var endLine = (_node_key_loc = node2.key.loc) === null || _node_key_loc === void 0 ? void 0 : (_node_key_loc_end = _node_key_loc.end) === null || _node_key_loc_end === void 0 ? void 0 : _node_key_loc_end.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      this.word("accessor", true);
      this.space();
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        this._variance(node2);
        this.print(node2.key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      if (node2.definite) {
        this.tokenChar(33);
      }
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node2) {
      this.printJoin(node2.decorators, node2);
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.key, node2);
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassMethod(node2) {
      this._classMethodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function ClassPrivateMethod(node2) {
      this._classMethodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function _classMethodHead(node2) {
      var _node_key_loc_end, _node_key_loc;
      this.printJoin(node2.decorators, node2);
      var endLine = (_node_key_loc = node2.key.loc) === null || _node_key_loc === void 0 ? void 0 : (_node_key_loc_end = _node_key_loc.end) === null || _node_key_loc_end === void 0 ? void 0 : _node_key_loc_end.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      this._methodHead(node2);
    }
    function StaticBlock(node2) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node2.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node2.body, node2, {
          indent: true
        });
        this.rightBrace(node2);
      }
    }
    var isIdentifier$1 = lib_exports.isIdentifier;
    function _params(node2, idNode, parentNode) {
      this.print(node2.typeParameters, node2);
      var nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node2.params, node2);
      this.tokenChar(41);
      var noLineTerminator = node2.type === "ArrowFunctionExpression";
      this.print(node2.returnType, node2, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, parent) {
      var paramLength = parameters.length;
      for (var i2 = 0; i2 < paramLength; i2++) {
        this._param(parameters[i2], parent);
        if (i2 < parameters.length - 1) {
          this.tokenChar(44);
          this.space();
        }
      }
    }
    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation, parameter);
    }
    function _methodHead(node2) {
      var kind = node2.kind;
      var key = node2.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node2.generator) {
          this.tokenChar(42);
        }
      }
      if (node2.computed) {
        this.tokenChar(91);
        this.print(key, node2);
        this.tokenChar(93);
      } else {
        this.print(key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      this._params(node2, node2.computed && node2.key.type !== "StringLiteral" ? void 0 : node2.key, void 0);
    }
    function _predicate(node2, noLineTerminatorAfter) {
      if (node2.predicate) {
        if (!node2.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node2.predicate, node2, noLineTerminatorAfter);
      }
    }
    function _functionHead(node2, parent) {
      if (node2.async) {
        this.word("async");
        this._endsWithInnerRaw = false;
        this.space();
      }
      this.word("function");
      if (node2.generator) {
        this._endsWithInnerRaw = false;
        this.tokenChar(42);
      }
      this.space();
      if (node2.id) {
        this.print(node2.id, node2);
      }
      this._params(node2, node2.id, parent);
      if (node2.type !== "TSDeclareFunction") {
        this._predicate(node2);
      }
    }
    function FunctionExpression(node2, parent) {
      this._functionHead(node2, parent);
      this.space();
      this.print(node2.body, node2);
    }
    function ArrowFunctionExpression(node2, parent) {
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      var firstParam;
      if (!this.format.retainLines && node2.params.length === 1 && isIdentifier$1(firstParam = node2.params[0]) && !hasTypesOrComments(node2, firstParam)) {
        this.print(firstParam, node2, true);
      } else {
        this._params(node2, void 0, parent);
      }
      this._predicate(node2, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.print(node2.body, node2);
    }
    function hasTypesOrComments(node2, param) {
      var _param_leadingComments, _param_trailingComments;
      return !!(node2.typeParameters || node2.returnType || node2.predicate || param.typeAnnotation || param.optional || ((_param_leadingComments = param.leadingComments) === null || _param_leadingComments === void 0 ? void 0 : _param_leadingComments.length) || ((_param_trailingComments = param.trailingComments) === null || _param_trailingComments === void 0 ? void 0 : _param_trailingComments.length));
    }
    function _getFuncIdName(idNode, parent) {
      var id = idNode;
      if (!id && parent) {
        var parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id)
        return;
      var nameInfo;
      if (id.type === "Identifier") {
        var _id_loc, _id_loc1;
        nameInfo = {
          pos: (_id_loc = id.loc) === null || _id_loc === void 0 ? void 0 : _id_loc.start,
          name: ((_id_loc1 = id.loc) === null || _id_loc1 === void 0 ? void 0 : _id_loc1.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id_loc2;
        nameInfo = {
          pos: (_id_loc2 = id.loc) === null || _id_loc2 === void 0 ? void 0 : _id_loc2.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id_loc3;
        nameInfo = {
          pos: (_id_loc3 = id.loc) === null || _id_loc3 === void 0 ? void 0 : _id_loc3.start,
          name: id.value
        };
      }
      return nameInfo;
    }
    var isClassDeclaration2 = lib_exports.isClassDeclaration;
    var isExportDefaultSpecifier2 = lib_exports.isExportDefaultSpecifier;
    var isExportNamespaceSpecifier2 = lib_exports.isExportNamespaceSpecifier;
    var isImportDefaultSpecifier2 = lib_exports.isImportDefaultSpecifier;
    var isImportNamespaceSpecifier2 = lib_exports.isImportNamespaceSpecifier;
    var isStatement$2 = lib_exports.isStatement;
    function ImportSpecifier(node2) {
      if (node2.importKind === "type" || node2.importKind === "typeof") {
        this.word(node2.importKind);
        this.space();
      }
      this.print(node2.imported, node2);
      if (node2.local && node2.local.name !== node2.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node2.local, node2);
      }
    }
    function ImportDefaultSpecifier(node2) {
      this.print(node2.local, node2);
    }
    function ExportDefaultSpecifier(node2) {
      this.print(node2.exported, node2);
    }
    function ExportSpecifier(node2) {
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node2.local, node2);
      if (node2.exported && node2.local.name !== node2.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node2.exported, node2);
      }
    }
    function ExportNamespaceSpecifier(node2) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node2.exported, node2);
    }
    var warningShown = false;
    function _printAttributes(node2) {
      var importAttributesKeyword = this.format.importAttributesKeyword;
      var attributes = node2.attributes, assertions = node2.assertions;
      if (attributes && !importAttributesKeyword && !warningShown) {
        warningShown = true;
        console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n');
      }
      var useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && importAttributesKeyword !== "with") {
        this.printList(attributes || assertions, node2);
        return;
      }
      this.tokenChar(123);
      this.space();
      this.printList(attributes || assertions, node2);
      this.space();
      this.tokenChar(125);
    }
    function ExportAllDeclaration(node2) {
      var _node_attributes, _node_assertions;
      this.word("export");
      this.space();
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if (((_node_attributes = node2.attributes) === null || _node_attributes === void 0 ? void 0 : _node_attributes.length) || ((_node_assertions = node2.assertions) === null || _node_assertions === void 0 ? void 0 : _node_assertions.length)) {
        this.print(node2.source, node2, true);
        this.space();
        this._printAttributes(node2);
      } else {
        this.print(node2.source, node2);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node2) {
      if (isClassDeclaration2(node2.declaration) && printer._shouldPrintDecoratorsBeforeExport(node2)) {
        printer.printJoin(node2.declaration.decorators, node2);
      }
    }
    function ExportNamedDeclaration(node2) {
      maybePrintDecoratorsBeforeExport(this, node2);
      this.word("export");
      this.space();
      if (node2.declaration) {
        var declar = node2.declaration;
        this.print(declar, node2);
        if (!isStatement$2(declar))
          this.semicolon();
      } else {
        if (node2.exportKind === "type") {
          this.word("type");
          this.space();
        }
        var specifiers = node2.specifiers.slice(0);
        var hasSpecial = false;
        for (; ; ) {
          var first = specifiers[0];
          if (isExportDefaultSpecifier2(first) || isExportNamespaceSpecifier2(first)) {
            hasSpecial = true;
            this.print(specifiers.shift(), node2);
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, node2);
            this.space();
          }
          this.tokenChar(125);
        }
        if (node2.source) {
          var _node_attributes, _node_assertions;
          this.space();
          this.word("from");
          this.space();
          if (((_node_attributes = node2.attributes) === null || _node_attributes === void 0 ? void 0 : _node_attributes.length) || ((_node_assertions = node2.assertions) === null || _node_assertions === void 0 ? void 0 : _node_assertions.length)) {
            this.print(node2.source, node2, true);
            this.space();
            this._printAttributes(node2);
          } else {
            this.print(node2.source, node2);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node2) {
      maybePrintDecoratorsBeforeExport(this, node2);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      var declar = node2.declaration;
      this.print(declar, node2);
      if (!isStatement$2(declar))
        this.semicolon();
    }
    function ImportDeclaration(node2) {
      var _node_attributes, _node_assertions;
      this.word("import");
      this.space();
      var isTypeKind = node2.importKind === "type" || node2.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node2.importKind);
        this.space();
      } else if (node2.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node2.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node2.phase);
        this.space();
      }
      var specifiers = node2.specifiers.slice(0);
      var hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        var first = specifiers[0];
        if (isImportDefaultSpecifier2(first) || isImportNamespaceSpecifier2(first)) {
          this.print(specifiers.shift(), node2);
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      if (specifiers.length) {
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, node2);
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if (((_node_attributes = node2.attributes) === null || _node_attributes === void 0 ? void 0 : _node_attributes.length) || ((_node_assertions = node2.assertions) === null || _node_assertions === void 0 ? void 0 : _node_assertions.length)) {
        this.print(node2.source, node2, true);
        this.space();
        this._printAttributes(node2);
      } else {
        this.print(node2.source, node2);
      }
      this.semicolon();
    }
    function ImportAttribute(node2) {
      this.print(node2.key);
      this.tokenChar(58);
      this.space();
      this.print(node2.value);
    }
    function ImportNamespaceSpecifier(node2) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node2.local, node2);
    }
    function ImportExpression(node2) {
      this.word("import");
      if (node2.phase) {
        this.tokenChar(46);
        this.word(node2.phase);
      }
      this.tokenChar(40);
      this.print(node2.source, node2);
      if (node2.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node2.options, node2);
      }
      this.tokenChar(41);
    }
    var isAssignmentPattern2 = lib_exports.isAssignmentPattern;
    var isIdentifier3 = lib_exports.isIdentifier;
    function Identifier(node2) {
      var _node_loc;
      this.sourceIdentifierName(((_node_loc = node2.loc) === null || _node_loc === void 0 ? void 0 : _node_loc.identifierName) || node2.name);
      this.word(node2.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement2(node2) {
      this.token("...");
      this.print(node2.argument, node2);
    }
    function ObjectExpression(node2) {
      var props = node2.properties;
      this.tokenChar(123);
      if (props.length) {
        this.space();
        this.printList(props, node2, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod(node2) {
      this.printJoin(node2.decorators, node2);
      this._methodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function ObjectProperty(node2) {
      this.printJoin(node2.decorators, node2);
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern2(node2.value) && isIdentifier3(node2.key) && node2.key.name === node2.value.left.name) {
          this.print(node2.value, node2);
          return;
        }
        this.print(node2.key, node2);
        if (node2.shorthand && isIdentifier3(node2.key) && isIdentifier3(node2.value) && node2.key.name === node2.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node2.value, node2);
    }
    function ArrayExpression2(node2) {
      var elems = node2.elements;
      var len = elems.length;
      this.tokenChar(91);
      for (var i2 = 0; i2 < elems.length; i2++) {
        var elem = elems[i2];
        if (elem) {
          if (i2 > 0)
            this.space();
          this.print(elem, node2);
          if (i2 < len - 1)
            this.tokenChar(44);
        } else {
          this.tokenChar(44);
        }
      }
      this.tokenChar(93);
    }
    function RecordExpression(node2) {
      var props = node2.properties;
      var startToken;
      var endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error('The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" ('.concat(JSON.stringify(this.format.recordAndTupleSyntaxType), " received)."));
      } else {
        startToken = "#{";
        endToken = "}";
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, node2, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node2) {
      var elems = node2.elements;
      var len = elems.length;
      var startToken;
      var endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error("".concat(this.format.recordAndTupleSyntaxType, " is not a valid recordAndTuple syntax type"));
      }
      this.token(startToken);
      for (var i2 = 0; i2 < elems.length; i2++) {
        var elem = elems[i2];
        if (elem) {
          if (i2 > 0)
            this.space();
          this.print(elem, node2);
          if (i2 < len - 1)
            this.tokenChar(44);
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node2) {
      this.word("/".concat(node2.pattern, "/").concat(node2.flags));
    }
    function BooleanLiteral(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node2) {
      var raw = this.getPossibleRaw(node2);
      var opts = this.format.jsescOption;
      var value1 = node2.value;
      var str = value1 + "";
      if (opts.numbers) {
        this.number((0, import_jsesc.default)(value1, opts), value1);
      } else if (raw == null) {
        this.number(str, value1);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value1);
      } else {
        this.number(raw, value1);
      }
    }
    function StringLiteral(node2) {
      var raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      var val = (0, import_jsesc.default)(node2.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node2) {
      var raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node2.value + "n");
    }
    function DecimalLiteral(node2) {
      var raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node2.value + "m");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set([
      "^^",
      "@@",
      "^",
      "%",
      "#"
    ]);
    function TopicReference() {
      var topicToken = this.format.topicToken;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        var givenTopicTokenJSON = JSON.stringify(topicToken);
        var validTopics = Array.from(validTopicTokenSet, function(v) {
          return JSON.stringify(v);
        });
        throw new Error('The "topicToken" generator option must be one of '.concat(validTopics.join(", "), " (").concat(givenTopicTokenJSON, " received instead)."));
      }
    }
    function PipelineTopicExpression(node2) {
      this.print(node2.expression, node2);
    }
    function PipelineBareFunction(node2) {
      this.print(node2.callee, node2);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
    var isDeclareExportDeclaration2 = lib_exports.isDeclareExportDeclaration;
    var isStatement$12 = lib_exports.isStatement;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node2) {
      this.print(node2.elementType, node2, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node2, parent) {
      if (!isDeclareExportDeclaration2(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node2);
    }
    function DeclareFunction(node2, parent) {
      if (!isDeclareExportDeclaration2(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.id.typeAnnotation.typeAnnotation, node2);
      if (node2.predicate) {
        this.space();
        this.print(node2.predicate, node2);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node2) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node2.value, node2);
      this.tokenChar(41);
    }
    function DeclareInterface(node2) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node2);
    }
    function DeclareModule(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node2.id, node2);
      this.space();
      this.print(node2.body, node2);
    }
    function DeclareModuleExports(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node2.typeAnnotation, node2);
    }
    function DeclareTypeAlias(node2) {
      this.word("declare");
      this.space();
      this.TypeAlias(node2);
    }
    function DeclareOpaqueType(node2, parent) {
      if (!isDeclareExportDeclaration2(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node2);
    }
    function DeclareVariable(node2, parent) {
      if (!isDeclareExportDeclaration2(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.id.typeAnnotation, node2);
      this.semicolon();
    }
    function DeclareExportDeclaration(node2) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node2.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node2);
    }
    function DeclareExportAllDeclaration(node2) {
      this.word("declare");
      this.space();
      ExportAllDeclaration.call(this, node2);
    }
    function EnumDeclaration(node2) {
      var id = node2.id, body = node2.body;
      this.word("enum");
      this.space();
      this.print(id, node2);
      this.print(body, node2);
    }
    function enumExplicitType(context, name2, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name2);
      }
      context.space();
    }
    function enumBody(context, node2) {
      var members = node2.members;
      context.token("{");
      context.indent();
      context.newline();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = members[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var member = _step8.value;
          context.print(member, node2);
          context.newline();
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      if (node2.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node2) {
      var explicitType = node2.explicitType;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node2);
    }
    function EnumNumberBody(node2) {
      var explicitType = node2.explicitType;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node2);
    }
    function EnumStringBody(node2) {
      var explicitType = node2.explicitType;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node2);
    }
    function EnumSymbolBody(node2) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node2);
    }
    function EnumDefaultedMember(node2) {
      var id = node2.id;
      this.print(id, node2);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node2) {
      var id = node2.id, init = node2.init;
      context.print(id, node2);
      context.space();
      context.token("=");
      context.space();
      context.print(init, node2);
      context.token(",");
    }
    function EnumBooleanMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumNumberMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumStringMember(node2) {
      enumInitializedMember(this, node2);
    }
    function FlowExportDeclaration(node2) {
      if (node2.declaration) {
        var declar = node2.declaration;
        this.print(declar, node2);
        if (!isStatement$12(declar))
          this.semicolon();
      } else {
        this.tokenChar(123);
        if (node2.specifiers.length) {
          this.space();
          this.printList(node2.specifiers, node2);
          this.space();
        }
        this.tokenChar(125);
        if (node2.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node2.source, node2);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node2, parent) {
      this.print(node2.typeParameters, node2);
      this.tokenChar(40);
      if (node2.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node2.this.typeAnnotation, node2);
        if (node2.params.length || node2.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node2.params, node2);
      if (node2.rest) {
        if (node2.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node2.rest, node2);
      }
      this.tokenChar(41);
      var type3 = parent === null || parent === void 0 ? void 0 : parent.type;
      if (type3 != null && (type3 === "ObjectTypeCallProperty" || type3 === "ObjectTypeInternalSlot" || type3 === "DeclareFunction" || type3 === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node2.returnType, node2);
    }
    function FunctionTypeParam(node2) {
      this.print(node2.name, node2);
      if (node2.optional)
        this.tokenChar(63);
      if (node2.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.typeAnnotation, node2);
    }
    function InterfaceExtends(node2) {
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2, true);
    }
    function _interfaceish(node2) {
      var _node_extends;
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      if ((_node_extends = node2.extends) === null || _node_extends === void 0 ? void 0 : _node_extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends, node2);
      }
      if (node2.type === "DeclareClass") {
        var _node_mixins, _node_implements;
        if ((_node_mixins = node2.mixins) === null || _node_mixins === void 0 ? void 0 : _node_mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node2.mixins, node2);
        }
        if ((_node_implements = node2.implements) === null || _node_implements === void 0 ? void 0 : _node_implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node2.implements, node2);
        }
      }
      this.space();
      this.print(node2.body, node2);
    }
    function _variance(node2) {
      var _node_variance;
      var kind = (_node_variance = node2.variance) === null || _node_variance === void 0 ? void 0 : _node_variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node2) {
      this.word("interface");
      this.space();
      this._interfaceish(node2);
    }
    function andSeparator() {
      this.space();
      this.tokenChar(38);
      this.space();
    }
    function InterfaceTypeAnnotation(node2) {
      var _node_extends;
      this.word("interface");
      if ((_node_extends = node2.extends) === null || _node_extends === void 0 ? void 0 : _node_extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends, node2);
      }
      this.space();
      this.print(node2.body, node2);
    }
    function IntersectionTypeAnnotation(node2) {
      this.printJoin(node2.types, node2, {
        separator: andSeparator
      });
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node2) {
      this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node2) {
      this.tokenChar(91);
      this.printList(node2.types, node2);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.argument, node2);
    }
    function TypeAlias(node2) {
      this.word("type");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right, node2);
      this.semicolon();
    }
    function TypeAnnotation(node2) {
      this.tokenChar(58);
      this.space();
      if (node2.optional)
        this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function TypeParameterInstantiation(node2) {
      this.tokenChar(60);
      this.printList(node2.params, node2, {});
      this.tokenChar(62);
    }
    function TypeParameter(node2) {
      this._variance(node2);
      this.word(node2.name);
      if (node2.bound) {
        this.print(node2.bound, node2);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default, node2);
      }
    }
    function OpaqueType(node2) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      if (node2.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node2.supertype, node2);
      }
      if (node2.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.impltype, node2);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node2) {
      var _this = this;
      if (node2.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      var props = _to_consumable_array(node2.properties).concat(_to_consumable_array(node2.callProperties || []), _to_consumable_array(node2.indexers || []), _to_consumable_array(node2.internalSlots || []));
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, node2, {
          addNewlines: function addNewlines(leading) {
            if (leading && !props[0])
              return 1;
          },
          indent: true,
          statement: true,
          iterator: function() {
            if (props.length !== 1 || node2.inexact) {
              _this.tokenChar(44);
              _this.space();
            }
          }
        });
        this.space();
      }
      if (node2.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node2.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node2.id, node2);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node2.optional)
        this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeCallProperty(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeIndexer(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this._variance(node2);
      this.tokenChar(91);
      if (node2.id) {
        this.print(node2.id, node2);
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.key, node2);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node2.value, node2);
    }
    function ObjectTypeProperty(node2) {
      if (node2.proto) {
        this.word("proto");
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.kind === "get" || node2.kind === "set") {
        this.word(node2.kind);
        this.space();
      }
      this._variance(node2);
      this.print(node2.key, node2);
      if (node2.optional)
        this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeSpreadProperty(node2) {
      this.token("...");
      this.print(node2.argument, node2);
    }
    function QualifiedTypeIdentifier(node2) {
      this.print(node2.qualification, node2);
      this.tokenChar(46);
      this.print(node2.id, node2);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator() {
      this.space();
      this.tokenChar(124);
      this.space();
    }
    function UnionTypeAnnotation(node2) {
      this.printJoin(node2.types, node2, {
        separator: orSeparator
      });
    }
    function TypeCastExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression, node2);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(41);
    }
    function Variance(node2) {
      if (node2.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node2) {
      this.print(node2.objectType, node2, true);
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node2) {
      this.print(node2.objectType, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
    function File(node2) {
      if (node2.program) {
        this.print(node2.program.interpreter, node2);
      }
      this.print(node2.program, node2);
    }
    function Program(node2) {
      var _node_directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      var directivesLen = (_node_directives = node2.directives) === null || _node_directives === void 0 ? void 0 : _node_directives.length;
      if (directivesLen) {
        var _node_directives__trailingComments;
        var newline = node2.body.length ? 2 : 1;
        this.printSequence(node2.directives, node2, {
          trailingCommentsLineOffset: newline
        });
        if (!((_node_directives__trailingComments = node2.directives[directivesLen - 1].trailingComments) === null || _node_directives__trailingComments === void 0 ? void 0 : _node_directives__trailingComments.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node2.body, node2);
    }
    function BlockStatement2(node2) {
      var _node_directives;
      this.tokenChar(123);
      var directivesLen = (_node_directives = node2.directives) === null || _node_directives === void 0 ? void 0 : _node_directives.length;
      if (directivesLen) {
        var _node_directives__trailingComments;
        var newline = node2.body.length ? 2 : 1;
        this.printSequence(node2.directives, node2, {
          indent: true,
          trailingCommentsLineOffset: newline
        });
        if (!((_node_directives__trailingComments = node2.directives[directivesLen - 1].trailingComments) === null || _node_directives__trailingComments === void 0 ? void 0 : _node_directives__trailingComments.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node2.body, node2, {
        indent: true
      });
      this.rightBrace(node2);
    }
    function Directive(node2) {
      this.print(node2.value, node2);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node2) {
      var raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      var value1 = node2.value;
      if (!unescapedDoubleQuoteRE.test(value1)) {
        this.token('"'.concat(value1, '"'));
      } else if (!unescapedSingleQuoteRE.test(value1)) {
        this.token("'".concat(value1, "'"));
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node2) {
      this.token("#!".concat(node2.value));
      this.newline(1, true);
    }
    function Placeholder(node2) {
      this.token("%%");
      this.print(node2.name);
      this.token("%%");
      if (node2.expectedNode === "Statement") {
        this.semicolon();
      }
    }
    function JSXAttribute(node2) {
      this.print(node2.name, node2);
      if (node2.value) {
        this.tokenChar(61);
        this.print(node2.value, node2);
      }
    }
    function JSXIdentifier(node2) {
      this.word(node2.name);
    }
    function JSXNamespacedName(node2) {
      this.print(node2.namespace, node2);
      this.tokenChar(58);
      this.print(node2.name, node2);
    }
    function JSXMemberExpression(node2) {
      this.print(node2.object, node2);
      this.tokenChar(46);
      this.print(node2.property, node2);
    }
    function JSXSpreadAttribute(node2) {
      this.tokenChar(123);
      this.token("...");
      this.print(node2.argument, node2);
      this.tokenChar(125);
    }
    function JSXExpressionContainer(node2) {
      this.tokenChar(123);
      this.print(node2.expression, node2);
      this.tokenChar(125);
    }
    function JSXSpreadChild(node2) {
      this.tokenChar(123);
      this.token("...");
      this.print(node2.expression, node2);
      this.tokenChar(125);
    }
    function JSXText(node2) {
      var raw = this.getPossibleRaw(node2);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node2.value, true);
      }
    }
    function JSXElement(node2) {
      var open = node2.openingElement;
      this.print(open, node2);
      if (open.selfClosing)
        return;
      this.indent();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = node2.children[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var child = _step8.value;
          this.print(child, node2);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      this.dedent();
      this.print(node2.closingElement, node2);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node2) {
      this.tokenChar(60);
      this.print(node2.name, node2);
      this.print(node2.typeParameters, node2);
      if (node2.attributes.length > 0) {
        this.space();
        this.printJoin(node2.attributes, node2, {
          separator: spaceSeparator
        });
      }
      if (node2.selfClosing) {
        this.space();
        this.token("/>");
      } else {
        this.tokenChar(62);
      }
    }
    function JSXClosingElement(node2) {
      this.token("</");
      this.print(node2.name, node2);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node2) {
      this.print(node2.openingFragment, node2);
      this.indent();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = node2.children[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var child = _step8.value;
          this.print(child, node2);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      this.dedent();
      this.print(node2.closingFragment, node2);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
    function TSTypeAnnotation(node2) {
      this.tokenChar(58);
      this.space();
      if (node2.optional)
        this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function TSTypeParameterInstantiation(node2, parent) {
      this.tokenChar(60);
      this.printList(node2.params, node2, {});
      if (parent.type === "ArrowFunctionExpression" && node2.params.length === 1) {
        this.tokenChar(44);
      }
      this.tokenChar(62);
    }
    function TSTypeParameter(node2) {
      if (node2.in) {
        this.word("in");
        this.space();
      }
      if (node2.out) {
        this.word("out");
        this.space();
      }
      this.word(node2.name.name);
      if (node2.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node2.constraint, node2);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default, node2);
      }
    }
    function TSParameterProperty(node2) {
      if (node2.accessibility) {
        this.word(node2.accessibility);
        this.space();
      }
      if (node2.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node2.parameter);
    }
    function TSDeclareFunction(node2, parent) {
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node2, parent);
      this.tokenChar(59);
    }
    function TSDeclareMethod(node2) {
      this._classMethodHead(node2);
      this.tokenChar(59);
    }
    function TSQualifiedName(node2) {
      this.print(node2.left, node2);
      this.tokenChar(46);
      this.print(node2.right, node2);
    }
    function TSCallSignatureDeclaration(node2) {
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSConstructSignatureDeclaration(node2) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSPropertySignature(node2) {
      var readonly = node2.readonly;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node2);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(59);
    }
    function tsPrintPropertyOrMethodName(node2) {
      if (node2.computed) {
        this.tokenChar(91);
      }
      this.print(node2.key, node2);
      if (node2.computed) {
        this.tokenChar(93);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node2) {
      var kind = node2.kind;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node2);
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSIndexSignature(node2) {
      var readonly = node2.readonly, isStatic2 = node2.static;
      if (isStatic2) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node2.parameters, node2);
      this.tokenChar(93);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(59);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node2) {
      this.tsPrintFunctionOrConstructorType(node2);
    }
    function TSConstructorType(node2) {
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node2);
    }
    function tsPrintFunctionOrConstructorType(node2) {
      var typeParameters = node2.typeParameters;
      var parameters = node2.params;
      this.print(typeParameters, node2);
      this.tokenChar(40);
      this._parameters(parameters, node2);
      this.tokenChar(41);
      this.space();
      this.token("=>");
      this.space();
      var returnType = node2.returnType;
      this.print(returnType.typeAnnotation, node2);
    }
    function TSTypeReference(node2) {
      this.print(node2.typeName, node2, true);
      this.print(node2.typeParameters, node2, true);
    }
    function TSTypePredicate(node2) {
      if (node2.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node2.parameterName);
      if (node2.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node2.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.exprName);
      if (node2.typeParameters) {
        this.print(node2.typeParameters, node2);
      }
    }
    function TSTypeLiteral(node2) {
      this.tsPrintTypeLiteralOrInterfaceBody(node2.members, node2);
    }
    function tsPrintTypeLiteralOrInterfaceBody(members, node2) {
      tsPrintBraced(this, members, node2);
    }
    function tsPrintBraced(printer, members, node2) {
      printer.token("{");
      if (members.length) {
        printer.indent();
        printer.newline();
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = members[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var member = _step8.value;
            printer.print(member, node2);
            printer.newline();
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        printer.dedent();
      }
      printer.rightBrace(node2);
    }
    function TSArrayType(node2) {
      this.print(node2.elementType, node2, true);
      this.token("[]");
    }
    function TSTupleType(node2) {
      this.tokenChar(91);
      this.printList(node2.elementTypes, node2);
      this.tokenChar(93);
    }
    function TSOptionalType(node2) {
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(63);
    }
    function TSRestType(node2) {
      this.token("...");
      this.print(node2.typeAnnotation, node2);
    }
    function TSNamedTupleMember(node2) {
      this.print(node2.label, node2);
      if (node2.optional)
        this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node2.elementType, node2);
    }
    function TSUnionType(node2) {
      tsPrintUnionOrIntersectionType(this, node2, "|");
    }
    function TSIntersectionType(node2) {
      tsPrintUnionOrIntersectionType(this, node2, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node2, sep) {
      printer.printJoin(node2.types, node2, {
        separator: function separator() {
          this.space();
          this.token(sep);
          this.space();
        }
      });
    }
    function TSConditionalType(node2) {
      this.print(node2.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node2.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node2.falseType);
    }
    function TSInferType(node2) {
      this.token("infer");
      this.space();
      this.print(node2.typeParameter);
    }
    function TSParenthesizedType(node2) {
      this.tokenChar(40);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(41);
    }
    function TSTypeOperator(node2) {
      this.word(node2.operator);
      this.space();
      this.print(node2.typeAnnotation, node2);
    }
    function TSIndexedAccessType(node2) {
      this.print(node2.objectType, node2, true);
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
    function TSMappedType(node2) {
      var nameType = node2.nameType, optional = node2.optional, readonly = node2.readonly, typeParameter2 = node2.typeParameter;
      this.tokenChar(123);
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this.word(typeParameter2.name.name);
      this.space();
      this.word("in");
      this.space();
      this.print(typeParameter2.constraint, typeParameter2);
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType, node2);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      this.tokenChar(58);
      this.space();
      this.print(node2.typeAnnotation, node2);
      this.space();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSLiteralType(node2) {
      this.print(node2.literal, node2);
    }
    function TSExpressionWithTypeArguments(node2) {
      this.print(node2.expression, node2);
      this.print(node2.typeParameters, node2);
    }
    function TSInterfaceDeclaration(node2) {
      var declare = node2.declare, id = node2.id, typeParameters = node2.typeParameters, extendz = node2.extends, body = node2.body;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id, node2);
      this.print(typeParameters, node2);
      if (extendz === null || extendz === void 0 ? void 0 : extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz, node2);
      }
      this.space();
      this.print(body, node2);
    }
    function TSInterfaceBody(node2) {
      this.tsPrintTypeLiteralOrInterfaceBody(node2.body, node2);
    }
    function TSTypeAliasDeclaration(node2) {
      var declare = node2.declare, id = node2.id, typeParameters = node2.typeParameters, typeAnnotation2 = node2.typeAnnotation;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id, node2);
      this.print(typeParameters, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation2, node2);
      this.tokenChar(59);
    }
    function TSTypeExpression2(node2) {
      var _expression2_trailingComments;
      var type3 = node2.type, expression2 = node2.expression, typeAnnotation2 = node2.typeAnnotation;
      var forceParens = !!((_expression2_trailingComments = expression2.trailingComments) === null || _expression2_trailingComments === void 0 ? void 0 : _expression2_trailingComments.length);
      this.print(expression2, node2, true, void 0, forceParens);
      this.space();
      this.word(type3 === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation2, node2);
    }
    function TSTypeAssertion(node2) {
      var typeAnnotation2 = node2.typeAnnotation, expression2 = node2.expression;
      this.tokenChar(60);
      this.print(typeAnnotation2, node2);
      this.tokenChar(62);
      this.space();
      this.print(expression2, node2);
    }
    function TSInstantiationExpression(node2) {
      this.print(node2.expression, node2);
      this.print(node2.typeParameters, node2);
    }
    function TSEnumDeclaration(node2) {
      var declare = node2.declare, isConst = node2.const, id = node2.id, members = node2.members;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id, node2);
      this.space();
      tsPrintBraced(this, members, node2);
    }
    function TSEnumMember(node2) {
      var id = node2.id, initializer = node2.initializer;
      this.print(id, node2);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer, node2);
      }
      this.tokenChar(44);
    }
    function TSModuleDeclaration(node2) {
      var declare = node2.declare, id = node2.id;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (!node2.global) {
        this.word(id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id, node2);
      if (!node2.body) {
        this.tokenChar(59);
        return;
      }
      var body = node2.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id, body);
        body = body.body;
      }
      this.space();
      this.print(body, node2);
    }
    function TSModuleBlock(node2) {
      tsPrintBraced(this, node2.body, node2);
    }
    function TSImportType(node2) {
      var argument = node2.argument, qualifier = node2.qualifier, typeParameters = node2.typeParameters;
      this.word("import");
      this.tokenChar(40);
      this.print(argument, node2);
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier, node2);
      }
      if (typeParameters) {
        this.print(typeParameters, node2);
      }
    }
    function TSImportEqualsDeclaration(node2) {
      var isExport = node2.isExport, id = node2.id, moduleReference = node2.moduleReference;
      if (isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference, node2);
      this.tokenChar(59);
    }
    function TSExternalModuleReference(node2) {
      this.token("require(");
      this.print(node2.expression, node2);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node2) {
      this.print(node2.expression, node2);
      this.tokenChar(33);
    }
    function TSExportAssignment(node2) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.expression, node2);
      this.tokenChar(59);
    }
    function TSNamespaceExportDeclaration(node2) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node2.id, node2);
    }
    function tsPrintSignatureDeclarationBase(node2) {
      var typeParameters = node2.typeParameters;
      var parameters = node2.params;
      this.print(typeParameters, node2);
      this.tokenChar(40);
      this._parameters(parameters, node2);
      this.tokenChar(41);
      var returnType = node2.returnType;
      this.print(returnType, node2);
    }
    function tsPrintClassMemberModifiers(node2) {
      var isField = node2.type === "ClassAccessorProperty" || node2.type === "ClassProperty";
      if (isField && node2.declare) {
        this.word("declare");
        this.space();
      }
      if (node2.accessibility) {
        this.word(node2.accessibility);
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.override) {
        this.word("override");
        this.space();
      }
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      if (isField && node2.readonly) {
        this.word("readonly");
        this.space();
      }
    }
    var generatorFunctions = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AnyTypeAnnotation,
      ArgumentPlaceholder,
      ArrayExpression: ArrayExpression2,
      ArrayPattern: ArrayExpression2,
      ArrayTypeAnnotation,
      ArrowFunctionExpression,
      AssignmentExpression,
      AssignmentPattern,
      AwaitExpression,
      BigIntLiteral,
      BinaryExpression: AssignmentExpression,
      BindExpression,
      BlockStatement: BlockStatement2,
      BooleanLiteral,
      BooleanLiteralTypeAnnotation,
      BooleanTypeAnnotation,
      BreakStatement,
      CallExpression,
      CatchClause,
      ClassAccessorProperty,
      ClassBody,
      ClassDeclaration,
      ClassExpression: ClassDeclaration,
      ClassImplements: InterfaceExtends,
      ClassMethod,
      ClassPrivateMethod,
      ClassPrivateProperty,
      ClassProperty,
      ConditionalExpression,
      ContinueStatement,
      DebuggerStatement,
      DecimalLiteral,
      DeclareClass,
      DeclareExportAllDeclaration,
      DeclareExportDeclaration,
      DeclareFunction,
      DeclareInterface,
      DeclareModule,
      DeclareModuleExports,
      DeclareOpaqueType,
      DeclareTypeAlias,
      DeclareVariable,
      DeclaredPredicate,
      Decorator,
      Directive,
      DirectiveLiteral,
      DoExpression,
      DoWhileStatement,
      EmptyStatement,
      EmptyTypeAnnotation,
      EnumBooleanBody,
      EnumBooleanMember,
      EnumDeclaration,
      EnumDefaultedMember,
      EnumNumberBody,
      EnumNumberMember,
      EnumStringBody,
      EnumStringMember,
      EnumSymbolBody,
      ExistsTypeAnnotation,
      ExportAllDeclaration,
      ExportDefaultDeclaration,
      ExportDefaultSpecifier,
      ExportNamedDeclaration,
      ExportNamespaceSpecifier,
      ExportSpecifier,
      ExpressionStatement,
      File,
      ForInStatement: ForInStatement2,
      ForOfStatement,
      ForStatement,
      FunctionDeclaration: FunctionExpression,
      FunctionExpression,
      FunctionTypeAnnotation,
      FunctionTypeParam,
      GenericTypeAnnotation: InterfaceExtends,
      Identifier,
      IfStatement,
      Import,
      ImportAttribute,
      ImportDeclaration,
      ImportDefaultSpecifier,
      ImportExpression,
      ImportNamespaceSpecifier,
      ImportSpecifier,
      IndexedAccessType,
      InferredPredicate,
      InterfaceDeclaration,
      InterfaceExtends,
      InterfaceTypeAnnotation,
      InterpreterDirective,
      IntersectionTypeAnnotation,
      JSXAttribute,
      JSXClosingElement,
      JSXClosingFragment,
      JSXElement,
      JSXEmptyExpression,
      JSXExpressionContainer,
      JSXFragment,
      JSXIdentifier,
      JSXMemberExpression,
      JSXNamespacedName,
      JSXOpeningElement,
      JSXOpeningFragment,
      JSXSpreadAttribute,
      JSXSpreadChild,
      JSXText,
      LabeledStatement,
      LogicalExpression: AssignmentExpression,
      MemberExpression,
      MetaProperty,
      MixedTypeAnnotation,
      ModuleExpression,
      NewExpression,
      NullLiteral,
      NullLiteralTypeAnnotation,
      NullableTypeAnnotation,
      NumberLiteralTypeAnnotation: NumericLiteral,
      NumberTypeAnnotation,
      NumericLiteral,
      ObjectExpression,
      ObjectMethod,
      ObjectPattern: ObjectExpression,
      ObjectProperty,
      ObjectTypeAnnotation,
      ObjectTypeCallProperty,
      ObjectTypeIndexer,
      ObjectTypeInternalSlot,
      ObjectTypeProperty,
      ObjectTypeSpreadProperty,
      OpaqueType,
      OptionalCallExpression,
      OptionalIndexedAccessType,
      OptionalMemberExpression,
      ParenthesizedExpression,
      PipelineBareFunction,
      PipelinePrimaryTopicReference,
      PipelineTopicExpression,
      Placeholder,
      PrivateName,
      Program,
      QualifiedTypeIdentifier,
      RecordExpression,
      RegExpLiteral,
      RestElement: RestElement2,
      ReturnStatement,
      SequenceExpression,
      SpreadElement: RestElement2,
      StaticBlock,
      StringLiteral,
      StringLiteralTypeAnnotation: StringLiteral,
      StringTypeAnnotation,
      Super,
      SwitchCase,
      SwitchStatement,
      SymbolTypeAnnotation,
      TSAnyKeyword,
      TSArrayType,
      TSAsExpression: TSTypeExpression2,
      TSBigIntKeyword,
      TSBooleanKeyword,
      TSCallSignatureDeclaration,
      TSConditionalType,
      TSConstructSignatureDeclaration,
      TSConstructorType,
      TSDeclareFunction,
      TSDeclareMethod,
      TSEnumDeclaration,
      TSEnumMember,
      TSExportAssignment,
      TSExpressionWithTypeArguments,
      TSExternalModuleReference,
      TSFunctionType,
      TSImportEqualsDeclaration,
      TSImportType,
      TSIndexSignature,
      TSIndexedAccessType,
      TSInferType,
      TSInstantiationExpression,
      TSInterfaceBody,
      TSInterfaceDeclaration,
      TSIntersectionType,
      TSIntrinsicKeyword,
      TSLiteralType,
      TSMappedType,
      TSMethodSignature,
      TSModuleBlock,
      TSModuleDeclaration,
      TSNamedTupleMember,
      TSNamespaceExportDeclaration,
      TSNeverKeyword,
      TSNonNullExpression,
      TSNullKeyword,
      TSNumberKeyword,
      TSObjectKeyword,
      TSOptionalType,
      TSParameterProperty,
      TSParenthesizedType,
      TSPropertySignature,
      TSQualifiedName,
      TSRestType,
      TSSatisfiesExpression: TSTypeExpression2,
      TSStringKeyword,
      TSSymbolKeyword,
      TSThisType,
      TSTupleType,
      TSTypeAliasDeclaration,
      TSTypeAnnotation,
      TSTypeAssertion,
      TSTypeLiteral,
      TSTypeOperator,
      TSTypeParameter,
      TSTypeParameterDeclaration: TSTypeParameterInstantiation,
      TSTypeParameterInstantiation,
      TSTypePredicate,
      TSTypeQuery,
      TSTypeReference,
      TSUndefinedKeyword,
      TSUnionType,
      TSUnknownKeyword,
      TSVoidKeyword,
      TaggedTemplateExpression,
      TemplateElement,
      TemplateLiteral,
      ThisExpression,
      ThisTypeAnnotation,
      ThrowStatement,
      TopicReference,
      TryStatement,
      TupleExpression,
      TupleTypeAnnotation,
      TypeAlias,
      TypeAnnotation,
      TypeCastExpression,
      TypeParameter,
      TypeParameterDeclaration: TypeParameterInstantiation,
      TypeParameterInstantiation,
      TypeofTypeAnnotation,
      UnaryExpression,
      UnionTypeAnnotation,
      UpdateExpression,
      V8IntrinsicIdentifier,
      VariableDeclaration,
      VariableDeclarator,
      Variance,
      VoidTypeAnnotation,
      WhileStatement,
      WithStatement,
      YieldExpression,
      _classMethodHead,
      _functionHead,
      _interfaceish,
      _methodHead,
      _param,
      _parameters,
      _params,
      _predicate,
      _printAttributes,
      _shouldPrintDecoratorsBeforeExport,
      _variance,
      tsPrintClassMemberModifiers,
      tsPrintFunctionOrConstructorType,
      tsPrintPropertyOrMethodName,
      tsPrintSignatureDeclarationBase,
      tsPrintTypeLiteralOrInterfaceBody
    });
    var isFunction3 = lib_exports.isFunction;
    var isStatement3 = lib_exports.isStatement;
    var isClassBody2 = lib_exports.isClassBody;
    var isTSInterfaceBody2 = lib_exports.isTSInterfaceBody;
    var isTSEnumDeclaration2 = lib_exports.isTSEnumDeclaration;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    var needsParens = n.needsParens;
    var Printer = /* @__PURE__ */ function() {
      "use strict";
      function Printer2(format, map) {
        _class_call_check(this, Printer2);
        __publicField(this, "inForStatementInitCounter", 0);
        __publicField(this, "_printStack", []);
        __publicField(this, "_indent", 0);
        __publicField(this, "_indentRepeat", 0);
        __publicField(this, "_insideAux", false);
        __publicField(this, "_parenPushNewlineState", null);
        __publicField(this, "_noLineTerminator", false);
        __publicField(this, "_printAuxAfterOnNextUserNode", false);
        __publicField(this, "_printedComments", /* @__PURE__ */ new Set());
        __publicField(this, "_endsWithInteger", false);
        __publicField(this, "_endsWithWord", false);
        __publicField(this, "_lastCommentLine", 0);
        __publicField(this, "_endsWithInnerRaw", false);
        __publicField(this, "_indentInnerComments", true);
        this.format = format;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map === null || map === void 0 ? void 0 : map._inputMap;
        this._buf = new Buffer2(map, format.indent.style[0]);
      }
      _create_class(Printer2, [
        {
          key: "generate",
          value: function generate3(ast) {
            this.print(ast);
            this._maybeAddAuxComment();
            return this._buf.get();
          }
        },
        {
          key: "indent",
          value: function indent2() {
            if (this.format.compact || this.format.concise)
              return;
            this._indent++;
          }
        },
        {
          key: "dedent",
          value: function dedent() {
            if (this.format.compact || this.format.concise)
              return;
            this._indent--;
          }
        },
        {
          key: "semicolon",
          value: function semicolon2() {
            var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            this._maybeAddAuxComment();
            if (force) {
              this._appendChar(59);
            } else {
              this._queue(59);
            }
            this._noLineTerminator = false;
          }
        },
        {
          key: "rightBrace",
          value: function rightBrace(node2) {
            if (this.format.minified) {
              this._buf.removeLastSemicolon();
            }
            this.sourceWithOffset("end", node2.loc, -1);
            this.tokenChar(125);
          }
        },
        {
          key: "rightParens",
          value: function rightParens(node2) {
            this.sourceWithOffset("end", node2.loc, -1);
            this.tokenChar(41);
          }
        },
        {
          key: "space",
          value: function space2() {
            var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            if (this.format.compact)
              return;
            if (force) {
              this._space();
            } else if (this._buf.hasContent()) {
              var lastCp = this.getLastChar();
              if (lastCp !== 32 && lastCp !== 10) {
                this._space();
              }
            }
          }
        },
        {
          key: "word",
          value: function word(str) {
            var noLineTerminatorAfter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            this._maybePrintInnerComments();
            if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
              this._space();
            }
            this._maybeAddAuxComment();
            this._append(str, false);
            this._endsWithWord = true;
            this._noLineTerminator = noLineTerminatorAfter;
          }
        },
        {
          key: "number",
          value: function number2(str, number2) {
            function isNonDecimalLiteral(str2) {
              if (str2.length > 2 && str2.charCodeAt(0) === 48) {
                var secondChar = str2.charCodeAt(1);
                return secondChar === 98 || secondChar === 111 || secondChar === 120;
              }
              return false;
            }
            this.word(str);
            this._endsWithInteger = Number.isInteger(number2) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
          }
        },
        {
          key: "token",
          value: function token(str) {
            var maybeNewline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            this._maybePrintInnerComments();
            var lastChar = this.getLastChar();
            var strFirst = str.charCodeAt(0);
            if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
              this._space();
            }
            this._maybeAddAuxComment();
            this._append(str, maybeNewline);
            this._noLineTerminator = false;
          }
        },
        {
          key: "tokenChar",
          value: function tokenChar(char) {
            this._maybePrintInnerComments();
            var lastChar = this.getLastChar();
            if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
              this._space();
            }
            this._maybeAddAuxComment();
            this._appendChar(char);
            this._noLineTerminator = false;
          }
        },
        {
          key: "newline",
          value: function newline() {
            var i2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, force = arguments.length > 1 ? arguments[1] : void 0;
            if (i2 <= 0)
              return;
            if (!force) {
              if (this.format.retainLines || this.format.compact)
                return;
              if (this.format.concise) {
                this.space();
                return;
              }
            }
            if (i2 > 2)
              i2 = 2;
            i2 -= this._buf.getNewlineCount();
            for (var j = 0; j < i2; j++) {
              this._newline();
            }
            return;
          }
        },
        {
          key: "endsWith",
          value: function endsWith(char) {
            return this.getLastChar() === char;
          }
        },
        {
          key: "getLastChar",
          value: function getLastChar() {
            return this._buf.getLastChar();
          }
        },
        {
          key: "endsWithCharAndNewline",
          value: function endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
        },
        {
          key: "removeTrailingNewline",
          value: function removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
        },
        {
          key: "exactSource",
          value: function exactSource(loc, cb) {
            if (!loc) {
              cb();
              return;
            }
            this._catchUp("start", loc);
            this._buf.exactSource(loc, cb);
          }
        },
        {
          key: "source",
          value: function source(prop, loc) {
            if (!loc)
              return;
            this._catchUp(prop, loc);
            this._buf.source(prop, loc);
          }
        },
        {
          key: "sourceWithOffset",
          value: function sourceWithOffset(prop, loc, columnOffset) {
            if (!loc)
              return;
            this._catchUp(prop, loc);
            this._buf.sourceWithOffset(prop, loc, columnOffset);
          }
        },
        {
          key: "withSource",
          value: function withSource(prop, loc, cb) {
            if (!loc) {
              cb();
              return;
            }
            this._catchUp(prop, loc);
            this._buf.withSource(prop, loc, cb);
          }
        },
        {
          key: "sourceIdentifierName",
          value: function sourceIdentifierName(identifierName, pos) {
            if (!this._buf._canMarkIdName)
              return;
            var sourcePosition = this._buf._sourcePosition;
            sourcePosition.identifierNamePos = pos;
            sourcePosition.identifierName = identifierName;
          }
        },
        {
          key: "_space",
          value: function _space() {
            this._queue(32);
          }
        },
        {
          key: "_newline",
          value: function _newline() {
            this._queue(10);
          }
        },
        {
          key: "_append",
          value: function _append(str, maybeNewline) {
            this._maybeAddParen(str);
            this._maybeIndent(str.charCodeAt(0));
            this._buf.append(str, maybeNewline);
            this._endsWithWord = false;
            this._endsWithInteger = false;
          }
        },
        {
          key: "_appendChar",
          value: function _appendChar(char) {
            this._maybeAddParenChar(char);
            this._maybeIndent(char);
            this._buf.appendChar(char);
            this._endsWithWord = false;
            this._endsWithInteger = false;
          }
        },
        {
          key: "_queue",
          value: function _queue(char) {
            this._maybeAddParenChar(char);
            this._maybeIndent(char);
            this._buf.queue(char);
            this._endsWithWord = false;
            this._endsWithInteger = false;
          }
        },
        {
          key: "_maybeIndent",
          value: function _maybeIndent(firstChar) {
            if (this._indent && firstChar !== 10 && this.endsWith(10)) {
              this._buf.queueIndentation(this._getIndent());
            }
          }
        },
        {
          key: "_shouldIndent",
          value: function _shouldIndent(firstChar) {
            if (this._indent && firstChar !== 10 && this.endsWith(10)) {
              return true;
            }
          }
        },
        {
          key: "_maybeAddParenChar",
          value: function _maybeAddParenChar(char) {
            var parenPushNewlineState = this._parenPushNewlineState;
            if (!parenPushNewlineState)
              return;
            if (char === 32) {
              return;
            }
            if (char !== 10) {
              this._parenPushNewlineState = null;
              return;
            }
            this.tokenChar(40);
            this.indent();
            parenPushNewlineState.printed = true;
          }
        },
        {
          key: "_maybeAddParen",
          value: function _maybeAddParen(str) {
            var parenPushNewlineState = this._parenPushNewlineState;
            if (!parenPushNewlineState)
              return;
            var len = str.length;
            var i2;
            for (i2 = 0; i2 < len && str.charCodeAt(i2) === 32; i2++)
              continue;
            if (i2 === len) {
              return;
            }
            var cha = str.charCodeAt(i2);
            if (cha !== 10) {
              if (cha !== 47 || i2 + 1 === len) {
                this._parenPushNewlineState = null;
                return;
              }
              var chaPost = str.charCodeAt(i2 + 1);
              if (chaPost === 42) {
                return;
              } else if (chaPost !== 47) {
                this._parenPushNewlineState = null;
                return;
              }
            }
            this.tokenChar(40);
            this.indent();
            parenPushNewlineState.printed = true;
          }
        },
        {
          key: "catchUp",
          value: function catchUp(line) {
            if (!this.format.retainLines)
              return;
            var count = line - this._buf.getCurrentLine();
            for (var i2 = 0; i2 < count; i2++) {
              this._newline();
            }
          }
        },
        {
          key: "_catchUp",
          value: function _catchUp(prop, loc) {
            var _loc_prop;
            if (!this.format.retainLines)
              return;
            var line = loc === null || loc === void 0 ? void 0 : (_loc_prop = loc[prop]) === null || _loc_prop === void 0 ? void 0 : _loc_prop.line;
            if (line != null) {
              var count = line - this._buf.getCurrentLine();
              for (var i2 = 0; i2 < count; i2++) {
                this._newline();
              }
            }
          }
        },
        {
          key: "_getIndent",
          value: function _getIndent() {
            return this._indentRepeat * this._indent;
          }
        },
        {
          key: "printTerminatorless",
          value: function printTerminatorless(node2, parent, isLabel) {
            if (isLabel) {
              this._noLineTerminator = true;
              this.print(node2, parent);
            } else {
              var terminatorState = {
                printed: false
              };
              this._parenPushNewlineState = terminatorState;
              this.print(node2, parent);
              if (terminatorState.printed) {
                this.dedent();
                this.newline();
                this.tokenChar(41);
              }
            }
          }
        },
        {
          key: "print",
          value: function print(node2, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
            var _node_extra, _node_leadingComments;
            if (!node2)
              return;
            this._endsWithInnerRaw = false;
            var nodeType = node2.type;
            var format = this.format;
            var oldConcise = format.concise;
            if (node2._compact) {
              format.concise = true;
            }
            var printMethod = this[nodeType];
            if (printMethod === void 0) {
              throw new ReferenceError("unknown node of type ".concat(JSON.stringify(nodeType), " with constructor ").concat(JSON.stringify(node2.constructor.name)));
            }
            this._printStack.push(node2);
            var oldInAux = this._insideAux;
            this._insideAux = node2.loc == void 0;
            this._maybeAddAuxComment(this._insideAux && !oldInAux);
            var parenthesized = (_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.parenthesized;
            var shouldPrintParens = forceParens || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node2, parent, this._printStack);
            if (!shouldPrintParens && parenthesized && ((_node_leadingComments = node2.leadingComments) === null || _node_leadingComments === void 0 ? void 0 : _node_leadingComments.length) && node2.leadingComments[0].type === "CommentBlock") {
              var parentType = parent === null || parent === void 0 ? void 0 : parent.type;
              switch (parentType) {
                case "ExpressionStatement":
                case "VariableDeclarator":
                case "AssignmentExpression":
                case "ReturnStatement":
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                case "NewExpression":
                  if (parent.callee !== node2)
                    break;
                default:
                  shouldPrintParens = true;
              }
            }
            if (shouldPrintParens) {
              this.tokenChar(40);
              this._endsWithInnerRaw = false;
            }
            this._lastCommentLine = 0;
            this._printLeadingComments(node2, parent);
            var loc = nodeType === "Program" || nodeType === "File" ? null : node2.loc;
            this.exactSource(loc, printMethod.bind(this, node2, parent));
            if (shouldPrintParens) {
              this._printTrailingComments(node2, parent);
              this.tokenChar(41);
              this._noLineTerminator = noLineTerminatorAfter;
            } else if (noLineTerminatorAfter && !this._noLineTerminator) {
              this._noLineTerminator = true;
              this._printTrailingComments(node2, parent);
            } else {
              this._printTrailingComments(node2, parent, trailingCommentsLineOffset);
            }
            this._printStack.pop();
            format.concise = oldConcise;
            this._insideAux = oldInAux;
            this._endsWithInnerRaw = false;
          }
        },
        {
          key: "_maybeAddAuxComment",
          value: function _maybeAddAuxComment(enteredPositionlessNode) {
            if (enteredPositionlessNode)
              this._printAuxBeforeComment();
            if (!this._insideAux)
              this._printAuxAfterComment();
          }
        },
        {
          key: "_printAuxBeforeComment",
          value: function _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = true;
            var comment2 = this.format.auxiliaryCommentBefore;
            if (comment2) {
              this._printComment({
                type: "CommentBlock",
                value: comment2
              }, 0);
            }
          }
        },
        {
          key: "_printAuxAfterComment",
          value: function _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = false;
            var comment2 = this.format.auxiliaryCommentAfter;
            if (comment2) {
              this._printComment({
                type: "CommentBlock",
                value: comment2
              }, 0);
            }
          }
        },
        {
          key: "getPossibleRaw",
          value: function getPossibleRaw(node2) {
            var extra = node2.extra;
            if ((extra === null || extra === void 0 ? void 0 : extra.raw) != null && extra.rawValue != null && node2.value === extra.rawValue) {
              return extra.raw;
            }
          }
        },
        {
          key: "printJoin",
          value: function printJoin(nodes2, parent) {
            var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!(nodes2 === null || nodes2 === void 0 ? void 0 : nodes2.length))
              return;
            var indent2 = opts.indent;
            if (indent2 == null && this.format.retainLines) {
              var _nodes2__loc;
              var startLine = (_nodes2__loc = nodes2[0].loc) === null || _nodes2__loc === void 0 ? void 0 : _nodes2__loc.start.line;
              if (startLine != null && startLine !== this._buf.getCurrentLine()) {
                indent2 = true;
              }
            }
            if (indent2)
              this.indent();
            var newlineOpts = {
              addNewlines: opts.addNewlines,
              nextNodeStartLine: 0
            };
            var separator = opts.separator ? opts.separator.bind(this) : null;
            var len = nodes2.length;
            for (var i2 = 0; i2 < len; i2++) {
              var _opts_iterator;
              var node2 = nodes2[i2];
              if (!node2)
                continue;
              if (opts.statement)
                this._printNewline(i2 === 0, newlineOpts);
              this.print(node2, parent, void 0, opts.trailingCommentsLineOffset || 0);
              (_opts_iterator = opts.iterator) === null || _opts_iterator === void 0 ? void 0 : _opts_iterator.call(opts, node2, i2);
              if (i2 < len - 1)
                separator === null || separator === void 0 ? void 0 : separator();
              if (opts.statement) {
                var _node_trailingComments;
                if (!((_node_trailingComments = node2.trailingComments) === null || _node_trailingComments === void 0 ? void 0 : _node_trailingComments.length)) {
                  this._lastCommentLine = 0;
                }
                if (i2 + 1 === len) {
                  this.newline(1);
                } else {
                  var _nextNode_loc;
                  var nextNode = nodes2[i2 + 1];
                  newlineOpts.nextNodeStartLine = ((_nextNode_loc = nextNode.loc) === null || _nextNode_loc === void 0 ? void 0 : _nextNode_loc.start.line) || 0;
                  this._printNewline(true, newlineOpts);
                }
              }
            }
            if (indent2)
              this.dedent();
          }
        },
        {
          key: "printAndIndentOnComments",
          value: function printAndIndentOnComments(node2, parent) {
            var indent2 = node2.leadingComments && node2.leadingComments.length > 0;
            if (indent2)
              this.indent();
            this.print(node2, parent);
            if (indent2)
              this.dedent();
          }
        },
        {
          key: "printBlock",
          value: function printBlock(parent) {
            var node2 = parent.body;
            if (node2.type !== "EmptyStatement") {
              this.space();
            }
            this.print(node2, parent);
          }
        },
        {
          key: "_printTrailingComments",
          value: function _printTrailingComments(node2, parent, lineOffset) {
            var innerComments = node2.innerComments, trailingComments = node2.trailingComments;
            if (innerComments === null || innerComments === void 0 ? void 0 : innerComments.length) {
              this._printComments(2, innerComments, node2, parent, lineOffset);
            }
            if (trailingComments === null || trailingComments === void 0 ? void 0 : trailingComments.length) {
              this._printComments(2, trailingComments, node2, parent, lineOffset);
            }
          }
        },
        {
          key: "_printLeadingComments",
          value: function _printLeadingComments(node2, parent) {
            var comments = node2.leadingComments;
            if (!(comments === null || comments === void 0 ? void 0 : comments.length))
              return;
            this._printComments(0, comments, node2, parent);
          }
        },
        {
          key: "_maybePrintInnerComments",
          value: function _maybePrintInnerComments() {
            if (this._endsWithInnerRaw)
              this.printInnerComments();
            this._endsWithInnerRaw = true;
            this._indentInnerComments = true;
          }
        },
        {
          key: "printInnerComments",
          value: function printInnerComments() {
            var node2 = this._printStack[this._printStack.length - 1];
            var comments = node2.innerComments;
            if (!(comments === null || comments === void 0 ? void 0 : comments.length))
              return;
            var hasSpace = this.endsWith(32);
            var indent2 = this._indentInnerComments;
            var printedCommentsCount = this._printedComments.size;
            if (indent2)
              this.indent();
            this._printComments(1, comments, node2);
            if (hasSpace && printedCommentsCount !== this._printedComments.size) {
              this.space();
            }
            if (indent2)
              this.dedent();
          }
        },
        {
          key: "noIndentInnerCommentsHere",
          value: function noIndentInnerCommentsHere() {
            this._indentInnerComments = false;
          }
        },
        {
          key: "printSequence",
          value: function printSequence(nodes2, parent) {
            var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            opts.statement = true;
            var _opts_indent;
            (_opts_indent = opts.indent) !== null && _opts_indent !== void 0 ? _opts_indent : opts.indent = false;
            this.printJoin(nodes2, parent, opts);
          }
        },
        {
          key: "printList",
          value: function printList(items, parent) {
            var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (opts.separator == null) {
              opts.separator = commaSeparator;
            }
            this.printJoin(items, parent, opts);
          }
        },
        {
          key: "_printNewline",
          value: function _printNewline(newLine, opts) {
            var format = this.format;
            if (format.retainLines || format.compact)
              return;
            if (format.concise) {
              this.space();
              return;
            }
            if (!newLine) {
              return;
            }
            var startLine = opts.nextNodeStartLine;
            var lastCommentLine = this._lastCommentLine;
            if (startLine > 0 && lastCommentLine > 0) {
              var offset2 = startLine - lastCommentLine;
              if (offset2 >= 0) {
                this.newline(offset2 || 1);
                return;
              }
            }
            if (this._buf.hasContent()) {
              this.newline(1);
            }
          }
        },
        {
          key: "_shouldPrintComment",
          value: function _shouldPrintComment(comment2) {
            if (comment2.ignore)
              return 0;
            if (this._printedComments.has(comment2))
              return 0;
            if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment2.value)) {
              return 2;
            }
            this._printedComments.add(comment2);
            if (!this.format.shouldPrintComment(comment2.value)) {
              return 0;
            }
            return 1;
          }
        },
        {
          key: "_printComment",
          value: function _printComment(comment2, skipNewLines) {
            var noLineTerminator = this._noLineTerminator;
            var isBlockComment = comment2.type === "CommentBlock";
            var printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
            if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
              this.newline(1);
            }
            var lastCharCode = this.getLastChar();
            if (lastCharCode !== 91 && lastCharCode !== 123) {
              this.space();
            }
            var val;
            if (isBlockComment) {
              var _parenPushNewlineState = this._parenPushNewlineState;
              if ((_parenPushNewlineState === null || _parenPushNewlineState === void 0 ? void 0 : _parenPushNewlineState.printed) === false && HAS_NEWLINE.test(comment2.value)) {
                this.tokenChar(40);
                this.indent();
                _parenPushNewlineState.printed = true;
              }
              val = "/*".concat(comment2.value, "*/");
              if (this.format.indent.adjustMultilineComment) {
                var _comment_loc;
                var offset2 = (_comment_loc = comment2.loc) === null || _comment_loc === void 0 ? void 0 : _comment_loc.start.column;
                if (offset2) {
                  var newlineRegex = new RegExp("\\n\\s{1," + offset2 + "}", "g");
                  val = val.replace(newlineRegex, "\n");
                }
                if (this.format.concise) {
                  val = val.replace(/\n(?!$)/g, "\n");
                } else {
                  var indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                  if (this._shouldIndent(47) || this.format.retainLines) {
                    indentSize += this._getIndent();
                  }
                  val = val.replace(/\n(?!$)/g, "\n".concat(" ".repeat(indentSize)));
                }
              }
            } else if (!noLineTerminator) {
              val = "//".concat(comment2.value);
            } else {
              val = "/*".concat(comment2.value, "*/");
            }
            if (this.endsWith(47))
              this._space();
            this.source("start", comment2.loc);
            this._append(val, isBlockComment);
            if (!isBlockComment && !noLineTerminator) {
              this.newline(1, true);
            }
            if (printNewLines && skipNewLines !== 3) {
              this.newline(1);
            }
          }
        },
        {
          key: "_printComments",
          value: function _printComments(type3, comments, node2, parent) {
            var lineOffset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
            var nodeLoc = node2.loc;
            var len = comments.length;
            var hasLoc = !!nodeLoc;
            var nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
            var nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
            var lastLine = 0;
            var leadingCommentNewline = 0;
            var maybeNewline = this._noLineTerminator ? function maybeNewline2() {
            } : this.newline.bind(this);
            for (var i2 = 0; i2 < len; i2++) {
              var comment2 = comments[i2];
              var shouldPrint = this._shouldPrintComment(comment2);
              if (shouldPrint === 2) {
                hasLoc = false;
                break;
              }
              if (hasLoc && comment2.loc && shouldPrint === 1) {
                var commentStartLine = comment2.loc.start.line;
                var commentEndLine = comment2.loc.end.line;
                if (type3 === 0) {
                  var offset2 = 0;
                  if (i2 === 0) {
                    if (this._buf.hasContent() && (comment2.type === "CommentLine" || commentStartLine != commentEndLine)) {
                      offset2 = leadingCommentNewline = 1;
                    }
                  } else {
                    offset2 = commentStartLine - lastLine;
                  }
                  lastLine = commentEndLine;
                  maybeNewline(offset2);
                  this._printComment(comment2, 1);
                  if (i2 + 1 === len) {
                    maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                    lastLine = nodeStartLine;
                  }
                } else if (type3 === 1) {
                  var offset1 = commentStartLine - (i2 === 0 ? nodeStartLine : lastLine);
                  lastLine = commentEndLine;
                  maybeNewline(offset1);
                  this._printComment(comment2, 1);
                  if (i2 + 1 === len) {
                    maybeNewline(Math.min(1, nodeEndLine - lastLine));
                    lastLine = nodeEndLine;
                  }
                } else {
                  var offset22 = commentStartLine - (i2 === 0 ? nodeEndLine - lineOffset : lastLine);
                  lastLine = commentEndLine;
                  maybeNewline(offset22);
                  this._printComment(comment2, 1);
                }
              } else {
                hasLoc = false;
                if (shouldPrint !== 1) {
                  continue;
                }
                if (len === 1) {
                  var singleLine = comment2.loc ? comment2.loc.start.line === comment2.loc.end.line : !HAS_NEWLINE.test(comment2.value);
                  var shouldSkipNewline = singleLine && !isStatement3(node2) && !isClassBody2(parent) && !isTSInterfaceBody2(parent) && !isTSEnumDeclaration2(parent);
                  if (type3 === 0) {
                    this._printComment(comment2, shouldSkipNewline && node2.type !== "ObjectExpression" || singleLine && isFunction3(parent, {
                      body: node2
                    }) ? 1 : 0);
                  } else if (shouldSkipNewline && type3 === 2) {
                    this._printComment(comment2, 1);
                  } else {
                    this._printComment(comment2, 0);
                  }
                } else if (type3 === 1 && !(node2.type === "ObjectExpression" && node2.properties.length > 1) && node2.type !== "ClassBody" && node2.type !== "TSInterfaceBody") {
                  this._printComment(comment2, i2 === 0 ? 2 : i2 === len - 1 ? 3 : 0);
                } else {
                  this._printComment(comment2, 0);
                }
              }
            }
            if (type3 === 2 && hasLoc && lastLine) {
              this._lastCommentLine = lastLine;
            }
          }
        }
      ]);
      return Printer2;
    }();
    Object.assign(Printer.prototype, generatorFunctions);
    function commaSeparator() {
      this.tokenChar(44);
      this.space();
    }
    function normalizeOptions(code22, opts) {
      var _opts_recordAndTupleSyntaxType;
      var format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: true
        }, opts.jsescOption),
        recordAndTupleSyntaxType: (_opts_recordAndTupleSyntaxType = opts.recordAndTupleSyntaxType) !== null && _opts_recordAndTupleSyntaxType !== void 0 ? _opts_recordAndTupleSyntaxType : "hash",
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || function() {
          return format.comments;
        };
      } else {
        format.shouldPrintComment = format.shouldPrintComment || function(value1) {
          return format.comments || value1.includes("@license") || value1.includes("@preserve");
        };
      }
      if (format.compact === "auto") {
        format.compact = typeof code22 === "string" && code22.length > 5e5;
        if (format.compact) {
          console.error("[BABEL] Note: The code generator has deoptimised the styling of ".concat(opts.filename, " as it exceeds the max of ", "500KB", "."));
        }
      }
      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }
      var auxiliaryCommentBefore = format.auxiliaryCommentBefore, auxiliaryCommentAfter = format.auxiliaryCommentAfter, shouldPrintComment = format.shouldPrintComment;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    function generate2(ast) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, code22 = arguments.length > 2 ? arguments[2] : void 0;
      var format = normalizeOptions(code22, opts);
      var map = opts.sourceMaps ? new SourceMap(opts, code22) : null;
      var printer = new Printer(format, map);
      return printer.generate(ast);
    }
    var import_debug = __toESM2(require_src2(), 1);
    var cloneNode3 = lib_exports.cloneNode;
    var exportNamedDeclaration2 = lib_exports.exportNamedDeclaration;
    var exportSpecifier2 = lib_exports.exportSpecifier;
    var identifier3 = lib_exports.identifier;
    var variableDeclaration2 = lib_exports.variableDeclaration;
    var variableDeclarator2 = lib_exports.variableDeclarator;
    function splitExportDeclaration(exportDeclaration) {
      if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (exportDeclaration.isExportDefaultDeclaration()) {
        var declaration2 = exportDeclaration.get("declaration");
        var standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration();
        var exportExpr = declaration2.isFunctionExpression() || declaration2.isClassExpression();
        var scope2 = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
        var id = declaration2.node.id;
        var needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope2.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration2.node.id = cloneNode3(id);
          }
        } else if (exportExpr && scope2.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope2.generateUidIdentifier(id.name);
        }
        var updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration2("var", [
          variableDeclarator2(cloneNode3(id), declaration2.node)
        ]);
        var updatedExportDeclaration = exportNamedDeclaration2(null, [
          exportSpecifier2(cloneNode3(id), identifier3("default"))
        ]);
        exportDeclaration.insertAfter(updatedExportDeclaration);
        exportDeclaration.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope2.registerDeclaration(exportDeclaration);
        }
        return exportDeclaration;
      } else if (exportDeclaration.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      var declaration = exportDeclaration.get("declaration");
      var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      var specifiers = Object.keys(bindingIdentifiers).map(function(name2) {
        return exportSpecifier2(identifier3(name2), identifier3(name2));
      });
      var aliasDeclar = exportNamedDeclaration2(null, specifiers);
      exportDeclaration.insertAfter(aliasDeclar);
      exportDeclaration.replaceWith(declaration.node);
      return exportDeclaration;
    }
    function requeueComputedKeyAndDecorators(path) {
      var context = path.context, node2 = path.node;
      if (node2.computed) {
        context.maybeQueue(path.get("key"));
      }
      if (node2.decorators) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = path.get("decorators")[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var decorator2 = _step8.value;
            context.maybeQueue(decorator2);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
    }
    var visitor = {
      FunctionParent: function FunctionParent(path) {
        if (path.isArrowFunctionExpression()) {
          return;
        } else {
          path.skip();
          if (path.isMethod()) {
            requeueComputedKeyAndDecorators(path);
          }
        }
      },
      Property: function Property(path) {
        if (path.isObjectProperty()) {
          return;
        }
        path.skip();
        requeueComputedKeyAndDecorators(path);
      }
    };
    var import_globals = __toESM2(require_globals22(), 1);
    var assignmentExpression2 = lib_exports.assignmentExpression;
    var expressionStatement3 = lib_exports.expressionStatement;
    var identifier4 = lib_exports.identifier;
    var visitor2 = {
      Scope: function Scope5(path, state) {
        if (state.kind === "let")
          path.skip();
      },
      FunctionParent: function FunctionParent(path) {
        path.skip();
      },
      VariableDeclaration: function VariableDeclaration2(path, state) {
        if (state.kind && path.node.kind !== state.kind)
          return;
        var nodes2 = [];
        var declarations = path.get("declarations");
        var firstId;
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = declarations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var declar = _step8.value;
            firstId = declar.node.id;
            if (declar.node.init) {
              nodes2.push(expressionStatement3(assignmentExpression2("=", declar.node.id, declar.node.init)));
            }
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = Object.keys(declar.getBindingIdentifiers())[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var name2 = _step12.value;
                state.emit(identifier4(name2), name2, declar.node.init !== null);
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        if (path.parentPath.isFor({
          left: path.node
        })) {
          path.replaceWith(firstId);
        } else {
          path.replaceWithMultiple(nodes2);
        }
      }
    };
    function hoistVariables(path, emit) {
      var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "var";
      path.traverse(visitor2, {
        kind,
        emit
      });
    }
    var NOT_LOCAL_BINDING2 = lib_exports.NOT_LOCAL_BINDING;
    var cloneNode4 = lib_exports.cloneNode;
    var identifier5 = lib_exports.identifier;
    var isAssignmentExpression3 = lib_exports.isAssignmentExpression;
    var isAssignmentPattern3 = lib_exports.isAssignmentPattern;
    var isFunction4 = lib_exports.isFunction;
    var isIdentifier4 = lib_exports.isIdentifier;
    var isLiteral3 = lib_exports.isLiteral;
    var isNullLiteral2 = lib_exports.isNullLiteral;
    var isObjectMethod2 = lib_exports.isObjectMethod;
    var isObjectProperty2 = lib_exports.isObjectProperty;
    var isRegExpLiteral2 = lib_exports.isRegExpLiteral;
    var isRestElement2 = lib_exports.isRestElement;
    var isTemplateLiteral2 = lib_exports.isTemplateLiteral;
    var isVariableDeclarator2 = lib_exports.isVariableDeclarator;
    var toBindingIdentifierName2 = lib_exports.toBindingIdentifierName;
    function getFunctionArity(node2) {
      var count = node2.params.findIndex(function(param) {
        return isAssignmentPattern3(param) || isRestElement2(param);
      });
      return count === -1 ? node2.params.length : count;
    }
    var buildPropertyMethodAssignmentWrapper = index2.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
    var buildGeneratorPropertyMethodAssignmentWrapper = index2.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
    var visitor3 = {
      "ReferencedIdentifier|BindingIdentifier": function(path, state) {
        if (path.node.name !== state.name)
          return;
        var localDeclar = path.scope.getBindingIdentifier(state.name);
        if (localDeclar !== state.outerDeclar)
          return;
        state.selfReference = true;
        path.stop();
      }
    };
    function getNameFromLiteralId(id) {
      if (isNullLiteral2(id)) {
        return "null";
      }
      if (isRegExpLiteral2(id)) {
        return "_".concat(id.pattern, "_").concat(id.flags);
      }
      if (isTemplateLiteral2(id)) {
        return id.quasis.map(function(quasi) {
          return quasi.value.raw;
        }).join("");
      }
      if (id.value !== void 0) {
        return id.value + "";
      }
      return "";
    }
    function wrap3(state, method, id, scope2) {
      if (state.selfReference) {
        if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
          scope2.rename(id.name);
        } else {
          if (!isFunction4(method))
            return;
          var build = buildPropertyMethodAssignmentWrapper;
          if (method.generator) {
            build = buildGeneratorPropertyMethodAssignmentWrapper;
          }
          var _$template = build({
            FUNCTION: method,
            FUNCTION_ID: id,
            FUNCTION_KEY: scope2.generateUidIdentifier(id.name)
          }).expression;
          var params = _$template.callee.body.body[0].params;
          for (var i2 = 0, len = getFunctionArity(method); i2 < len; i2++) {
            params.push(scope2.generateUidIdentifier("x"));
          }
          return _$template;
        }
      }
      method.id = id;
      scope2.getProgramParent().references[id.name] = true;
    }
    function visit3(node2, name2, scope2) {
      var state = {
        selfAssignment: false,
        selfReference: false,
        outerDeclar: scope2.getBindingIdentifier(name2),
        name: name2
      };
      var binding = scope2.getOwnBinding(name2);
      if (binding) {
        if (binding.kind === "param") {
          state.selfReference = true;
        }
      } else if (state.outerDeclar || scope2.hasGlobal(name2)) {
        scope2.traverse(node2, visitor3, state);
      }
      return state;
    }
    function index22(param) {
      var node2 = param.node, parent = param.parent, scope2 = param.scope, id = param.id, localBinding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, supportUnicodeId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (node2.id)
        return;
      if ((isObjectProperty2(parent) || isObjectMethod2(parent, {
        kind: "method"
      })) && (!parent.computed || isLiteral3(parent.key))) {
        id = parent.key;
      } else if (isVariableDeclarator2(parent)) {
        id = parent.id;
        if (isIdentifier4(id) && !localBinding) {
          var binding = scope2.parent.getBinding(id.name);
          if (binding && binding.constant && scope2.getBinding(id.name) === binding) {
            node2.id = cloneNode4(id);
            node2.id[NOT_LOCAL_BINDING2] = true;
            return;
          }
        }
      } else if (isAssignmentExpression3(parent, {
        operator: "="
      })) {
        id = parent.left;
      } else if (!id) {
        return;
      }
      var name2;
      if (id && isLiteral3(id)) {
        name2 = getNameFromLiteralId(id);
      } else if (id && isIdentifier4(id)) {
        name2 = id.name;
      }
      if (name2 === void 0) {
        return;
      }
      if (!supportUnicodeId && isFunction4(node2) && /[\uD800-\uDFFF]/.test(name2)) {
        return;
      }
      name2 = toBindingIdentifierName2(name2);
      var newId = identifier5(name2);
      newId[NOT_LOCAL_BINDING2] = true;
      var state = visit3(node2, name2, scope2);
      return wrap3(state, node2, newId, scope2) || node2;
    }
    var ReferencedIdentifier = [
      "Identifier",
      "JSXIdentifier"
    ];
    var ReferencedMemberExpression = [
      "MemberExpression"
    ];
    var BindingIdentifier = [
      "Identifier"
    ];
    var Statement = [
      "Statement"
    ];
    var Expression = [
      "Expression"
    ];
    var Scope$1 = [
      "Scopable",
      "Pattern"
    ];
    var Referenced = null;
    var BlockScoped = null;
    var Var = [
      "VariableDeclaration"
    ];
    var User = null;
    var Generated = null;
    var Pure = null;
    var Flow = [
      "Flow",
      "ImportDeclaration",
      "ExportDeclaration",
      "ImportSpecifier"
    ];
    var RestProperty2 = [
      "RestElement"
    ];
    var SpreadProperty2 = [
      "RestElement"
    ];
    var ExistentialTypeParam = [
      "ExistsTypeAnnotation"
    ];
    var NumericLiteralTypeAnnotation = [
      "NumberLiteralTypeAnnotation"
    ];
    var ForAwaitStatement = [
      "ForOfStatement"
    ];
    var virtualTypes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BindingIdentifier,
      BlockScoped,
      ExistentialTypeParam,
      Expression,
      Flow,
      ForAwaitStatement,
      Generated,
      NumericLiteralTypeAnnotation,
      Pure,
      Referenced,
      ReferencedIdentifier,
      ReferencedMemberExpression,
      RestProperty: RestProperty2,
      Scope: Scope$1,
      SpreadProperty: SpreadProperty2,
      Statement,
      User,
      Var
    });
    var isBinding2 = lib_exports.isBinding;
    var nodeIsBlockScoped = lib_exports.isBlockScoped;
    var isExportDeclaration$1 = lib_exports.isExportDeclaration;
    var nodeIsExpression = lib_exports.isExpression;
    var nodeIsFlow = lib_exports.isFlow;
    var isForStatement3 = lib_exports.isForStatement;
    var isForXStatement2 = lib_exports.isForXStatement;
    var isIdentifier$6 = lib_exports.isIdentifier;
    var isImportDeclaration$1 = lib_exports.isImportDeclaration;
    var isImportSpecifier2 = lib_exports.isImportSpecifier;
    var isJSXIdentifier3 = lib_exports.isJSXIdentifier;
    var isJSXMemberExpression2 = lib_exports.isJSXMemberExpression;
    var isMemberExpression3 = lib_exports.isMemberExpression;
    var nodeIsRestElement = lib_exports.isRestElement;
    var nodeIsReferenced = lib_exports.isReferenced;
    var nodeIsScope = lib_exports.isScope;
    var nodeIsStatement = lib_exports.isStatement;
    var nodeIsVar = lib_exports.isVar;
    var isVariableDeclaration$2 = lib_exports.isVariableDeclaration;
    var react$1 = lib_exports.react;
    var isForOfStatement3 = lib_exports.isForOfStatement;
    var isCompatTag2 = react$1.isCompatTag;
    function isReferencedIdentifier(opts) {
      var _this = this, node2 = _this.node, parent = _this.parent;
      if (!isIdentifier$6(node2, opts) && !isJSXMemberExpression2(parent, opts)) {
        if (isJSXIdentifier3(node2, opts)) {
          if (isCompatTag2(node2.name))
            return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      var _this = this, node2 = _this.node, parent = _this.parent;
      return isMemberExpression3(node2) && nodeIsReferenced(node2, parent);
    }
    function isBindingIdentifier() {
      var _this = this, node2 = _this.node, parent = _this.parent;
      var grandparent = this.parentPath.parent;
      return isIdentifier$6(node2) && isBinding2(node2, parent, grandparent);
    }
    function isStatement$13() {
      var _this = this, node2 = _this.node, parent = _this.parent;
      if (nodeIsStatement(node2)) {
        if (isVariableDeclaration$2(node2)) {
          if (isForXStatement2(parent, {
            left: node2
          }))
            return false;
          if (isForStatement3(parent, {
            init: node2
          }))
            return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression$3() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope2() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced2() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped2() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar2() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow2() {
      var node2 = this.node;
      if (nodeIsFlow(node2)) {
        return true;
      } else if (isImportDeclaration$1(node2)) {
        return node2.importKind === "type" || node2.importKind === "typeof";
      } else if (isExportDeclaration$1(node2)) {
        return node2.exportKind === "type";
      } else if (isImportSpecifier2(node2)) {
        return node2.importKind === "type" || node2.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty2() {
      return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
    }
    function isSpreadProperty2() {
      return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
    }
    function isForAwaitStatement() {
      return isForOfStatement3(this.node, {
        await: true
      });
    }
    var NodePath_virtual_types_validator = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isBindingIdentifier,
      isBlockScoped: isBlockScoped2,
      isExpression: isExpression$3,
      isFlow: isFlow2,
      isForAwaitStatement,
      isGenerated,
      isPure,
      isReferenced: isReferenced2,
      isReferencedIdentifier,
      isReferencedMemberExpression,
      isRestProperty: isRestProperty2,
      isScope: isScope2,
      isSpreadProperty: isSpreadProperty2,
      isStatement: isStatement$13,
      isUser,
      isVar: isVar2
    });
    var DEPRECATED_KEYS2 = lib_exports.DEPRECATED_KEYS;
    var DEPRECATED_ALIASES2 = lib_exports.DEPRECATED_ALIASES;
    var FLIPPED_ALIAS_KEYS3 = lib_exports.FLIPPED_ALIAS_KEYS;
    var TYPES2 = lib_exports.TYPES;
    var deprecationWarning2 = lib_exports.__internal__deprecationWarning;
    function isVirtualType(type3) {
      return type3 in virtualTypes;
    }
    function isExplodedVisitor(visitor4) {
      return visitor4 === null || visitor4 === void 0 ? void 0 : visitor4._exploded;
    }
    function explode(visitor4) {
      if (isExplodedVisitor(visitor4))
        return visitor4;
      visitor4._exploded = true;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(visitor4)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var nodeType = _step8.value;
          if (shouldIgnoreKey(nodeType))
            continue;
          var parts = nodeType.split("|");
          if (parts.length === 1)
            continue;
          var fns = visitor4[nodeType];
          delete visitor4[nodeType];
          var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = parts[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var part = _step12.value;
              visitor4[part] = fns;
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      verify(visitor4);
      delete visitor4.__esModule;
      ensureEntranceObjects(visitor4);
      ensureCallbackArrays(visitor4);
      var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
      try {
        for (var _iterator22 = Object.keys(visitor4)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var nodeType1 = _step22.value;
          if (shouldIgnoreKey(nodeType1))
            continue;
          if (!isVirtualType(nodeType1))
            continue;
          var fns1 = visitor4[nodeType1];
          var _iteratorNormalCompletion32 = true, _didIteratorError32 = false, _iteratorError32 = void 0;
          try {
            for (var _iterator32 = Object.keys(fns1)[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
              var type3 = _step32.value;
              fns1[type3] = wrapCheck(nodeType1, fns1[type3]);
            }
          } catch (err) {
            _didIteratorError32 = true;
            _iteratorError32 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                _iterator32.return();
              }
            } finally {
              if (_didIteratorError32) {
                throw _iteratorError32;
              }
            }
          }
          delete visitor4[nodeType1];
          var types22 = virtualTypes[nodeType1];
          if (types22 !== null) {
            var _iteratorNormalCompletion42 = true, _didIteratorError42 = false, _iteratorError42 = void 0;
            try {
              for (var _iterator42 = types22[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                var type12 = _step42.value;
                if (visitor4[type12]) {
                  mergePair(visitor4[type12], fns1);
                } else {
                  visitor4[type12] = fns1;
                }
              }
            } catch (err) {
              _didIteratorError42 = true;
              _iteratorError42 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion42 && _iterator42.return != null) {
                  _iterator42.return();
                }
              } finally {
                if (_didIteratorError42) {
                  throw _iteratorError42;
                }
              }
            }
          } else {
            mergePair(visitor4, fns1);
          }
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
            _iterator22.return();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }
      var _iteratorNormalCompletion52 = true, _didIteratorError52 = false, _iteratorError52 = void 0;
      try {
        for (var _iterator52 = Object.keys(visitor4)[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
          var nodeType2 = _step52.value;
          if (shouldIgnoreKey(nodeType2))
            continue;
          var aliases = FLIPPED_ALIAS_KEYS3[nodeType2];
          if (nodeType2 in DEPRECATED_KEYS2) {
            var deprecatedKey = DEPRECATED_KEYS2[nodeType2];
            deprecationWarning2(nodeType2, deprecatedKey, "Visitor ");
            aliases = [
              deprecatedKey
            ];
          } else if (nodeType2 in DEPRECATED_ALIASES2) {
            var deprecatedAlias = DEPRECATED_ALIASES2[nodeType2];
            deprecationWarning2(nodeType2, deprecatedAlias, "Visitor ");
            aliases = FLIPPED_ALIAS_KEYS3[deprecatedAlias];
          }
          if (!aliases)
            continue;
          var fns2 = visitor4[nodeType2];
          delete visitor4[nodeType2];
          var _iteratorNormalCompletion62 = true, _didIteratorError62 = false, _iteratorError62 = void 0;
          try {
            for (var _iterator62 = aliases[Symbol.iterator](), _step62; !(_iteratorNormalCompletion62 = (_step62 = _iterator62.next()).done); _iteratorNormalCompletion62 = true) {
              var alias2 = _step62.value;
              var existing = visitor4[alias2];
              if (existing) {
                mergePair(existing, fns2);
              } else {
                visitor4[alias2] = Object.assign({}, fns2);
              }
            }
          } catch (err) {
            _didIteratorError62 = true;
            _iteratorError62 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion62 && _iterator62.return != null) {
                _iterator62.return();
              }
            } finally {
              if (_didIteratorError62) {
                throw _iteratorError62;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError52 = true;
        _iteratorError52 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion52 && _iterator52.return != null) {
            _iterator52.return();
          }
        } finally {
          if (_didIteratorError52) {
            throw _iteratorError52;
          }
        }
      }
      var _iteratorNormalCompletion72 = true, _didIteratorError72 = false, _iteratorError72 = void 0;
      try {
        for (var _iterator72 = Object.keys(visitor4)[Symbol.iterator](), _step72; !(_iteratorNormalCompletion72 = (_step72 = _iterator72.next()).done); _iteratorNormalCompletion72 = true) {
          var nodeType3 = _step72.value;
          if (shouldIgnoreKey(nodeType3))
            continue;
          ensureCallbackArrays(visitor4[nodeType3]);
        }
      } catch (err) {
        _didIteratorError72 = true;
        _iteratorError72 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion72 && _iterator72.return != null) {
            _iterator72.return();
          }
        } finally {
          if (_didIteratorError72) {
            throw _iteratorError72;
          }
        }
      }
      return visitor4;
    }
    function verify(visitor4) {
      if (visitor4._verified)
        return;
      if (typeof visitor4 === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(visitor4)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var nodeType = _step8.value;
          if (nodeType === "enter" || nodeType === "exit") {
            validateVisitorMethods(nodeType, visitor4[nodeType]);
          }
          if (shouldIgnoreKey(nodeType))
            continue;
          if (TYPES2.indexOf(nodeType) < 0) {
            throw new Error("You gave us a visitor for the node type ".concat(nodeType, " but it's not a valid type"));
          }
          var visitors2 = visitor4[nodeType];
          if (typeof visitors2 === "object") {
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = Object.keys(visitors2)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var visitorKey = _step12.value;
                if (visitorKey === "enter" || visitorKey === "exit") {
                  validateVisitorMethods("".concat(nodeType, ".").concat(visitorKey), visitors2[visitorKey]);
                } else {
                  throw new Error("You passed `traverse()` a visitor object with the property ".concat(nodeType, " that has the invalid property ").concat(visitorKey));
                }
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      visitor4._verified = true;
    }
    function validateVisitorMethods(path, val) {
      var fns = [].concat(val);
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = fns[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var fn = _step8.value;
          if (typeof fn !== "function") {
            throw new TypeError("Non-function found defined in ".concat(path, " with type ").concat(typeof fn === "undefined" ? "undefined" : _type_of(fn)));
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    function merge22(visitors2) {
      var states = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], wrapper = arguments.length > 2 ? arguments[2] : void 0;
      var mergedVisitor = {};
      for (var i2 = 0; i2 < visitors2.length; i2++) {
        var visitor4 = explode(visitors2[i2]);
        var state = states[i2];
        var topVisitor = visitor4;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = Object.keys(visitor4)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var key = _step8.value;
            if (shouldIgnoreKey(key))
              continue;
            var typeVisitor = visitor4[key];
            if (state || wrapper) {
              typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
            }
            var nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
            mergePair(nodeVisitor, typeVisitor);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      {
        return Object.assign({}, mergedVisitor, {
          _exploded: true,
          _verified: true
        });
      }
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      var _loop5 = function(_i2, _iter2) {
        var phase = _iter2[_i2];
        var fns = oldVisitor[phase];
        if (!Array.isArray(fns))
          return "continue";
        fns = fns.map(function(fn) {
          var newFn = fn;
          if (state) {
            newFn = function newFn2(path) {
              fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state === null || state === void 0 ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = function() {
              return fn.toString();
            };
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      };
      var newVisitor = {};
      for (var _i = 0, _iter = [
        "enter",
        "exit"
      ]; _i < _iter.length; _i++)
        _loop5(_i, _iter);
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = Object.keys(obj)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          if (shouldIgnoreKey(key))
            continue;
          var fns = obj[key];
          if (typeof fns === "function") {
            obj[key] = {
              enter: fns
            };
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter))
        obj.enter = [
          obj.enter
        ];
      if (obj.exit && !Array.isArray(obj.exit))
        obj.exit = [
          obj.exit
        ];
    }
    function wrapCheck(nodeType, fn) {
      var fnKey = "is".concat(nodeType);
      var validator = NodePath_virtual_types_validator[fnKey];
      var newFn = function newFn2(path) {
        if (validator.call(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = function() {
        return fn.toString();
      };
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_")
        return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip")
        return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys") {
        return true;
      }
      return false;
    }
    function mergePair(dest, src) {
      for (var _i = 0, _iter = [
        "enter",
        "exit"
      ]; _i < _iter.length; _i++) {
        var phase = _iter[_i];
        if (!src[phase])
          continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
    var visitors = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      explode,
      isExplodedVisitor,
      merge: merge22,
      verify
    });
    var pathsCache = /* @__PURE__ */ new WeakMap();
    var scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache_get;
      return (_pathsCache_get = pathsCache.get(hub !== null && hub !== void 0 ? hub : nullHub)) === null || _pathsCache_get === void 0 ? void 0 : _pathsCache_get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      var parents = pathsCache.get(hub !== null && hub !== void 0 ? hub : nullHub);
      if (!parents)
        pathsCache.set(hub !== null && hub !== void 0 ? hub : nullHub, parents = /* @__PURE__ */ new WeakMap());
      var paths = parents.get(parent);
      if (!paths)
        parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
    var cache = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      clear,
      clearPath,
      clearScope,
      getCachedPaths,
      getOrCreateCachedPaths,
      get path() {
        return pathsCache;
      },
      get scope() {
        return scope;
      }
    });
    var renameVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier2(param, state) {
        var node2 = param.node;
        if (node2.name === state.oldName) {
          node2.name = state.newName;
        }
      },
      Scope: function Scope5(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
          if (path.isMethod()) {
            requeueComputedKeyAndDecorators(path);
          }
        }
      },
      ObjectProperty: function ObjectProperty2(param, state) {
        var node2 = param.node, scope2 = param.scope;
        var name2 = node2.key.name;
        if (node2.shorthand && (name2 === state.oldName || name2 === state.newName) && scope2.getBindingIdentifier(name2) === state.binding.identifier) {
          var _node_extra;
          node2.shorthand = false;
          if ((_node_extra = node2.extra) === null || _node_extra === void 0 ? void 0 : _node_extra.shorthand)
            node2.extra.shorthand = false;
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator": function(path, state) {
        if (path.isVariableDeclaration())
          return;
        var ids = path.getOuterBindingIdentifiers();
        for (var name2 in ids) {
          if (name2 === state.oldName)
            ids[name2].name = state.newName;
        }
      }
    };
    var Renamer = /* @__PURE__ */ function() {
      "use strict";
      function Renamer2(binding, oldName, newName) {
        _class_call_check(this, Renamer2);
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      _create_class(Renamer2, [
        {
          key: "maybeConvertFromExportDeclaration",
          value: function maybeConvertFromExportDeclaration(parentDeclar) {
            var maybeExportDeclar = parentDeclar.parentPath;
            if (!maybeExportDeclar.isExportDeclaration()) {
              return;
            }
            if (maybeExportDeclar.isExportDefaultDeclaration()) {
              var declaration = maybeExportDeclar.node.declaration;
              if (isDeclaration2(declaration) && !declaration.id) {
                return;
              }
            }
            if (maybeExportDeclar.isExportAllDeclaration()) {
              return;
            }
            splitExportDeclaration(maybeExportDeclar);
          }
        },
        {
          key: "maybeConvertFromClassFunctionDeclaration",
          value: function maybeConvertFromClassFunctionDeclaration(path) {
            return path;
          }
        },
        {
          key: "maybeConvertFromClassFunctionExpression",
          value: function maybeConvertFromClassFunctionExpression(path) {
            return path;
          }
        },
        {
          key: "rename",
          value: function rename() {
            var _this = this, binding = _this.binding, oldName = _this.oldName, newName = _this.newName;
            var scope2 = binding.scope, path = binding.path;
            var parentDeclar = path.find(function(path2) {
              return path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression();
            });
            if (parentDeclar) {
              var bindingIds = parentDeclar.getOuterBindingIdentifiers();
              if (bindingIds[oldName] === binding.identifier) {
                this.maybeConvertFromExportDeclaration(parentDeclar);
              }
            }
            var blockToTraverse = scope2.block;
            traverseNode(blockToTraverse, explode(renameVisitor), scope2, this, scope2.path, {
              discriminant: true
            });
            {
              scope2.removeOwnBinding(oldName);
              scope2.bindings[newName] = binding;
              this.binding.identifier.name = newName;
            }
            if (parentDeclar) {
              this.maybeConvertFromClassFunctionDeclaration(path);
              this.maybeConvertFromClassFunctionExpression(path);
            }
          }
        }
      ]);
      return Renamer2;
    }();
    var Binding = /* @__PURE__ */ function() {
      "use strict";
      function Binding2(param) {
        var identifier7 = param.identifier, scope2 = param.scope, path = param.path, kind = param.kind;
        _class_call_check(this, Binding2);
        __publicField(this, "identifier");
        __publicField(this, "scope");
        __publicField(this, "path");
        __publicField(this, "kind");
        __publicField(this, "constantViolations", []);
        __publicField(this, "constant", true);
        __publicField(this, "referencePaths", []);
        __publicField(this, "referenced", false);
        __publicField(this, "references", 0);
        this.identifier = identifier7;
        this.scope = scope2;
        this.path = path;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path)) {
          this.reassign(path);
        }
        this.clearValue();
      }
      _create_class(Binding2, [
        {
          key: "deoptValue",
          value: function deoptValue() {
            this.clearValue();
            this.hasDeoptedValue = true;
          }
        },
        {
          key: "setValue",
          value: function setValue(value1) {
            if (this.hasDeoptedValue)
              return;
            this.hasValue = true;
            this.value = value1;
          }
        },
        {
          key: "clearValue",
          value: function clearValue() {
            this.hasDeoptedValue = false;
            this.hasValue = false;
            this.value = null;
          }
        },
        {
          key: "reassign",
          value: function reassign(path) {
            this.constant = false;
            if (this.constantViolations.indexOf(path) !== -1) {
              return;
            }
            this.constantViolations.push(path);
          }
        },
        {
          key: "reference",
          value: function reference(path) {
            if (this.referencePaths.indexOf(path) !== -1) {
              return;
            }
            this.referenced = true;
            this.references++;
            this.referencePaths.push(path);
          }
        },
        {
          key: "dereference",
          value: function dereference() {
            this.references--;
            this.referenced = !!this.references;
          }
        }
      ]);
      return Binding2;
    }();
    function isDeclaredInLoop(path) {
      var ref2;
      for (var parentPath = path.parentPath, key = path.key; parentPath; ref2 = parentPath, parentPath = ref2.parentPath, key = ref2.key, ref2) {
        if (parentPath.isFunctionParent())
          return false;
        if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
          return true;
        }
      }
      return false;
    }
    var NOT_LOCAL_BINDING3 = lib_exports.NOT_LOCAL_BINDING;
    var callExpression$3 = lib_exports.callExpression;
    var cloneNode$3 = lib_exports.cloneNode;
    var getBindingIdentifiers$3 = lib_exports.getBindingIdentifiers;
    var identifier$3 = lib_exports.identifier;
    var isArrayExpression3 = lib_exports.isArrayExpression;
    var isBinary3 = lib_exports.isBinary;
    var isClass2 = lib_exports.isClass;
    var isClassBody3 = lib_exports.isClassBody;
    var isClassDeclaration3 = lib_exports.isClassDeclaration;
    var isExportAllDeclaration2 = lib_exports.isExportAllDeclaration;
    var isExportDefaultDeclaration3 = lib_exports.isExportDefaultDeclaration;
    var isExportNamedDeclaration$1 = lib_exports.isExportNamedDeclaration;
    var isFunctionDeclaration2 = lib_exports.isFunctionDeclaration;
    var isIdentifier$5 = lib_exports.isIdentifier;
    var isImportDeclaration2 = lib_exports.isImportDeclaration;
    var isLiteral$12 = lib_exports.isLiteral;
    var isMethod2 = lib_exports.isMethod;
    var isModuleSpecifier2 = lib_exports.isModuleSpecifier;
    var isNullLiteral3 = lib_exports.isNullLiteral;
    var isObjectExpression3 = lib_exports.isObjectExpression;
    var isProperty2 = lib_exports.isProperty;
    var isPureish2 = lib_exports.isPureish;
    var isRegExpLiteral3 = lib_exports.isRegExpLiteral;
    var isSuper$1 = lib_exports.isSuper;
    var isTaggedTemplateExpression2 = lib_exports.isTaggedTemplateExpression;
    var isTemplateLiteral3 = lib_exports.isTemplateLiteral;
    var isThisExpression2 = lib_exports.isThisExpression;
    var isUnaryExpression2 = lib_exports.isUnaryExpression;
    var isVariableDeclaration$1 = lib_exports.isVariableDeclaration;
    var matchesPattern$1 = lib_exports.matchesPattern;
    var memberExpression$1 = lib_exports.memberExpression;
    var numericLiteral$2 = lib_exports.numericLiteral;
    var toIdentifier22 = lib_exports.toIdentifier;
    var variableDeclaration$1 = lib_exports.variableDeclaration;
    var variableDeclarator$1 = lib_exports.variableDeclarator;
    var isRecordExpression2 = lib_exports.isRecordExpression;
    var isTupleExpression2 = lib_exports.isTupleExpression;
    var isObjectProperty3 = lib_exports.isObjectProperty;
    var isTopicReference2 = lib_exports.isTopicReference;
    var isMetaProperty2 = lib_exports.isMetaProperty;
    var isPrivateName2 = lib_exports.isPrivateName;
    var isExportDeclaration3 = lib_exports.isExportDeclaration;
    var buildUndefinedNode$1 = lib_exports.buildUndefinedNode;
    function gatherNodeParts(node2, parts) {
      switch (node2 === null || node2 === void 0 ? void 0 : node2.type) {
        default:
          if (isImportDeclaration2(node2) || isExportDeclaration3(node2)) {
            var _node_specifiers;
            if ((isExportAllDeclaration2(node2) || isExportNamedDeclaration$1(node2) || isImportDeclaration2(node2)) && node2.source) {
              gatherNodeParts(node2.source, parts);
            } else if ((isExportNamedDeclaration$1(node2) || isImportDeclaration2(node2)) && ((_node_specifiers = node2.specifiers) === null || _node_specifiers === void 0 ? void 0 : _node_specifiers.length)) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = node2.specifiers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var e = _step8.value;
                  gatherNodeParts(e, parts);
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            } else if ((isExportDefaultDeclaration3(node2) || isExportNamedDeclaration$1(node2)) && node2.declaration) {
              gatherNodeParts(node2.declaration, parts);
            }
          } else if (isModuleSpecifier2(node2)) {
            gatherNodeParts(node2.local, parts);
          } else if (isLiteral$12(node2) && !isNullLiteral3(node2) && !isRegExpLiteral3(node2) && !isTemplateLiteral3(node2)) {
            parts.push(node2.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node2.object, parts);
          gatherNodeParts(node2.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node2.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node2.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = node2.properties[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var e1 = _step12.value;
              gatherNodeParts(e1, parts);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node2.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node2.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node2.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node2.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node2.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node2.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node2.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node2.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node2.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node2.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node2.meta, parts);
          gatherNodeParts(node2.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node2.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node2.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node2.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node2.namespace, parts);
          gatherNodeParts(node2.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      ForStatement: function ForStatement2(path) {
        var declar = path.get("init");
        if (declar.isVar()) {
          var scope2 = path.scope;
          var parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration: function Declaration(path) {
        if (path.isBlockScoped())
          return;
        if (path.isImportDeclaration())
          return;
        if (path.isExportDeclaration())
          return;
        var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration: function ImportDeclaration2(path) {
        var parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier: function ReferencedIdentifier2(path, state) {
        state.references.push(path);
      },
      ForXStatement: function ForXStatement2(path, state) {
        var left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        } else if (left.isVar()) {
          var scope2 = path.scope;
          var parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit: function exit2(path) {
          var node2 = path.node, scope2 = path.scope;
          if (isExportAllDeclaration2(node2))
            return;
          var declar = node2.declaration;
          if (isClassDeclaration3(declar) || isFunctionDeclaration2(declar)) {
            var id = declar.id;
            if (!id)
              return;
            var binding = scope2.getBinding(id.name);
            binding === null || binding === void 0 ? void 0 : binding.reference(path);
          } else if (isVariableDeclaration$1(declar)) {
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = declar.declarations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var decl = _step8.value;
                var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                try {
                  for (var _iterator12 = Object.keys(getBindingIdentifiers$3(decl))[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var name2 = _step12.value;
                    var binding1 = scope2.getBinding(name2);
                    binding1 === null || binding1 === void 0 ? void 0 : binding1.reference(path);
                  }
                } catch (err) {
                  _didIteratorError12 = true;
                  _iteratorError12 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                      _iterator12.return();
                    }
                  } finally {
                    if (_didIteratorError12) {
                      throw _iteratorError12;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        }
      },
      LabeledStatement: function LabeledStatement2(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression: function AssignmentExpression3(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression: function UpdateExpression3(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression: function UnaryExpression3(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped: function BlockScoped2(path) {
        var scope2 = path.scope;
        if (scope2.path === path)
          scope2 = scope2.parent;
        var parent = scope2.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          var id = path.node.id;
          var name2 = id.name;
          path.scope.bindings[name2] = path.scope.parent.getBinding(name2);
        }
      },
      CatchClause: function CatchClause2(path) {
        path.scope.registerBinding("let", path);
      },
      Function: function Function1(path) {
        var params = path.get("params");
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var param = _step8.value;
            path.scope.registerBinding("param", param);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING3]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      ClassExpression: function ClassExpression2(path) {
        if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING3]) {
          path.scope.registerBinding("local", path);
        }
      }
    };
    var uid = 0;
    var _Scope = /* @__PURE__ */ function() {
      "use strict";
      function _Scope2(path) {
        _class_call_check(this, _Scope2);
        __publicField(this, "uid");
        __publicField(this, "path");
        __publicField(this, "block");
        __publicField(this, "labels");
        __publicField(this, "inited");
        __publicField(this, "bindings");
        __publicField(this, "references");
        __publicField(this, "globals");
        __publicField(this, "uids");
        __publicField(this, "data");
        __publicField(this, "crawling");
        var node2 = path.node;
        var cached = scope.get(node2);
        if ((cached === null || cached === void 0 ? void 0 : cached.path) === path) {
          return cached;
        }
        scope.set(node2, this);
        this.uid = uid++;
        this.block = node2;
        this.path = path;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      _create_class(_Scope2, [
        {
          key: "parent",
          get: function get3() {
            var parent, path = this.path;
            do {
              var shouldSkip2 = path.key === "key" || path.listKey === "decorators";
              path = path.parentPath;
              if (shouldSkip2 && path.isMethod())
                path = path.parentPath;
              if (path && path.isScope())
                parent = path;
            } while (path && !parent);
            return parent === null || parent === void 0 ? void 0 : parent.scope;
          }
        },
        {
          key: "parentBlock",
          get: function get3() {
            return this.path.parent;
          }
        },
        {
          key: "hub",
          get: function get3() {
            return this.path.hub;
          }
        },
        {
          key: "traverse",
          value: function traverse4(node2, opts, state) {
            traverse3(node2, opts, this, state, this.path);
          }
        },
        {
          key: "generateDeclaredUidIdentifier",
          value: function generateDeclaredUidIdentifier(name2) {
            var id = this.generateUidIdentifier(name2);
            this.push({
              id
            });
            return cloneNode$3(id);
          }
        },
        {
          key: "generateUidIdentifier",
          value: function generateUidIdentifier(name2) {
            return identifier$3(this.generateUid(name2));
          }
        },
        {
          key: "generateUid",
          value: function generateUid() {
            var name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
            name2 = toIdentifier22(name2).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            var uid2;
            var i2 = 1;
            do {
              uid2 = this._generateUid(name2, i2);
              i2++;
            } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
            var program3 = this.getProgramParent();
            program3.references[uid2] = true;
            program3.uids[uid2] = true;
            return uid2;
          }
        },
        {
          key: "_generateUid",
          value: function _generateUid(name2, i2) {
            var id = name2;
            if (i2 > 1)
              id += i2;
            return "_".concat(id);
          }
        },
        {
          key: "generateUidBasedOnNode",
          value: function generateUidBasedOnNode(node2, defaultName) {
            var parts = [];
            gatherNodeParts(node2, parts);
            var id = parts.join("$");
            id = id.replace(/^_/, "") || defaultName || "ref";
            return this.generateUid(id.slice(0, 20));
          }
        },
        {
          key: "generateUidIdentifierBasedOnNode",
          value: function generateUidIdentifierBasedOnNode(node2, defaultName) {
            return identifier$3(this.generateUidBasedOnNode(node2, defaultName));
          }
        },
        {
          key: "isStatic",
          value: function isStatic2(node2) {
            if (isThisExpression2(node2) || isSuper$1(node2) || isTopicReference2(node2)) {
              return true;
            }
            if (isIdentifier$5(node2)) {
              var binding = this.getBinding(node2.name);
              if (binding) {
                return binding.constant;
              } else {
                return this.hasBinding(node2.name);
              }
            }
            return false;
          }
        },
        {
          key: "maybeGenerateMemoised",
          value: function maybeGenerateMemoised(node2, dontPush) {
            if (this.isStatic(node2)) {
              return null;
            } else {
              var id = this.generateUidIdentifierBasedOnNode(node2);
              if (!dontPush) {
                this.push({
                  id
                });
                return cloneNode$3(id);
              }
              return id;
            }
          }
        },
        {
          key: "checkBlockScopedCollisions",
          value: function checkBlockScopedCollisions(local, kind, name2, id) {
            if (kind === "param")
              return;
            if (local.kind === "local")
              return;
            var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
            if (duplicate) {
              throw this.hub.buildError(id, 'Duplicate declaration "'.concat(name2, '"'), TypeError);
            }
          }
        },
        {
          key: "rename",
          value: function rename(oldName, newName) {
            var binding = this.getBinding(oldName);
            if (binding) {
              newName || (newName = this.generateUidIdentifier(oldName).name);
              var renamer = new Renamer(binding, oldName, newName);
              {
                renamer.rename();
              }
            }
          }
        },
        {
          key: "_renameFromMap",
          value: function _renameFromMap(map, oldName, newName, value1) {
            if (map[oldName]) {
              map[newName] = value1;
              map[oldName] = null;
            }
          }
        },
        {
          key: "dump",
          value: function dump() {
            var sep = "-".repeat(60);
            console.log(sep);
            var scope2 = this;
            do {
              console.log("#", scope2.block.type);
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = Object.keys(scope2.bindings)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var name2 = _step8.value;
                  var binding = scope2.bindings[name2];
                  console.log(" -", name2, {
                    constant: binding.constant,
                    references: binding.references,
                    violations: binding.constantViolations.length,
                    kind: binding.kind
                  });
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            } while (scope2 = scope2.parent);
            console.log(sep);
          }
        },
        {
          key: "toArray",
          value: function toArray(node2, i2, arrayLikeIsIterable) {
            if (isIdentifier$5(node2)) {
              var binding = this.getBinding(node2.name);
              if ((binding === null || binding === void 0 ? void 0 : binding.constant) && binding.path.isGenericType("Array")) {
                return node2;
              }
            }
            if (isArrayExpression3(node2)) {
              return node2;
            }
            if (isIdentifier$5(node2, {
              name: "arguments"
            })) {
              return callExpression$3(memberExpression$1(memberExpression$1(memberExpression$1(identifier$3("Array"), identifier$3("prototype")), identifier$3("slice")), identifier$3("call")), [
                node2
              ]);
            }
            var helperName;
            var args = [
              node2
            ];
            if (i2 === true) {
              helperName = "toConsumableArray";
            } else if (typeof i2 === "number") {
              args.push(numericLiteral$2(i2));
              helperName = "slicedToArray";
            } else {
              helperName = "toArray";
            }
            if (arrayLikeIsIterable) {
              args.unshift(this.hub.addHelper(helperName));
              helperName = "maybeArrayLike";
            }
            return callExpression$3(this.hub.addHelper(helperName), args);
          }
        },
        {
          key: "hasLabel",
          value: function hasLabel(name2) {
            return !!this.getLabel(name2);
          }
        },
        {
          key: "getLabel",
          value: function getLabel(name2) {
            return this.labels.get(name2);
          }
        },
        {
          key: "registerLabel",
          value: function registerLabel(path) {
            this.labels.set(path.node.label.name, path);
          }
        },
        {
          key: "registerDeclaration",
          value: function registerDeclaration(path) {
            if (path.isLabeledStatement()) {
              this.registerLabel(path);
            } else if (path.isFunctionDeclaration()) {
              this.registerBinding("hoisted", path.get("id"), path);
            } else if (path.isVariableDeclaration()) {
              var declarations = path.get("declarations");
              var kind = path.node.kind;
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = declarations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var declar = _step8.value;
                  this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            } else if (path.isClassDeclaration()) {
              if (path.node.declare)
                return;
              this.registerBinding("let", path);
            } else if (path.isImportDeclaration()) {
              var isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
              var specifiers = path.get("specifiers");
              var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
              try {
                for (var _iterator12 = specifiers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                  var specifier = _step12.value;
                  var isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
                  this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
                }
              } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                    _iterator12.return();
                  }
                } finally {
                  if (_didIteratorError12) {
                    throw _iteratorError12;
                  }
                }
              }
            } else if (path.isExportDeclaration()) {
              var declar1 = path.get("declaration");
              if (declar1.isClassDeclaration() || declar1.isFunctionDeclaration() || declar1.isVariableDeclaration()) {
                this.registerDeclaration(declar1);
              }
            } else {
              this.registerBinding("unknown", path);
            }
          }
        },
        {
          key: "buildUndefinedNode",
          value: function buildUndefinedNode3() {
            return buildUndefinedNode$1();
          }
        },
        {
          key: "registerConstantViolation",
          value: function registerConstantViolation(path) {
            var ids = path.getBindingIdentifiers();
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = Object.keys(ids)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var name2 = _step8.value;
                var _this_getBinding;
                (_this_getBinding = this.getBinding(name2)) === null || _this_getBinding === void 0 ? void 0 : _this_getBinding.reassign(path);
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        {
          key: "registerBinding",
          value: function registerBinding(kind, path) {
            var bindingPath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : path;
            if (!kind)
              throw new ReferenceError("no `kind`");
            if (path.isVariableDeclaration()) {
              var declarators = path.get("declarations");
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = declarators[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var declar = _step8.value;
                  this.registerBinding(kind, declar);
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              return;
            }
            var parent = this.getProgramParent();
            var ids = path.getOuterBindingIdentifiers(true);
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = Object.keys(ids)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var name2 = _step12.value;
                parent.references[name2] = true;
                var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
                try {
                  for (var _iterator22 = ids[name2][Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                    var id = _step22.value;
                    var local = this.getOwnBinding(name2);
                    if (local) {
                      if (local.identifier === id)
                        continue;
                      this.checkBlockScopedCollisions(local, kind, name2, id);
                    }
                    if (local) {
                      this.registerConstantViolation(bindingPath);
                    } else {
                      this.bindings[name2] = new Binding({
                        identifier: id,
                        scope: this,
                        path: bindingPath,
                        kind
                      });
                    }
                  }
                } catch (err) {
                  _didIteratorError22 = true;
                  _iteratorError22 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                      _iterator22.return();
                    }
                  } finally {
                    if (_didIteratorError22) {
                      throw _iteratorError22;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        },
        {
          key: "addGlobal",
          value: function addGlobal(node2) {
            this.globals[node2.name] = node2;
          }
        },
        {
          key: "hasUid",
          value: function hasUid(name2) {
            var scope2 = this;
            do {
              if (scope2.uids[name2])
                return true;
            } while (scope2 = scope2.parent);
            return false;
          }
        },
        {
          key: "hasGlobal",
          value: function hasGlobal(name2) {
            var scope2 = this;
            do {
              if (scope2.globals[name2])
                return true;
            } while (scope2 = scope2.parent);
            return false;
          }
        },
        {
          key: "hasReference",
          value: function hasReference(name2) {
            return !!this.getProgramParent().references[name2];
          }
        },
        {
          key: "isPure",
          value: function isPure2(node2, constantsOnly) {
            if (isIdentifier$5(node2)) {
              var binding = this.getBinding(node2.name);
              if (!binding)
                return false;
              if (constantsOnly)
                return binding.constant;
              return true;
            } else if (isThisExpression2(node2) || isMetaProperty2(node2) || isTopicReference2(node2) || isPrivateName2(node2)) {
              return true;
            } else if (isClass2(node2)) {
              var _node_decorators;
              if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
                return false;
              }
              if (((_node_decorators = node2.decorators) === null || _node_decorators === void 0 ? void 0 : _node_decorators.length) > 0) {
                return false;
              }
              return this.isPure(node2.body, constantsOnly);
            } else if (isClassBody3(node2)) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = node2.body[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var method = _step8.value;
                  if (!this.isPure(method, constantsOnly))
                    return false;
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              return true;
            } else if (isBinary3(node2)) {
              return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly);
            } else if (isArrayExpression3(node2) || isTupleExpression2(node2)) {
              var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
              try {
                for (var _iterator12 = node2.elements[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                  var elem = _step12.value;
                  if (elem !== null && !this.isPure(elem, constantsOnly))
                    return false;
                }
              } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                    _iterator12.return();
                  }
                } finally {
                  if (_didIteratorError12) {
                    throw _iteratorError12;
                  }
                }
              }
              return true;
            } else if (isObjectExpression3(node2) || isRecordExpression2(node2)) {
              var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
              try {
                for (var _iterator22 = node2.properties[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                  var prop = _step22.value;
                  if (!this.isPure(prop, constantsOnly))
                    return false;
                }
              } catch (err) {
                _didIteratorError22 = true;
                _iteratorError22 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                    _iterator22.return();
                  }
                } finally {
                  if (_didIteratorError22) {
                    throw _iteratorError22;
                  }
                }
              }
              return true;
            } else if (isMethod2(node2)) {
              var _node_decorators1;
              if (node2.computed && !this.isPure(node2.key, constantsOnly))
                return false;
              if (((_node_decorators1 = node2.decorators) === null || _node_decorators1 === void 0 ? void 0 : _node_decorators1.length) > 0) {
                return false;
              }
              return true;
            } else if (isProperty2(node2)) {
              var _node_decorators2;
              if (node2.computed && !this.isPure(node2.key, constantsOnly))
                return false;
              if (((_node_decorators2 = node2.decorators) === null || _node_decorators2 === void 0 ? void 0 : _node_decorators2.length) > 0) {
                return false;
              }
              if (isObjectProperty3(node2) || node2.static) {
                if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
                  return false;
                }
              }
              return true;
            } else if (isUnaryExpression2(node2)) {
              return this.isPure(node2.argument, constantsOnly);
            } else if (isTaggedTemplateExpression2(node2)) {
              return matchesPattern$1(node2.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node2.quasi, constantsOnly);
            } else if (isTemplateLiteral3(node2)) {
              var _iteratorNormalCompletion32 = true, _didIteratorError32 = false, _iteratorError32 = void 0;
              try {
                for (var _iterator32 = node2.expressions[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                  var expression2 = _step32.value;
                  if (!this.isPure(expression2, constantsOnly))
                    return false;
                }
              } catch (err) {
                _didIteratorError32 = true;
                _iteratorError32 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                    _iterator32.return();
                  }
                } finally {
                  if (_didIteratorError32) {
                    throw _iteratorError32;
                  }
                }
              }
              return true;
            } else {
              return isPureish2(node2);
            }
          }
        },
        {
          key: "setData",
          value: function setData(key, val) {
            return this.data[key] = val;
          }
        },
        {
          key: "getData",
          value: function getData(key) {
            var scope2 = this;
            do {
              var data2 = scope2.data[key];
              if (data2 != null)
                return data2;
            } while (scope2 = scope2.parent);
          }
        },
        {
          key: "removeData",
          value: function removeData(key) {
            var scope2 = this;
            do {
              var data2 = scope2.data[key];
              if (data2 != null)
                scope2.data[key] = null;
            } while (scope2 = scope2.parent);
          }
        },
        {
          key: "init",
          value: function init() {
            if (!this.inited) {
              this.inited = true;
              this.crawl();
            }
          }
        },
        {
          key: "crawl",
          value: function crawl2() {
            var path = this.path;
            this.references = /* @__PURE__ */ Object.create(null);
            this.bindings = /* @__PURE__ */ Object.create(null);
            this.globals = /* @__PURE__ */ Object.create(null);
            this.uids = /* @__PURE__ */ Object.create(null);
            this.data = /* @__PURE__ */ Object.create(null);
            var programParent = this.getProgramParent();
            if (programParent.crawling)
              return;
            var state = {
              references: [],
              constantViolations: [],
              assignments: []
            };
            this.crawling = true;
            if (path.type !== "Program" && isExplodedVisitor(collectorVisitor)) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = collectorVisitor.enter[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var visit32 = _step8.value;
                  visit32.call(state, path, state);
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              var typeVisitors = collectorVisitor[path.type];
              if (typeVisitors) {
                var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                try {
                  for (var _iterator12 = typeVisitors.enter[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var visit31 = _step12.value;
                    visit31.call(state, path, state);
                  }
                } catch (err) {
                  _didIteratorError12 = true;
                  _iteratorError12 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                      _iterator12.return();
                    }
                  } finally {
                    if (_didIteratorError12) {
                      throw _iteratorError12;
                    }
                  }
                }
              }
            }
            path.traverse(collectorVisitor, state);
            this.crawling = false;
            var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
            try {
              for (var _iterator22 = state.assignments[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var path2 = _step22.value;
                var ids = path2.getBindingIdentifiers();
                var _iteratorNormalCompletion32 = true, _didIteratorError32 = false, _iteratorError32 = void 0;
                try {
                  for (var _iterator32 = Object.keys(ids)[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                    var name2 = _step32.value;
                    if (path2.scope.getBinding(name2))
                      continue;
                    programParent.addGlobal(ids[name2]);
                  }
                } catch (err) {
                  _didIteratorError32 = true;
                  _iteratorError32 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                      _iterator32.return();
                    }
                  } finally {
                    if (_didIteratorError32) {
                      throw _iteratorError32;
                    }
                  }
                }
                path2.scope.registerConstantViolation(path2);
              }
            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                  _iterator22.return();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }
            var _iteratorNormalCompletion42 = true, _didIteratorError42 = false, _iteratorError42 = void 0;
            try {
              for (var _iterator42 = state.references[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                var ref2 = _step42.value;
                var binding = ref2.scope.getBinding(ref2.node.name);
                if (binding) {
                  binding.reference(ref2);
                } else {
                  programParent.addGlobal(ref2.node);
                }
              }
            } catch (err) {
              _didIteratorError42 = true;
              _iteratorError42 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion42 && _iterator42.return != null) {
                  _iterator42.return();
                }
              } finally {
                if (_didIteratorError42) {
                  throw _iteratorError42;
                }
              }
            }
            var _iteratorNormalCompletion52 = true, _didIteratorError52 = false, _iteratorError52 = void 0;
            try {
              for (var _iterator52 = state.constantViolations[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
                var path21 = _step52.value;
                path21.scope.registerConstantViolation(path21);
              }
            } catch (err) {
              _didIteratorError52 = true;
              _iteratorError52 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion52 && _iterator52.return != null) {
                  _iterator52.return();
                }
              } finally {
                if (_didIteratorError52) {
                  throw _iteratorError52;
                }
              }
            }
          }
        },
        {
          key: "push",
          value: function push2(opts) {
            var path = this.path;
            if (path.isPattern()) {
              path = this.getPatternParent().path;
            } else if (!path.isBlockStatement() && !path.isProgram()) {
              path = this.getBlockParent().path;
            }
            if (path.isSwitchStatement()) {
              path = (this.getFunctionParent() || this.getProgramParent()).path;
            }
            var init = opts.init, unique = opts.unique, _opts_kind = opts.kind, kind = _opts_kind === void 0 ? "var" : _opts_kind, id = opts.id;
            if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
              callee: path.node
            }) && path.parent.arguments.length <= path.node.params.length && isIdentifier2(id)) {
              path.pushContainer("params", id);
              path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
              return;
            }
            if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
              path.ensureBlock();
              path = path.get("body");
            }
            var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
            var dataKey = "declaration:".concat(kind, ":").concat(blockHoist);
            var declarPath = !unique && path.getData(dataKey);
            if (!declarPath) {
              var declar = variableDeclaration$1(kind, []);
              declar._blockHoist = blockHoist;
              var ref2;
              ref2 = _sliced_to_array(path.unshiftContainer("body", [
                declar
              ]), 1), declarPath = ref2[0], ref2;
              if (!unique)
                path.setData(dataKey, declarPath);
            }
            var declarator = variableDeclarator$1(id, init);
            var len = declarPath.node.declarations.push(declarator);
            path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
          }
        },
        {
          key: "getProgramParent",
          value: function getProgramParent() {
            var scope2 = this;
            do {
              if (scope2.path.isProgram()) {
                return scope2;
              }
            } while (scope2 = scope2.parent);
            throw new Error("Couldn't find a Program");
          }
        },
        {
          key: "getFunctionParent",
          value: function getFunctionParent2() {
            var scope2 = this;
            do {
              if (scope2.path.isFunctionParent()) {
                return scope2;
              }
            } while (scope2 = scope2.parent);
            return null;
          }
        },
        {
          key: "getBlockParent",
          value: function getBlockParent() {
            var scope2 = this;
            do {
              if (scope2.path.isBlockParent()) {
                return scope2;
              }
            } while (scope2 = scope2.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
        },
        {
          key: "getPatternParent",
          value: function getPatternParent() {
            var scope2 = this;
            do {
              if (!scope2.path.isPattern()) {
                return scope2.getBlockParent();
              }
            } while (scope2 = scope2.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
        },
        {
          key: "getAllBindings",
          value: function getAllBindings() {
            var ids = /* @__PURE__ */ Object.create(null);
            var scope2 = this;
            do {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = Object.keys(scope2.bindings)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var key = _step8.value;
                  if (key in ids === false) {
                    ids[key] = scope2.bindings[key];
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
              scope2 = scope2.parent;
            } while (scope2);
            return ids;
          }
        },
        {
          key: "getAllBindingsOfKind",
          value: function getAllBindingsOfKind() {
            for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
              kinds[_key] = arguments[_key];
            }
            var ids = /* @__PURE__ */ Object.create(null);
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = kinds[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var kind = _step8.value;
                var scope2 = this;
                do {
                  var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                  try {
                    for (var _iterator12 = Object.keys(scope2.bindings)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                      var name2 = _step12.value;
                      var binding = scope2.bindings[name2];
                      if (binding.kind === kind)
                        ids[name2] = binding;
                    }
                  } catch (err) {
                    _didIteratorError12 = true;
                    _iteratorError12 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                        _iterator12.return();
                      }
                    } finally {
                      if (_didIteratorError12) {
                        throw _iteratorError12;
                      }
                    }
                  }
                  scope2 = scope2.parent;
                } while (scope2);
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            return ids;
          }
        },
        {
          key: "bindingIdentifierEquals",
          value: function bindingIdentifierEquals(name2, node2) {
            return this.getBindingIdentifier(name2) === node2;
          }
        },
        {
          key: "getBinding",
          value: function getBinding2(name2) {
            var scope2 = this;
            var previousPath;
            do {
              var binding = scope2.getOwnBinding(name2);
              if (binding) {
                if ((previousPath === null || previousPath === void 0 ? void 0 : previousPath.isPattern()) && binding.kind !== "param" && binding.kind !== "local")
                  ;
                else {
                  return binding;
                }
              } else if (!binding && name2 === "arguments" && scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
                break;
              }
              previousPath = scope2.path;
            } while (scope2 = scope2.parent);
          }
        },
        {
          key: "getOwnBinding",
          value: function getOwnBinding(name2) {
            return this.bindings[name2];
          }
        },
        {
          key: "getBindingIdentifier",
          value: function getBindingIdentifier(name2) {
            var _this_getBinding;
            return (_this_getBinding = this.getBinding(name2)) === null || _this_getBinding === void 0 ? void 0 : _this_getBinding.identifier;
          }
        },
        {
          key: "getOwnBindingIdentifier",
          value: function getOwnBindingIdentifier(name2) {
            var binding = this.bindings[name2];
            return binding === null || binding === void 0 ? void 0 : binding.identifier;
          }
        },
        {
          key: "hasOwnBinding",
          value: function hasOwnBinding(name2) {
            return !!this.getOwnBinding(name2);
          }
        },
        {
          key: "hasBinding",
          value: function hasBinding(name2, opts) {
            if (!name2)
              return false;
            if (this.hasOwnBinding(name2))
              return true;
            {
              if (typeof opts === "boolean")
                opts = {
                  noGlobals: opts
                };
            }
            if (this.parentHasBinding(name2, opts))
              return true;
            if (!(opts === null || opts === void 0 ? void 0 : opts.noUids) && this.hasUid(name2))
              return true;
            if (!(opts === null || opts === void 0 ? void 0 : opts.noGlobals) && _Scope2.globals.includes(name2))
              return true;
            if (!(opts === null || opts === void 0 ? void 0 : opts.noGlobals) && _Scope2.contextVariables.includes(name2))
              return true;
            return false;
          }
        },
        {
          key: "parentHasBinding",
          value: function parentHasBinding(name2, opts) {
            var _this_parent;
            return (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.hasBinding(name2, opts);
          }
        },
        {
          key: "moveBindingTo",
          value: function moveBindingTo(name2, scope2) {
            var info = this.getBinding(name2);
            if (info) {
              info.scope.removeOwnBinding(name2);
              info.scope = scope2;
              scope2.bindings[name2] = info;
            }
          }
        },
        {
          key: "removeOwnBinding",
          value: function removeOwnBinding(name2) {
            delete this.bindings[name2];
          }
        },
        {
          key: "removeBinding",
          value: function removeBinding(name2) {
            var _this_getBinding;
            (_this_getBinding = this.getBinding(name2)) === null || _this_getBinding === void 0 ? void 0 : _this_getBinding.scope.removeOwnBinding(name2);
            var scope2 = this;
            do {
              if (scope2.uids[name2]) {
                scope2.uids[name2] = false;
              }
            } while (scope2 = scope2.parent);
          }
        }
      ]);
      return _Scope2;
    }();
    __publicField(_Scope, "globals", Object.keys(import_globals.default.builtin));
    __publicField(_Scope, "contextVariables", [
      "arguments",
      "undefined",
      "Infinity",
      "NaN"
    ]);
    var Scope22 = _Scope;
    var VISITOR_KEYS$4 = lib_exports.VISITOR_KEYS;
    function findParent(callback) {
      var path = this;
      while (path = path.parentPath) {
        if (callback(path))
          return path;
      }
      return null;
    }
    function find2(callback) {
      var path = this;
      do {
        if (callback(path))
          return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent(function(p) {
        return p.isFunction();
      });
    }
    function getStatementParent() {
      var path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i2, ancestries) {
        var earliest;
        var keys2 = VISITOR_KEYS$4[deepest.type];
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = ancestries[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var ancestry = _step8.value;
            var path = ancestry[i2 + 1];
            if (!earliest) {
              earliest = path;
              continue;
            }
            if (path.listKey && earliest.listKey === path.listKey) {
              if (path.key < earliest.key) {
                earliest = path;
                continue;
              }
            }
            var earliestKeyIndex = keys2.indexOf(earliest.parentKey);
            var currentKeyIndex = keys2.indexOf(path.parentKey);
            if (earliestKeyIndex > currentKeyIndex) {
              earliest = path;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      var _this = this;
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      var minDepth = Infinity;
      var lastCommonIndex, lastCommon;
      var ancestries = paths.map(function(path) {
        var ancestry2 = [];
        do {
          ancestry2.unshift(path);
        } while ((path = path.parentPath) && path !== _this);
        if (ancestry2.length < minDepth) {
          minDepth = ancestry2.length;
        }
        return ancestry2;
      });
      var first = ancestries[0];
      depthLoop:
        for (var i2 = 0; i2 < minDepth; i2++) {
          var shouldMatch = first[i2];
          var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
          try {
            for (var _iterator8 = ancestries[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var ancestry = _step8.value;
              if (ancestry[i2] !== shouldMatch) {
                break depthLoop;
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
          lastCommonIndex = i2;
          lastCommon = shouldMatch;
        }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      var path = this;
      var paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent(function(parent) {
        return parent === maybeAncestor;
      });
    }
    function inType() {
      for (var _len = arguments.length, candidateTypes = new Array(_len), _key = 0; _key < _len; _key++) {
        candidateTypes[_key] = arguments[_key];
      }
      var path = this;
      while (path) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = candidateTypes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var type3 = _step8.value;
            if (path.node.type === type3)
              return true;
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        path = path.parentPath;
      }
      return false;
    }
    var NodePath_ancestry = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      find: find2,
      findParent,
      getAncestry,
      getDeepestCommonAncestorFrom,
      getEarliestCommonAncestorFrom,
      getFunctionParent,
      getStatementParent,
      inType,
      isAncestor,
      isDescendant
    });
    var createFlowUnionType2 = lib_exports.createFlowUnionType;
    var createTSUnionType2 = lib_exports.createTSUnionType;
    var createUnionTypeAnnotation = lib_exports.createUnionTypeAnnotation;
    var isFlowType2 = lib_exports.isFlowType;
    var isTSType2 = lib_exports.isTSType;
    function createUnionType(types22) {
      {
        if (isFlowType2(types22[0])) {
          return createFlowUnionType2(types22);
        }
        if (isTSType2(types22[0])) {
          return createTSUnionType2(types22);
        }
      }
    }
    var BOOLEAN_NUMBER_BINARY_OPERATORS2 = lib_exports.BOOLEAN_NUMBER_BINARY_OPERATORS;
    var createTypeAnnotationBasedOnTypeof2 = lib_exports.createTypeAnnotationBasedOnTypeof;
    var numberTypeAnnotation$1 = lib_exports.numberTypeAnnotation;
    var voidTypeAnnotation$2 = lib_exports.voidTypeAnnotation;
    function infererReference(node2) {
      if (!this.isReferenced())
        return;
      var binding = this.scope.getBinding(node2.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node2.name);
        }
      }
      if (node2.name === "undefined") {
        return voidTypeAnnotation$2();
      } else if (node2.name === "NaN" || node2.name === "Infinity") {
        return numberTypeAnnotation$1();
      } else if (node2.name === "arguments")
        ;
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name2) {
      var types22 = [];
      var functionConstantViolations = [];
      var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      var testType = getConditionalAnnotation(binding, path, name2);
      if (testType) {
        var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter(function(path2) {
          return testConstantViolations.indexOf(path2) < 0;
        });
        types22.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        var _constantViolations;
        (_constantViolations = constantViolations).push.apply(_constantViolations, _to_consumable_array(functionConstantViolations));
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = constantViolations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var violation = _step8.value;
            types22.push(violation.getTypeAnnotation());
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      if (!types22.length) {
        return;
      }
      return createUnionType(types22);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      var violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter(function(violation) {
        violation = violation.resolve();
        var status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown")
          functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name2, path) {
      var operator = path.node.operator;
      var right = path.get("right").resolve();
      var left = path.get("left").resolve();
      var target;
      if (left.isIdentifier({
        name: name2
      })) {
        target = right;
      } else if (right.isIdentifier({
        name: name2
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS2.indexOf(operator) >= 0) {
          return numberTypeAnnotation$1();
        }
        return;
      }
      if (operator !== "===" && operator !== "==")
        return;
      var typeofPath;
      var typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath)
        return;
      if (!typeofPath.get("argument").isIdentifier({
        name: name2
      }))
        return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral())
        return;
      var typeValue = typePath.node.value;
      if (typeof typeValue !== "string")
        return;
      return createTypeAnnotationBasedOnTypeof2(typeValue);
    }
    function getParentConditionalPath(binding, path, name2) {
      var parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name2) !== binding)
            return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name2) {
      var ifStatement2 = getParentConditionalPath(binding, path, name2);
      if (!ifStatement2)
        return;
      var test = ifStatement2.get("test");
      var paths = [
        test
      ];
      var types22 = [];
      for (var i2 = 0; i2 < paths.length; i2++) {
        var path2 = paths[i2];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          var type3 = inferAnnotationFromBinaryExpression(name2, path2);
          if (type3)
            types22.push(type3);
        }
      }
      if (types22.length) {
        return {
          typeAnnotation: createUnionType(types22),
          ifStatement: ifStatement2
        };
      }
      return getConditionalAnnotation(binding, ifStatement2, name2);
    }
    var BOOLEAN_BINARY_OPERATORS2 = lib_exports.BOOLEAN_BINARY_OPERATORS;
    var BOOLEAN_UNARY_OPERATORS2 = lib_exports.BOOLEAN_UNARY_OPERATORS;
    var NUMBER_BINARY_OPERATORS2 = lib_exports.NUMBER_BINARY_OPERATORS;
    var NUMBER_UNARY_OPERATORS2 = lib_exports.NUMBER_UNARY_OPERATORS;
    var STRING_UNARY_OPERATORS2 = lib_exports.STRING_UNARY_OPERATORS;
    var anyTypeAnnotation$1 = lib_exports.anyTypeAnnotation;
    var arrayTypeAnnotation2 = lib_exports.arrayTypeAnnotation;
    var booleanTypeAnnotation2 = lib_exports.booleanTypeAnnotation;
    var buildMatchMemberExpression2 = lib_exports.buildMatchMemberExpression;
    var genericTypeAnnotation2 = lib_exports.genericTypeAnnotation;
    var identifier$2 = lib_exports.identifier;
    var nullLiteralTypeAnnotation2 = lib_exports.nullLiteralTypeAnnotation;
    var numberTypeAnnotation2 = lib_exports.numberTypeAnnotation;
    var stringTypeAnnotation$1 = lib_exports.stringTypeAnnotation;
    var tupleTypeAnnotation2 = lib_exports.tupleTypeAnnotation;
    var unionTypeAnnotation2 = lib_exports.unionTypeAnnotation;
    var voidTypeAnnotation$1 = lib_exports.voidTypeAnnotation;
    var isIdentifier$4 = lib_exports.isIdentifier;
    function VariableDeclarator2() {
      if (!this.get("id").isIdentifier())
        return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression2(node2) {
      return node2.typeAnnotation;
    }
    TypeCastExpression2.validParent = true;
    function TSAsExpression2(node2) {
      return node2.typeAnnotation;
    }
    TSAsExpression2.validParent = true;
    function TSNonNullExpression2() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression2(node2) {
      if (node2.callee.type === "Identifier") {
        return genericTypeAnnotation2(node2.callee);
      }
    }
    function TemplateLiteral2() {
      return stringTypeAnnotation$1();
    }
    function UnaryExpression2(node2) {
      var operator = node2.operator;
      if (operator === "void") {
        return voidTypeAnnotation$1();
      } else if (NUMBER_UNARY_OPERATORS2.indexOf(operator) >= 0) {
        return numberTypeAnnotation2();
      } else if (STRING_UNARY_OPERATORS2.indexOf(operator) >= 0) {
        return stringTypeAnnotation$1();
      } else if (BOOLEAN_UNARY_OPERATORS2.indexOf(operator) >= 0) {
        return booleanTypeAnnotation2();
      }
    }
    function BinaryExpression22(node2) {
      var operator = node2.operator;
      if (NUMBER_BINARY_OPERATORS2.indexOf(operator) >= 0) {
        return numberTypeAnnotation2();
      } else if (BOOLEAN_BINARY_OPERATORS2.indexOf(operator) >= 0) {
        return booleanTypeAnnotation2();
      } else if (operator === "+") {
        var right = this.get("right");
        var left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation2();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation$1();
        }
        return unionTypeAnnotation2([
          stringTypeAnnotation$1(),
          numberTypeAnnotation2()
        ]);
      }
    }
    function LogicalExpression2() {
      var argumentTypes = [
        this.get("left").getTypeAnnotation(),
        this.get("right").getTypeAnnotation()
      ];
      return createUnionType(argumentTypes);
    }
    function ConditionalExpression2() {
      var argumentTypes = [
        this.get("consequent").getTypeAnnotation(),
        this.get("alternate").getTypeAnnotation()
      ];
      return createUnionType(argumentTypes);
    }
    function SequenceExpression2() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression2() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression2() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression2(node2) {
      var operator = node2.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation2();
      }
    }
    function StringLiteral2() {
      return stringTypeAnnotation$1();
    }
    function NumericLiteral2() {
      return numberTypeAnnotation2();
    }
    function BooleanLiteral2() {
      return booleanTypeAnnotation2();
    }
    function NullLiteral2() {
      return nullLiteralTypeAnnotation2();
    }
    function RegExpLiteral2() {
      return genericTypeAnnotation2(identifier$2("RegExp"));
    }
    function ObjectExpression2() {
      return genericTypeAnnotation2(identifier$2("Object"));
    }
    function ArrayExpression22() {
      return genericTypeAnnotation2(identifier$2("Array"));
    }
    function RestElement22() {
      return ArrayExpression22();
    }
    RestElement22.validParent = true;
    function Func() {
      return genericTypeAnnotation2(identifier$2("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression2("Array.from");
    var isObjectKeys = buildMatchMemberExpression2("Object.keys");
    var isObjectValues = buildMatchMemberExpression2("Object.values");
    var isObjectEntries = buildMatchMemberExpression2("Object.entries");
    function CallExpression2() {
      var callee = this.node.callee;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation2(stringTypeAnnotation$1());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier$4(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation2(anyTypeAnnotation$1());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation2(tupleTypeAnnotation2([
          stringTypeAnnotation$1(),
          anyTypeAnnotation$1()
        ]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression2() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        var node2 = callee.node;
        if (node2.async) {
          if (node2.generator) {
            return genericTypeAnnotation2(identifier$2("AsyncIterator"));
          } else {
            return genericTypeAnnotation2(identifier$2("Promise"));
          }
        } else {
          if (node2.generator) {
            return genericTypeAnnotation2(identifier$2("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else
            ;
        }
      }
    }
    var inferers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArrayExpression: ArrayExpression22,
      ArrowFunctionExpression: Func,
      AssignmentExpression: AssignmentExpression2,
      BinaryExpression: BinaryExpression22,
      BooleanLiteral: BooleanLiteral2,
      CallExpression: CallExpression2,
      ClassDeclaration: Func,
      ClassExpression: Func,
      ConditionalExpression: ConditionalExpression2,
      FunctionDeclaration: Func,
      FunctionExpression: Func,
      Identifier: infererReference,
      LogicalExpression: LogicalExpression2,
      NewExpression: NewExpression2,
      NullLiteral: NullLiteral2,
      NumericLiteral: NumericLiteral2,
      ObjectExpression: ObjectExpression2,
      ParenthesizedExpression: ParenthesizedExpression2,
      RegExpLiteral: RegExpLiteral2,
      RestElement: RestElement22,
      SequenceExpression: SequenceExpression2,
      StringLiteral: StringLiteral2,
      TSAsExpression: TSAsExpression2,
      TSNonNullExpression: TSNonNullExpression2,
      TaggedTemplateExpression: TaggedTemplateExpression2,
      TemplateLiteral: TemplateLiteral2,
      TypeCastExpression: TypeCastExpression2,
      UnaryExpression: UnaryExpression2,
      UpdateExpression: UpdateExpression2,
      VariableDeclarator: VariableDeclarator2
    });
    var anyTypeAnnotation2 = lib_exports.anyTypeAnnotation;
    var isAnyTypeAnnotation2 = lib_exports.isAnyTypeAnnotation;
    var isArrayTypeAnnotation3 = lib_exports.isArrayTypeAnnotation;
    var isBooleanTypeAnnotation2 = lib_exports.isBooleanTypeAnnotation;
    var isEmptyTypeAnnotation2 = lib_exports.isEmptyTypeAnnotation;
    var isFlowBaseAnnotation2 = lib_exports.isFlowBaseAnnotation;
    var isGenericTypeAnnotation2 = lib_exports.isGenericTypeAnnotation;
    var isIdentifier$3 = lib_exports.isIdentifier;
    var isMixedTypeAnnotation2 = lib_exports.isMixedTypeAnnotation;
    var isNumberTypeAnnotation2 = lib_exports.isNumberTypeAnnotation;
    var isStringTypeAnnotation2 = lib_exports.isStringTypeAnnotation;
    var isTSArrayType2 = lib_exports.isTSArrayType;
    var isTSTypeAnnotation2 = lib_exports.isTSTypeAnnotation;
    var isTSTypeReference2 = lib_exports.isTSTypeReference;
    var isTupleTypeAnnotation2 = lib_exports.isTupleTypeAnnotation;
    var isTypeAnnotation2 = lib_exports.isTypeAnnotation;
    var isUnionTypeAnnotation2 = lib_exports.isUnionTypeAnnotation;
    var isVoidTypeAnnotation2 = lib_exports.isVoidTypeAnnotation;
    var stringTypeAnnotation2 = lib_exports.stringTypeAnnotation;
    var voidTypeAnnotation2 = lib_exports.voidTypeAnnotation;
    function getTypeAnnotation() {
      var type3 = this.getData("typeAnnotation");
      if (type3 != null) {
        return type3;
      }
      type3 = this._getTypeAnnotation() || anyTypeAnnotation2();
      if (isTypeAnnotation2(type3) || isTSTypeAnnotation2(type3)) {
        type3 = type3.typeAnnotation;
      }
      this.setData("typeAnnotation", type3);
      return type3;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      var node2 = this.node;
      if (!node2) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          var declar = this.parentPath.parentPath;
          var declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation2();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation2();
          }
          return voidTypeAnnotation2();
        } else {
          return;
        }
      }
      if (node2.typeAnnotation) {
        return node2.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node2)) {
        return;
      }
      typeAnnotationInferringNodes.add(node2);
      try {
        var inferer = inferers[node2.type];
        if (inferer) {
          return inferer.call(this, node2);
        }
        inferer = inferers[this.parentPath.type];
        if (inferer === null || inferer === void 0 ? void 0 : inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node2);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type3, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation2(type3);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation2(type3);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation2(type3);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation2(type3);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation2(type3);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation2(type3);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation2(type3);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error("Unknown base type ".concat(baseName));
        }
      }
    }
    function couldBeBaseType(name2) {
      var type3 = this.getTypeAnnotation();
      if (isAnyTypeAnnotation2(type3))
        return true;
      if (isUnionTypeAnnotation2(type3)) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = type3.types[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var type22 = _step8.value;
            if (isAnyTypeAnnotation2(type22) || _isBaseType(name2, type22, true)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return false;
      } else {
        return _isBaseType(name2, type3, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      var left = this.getTypeAnnotation();
      var right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation2(left) && isFlowBaseAnnotation2(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      var type3 = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType2(type3) || isArrayTypeAnnotation3(type3) || isTupleTypeAnnotation2(type3)) {
          return true;
        }
      }
      return isGenericTypeAnnotation2(type3) && isIdentifier$3(type3.id, {
        name: genericName
      }) || isTSTypeReference2(type3) && isIdentifier$3(type3.typeName, {
        name: genericName
      });
    }
    var NodePath_inference = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _getTypeAnnotation,
      baseTypeStrictlyMatches,
      couldBeBaseType,
      getTypeAnnotation,
      isBaseType,
      isGenericType
    });
    var FUNCTION_TYPES2 = lib_exports.FUNCTION_TYPES;
    var arrowFunctionExpression$2 = lib_exports.arrowFunctionExpression;
    var assignmentExpression$2 = lib_exports.assignmentExpression;
    var awaitExpression2 = lib_exports.awaitExpression;
    var blockStatement$2 = lib_exports.blockStatement;
    var buildUndefinedNode2 = lib_exports.buildUndefinedNode;
    var callExpression$2 = lib_exports.callExpression;
    var cloneNode$2 = lib_exports.cloneNode;
    var conditionalExpression$1 = lib_exports.conditionalExpression;
    var expressionStatement$2 = lib_exports.expressionStatement;
    var getBindingIdentifiers$2 = lib_exports.getBindingIdentifiers;
    var identifier$1 = lib_exports.identifier;
    var inheritLeadingComments2 = lib_exports.inheritLeadingComments;
    var inheritTrailingComments2 = lib_exports.inheritTrailingComments;
    var inheritsComments2 = lib_exports.inheritsComments;
    var isBlockStatement$1 = lib_exports.isBlockStatement;
    var isEmptyStatement2 = lib_exports.isEmptyStatement;
    var isExpression$2 = lib_exports.isExpression;
    var isExpressionStatement4 = lib_exports.isExpressionStatement;
    var isIfStatement3 = lib_exports.isIfStatement;
    var isProgram2 = lib_exports.isProgram;
    var isStatement4 = lib_exports.isStatement;
    var isVariableDeclaration2 = lib_exports.isVariableDeclaration;
    var removeComments2 = lib_exports.removeComments;
    var returnStatement$1 = lib_exports.returnStatement;
    var sequenceExpression$1 = lib_exports.sequenceExpression;
    var validate$13 = lib_exports.validate;
    var yieldExpression2 = lib_exports.yieldExpression;
    function replaceWithMultiple(nodes2) {
      var _getCachedPaths;
      this.resync();
      nodes2 = this._verifyNodeList(nodes2);
      inheritLeadingComments2(nodes2[0], this.node);
      inheritTrailingComments2(nodes2[nodes2.length - 1], this.node);
      (_getCachedPaths = getCachedPaths(this.hub, this.parent)) === null || _getCachedPaths === void 0 ? void 0 : _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      var paths = this.insertAfter(nodes2);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      this.resync();
      var ast;
      try {
        replacement = "(".concat(replacement, ")");
        ast = parse4(replacement);
      } catch (err) {
        var loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      var expressionAST = ast.program.body[0].expression;
      traverse3.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      this.resync();
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      var replacement = _instanceof(replacementPath, NodePath) ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [
          this
        ];
      }
      if (this.isProgram() && !isProgram2(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      var nodePath = "";
      if (this.isNodeType("Statement") && isExpression$2(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement$2(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement4(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([
            replacement
          ]);
        }
      }
      var oldNode = this.node;
      if (oldNode) {
        inheritsComments2(replacement, oldNode);
        removeComments2(oldNode);
      }
      this._replaceWith(replacement);
      this.type = replacement.type;
      this.setScope();
      this.requeue();
      return [
        nodePath ? this.get(nodePath) : this
      ];
    }
    function _replaceWith(node2) {
      var _getCachedPaths;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate$13(this.parent, this.key, [
          node2
        ]);
      } else {
        validate$13(this.parent, this.key, node2);
      }
      this.debug("Replace with ".concat(node2 === null || node2 === void 0 ? void 0 : node2.type));
      (_getCachedPaths = getCachedPaths(this.hub, this.parent)) === null || _getCachedPaths === void 0 ? void 0 : _getCachedPaths.set(node2, this).delete(this.node);
      this.node = this.container[this.key] = node2;
    }
    function replaceExpressionWithStatements(nodes2) {
      var _this = this;
      this.resync();
      var declars = [];
      var nodesAsSingleExpression = gatherSequenceExpressions(nodes2, declars);
      if (nodesAsSingleExpression) {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = declars[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var id = _step8.value;
            this.scope.push({
              id
            });
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      var functionParent = this.getFunctionParent();
      var isParentAsync = functionParent === null || functionParent === void 0 ? void 0 : functionParent.is("async");
      var isParentGenerator = functionParent === null || functionParent === void 0 ? void 0 : functionParent.is("generator");
      var container = arrowFunctionExpression$2([], blockStatement$2(nodes2));
      this.replaceWith(callExpression$2(container, []));
      var callee = this.get("callee");
      hoistVariables(callee.get("body"), function(id2) {
        _this.scope.push({
          id: id2
        });
      }, "var");
      var completionRecords = this.get("callee").getCompletionRecords();
      var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
      try {
        for (var _iterator12 = completionRecords[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var path = _step12.value;
          if (!path.isExpressionStatement())
            continue;
          var loop = path.findParent(function(path2) {
            return path2.isLoop();
          });
          if (loop) {
            var uid2 = loop.getData("expressionReplacementReturnUid");
            if (!uid2) {
              uid2 = callee.scope.generateDeclaredUidIdentifier("ret");
              callee.get("body").pushContainer("body", returnStatement$1(cloneNode$2(uid2)));
              loop.setData("expressionReplacementReturnUid", uid2);
            } else {
              uid2 = identifier$1(uid2.name);
            }
            path.get("expression").replaceWith(assignmentExpression$2("=", cloneNode$2(uid2), path.node.expression));
          } else {
            path.replaceWith(returnStatement$1(path.node.expression));
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
      callee.arrowFunctionToExpression();
      var newCallee = callee;
      var needToAwaitFunction = isParentAsync && traverse3.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES2);
      var needToYieldFunction = isParentGenerator && traverse3.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES2);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression2(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression2(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes2, declars) {
      var exprs = [];
      var ensureLastUndefined = true;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = nodes2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var node2 = _step8.value;
          if (!isEmptyStatement2(node2)) {
            ensureLastUndefined = false;
          }
          if (isExpression$2(node2)) {
            exprs.push(node2);
          } else if (isExpressionStatement4(node2)) {
            exprs.push(node2.expression);
          } else if (isVariableDeclaration2(node2)) {
            if (node2.kind !== "var")
              return;
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = node2.declarations[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var declar = _step12.value;
                var bindings = getBindingIdentifiers$2(declar);
                var _iteratorNormalCompletion22 = true, _didIteratorError22 = false, _iteratorError22 = void 0;
                try {
                  for (var _iterator22 = Object.keys(bindings)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                    var key = _step22.value;
                    declars.push(cloneNode$2(bindings[key]));
                  }
                } catch (err) {
                  _didIteratorError22 = true;
                  _iteratorError22 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                      _iterator22.return();
                    }
                  } finally {
                    if (_didIteratorError22) {
                      throw _iteratorError22;
                    }
                  }
                }
                if (declar.init) {
                  exprs.push(assignmentExpression$2("=", declar.id, declar.init));
                }
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
            ensureLastUndefined = true;
          } else if (isIfStatement3(node2)) {
            var consequent = node2.consequent ? gatherSequenceExpressions([
              node2.consequent
            ], declars) : buildUndefinedNode2();
            var alternate = node2.alternate ? gatherSequenceExpressions([
              node2.alternate
            ], declars) : buildUndefinedNode2();
            if (!consequent || !alternate)
              return;
            exprs.push(conditionalExpression$1(node2.test, consequent, alternate));
          } else if (isBlockStatement$1(node2)) {
            var body = gatherSequenceExpressions(node2.body, declars);
            if (!body)
              return;
            exprs.push(body);
          } else if (isEmptyStatement2(node2)) {
            if (nodes2.indexOf(node2) === 0) {
              ensureLastUndefined = true;
            }
          } else {
            return;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      if (ensureLastUndefined)
        exprs.push(buildUndefinedNode2());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression$1(exprs);
      }
    }
    function replaceInline(nodes2) {
      this.resync();
      if (Array.isArray(nodes2)) {
        if (Array.isArray(this.container)) {
          nodes2 = this._verifyNodeList(nodes2);
          var paths = this._containerInsertAfter(nodes2);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes2);
        }
      } else {
        return this.replaceWith(nodes2);
      }
    }
    var NodePath_replacement = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _replaceWith,
      replaceExpressionWithStatements,
      replaceInline,
      replaceWith,
      replaceWithMultiple,
      replaceWithSourceString
    });
    var VALID_OBJECT_CALLEES = [
      "Number",
      "String",
      "Math"
    ];
    var VALID_IDENTIFIER_CALLEES = [
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "btoa",
      "atob"
    ];
    var INVALID_METHODS = [
      "random"
    ];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      var res = this.evaluate();
      if (res.confident)
        return !!res.value;
    }
    function deopt(path, state) {
      if (!state.confident)
        return;
      state.deoptPath = path;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([
      [
        "undefined",
        void 0
      ],
      [
        "Infinity",
        Infinity
      ],
      [
        "NaN",
        NaN
      ]
    ]);
    function evaluateCached(path, state) {
      var node2 = path.node;
      var seen = state.seen;
      if (seen.has(node2)) {
        var existing = seen.get(node2);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        var item = {
          resolved: false
        };
        seen.set(node2, item);
        var val = _evaluate(path, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path, state) {
      if (!state.confident)
        return;
      if (path.isSequenceExpression()) {
        var exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
      }
      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        var object = path.get("tag.object");
        var name2 = object.node.name;
        var property = path.get("tag.property");
        if (object.isIdentifier() && name2 === "String" && !path.scope.getBinding(name2) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
      }
      if (path.isConditionalExpression()) {
        var testResult = evaluateCached(path.get("test"), state);
        if (!state.confident)
          return;
        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: path.node
      })) {
        var property1 = path.get("property");
        var object1 = path.get("object");
        if (object1.isLiteral()) {
          var value1 = object1.node.value;
          var type3 = typeof value1 === "undefined" ? "undefined" : _type_of(value1);
          var key = null;
          if (path.node.computed) {
            key = evaluateCached(property1, state);
            if (!state.confident)
              return;
          } else if (property1.isIdentifier()) {
            key = property1.node.name;
          }
          if ((type3 === "number" || type3 === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
            return value1[key];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        var binding = path.scope.getBinding(path.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        var name1 = path.node.name;
        if (Globals.has(name1)) {
          if (!binding) {
            return Globals.get(name1);
          }
          deopt(binding.path, state);
          return;
        }
        var resolved = path.resolve();
        if (resolved === path) {
          deopt(path, state);
          return;
        } else {
          return evaluateCached(resolved, state);
        }
      }
      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (path.node.operator === "void") {
          return void 0;
        }
        var argument = path.get("argument");
        if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        var arg = evaluateCached(argument, state);
        if (!state.confident)
          return;
        switch (path.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg === "undefined" ? "undefined" : _type_of(arg);
        }
      }
      if (path.isArrayExpression()) {
        var arr = [];
        var elems = path.get("elements");
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = elems[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var elem = _step8.value;
            var elemValue = elem.evaluate();
            if (elemValue.confident) {
              arr.push(elemValue.value);
            } else {
              deopt(elemValue.deopt, state);
              return;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        var obj = {};
        var props = path.get("properties");
        var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
        try {
          for (var _iterator12 = props[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var prop = _step12.value;
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
              deopt(prop, state);
              return;
            }
            var keyPath = prop.get("key");
            var key1 = void 0;
            if (prop.node.computed) {
              key1 = keyPath.evaluate();
              if (!key1.confident) {
                deopt(key1.deopt, state);
                return;
              }
              key1 = key1.value;
            } else if (keyPath.isIdentifier()) {
              key1 = keyPath.node.name;
            } else {
              key1 = keyPath.node.value;
            }
            var valuePath = prop.get("value");
            var value2 = valuePath.evaluate();
            if (!value2.confident) {
              deopt(value2.deopt, state);
              return;
            }
            value2 = value2.value;
            obj[key1] = value2;
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
              _iterator12.return();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
        return obj;
      }
      if (path.isLogicalExpression()) {
        var wasConfident = state.confident;
        var left = evaluateCached(path.get("left"), state);
        var leftConfident = state.confident;
        state.confident = wasConfident;
        var right = evaluateCached(path.get("right"), state);
        var rightConfident = state.confident;
        switch (path.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident)
              return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident)
              return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident)
              return;
            return left !== null && left !== void 0 ? left : right;
        }
      }
      if (path.isBinaryExpression()) {
        var left1 = evaluateCached(path.get("left"), state);
        if (!state.confident)
          return;
        var right1 = evaluateCached(path.get("right"), state);
        if (!state.confident)
          return;
        switch (path.node.operator) {
          case "-":
            return left1 - right1;
          case "+":
            return left1 + right1;
          case "/":
            return left1 / right1;
          case "*":
            return left1 * right1;
          case "%":
            return left1 % right1;
          case "**":
            return Math.pow(left1, right1);
          case "<":
            return left1 < right1;
          case ">":
            return left1 > right1;
          case "<=":
            return left1 <= right1;
          case ">=":
            return left1 >= right1;
          case "==":
            return left1 == right1;
          case "!=":
            return left1 != right1;
          case "===":
            return left1 === right1;
          case "!==":
            return left1 !== right1;
          case "|":
            return left1 | right1;
          case "&":
            return left1 & right1;
          case "^":
            return left1 ^ right1;
          case "<<":
            return left1 << right1;
          case ">>":
            return left1 >> right1;
          case ">>>":
            return left1 >>> right1;
        }
      }
      if (path.isCallExpression()) {
        var callee = path.get("callee");
        var context;
        var func;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          var object2 = callee.get("object");
          var property2 = callee.get("property");
          if (object2.isIdentifier() && property2.isIdentifier() && isValidObjectCallee(object2.node.name) && !isInvalidMethod(property2.node.name)) {
            context = global[object2.node.name];
            var key2 = property2.node.name;
            if (Object.hasOwnProperty.call(context, key2)) {
              func = context[key2];
            }
          }
          if (object2.isLiteral() && property2.isIdentifier()) {
            var type12 = _type_of(object2.node.value);
            if (type12 === "string" || type12 === "number") {
              context = object2.node.value;
              func = context[property2.node.name];
            }
          }
        }
        if (func) {
          var args = path.get("arguments").map(function(arg2) {
            return evaluateCached(arg2, state);
          });
          if (!state.confident)
            return;
          return func.apply(context, args);
        }
      }
      deopt(path, state);
    }
    function evaluateQuasis(path, quasis, state) {
      var raw = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var str = "";
      var i2 = 0;
      var exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = quasis[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var elem = _step8.value;
          if (!state.confident)
            break;
          str += raw ? elem.value.raw : elem.value.cooked;
          var expr = exprs[i2++];
          if (expr)
            str += String(evaluateCached(expr, state));
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      if (!state.confident)
        return;
      return str;
    }
    function evaluate() {
      var state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      var value1 = evaluateCached(this, state);
      if (!state.confident)
        value1 = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value: value1
      };
    }
    var NodePath_evaluation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      evaluate,
      evaluateTruthy
    });
    var arrowFunctionExpression$1 = lib_exports.arrowFunctionExpression;
    var assignmentExpression$1 = lib_exports.assignmentExpression;
    var binaryExpression2 = lib_exports.binaryExpression;
    var blockStatement$1 = lib_exports.blockStatement;
    var callExpression$1 = lib_exports.callExpression;
    var conditionalExpression2 = lib_exports.conditionalExpression;
    var expressionStatement$1 = lib_exports.expressionStatement;
    var identifier6 = lib_exports.identifier;
    var isIdentifier$22 = lib_exports.isIdentifier;
    var jsxIdentifier22 = lib_exports.jsxIdentifier;
    var logicalExpression2 = lib_exports.logicalExpression;
    var LOGICAL_OPERATORS2 = lib_exports.LOGICAL_OPERATORS;
    var memberExpression2 = lib_exports.memberExpression;
    var metaProperty2 = lib_exports.metaProperty;
    var numericLiteral$1 = lib_exports.numericLiteral;
    var objectExpression2 = lib_exports.objectExpression;
    var restElement2 = lib_exports.restElement;
    var returnStatement2 = lib_exports.returnStatement;
    var sequenceExpression2 = lib_exports.sequenceExpression;
    var spreadElement2 = lib_exports.spreadElement;
    var stringLiteral3 = lib_exports.stringLiteral;
    var _super2 = lib_exports.super;
    var thisExpression$1 = lib_exports.thisExpression;
    var toExpression2 = lib_exports.toExpression;
    var unaryExpression$1 = lib_exports.unaryExpression;
    function toComputedKey2() {
      var key;
      if (this.isMemberExpression()) {
        key = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier$22(key))
          key = stringLiteral3(key.name);
      }
      return key;
    }
    function ensureBlock2() {
      var body = this.get("body");
      var bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      var statements2 = [];
      var stringPath = "body";
      var key;
      var listKey;
      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements2.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key = "argument";
          statements2.push(returnStatement2(body.node));
        } else {
          key = "expression";
          statements2.push(expressionStatement$1(body.node));
        }
      }
      this.node.body = blockStatement$1(statements2);
      var parentPath = this.get(stringPath);
      body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType(path, type3) {
      path.node.type = type3;
    }
    function arrowFunctionToExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref_allowInsertArrow = _ref.allowInsertArrow, allowInsertArrow = _ref_allowInsertArrow === void 0 ? true : _ref_allowInsertArrow, _ref_allowInsertArrowWithRest = _ref.allowInsertArrowWithRest, allowInsertArrowWithRest = _ref_allowInsertArrowWithRest === void 0 ? allowInsertArrow : _ref_allowInsertArrowWithRest, _ref_noNewArrows = _ref.noNewArrows, noNewArrows = _ref_noNewArrows === void 0 ? true : _ref_noNewArrows;
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      var _hoistFunctionEnvironment = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest), thisBinding = _hoistFunctionEnvironment.thisBinding, fn = _hoistFunctionEnvironment.fnPath;
      fn.ensureBlock();
      setType(fn, "FunctionExpression");
      if (!noNewArrows) {
        var checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression2([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement$1(callExpression$1(this.hub.addHelper("newArrowCheck"), [
          thisExpression$1(),
          checkBinding ? identifier6(checkBinding.name) : identifier6(thisBinding)
        ])));
        fn.replaceWith(callExpression$1(memberExpression2(index22(this, true) || fn.node, identifier6("bind")), [
          checkBinding ? identifier6(checkBinding.name) : thisExpression$1()
        ]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = merge22([
      {
        CallExpression: function CallExpression3(child, param) {
          var allSuperCalls = param.allSuperCalls;
          if (!child.get("callee").isSuper())
            return;
          allSuperCalls.push(child);
        }
      },
      visitor
    ]);
    function hoistFunctionEnvironment(fnPath) {
      var noNewArrows = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, allowInsertArrow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, allowInsertArrowWithRest = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var arrowParent;
      var thisEnvFn = fnPath.findParent(function(p) {
        if (p.isArrowFunctionExpression()) {
          arrowParent !== null && arrowParent !== void 0 ? arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      var inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression$1(arrowFunctionExpression$1([], toExpression2(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      var _getScopeInformation = getScopeInformation(fnPath), thisPaths = _getScopeInformation.thisPaths, argumentsPaths = _getScopeInformation.argumentsPaths, newTargetPaths = _getScopeInformation.newTargetPaths, superProps = _getScopeInformation.superProps, superCalls = _getScopeInformation.superCalls;
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        var allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        var superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach(function(superCall) {
          var callee = identifier6(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        var argumentsBinding = getBinding(thisEnvFn, "arguments", function() {
          var args = function() {
            return identifier6("arguments");
          };
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression2(binaryExpression2("===", unaryExpression$1("typeof", args()), stringLiteral3("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach(function(argumentsChild) {
          var argsRef = identifier6(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        var newTargetBinding = getBinding(thisEnvFn, "newtarget", function() {
          return metaProperty2(identifier6("new"), identifier6("target"));
        });
        newTargetPaths.forEach(function(targetChild) {
          var targetRef = identifier6(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        var flatSuperProps = superProps.reduce(function(acc, superProp) {
          return acc.concat(standardizeSuperProperty(superProp));
        }, []);
        flatSuperProps.forEach(function(superProp) {
          var key = superProp.node.computed ? "" : superProp.get("property").node.name;
          var superParentPath = superProp.parentPath;
          var isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          var isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          var isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          var superBinding2 = getSuperPropBinding(thisEnvFn, isAssignment, key);
          var args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            var value1 = superParentPath.node.right;
            args.push(value1);
          }
          var call2 = callExpression$1(identifier6(superBinding2), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression$1());
            superProp.replaceWith(memberExpression2(call2, identifier6("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call2);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression$1(memberExpression2(call2, identifier6("bind"), false), [
              thisExpression$1()
            ]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call2);
          }
        });
      }
      var thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach(function(thisChild) {
            var thisRef = thisChild.isJSX() ? jsxIdentifier22(thisBinding) : identifier6(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows)
            thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS2.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        var assignmentPath = superProp.parentPath;
        var op = assignmentPath.node.operator.slice(0, -1);
        var value1 = assignmentPath.node.right;
        var isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          var object = superProp.node.object;
          var property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object, assignmentExpression$1("=", tmp, property), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier6(tmp.name), true), value1));
        } else {
          var object1 = superProp.node.object;
          var property1 = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object1, property1));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object1, identifier6(property1.name)), value1));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression2(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [
          assignmentPath.get("left"),
          assignmentPath.get("right").get("left")
        ];
      } else if (superProp.parentPath.isUpdateExpression()) {
        var updateExpr = superProp.parentPath;
        var tmp1 = superProp.scope.generateDeclaredUidIdentifier("tmp");
        var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        var parts = [
          assignmentExpression$1("=", tmp1, memberExpression2(superProp.node.object, computedKey ? assignmentExpression$1("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)),
          assignmentExpression$1("=", memberExpression2(superProp.node.object, computedKey ? identifier6(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression2(superProp.parentPath.node.operator[0], identifier6(tmp1.name), numericLiteral$1(1)))
        ];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier6(tmp1.name));
        }
        updateExpr.replaceWith(sequenceExpression2(parts));
        var left = updateExpr.get("expressions.0.right");
        var right = updateExpr.get("expressions.1.left");
        return [
          left,
          right
        ];
      }
      return [
        superProp
      ];
      function rightExpression(op2, left2, right2) {
        if (op2 === "=") {
          return assignmentExpression$1("=", left2, right2);
        } else {
          return binaryExpression2(op2, left2, right2);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = merge22([
      {
        CallExpression: function CallExpression3(child, param) {
          var supers = param.supers, thisBinding = param.thisBinding;
          if (!child.get("callee").isSuper())
            return;
          if (supers.has(child.node))
            return;
          supers.add(child.node);
          child.replaceWithMultiple([
            child.node,
            assignmentExpression$1("=", identifier6(thisBinding), identifier6("this"))
          ]);
        }
      },
      visitor
    ]);
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", function(thisBinding) {
        if (!inConstructor || !hasSuperClass(thisEnvFn))
          return thisExpression$1();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", function() {
        var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression$1([
          restElement2(argsBinding)
        ], callExpression$1(_super2(), [
          spreadElement2(identifier6(argsBinding.name))
        ]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      var op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, "superprop_".concat(op, ":").concat(propName || ""), function() {
        var argsList = [];
        var fnBody;
        if (propName) {
          fnBody = memberExpression2(_super2(), identifier6(propName));
        } else {
          var method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression2(_super2(), identifier6(method.name), true);
        }
        if (isAssignment) {
          var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression$1("=", fnBody, identifier6(valueIdent.name));
        }
        return arrowFunctionExpression$1(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init) {
      var cacheKey = "binding:" + key;
      var data2 = thisEnvFn.getData(cacheKey);
      if (!data2) {
        var id = thisEnvFn.scope.generateUidIdentifier(key);
        data2 = id.name;
        thisEnvFn.setData(cacheKey, data2);
        thisEnvFn.scope.push({
          id,
          init: init(data2)
        });
      }
      return data2;
    }
    var getScopeInformationVisitor = merge22([
      {
        ThisExpression: function ThisExpression2(child, param) {
          var thisPaths = param.thisPaths;
          thisPaths.push(child);
        },
        JSXIdentifier: function JSXIdentifier2(child, param) {
          var thisPaths = param.thisPaths;
          if (child.node.name !== "this")
            return;
          if (!child.parentPath.isJSXMemberExpression({
            object: child.node
          }) && !child.parentPath.isJSXOpeningElement({
            name: child.node
          })) {
            return;
          }
          thisPaths.push(child);
        },
        CallExpression: function CallExpression3(child, param) {
          var superCalls = param.superCalls;
          if (child.get("callee").isSuper())
            superCalls.push(child);
        },
        MemberExpression: function MemberExpression2(child, param) {
          var superProps = param.superProps;
          if (child.get("object").isSuper())
            superProps.push(child);
        },
        Identifier: function Identifier2(child, param) {
          var argumentsPaths = param.argumentsPaths;
          if (!child.isReferencedIdentifier({
            name: "arguments"
          }))
            return;
          var curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments")) {
              curr.rename("arguments");
              return;
            }
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
              break;
            }
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        },
        MetaProperty: function MetaProperty2(child, param) {
          var newTargetPaths = param.newTargetPaths;
          if (!child.get("meta").isIdentifier({
            name: "new"
          }))
            return;
          if (!child.get("property").isIdentifier({
            name: "target"
          }))
            return;
          newTargetPaths.push(child);
        }
      },
      visitor
    ]);
    function getScopeInformation(fnPath) {
      var thisPaths = [];
      var argumentsPaths = [];
      var newTargetPaths = [];
      var superProps = [];
      var superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    var NodePath_conversion = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      arrowFunctionToExpression,
      ensureBlock: ensureBlock2,
      toComputedKey: toComputedKey2,
      unwrapFunctionEnvironment
    });
    var STATEMENT_OR_BLOCK_KEYS2 = lib_exports.STATEMENT_OR_BLOCK_KEYS;
    var VISITOR_KEYS$3 = lib_exports.VISITOR_KEYS;
    var isBlockStatement3 = lib_exports.isBlockStatement;
    var isExpression$1 = lib_exports.isExpression;
    var isIdentifier$12 = lib_exports.isIdentifier;
    var isLiteral4 = lib_exports.isLiteral;
    var isStringLiteral4 = lib_exports.isStringLiteral;
    var isType3 = lib_exports.isType;
    var _matchesPattern = lib_exports.matchesPattern;
    function matchesPattern2(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    function has2(key) {
      var val = this.node && this.node[key];
      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    var is22 = has2;
    function isnt(key) {
      return !this.has(key);
    }
    function equals(key, value1) {
      return this.node[key] === value1;
    }
    function isNodeType(type3) {
      return isType3(this.type, type3);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement3(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression$1(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      var path = this;
      var first = true;
      do {
        var type3 = path.type, container = path.container;
        if (!first && (path.isFunction() || type3 === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement3(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS2.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral4(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          var object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      var binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module")
        return false;
      var path = binding.path;
      var parent = path.parentPath;
      if (!parent.isImportDeclaration())
        return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName)
          return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && isIdentifier$12(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      var node2 = this.node;
      if (node2.end) {
        var code22 = this.hub.getCode();
        if (code22)
          return code22.slice(node2.start, node2.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type3, key) {
      switch (type3) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (var i2 = 0; i2 < maxIndex; i2++) {
        var path = paths[i2];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache2) {
      var funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache2);
      }
      var paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.indexOf(base) >= 0)
        return "after";
      if (paths.this.indexOf(target) >= 0)
        return "before";
      var commonPath;
      var commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        var path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      var divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      var keys2 = VISITOR_KEYS$3[commonPath.type];
      var keyPosition = {
        this: keys2.indexOf(divergence.this.parentKey),
        target: keys2.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache2) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      var binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references)
        return "before";
      var referencePaths = binding.referencePaths;
      var allStatus;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = referencePaths[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var path = _step8.value;
          var childOfFunction = !!path.find(function(path2) {
            return path2.node === target.node;
          });
          if (childOfFunction)
            continue;
          if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
            return "unknown";
          }
          var status = _guessExecutionStatusRelativeToCached(base, path, cache2);
          if (allStatus && allStatus !== status) {
            return "unknown";
          } else {
            allStatus = status;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache2) {
      var nodeMap = cache2.get(base.node);
      var cached;
      if (!nodeMap) {
        cache2.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      var result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve3(dangerous, resolved) {
      return this._resolve(dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      if (resolved && resolved.indexOf(this) >= 0)
        return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding)
          return;
        if (!binding.constant)
          return;
        if (binding.kind === "module")
          return;
        if (binding.path !== this) {
          var ret = binding.path.resolve(dangerous, resolved);
          if (this.find(function(parent) {
            return parent.node === ret.node;
          }))
            return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        var targetKey = this.toComputedKey();
        if (!isLiteral4(targetKey))
          return;
        var targetName = targetKey.value;
        var target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          var props = target.get("properties");
          var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
          try {
            for (var _iterator8 = props[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var prop = _step8.value;
              if (!prop.isProperty())
                continue;
              var key = prop.get("key");
              var match = prop.isnt("computed") && key.isIdentifier({
                name: targetName
              });
              match = match || key.isLiteral({
                value: targetName
              });
              if (match)
                return prop.get("value").resolve(dangerous, resolved);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          var elems = target.get("elements");
          var elem = elems[targetName];
          if (elem)
            return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding)
          return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every(function(expression2) {
            return expression2.isConstantExpression();
          });
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        var operator = this.node.operator;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      return false;
    }
    function isInStrictMode() {
      var start2 = this.isProgram() ? this : this.parentPath;
      var strictParent = start2.find(function(path) {
        if (path.isProgram({
          sourceType: "module"
        }))
          return true;
        if (path.isClass())
          return true;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        var body;
        if (path.isFunction()) {
          body = path.node.body;
        } else if (path.isProgram()) {
          body = path.node;
        } else {
          return false;
        }
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = body.directives[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var directive2 = _step8.value;
            if (directive2.value.value === "use strict") {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      });
      return !!strictParent;
    }
    var NodePath_introspection = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _guessExecutionStatusRelativeTo,
      _resolve,
      canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement,
      equals,
      getSource,
      has: has2,
      is: is22,
      isCompletionRecord,
      isConstantExpression,
      isInStrictMode,
      isNodeType,
      isStatementOrBlock,
      isStatic,
      isnt,
      matchesPattern: matchesPattern2,
      referencesImport,
      resolve: resolve3,
      willIMaybeExecuteBefore
    });
    function call(key) {
      var opts = this.opts;
      this.debug(key);
      if (this.node) {
        if (this._call(opts[key]))
          return true;
      }
      if (this.node) {
        var _opts_this_node_type;
        return this._call((_opts_this_node_type = opts[this.node.type]) === null || _opts_this_node_type === void 0 ? void 0 : _opts_this_node_type[key]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns)
        return false;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = fns[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var fn = _step8.value;
          if (!fn)
            continue;
          var node2 = this.node;
          if (!node2)
            return true;
          var ret = fn.call(this.state, this, this.state);
          if (ret && typeof ret === "object" && typeof ret.then === "function") {
            throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          if (ret) {
            throw new Error("Unexpected return value from visitor method ".concat(fn));
          }
          if (this.node !== node2)
            return true;
          if (this._traverseFlags > 0)
            return true;
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return false;
    }
    function isDenylisted() {
      var _this_opts_denylist;
      var denylist = (_this_opts_denylist = this.opts.denylist) !== null && _this_opts_denylist !== void 0 ? _this_opts_denylist : this.opts.blacklist;
      return denylist && denylist.indexOf(this.node.type) > -1;
    }
    function restoreContext(path, context) {
      if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
      }
    }
    function visit22() {
      var _this_opts_shouldSkip, _this_opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this_opts_shouldSkip = (_this_opts = this.opts).shouldSkip) === null || _this_opts_shouldSkip === void 0 ? void 0 : _this_opts_shouldSkip.call(_this_opts, this)) {
        return false;
      }
      var currentContext = this.context;
      if (this.shouldSkip || this.call("enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = traverseNode(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      this.call("exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
    }
    function setScope() {
      var _this_opts, _this_scope;
      if ((_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.noScope)
        return;
      var path = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
        path = path.parentPath;
      }
      var target;
      while (path && !target) {
        var _path_opts;
        if ((_path_opts = path.opts) === null || _path_opts === void 0 ? void 0 : _path_opts.noScope)
          return;
        target = path.scope;
        path = path.parentPath;
      }
      this.scope = this.getScope(target);
      (_this_scope = this.scope) === null || _this_scope === void 0 ? void 0 : _this_scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      this.setScope();
      return this;
    }
    function resync() {
      if (this.removed)
        return;
      this._resyncParent();
      this._resyncList();
      this._resyncKey();
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container)
        return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (var i2 = 0; i2 < this.container.length; i2++) {
          if (this.container[i2] === this.node) {
            this.setKey(i2);
            return;
          }
        }
      } else {
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = Object.keys(this.container)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var key = _step8.value;
            if (this.container[key] === this.node) {
              this.setKey(key);
              return;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList)
        return;
      var newContainer = this.parent[this.listKey];
      if (this.container === newContainer)
        return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        this._markRemoved();
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container, listKey, key) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      this.setKey(key);
    }
    function setKey(key) {
      var _this_node;
      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this_node = this.node) === null || _this_node === void 0 ? void 0 : _this_node.type;
    }
    function requeue() {
      var pathToQueue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
      if (pathToQueue.removed)
        return;
      {
        pathToQueue.shouldSkip = false;
      }
      var contexts = this.contexts;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = contexts[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var context = _step8.value;
          context.maybeQueue(pathToQueue);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    function _getQueueContexts() {
      var path = this;
      var contexts = this.contexts;
      while (!contexts.length) {
        path = path.parentPath;
        if (!path)
          break;
        contexts = path.contexts;
      }
      return contexts;
    }
    var NodePath_context = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _call,
      _getQueueContexts,
      _resyncKey,
      _resyncList,
      _resyncParent,
      _resyncRemoved,
      call,
      isBlacklisted: isDenylisted,
      isDenylisted,
      popContext,
      pushContext,
      requeue,
      resync,
      setContext,
      setKey,
      setScope,
      setup,
      skip,
      skipKey,
      stop,
      visit: visit22
    });
    var hooks = [
      function(self2, parent) {
        var removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
        if (removeParent) {
          parent.remove();
          return true;
        }
      },
      function(self2, parent) {
        if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
          parent.replaceWith(parent.node.expressions[0]);
          return true;
        }
      },
      function(self2, parent) {
        if (parent.isBinary()) {
          if (self2.key === "left") {
            parent.replaceWith(parent.node.right);
          } else {
            parent.replaceWith(parent.node.left);
          }
          return true;
        }
      },
      function(self2, parent) {
        if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
          self2.replaceWith({
            type: "BlockStatement",
            body: []
          });
          return true;
        }
      }
    ];
    var getBindingIdentifiers$1 = lib_exports.getBindingIdentifiers;
    function remove() {
      var _this_opts;
      this._assertUnremoved();
      this.resync();
      if (!((_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.noScope)) {
        this._removeFromScope();
      }
      if (this._callRemovalHooks()) {
        this._markRemoved();
        return;
      }
      this.shareCommentsWithSiblings();
      this._remove();
      this._markRemoved();
    }
    function _removeFromScope() {
      var _this = this;
      var bindings = getBindingIdentifiers$1(this.node, false, false, true);
      Object.keys(bindings).forEach(function(name2) {
        return _this.scope.removeBinding(name2);
      });
    }
    function _callRemovalHooks() {
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = hooks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var fn = _step8.value;
          if (fn(this, this.parentPath))
            return true;
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        this.updateSiblingKeys(this.key, -1);
      } else {
        this._replaceWith(null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= SHOULD_SKIP | REMOVED;
      if (this.parent) {
        getCachedPaths(this.hub, this.parent).delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
    var NodePath_removal = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _assertUnremoved,
      _callRemovalHooks,
      _markRemoved,
      _remove,
      _removeFromScope,
      remove
    });
    var react2 = lib_exports.react;
    var cloneNode$1 = lib_exports.cloneNode;
    var jsxExpressionContainer22 = lib_exports.jsxExpressionContainer;
    var variableDeclaration3 = lib_exports.variableDeclaration;
    var variableDeclarator3 = lib_exports.variableDeclarator;
    var referenceVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier2(path, state) {
        if (path.isJSXIdentifier() && react2.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path.node.name === "this") {
          var scope2 = path.scope;
          do {
            if (scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope2 = scope2.parent);
          if (scope2)
            state.breakOnScopePaths.push(scope2.path);
        }
        var binding = path.scope.getBinding(path.node.name);
        if (!binding)
          return;
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = binding.constantViolations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var violation = _step8.value;
            if (violation.scope !== binding.path.scope) {
              state.mutableBinding = true;
              path.stop();
              return;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        if (binding !== state.scope.getBinding(path.node.name))
          return;
        state.bindings[path.node.name] = binding;
      }
    };
    var PathHoister = /* @__PURE__ */ function() {
      "use strict";
      function PathHoister2(path, scope2) {
        _class_call_check(this, PathHoister2);
        __publicField(this, "breakOnScopePaths");
        __publicField(this, "bindings");
        __publicField(this, "mutableBinding");
        __publicField(this, "scopes");
        __publicField(this, "scope");
        __publicField(this, "path");
        __publicField(this, "attachAfter");
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope2;
        this.path = path;
        this.attachAfter = false;
      }
      _create_class(PathHoister2, [
        {
          key: "isCompatibleScope",
          value: function isCompatibleScope(scope2) {
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = Object.keys(this.bindings)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var key = _step8.value;
                var binding = this.bindings[key];
                if (!scope2.bindingIdentifierEquals(key, binding.identifier)) {
                  return false;
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            return true;
          }
        },
        {
          key: "getCompatibleScopes",
          value: function getCompatibleScopes() {
            var scope2 = this.path.scope;
            do {
              if (this.isCompatibleScope(scope2)) {
                this.scopes.push(scope2);
              } else {
                break;
              }
              if (this.breakOnScopePaths.indexOf(scope2.path) >= 0) {
                break;
              }
            } while (scope2 = scope2.parent);
          }
        },
        {
          key: "getAttachmentPath",
          value: function getAttachmentPath() {
            var path = this._getAttachmentPath();
            if (!path)
              return;
            var targetScope = path.scope;
            if (targetScope.path === path) {
              targetScope = path.scope.parent;
            }
            if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
              var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
              try {
                for (var _iterator8 = Object.keys(this.bindings)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                  var name2 = _step8.value;
                  if (!targetScope.hasOwnBinding(name2))
                    continue;
                  var binding = this.bindings[name2];
                  if (binding.kind === "param" || binding.path.parentKey === "params") {
                    continue;
                  }
                  var bindingParentPath = this.getAttachmentParentForPath(binding.path);
                  if (bindingParentPath.key >= path.key) {
                    this.attachAfter = true;
                    path = binding.path;
                    var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
                    try {
                      for (var _iterator12 = binding.constantViolations[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                        var violationPath = _step12.value;
                        if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                          path = violationPath;
                        }
                      }
                    } catch (err) {
                      _didIteratorError12 = true;
                      _iteratorError12 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                          _iterator12.return();
                        }
                      } finally {
                        if (_didIteratorError12) {
                          throw _iteratorError12;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                    _iterator8.return();
                  }
                } finally {
                  if (_didIteratorError8) {
                    throw _iteratorError8;
                  }
                }
              }
            }
            return path;
          }
        },
        {
          key: "_getAttachmentPath",
          value: function _getAttachmentPath() {
            var scopes = this.scopes;
            var scope2 = scopes.pop();
            if (!scope2)
              return;
            if (scope2.path.isFunction()) {
              if (this.hasOwnParamBindings(scope2)) {
                if (this.scope === scope2)
                  return;
                var bodies = scope2.path.get("body").get("body");
                for (var i2 = 0; i2 < bodies.length; i2++) {
                  if (bodies[i2].node._blockHoist)
                    continue;
                  return bodies[i2];
                }
              } else {
                return this.getNextScopeAttachmentParent();
              }
            } else if (scope2.path.isProgram()) {
              return this.getNextScopeAttachmentParent();
            }
          }
        },
        {
          key: "getNextScopeAttachmentParent",
          value: function getNextScopeAttachmentParent() {
            var scope2 = this.scopes.pop();
            if (scope2)
              return this.getAttachmentParentForPath(scope2.path);
          }
        },
        {
          key: "getAttachmentParentForPath",
          value: function getAttachmentParentForPath(path) {
            do {
              if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
                return path;
              }
            } while (path = path.parentPath);
          }
        },
        {
          key: "hasOwnParamBindings",
          value: function hasOwnParamBindings(scope2) {
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = Object.keys(this.bindings)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var name2 = _step8.value;
                if (!scope2.hasOwnBinding(name2))
                  continue;
                var binding = this.bindings[name2];
                if (binding.kind === "param" && binding.constant)
                  return true;
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            return false;
          }
        },
        {
          key: "run",
          value: function run() {
            this.path.traverse(referenceVisitor, this);
            if (this.mutableBinding)
              return;
            this.getCompatibleScopes();
            var attachTo = this.getAttachmentPath();
            if (!attachTo)
              return;
            if (attachTo.getFunctionParent() === this.path.getFunctionParent())
              return;
            var uid2 = attachTo.scope.generateUidIdentifier("ref");
            var declarator = variableDeclarator3(uid2, this.path.node);
            var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
            var _attachTo_insertFn = _sliced_to_array(attachTo[insertFn]([
              attachTo.isVariableDeclarator() ? declarator : variableDeclaration3("var", [
                declarator
              ])
            ]), 1), attached = _attachTo_insertFn[0];
            var parent = this.path.parentPath;
            if (parent.isJSXElement() && this.path.container === parent.node.children) {
              uid2 = jsxExpressionContainer22(uid2);
            }
            this.path.replaceWith(cloneNode$1(uid2));
            return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
          }
        }
      ]);
      return PathHoister2;
    }();
    var arrowFunctionExpression2 = lib_exports.arrowFunctionExpression;
    var assertExpression2 = lib_exports.assertExpression;
    var assignmentExpression3 = lib_exports.assignmentExpression;
    var blockStatement3 = lib_exports.blockStatement;
    var callExpression2 = lib_exports.callExpression;
    var cloneNode5 = lib_exports.cloneNode;
    var expressionStatement4 = lib_exports.expressionStatement;
    var isAssignmentExpression4 = lib_exports.isAssignmentExpression;
    var isCallExpression4 = lib_exports.isCallExpression;
    var isExportNamedDeclaration3 = lib_exports.isExportNamedDeclaration;
    var isExpression2 = lib_exports.isExpression;
    var isIdentifier5 = lib_exports.isIdentifier;
    var isSequenceExpression2 = lib_exports.isSequenceExpression;
    var isSuper2 = lib_exports.isSuper;
    var thisExpression2 = lib_exports.thisExpression;
    function insertBefore(nodes_) {
      this._assertUnremoved();
      var nodes2 = this._verifyNodeList(nodes_);
      var _this = this, parentPath = _this.parentPath, parent = _this.parent;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes2);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node)
          nodes2.push(this.node);
        return this.replaceExpressionWithStatements(nodes2);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertBefore(nodes2);
      } else if (this.isStatementOrBlock()) {
        var node2 = this.node;
        var shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [
          node2
        ] : []));
        return this.unshiftContainer("body", nodes2);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes2) {
      var _this_container;
      this.updateSiblingKeys(from, nodes2.length);
      var paths = [];
      (_this_container = this.container).splice.apply(_this_container, [
        from,
        0
      ].concat(_to_consumable_array(nodes2)));
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var _this_context;
        var to = from + i2;
        var path = this.getSibling(to);
        paths.push(path);
        if ((_this_context = this.context) === null || _this_context === void 0 ? void 0 : _this_context.queue) {
          path.pushContext(this.context);
        }
      }
      var contexts = this._getQueueContexts();
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = paths[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var path1 = _step8.value;
          path1.setScope();
          path1.debug("Inserted.");
          var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = contexts[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var context = _step12.value;
              context.maybeQueue(path1, true);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes2) {
      return this._containerInsert(this.key, nodes2);
    }
    function _containerInsertAfter(nodes2) {
      return this._containerInsert(this.key + 1, nodes2);
    }
    var last = function(arr) {
      return arr[arr.length - 1];
    };
    function isHiddenInSequenceExpression(path) {
      return isSequenceExpression2(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
    }
    function isAlmostConstantAssignment(node2, scope2) {
      if (!isAssignmentExpression4(node2) || !isIdentifier5(node2.left)) {
        return false;
      }
      var blockScope = scope2.getBlockParent();
      return blockScope.hasOwnBinding(node2.left.name) && blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      this._assertUnremoved();
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      var nodes2 = this._verifyNodeList(nodes_);
      var _this = this, parentPath = _this.parentPath, parent = _this.parent;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes2.map(function(node3) {
          return isExpression2(node3) ? expressionStatement4(node3) : node3;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) {
          var node2 = this.node;
          var _this1 = this, scope2 = _this1.scope;
          if (scope2.path.isPattern()) {
            assertExpression2(node2);
            this.replaceWith(callExpression2(arrowFunctionExpression2([], node2), []));
            this.get("callee.body").insertAfter(nodes2);
            return [
              this
            ];
          }
          if (isHiddenInSequenceExpression(this)) {
            nodes2.unshift(node2);
          } else if (isCallExpression4(node2) && isSuper2(node2.callee)) {
            nodes2.unshift(node2);
            nodes2.push(thisExpression2());
          } else if (isAlmostConstantAssignment(node2, scope2)) {
            nodes2.unshift(node2);
            nodes2.push(cloneNode5(node2.left));
          } else if (scope2.isPure(node2, true)) {
            nodes2.push(node2);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node2
            })) {
              scope2 = scope2.parent;
            }
            var temp = scope2.generateDeclaredUidIdentifier();
            nodes2.unshift(expressionStatement4(assignmentExpression3("=", cloneNode5(temp), node2)));
            nodes2.push(expressionStatement4(cloneNode5(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes2);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertAfter(nodes2);
      } else if (this.isStatementOrBlock()) {
        var node1 = this.node;
        var shouldInsertCurrentNode = node1 && (!this.isExpressionStatement() || node1.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [
          node1
        ] : []));
        return this.pushContainer("body", nodes2);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent)
        return;
      var paths = getCachedPaths(this.hub, this.parent) || [];
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = paths[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step_value = _sliced_to_array(_step8.value, 2), path = _step_value[1];
          if (typeof path.key === "number" && path.key >= fromIndex) {
            path.key += incrementBy;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    function _verifyNodeList(nodes2) {
      if (!nodes2) {
        return [];
      }
      if (!Array.isArray(nodes2)) {
        nodes2 = [
          nodes2
        ];
      }
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var node2 = nodes2[i2];
        var msg = void 0;
        if (!node2) {
          msg = "has falsy node";
        } else if (typeof node2 !== "object") {
          msg = "contains a non-object node";
        } else if (!node2.type) {
          msg = "without a type";
        } else if (_instanceof(node2, NodePath)) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          var type3 = Array.isArray(node2) ? "array" : typeof node2 === "undefined" ? "undefined" : _type_of(node2);
          throw new Error("Node list ".concat(msg, " with the index of ").concat(i2, " and type of ").concat(type3));
        }
      }
      return nodes2;
    }
    function unshiftContainer(listKey, nodes2) {
      this._assertUnremoved();
      nodes2 = this._verifyNodeList(nodes2);
      var path = NodePath.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return path._containerInsertBefore(nodes2);
    }
    function pushContainer(listKey, nodes2) {
      this._assertUnremoved();
      var verifiedNodes = this._verifyNodeList(nodes2);
      var container = this.node[listKey];
      var path = NodePath.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context);
      return path.replaceWithMultiple(verifiedNodes);
    }
    function hoist() {
      var scope2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.scope;
      var hoister = new PathHoister(this, scope2);
      return hoister.run();
    }
    var NodePath_modification = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _containerInsert,
      _containerInsertAfter,
      _containerInsertBefore,
      _verifyNodeList,
      hoist,
      insertAfter,
      insertBefore,
      pushContainer,
      unshiftContainer,
      updateSiblingKeys
    });
    var _getBindingIdentifiers = lib_exports.getBindingIdentifiers;
    var _getOuterBindingIdentifiers = lib_exports.getOuterBindingIdentifiers;
    var isDeclaration22 = lib_exports.isDeclaration;
    var numericLiteral2 = lib_exports.numericLiteral;
    var unaryExpression2 = lib_exports.unaryExpression;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path, records, context) {
      if (path) {
        var _records;
        (_records = records).push.apply(_records, _to_consumable_array(_getCompletionRecords(path, context)));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      var _records;
      var lastNormalCompletions = [];
      for (var i2 = 0; i2 < cases.length; i2++) {
        var _records1;
        var casePath = cases[i2];
        var caseCompletions = _getCompletionRecords(casePath, context);
        var normalCompletions = [];
        var breakCompletions = [];
        var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
        try {
          for (var _iterator8 = caseCompletions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var c2 = _step8.value;
            if (c2.type === NORMAL_COMPLETION) {
              normalCompletions.push(c2);
            }
            if (c2.type === BREAK_COMPLETION) {
              breakCompletions.push(c2);
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        (_records1 = records).push.apply(_records1, _to_consumable_array(breakCompletions));
      }
      (_records = records).push.apply(_records, _to_consumable_array(lastNormalCompletions));
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach(function(c2) {
        c2.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach(function(c2) {
        if (c2.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c2.path.replaceWith(unaryExpression2("void", numericLiteral2(0)));
          } else {
            c2.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      var completions = [];
      if (context.canHaveBreak) {
        var _loop5 = function(i3) {
          var path = paths[i3];
          var newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          var statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every(function(c3) {
            return c3.type === BREAK_COMPLETION;
          })) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every(function(c3) {
              return c3.path.isBreakStatement({
                label: null
              });
            })) {
              var _completions2;
              normalCompletionToBreak(lastNormalCompletions);
              (_completions2 = completions).push.apply(_completions2, _to_consumable_array(lastNormalCompletions));
              if (lastNormalCompletions.some(function(c3) {
                return c3.path.isDeclaration();
              })) {
                var _completions1;
                (_completions1 = completions).push.apply(_completions1, _to_consumable_array(statementCompletions));
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              var _completions22;
              (_completions22 = completions).push.apply(_completions22, _to_consumable_array(statementCompletions));
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            return "break";
          }
          if (i3 === paths.length - 1) {
            var _completions3;
            (_completions3 = completions).push.apply(_completions3, _to_consumable_array(statementCompletions));
          } else {
            lastNormalCompletions = [];
            for (var i22 = 0; i22 < statementCompletions.length; i22++) {
              var c2 = statementCompletions[i22];
              if (c2.type === BREAK_COMPLETION) {
                completions.push(c2);
              }
              if (c2.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c2);
              }
            }
          }
        };
        var lastNormalCompletions = [];
        for (var i2 = 0; i2 < paths.length; i2++) {
          var _ret = _loop5(i2);
          if (_ret === "break")
            break;
        }
      } else if (paths.length) {
        for (var i1 = paths.length - 1; i1 >= 0; i1--) {
          var pathCompletions = _getCompletionRecords(paths[i1], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            var _completions;
            (_completions = completions).push.apply(_completions, _to_consumable_array(pathCompletions));
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      var records = [];
      if (path.isIfStatement()) {
        records = addCompletionRecords(path.get("consequent"), records, context);
        records = addCompletionRecords(path.get("alternate"), records, context);
      } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get("body"), context);
      } else if (path.isFunction()) {
        return _getCompletionRecords(path.get("body"), context);
      } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get("block"), records, context);
        records = addCompletionRecords(path.get("handler"), records, context);
      } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get("cases"), records, context);
      } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        });
      } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
      } else {
        records.push(NormalCompletion(path));
      }
      return records;
    }
    function getCompletionRecords() {
      var records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map(function(r) {
        return r.path;
      });
    }
    function getSibling(key) {
      return NodePath.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(++_key);
      var siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(--_key);
      var siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get2(key) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (context === true)
        context = this.context;
      var parts = key.split(".");
      if (parts.length === 1) {
        return this._getKey(key, context);
      } else {
        return this._getPattern(parts, context);
      }
    }
    function _getKey(key, context) {
      var _this = this;
      var node2 = this.node;
      var container = node2[key];
      if (Array.isArray(container)) {
        return container.map(function(_, i2) {
          return NodePath.get({
            listKey: key,
            parentPath: _this,
            parent: node2,
            container,
            key: i2
          }).setContext(context);
        });
      } else {
        return NodePath.get({
          parentPath: this,
          parent: node2,
          container: node2,
          key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      var path = this;
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = parts[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var part = _step8.value;
          if (part === ".") {
            path = path.parentPath;
          } else {
            if (Array.isArray(path)) {
              path = path[part];
            } else {
              path = path.get(part, context);
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return path;
    }
    function getBindingIdentifiers2(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers2(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths() {
      var duplicates = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, outerOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var path = this;
      var search2 = [
        path
      ];
      var ids = /* @__PURE__ */ Object.create(null);
      while (search2.length) {
        var id = search2.shift();
        if (!id)
          continue;
        if (!id.node)
          continue;
        var keys2 = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            var _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          var declaration = id.get("declaration");
          if (isDeclaration22(declaration)) {
            search2.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search2.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys2) {
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var key = keys2[i2];
            var child = id.get(key);
            if (Array.isArray(child)) {
              var _search;
              (_search = search2).push.apply(_search, _to_consumable_array(child));
            } else if (child.node) {
              search2.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths() {
      var duplicates = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      return this.getBindingIdentifierPaths(duplicates, true);
    }
    var NodePath_family = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _getKey,
      _getPattern,
      get: get2,
      getAllNextSiblings,
      getAllPrevSiblings,
      getBindingIdentifierPaths,
      getBindingIdentifiers: getBindingIdentifiers2,
      getCompletionRecords,
      getNextSibling,
      getOpposite,
      getOuterBindingIdentifierPaths,
      getOuterBindingIdentifiers: getOuterBindingIdentifiers2,
      getPrevSibling,
      getSibling
    });
    var _addComment = lib_exports.addComment;
    var _addComments = lib_exports.addComments;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string")
        return;
      var node2 = this.node;
      if (!node2)
        return;
      var trailing = node2.trailingComments;
      var leading = node2.leadingComments;
      if (!trailing && !leading)
        return;
      var prev = this.getSibling(this.key - 1);
      var next = this.getSibling(this.key + 1);
      var hasPrev = Boolean(prev.node);
      var hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading) {
          prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
        }
        if (trailing && !hasNext)
          prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading && !hasPrev)
          next.addComments("leading", leading);
      }
    }
    function removeIfExisting(list3, toRemove) {
      if (!(toRemove === null || toRemove === void 0 ? void 0 : toRemove.length))
        return list3;
      var set = new Set(toRemove);
      return list3.filter(function(el) {
        return !set.has(el);
      });
    }
    function addComment2(type3, content3, line) {
      _addComment(this.node, type3, content3, line);
    }
    function addComments2(type3, comments) {
      _addComments(this.node, type3, comments);
    }
    var NodePath_comments = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      addComment: addComment2,
      addComments: addComments2,
      shareCommentsWithSiblings
    });
    var validate3 = lib_exports.validate;
    var debug = (0, import_debug.default)("babel");
    var REMOVED = 1 << 0;
    var SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = 1 << 2;
    var NodePath = /* @__PURE__ */ function() {
      "use strict";
      function _NodePath(hub, parent) {
        _class_call_check(this, _NodePath);
        __publicField(this, "contexts", []);
        __publicField(this, "state", null);
        __publicField(this, "opts", null);
        __publicField(this, "_traverseFlags", 0);
        __publicField(this, "skipKeys", null);
        __publicField(this, "parentPath", null);
        __publicField(this, "container", null);
        __publicField(this, "listKey", null);
        __publicField(this, "key", null);
        __publicField(this, "node", null);
        __publicField(this, "type", null);
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      _create_class(_NodePath, [
        {
          key: "getScope",
          value: function getScope(scope2) {
            return this.isScope() ? new Scope22(this) : scope2;
          }
        },
        {
          key: "setData",
          value: function setData(key, val) {
            if (this.data == null) {
              this.data = /* @__PURE__ */ Object.create(null);
            }
            return this.data[key] = val;
          }
        },
        {
          key: "getData",
          value: function getData(key, def) {
            if (this.data == null) {
              this.data = /* @__PURE__ */ Object.create(null);
            }
            var val = this.data[key];
            if (val === void 0 && def !== void 0)
              val = this.data[key] = def;
            return val;
          }
        },
        {
          key: "hasNode",
          value: function hasNode() {
            return this.node != null;
          }
        },
        {
          key: "buildCodeFrameError",
          value: function buildCodeFrameError(msg) {
            var Error2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SyntaxError;
            return this.hub.buildError(this.node, msg, Error2);
          }
        },
        {
          key: "traverse",
          value: function traverse4(visitor4, state) {
            traverse3(this.node, visitor4, this.scope, state, this);
          }
        },
        {
          key: "set",
          value: function set(key, node2) {
            validate3(this.node, key, node2);
            this.node[key] = node2;
          }
        },
        {
          key: "getPathLocation",
          value: function getPathLocation() {
            var parts = [];
            var path = this;
            do {
              var key = path.key;
              if (path.inList)
                key = "".concat(path.listKey, "[").concat(key, "]");
              parts.unshift(key);
            } while (path = path.parentPath);
            return parts.join(".");
          }
        },
        {
          key: "debug",
          value: function debug1(message) {
            if (!debug.enabled)
              return;
            debug("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(message));
          }
        },
        {
          key: "toString",
          value: function toString4() {
            return generate2(this.node).code;
          }
        },
        {
          key: "inList",
          get: function get3() {
            return !!this.listKey;
          },
          set: function set(inList) {
            if (!inList) {
              this.listKey = null;
            }
          }
        },
        {
          key: "parentKey",
          get: function get3() {
            return this.listKey || this.key;
          }
        },
        {
          key: "shouldSkip",
          get: function get3() {
            return !!(this._traverseFlags & SHOULD_SKIP);
          },
          set: function set(v) {
            if (v) {
              this._traverseFlags |= SHOULD_SKIP;
            } else {
              this._traverseFlags &= ~SHOULD_SKIP;
            }
          }
        },
        {
          key: "shouldStop",
          get: function get3() {
            return !!(this._traverseFlags & SHOULD_STOP);
          },
          set: function set(v) {
            if (v) {
              this._traverseFlags |= SHOULD_STOP;
            } else {
              this._traverseFlags &= ~SHOULD_STOP;
            }
          }
        },
        {
          key: "removed",
          get: function get3() {
            return !!(this._traverseFlags & REMOVED);
          },
          set: function set(v) {
            if (v) {
              this._traverseFlags |= REMOVED;
            } else {
              this._traverseFlags &= ~REMOVED;
            }
          }
        }
      ], [
        {
          key: "get",
          value: function get3(param) {
            var hub = param.hub, parentPath = param.parentPath, parent = param.parent, container = param.container, listKey = param.listKey, key = param.key;
            if (!hub && parentPath) {
              hub = parentPath.hub;
            }
            if (!parent) {
              throw new Error("To get a node path the parent needs to exist");
            }
            var targetNode = container[key];
            var paths = getOrCreateCachedPaths(hub, parent);
            var path = paths.get(targetNode);
            if (!path) {
              path = new _NodePath(hub, parent);
              if (targetNode)
                paths.set(targetNode, path);
            }
            path.setup(parentPath, container, listKey, key);
            return path;
          }
        }
      ]);
      return _NodePath;
    }();
    Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = void 0;
    try {
      _loop4 = function() {
        var type3 = _step6.value;
        var typeKey = "is".concat(type3);
        var fn = lib_exports[typeKey];
        NodePath.prototype[typeKey] = function(opts) {
          return fn(this.node, opts);
        };
        NodePath.prototype["assert".concat(type3)] = function(opts) {
          if (!fn(this.node, opts)) {
            throw new TypeError("Expected node path of type ".concat(type3));
          }
        };
      };
      for (_iterator6 = TYPES[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true)
        _loop4();
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
    var _loop4;
    var _iterator6;
    var _step6;
    Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = void 0;
    try {
      for (_iterator7 = Object.keys(virtualTypes)[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        type2 = _step7.value;
        if (type2[0] === "_")
          continue;
        if (!TYPES.includes(type2))
          TYPES.push(type2);
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
          _iterator7.return();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
    var type2;
    var _iterator7;
    var _step7;
    var VISITOR_KEYS$2 = lib_exports.VISITOR_KEYS;
    var TraversalContext = /* @__PURE__ */ function() {
      "use strict";
      function TraversalContext2(scope2, opts, state, parentPath) {
        _class_call_check(this, TraversalContext2);
        __publicField(this, "queue", null);
        __publicField(this, "priorityQueue", null);
        this.parentPath = parentPath;
        this.scope = scope2;
        this.state = state;
        this.opts = opts;
      }
      _create_class(TraversalContext2, [
        {
          key: "shouldVisit",
          value: function shouldVisit(node2) {
            var opts = this.opts;
            if (opts.enter || opts.exit)
              return true;
            if (opts[node2.type])
              return true;
            var keys2 = VISITOR_KEYS$2[node2.type];
            if (!(keys2 === null || keys2 === void 0 ? void 0 : keys2.length))
              return false;
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var key = _step8.value;
                if (node2[key]) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            return false;
          }
        },
        {
          key: "create",
          value: function create4(node2, container, key, listKey) {
            return NodePath.get({
              parentPath: this.parentPath,
              parent: node2,
              container,
              key,
              listKey
            });
          }
        },
        {
          key: "maybeQueue",
          value: function maybeQueue(path, notPriority) {
            if (this.queue) {
              if (notPriority) {
                this.queue.push(path);
              } else {
                this.priorityQueue.push(path);
              }
            }
          }
        },
        {
          key: "visitMultiple",
          value: function visitMultiple(container, parent, listKey) {
            if (container.length === 0)
              return false;
            var queue = [];
            for (var key = 0; key < container.length; key++) {
              var node2 = container[key];
              if (node2 && this.shouldVisit(node2)) {
                queue.push(this.create(parent, container, key, listKey));
              }
            }
            return this.visitQueue(queue);
          }
        },
        {
          key: "visitSingle",
          value: function visitSingle(node2, key) {
            if (this.shouldVisit(node2[key])) {
              return this.visitQueue([
                this.create(node2, node2, key)
              ]);
            } else {
              return false;
            }
          }
        },
        {
          key: "visitQueue",
          value: function visitQueue(queue) {
            this.queue = queue;
            this.priorityQueue = [];
            var visited = /* @__PURE__ */ new WeakSet();
            var stop2 = false;
            var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
            try {
              for (var _iterator8 = queue[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var path = _step8.value;
                path.resync();
                if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
                  path.pushContext(this);
                }
                if (path.key === null)
                  continue;
                var node2 = path.node;
                if (visited.has(node2))
                  continue;
                if (node2)
                  visited.add(node2);
                if (path.visit()) {
                  stop2 = true;
                  break;
                }
                if (this.priorityQueue.length) {
                  stop2 = this.visitQueue(this.priorityQueue);
                  this.priorityQueue = [];
                  this.queue = queue;
                  if (stop2)
                    break;
                }
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
            var _iteratorNormalCompletion12 = true, _didIteratorError12 = false, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = queue[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var path1 = _step12.value;
                path1.popContext();
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
            this.queue = null;
            return stop2;
          }
        },
        {
          key: "visit",
          value: function visit4(node2, key) {
            var nodes2 = node2[key];
            if (!nodes2)
              return false;
            if (Array.isArray(nodes2)) {
              return this.visitMultiple(nodes2, node2, key);
            } else {
              return this.visitSingle(node2, key);
            }
          }
        }
      ]);
      return TraversalContext2;
    }();
    var VISITOR_KEYS$1 = lib_exports.VISITOR_KEYS;
    function traverseNode(node2, opts, scope2, state, path, skipKeys, visitSelf) {
      var keys2 = VISITOR_KEYS$1[node2.type];
      if (!keys2)
        return false;
      var context = new TraversalContext(scope2, opts, state, path);
      if (visitSelf) {
        if (skipKeys === null || skipKeys === void 0 ? void 0 : skipKeys[path.parentKey])
          return false;
        return context.visitQueue([
          path
        ]);
      }
      var _iteratorNormalCompletion8 = true, _didIteratorError8 = false, _iteratorError8 = void 0;
      try {
        for (var _iterator8 = keys2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var key = _step8.value;
          if (skipKeys === null || skipKeys === void 0 ? void 0 : skipKeys[key])
            continue;
          if (context.visit(node2, key)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return false;
    }
    var VISITOR_KEYS2 = lib_exports.VISITOR_KEYS;
    var removeProperties2 = lib_exports.removeProperties;
    var traverseFast2 = lib_exports.traverseFast;
    function traverse3(parent) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, scope2 = arguments.length > 2 ? arguments[2] : void 0, state = arguments.length > 3 ? arguments[3] : void 0, parentPath = arguments.length > 4 ? arguments[4] : void 0, visitSelf = arguments.length > 5 ? arguments[5] : void 0;
      if (!parent)
        return;
      if (!opts.noScope && !scope2) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error("You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ".concat(parent.type, " node without passing scope and parentPath."));
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS2[parent.type]) {
        return;
      }
      explode(opts);
      traverseNode(parent, opts, scope2, state, parentPath, null, visitSelf);
    }
    traverse3.visitors = visitors;
    traverse3.verify = verify;
    traverse3.explode = explode;
    traverse3.cheap = function(node2, enter) {
      traverseFast2(node2, enter);
      return;
    };
    traverse3.node = function(node2, opts, scope2, state, path, skipKeys) {
      traverseNode(node2, opts, scope2, state, path, skipKeys);
    };
    traverse3.clearNode = function(node2, opts) {
      removeProperties2(node2, opts);
    };
    traverse3.removeProperties = function(tree, opts) {
      traverseFast2(tree, traverse3.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }
    traverse3.hasType = function(tree, type3, denylistTypes) {
      if (denylistTypes === null || denylistTypes === void 0 ? void 0 : denylistTypes.includes(tree.type))
        return false;
      if (tree.type === type3)
        return true;
      var state = {
        has: false,
        type: type3
      };
      traverse3(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse3.cache = cache;
  }
});

// node_modules/estree-to-babel/lib/traverse-object-expression.js
var require_traverse_object_expression = __commonJS({
  "node_modules/estree-to-babel/lib/traverse-object-expression.js"(exports, module2) {
    "use strict";
    var {
      isFunctionExpression,
      ObjectMethod
    } = require_bundle().types;
    var { assign } = Object;
    module2.exports = (propertiesPaths) => {
      for (const propPath of propertiesPaths) {
        const {
          computed,
          key,
          method,
          value
        } = propPath.node;
        if (method && isFunctionExpression(value)) {
          propPath.replaceWith(ObjectMethod("method", key, value.params, value.body, computed));
          assign(propPath.node, {
            id: null,
            method: true,
            generator: value.generator,
            loc: getObjectMethodLoc(key, value),
            async: value.async,
            type: "ObjectMethod"
          });
        }
      }
    };
    function getObjectMethodLoc(key, value) {
      if (key.loc && value.loc)
        return {
          start: key.loc.start,
          end: value.loc.end
        };
      return null;
    }
  }
});

// node_modules/estree-to-babel/lib/set-class-method.js
var require_set_class_method = __commonJS({
  "node_modules/estree-to-babel/lib/set-class-method.js"(exports, module2) {
    "use strict";
    var {
      classPrivateMethod,
      classMethod,
      PrivateName,
      Identifier
    } = require_bundle().types;
    var { assign } = Object;
    module2.exports = (path) => {
      const { node: node2 } = path;
      const {
        key,
        kind,
        computed,
        loc
      } = node2;
      const {
        body,
        params,
        expression,
        generator
      } = node2.value;
      const method = getClassMethod({
        kind,
        key,
        params,
        body,
        computed,
        nodeStatic: node2.static
      });
      path.replaceWith(method);
      assign(path.node, {
        loc,
        expression,
        generator
      });
    };
    var isPrivateIdentifier = ({ type }) => type === "PrivateIdentifier";
    function getClassMethod({ kind, key, params, body, computed, nodeStatic }) {
      if (isPrivateIdentifier(key)) {
        const newKey = convertPrivateIdentifier(key);
        return classPrivateMethod(kind, newKey, params, body, computed);
      }
      return classMethod(kind, key, params, body, computed, nodeStatic);
    }
    function convertPrivateIdentifier(node2) {
      return PrivateName(Identifier(node2.name));
    }
  }
});

// node_modules/estree-to-babel/lib/set-class-private-property.js
var require_set_class_private_property = __commonJS({
  "node_modules/estree-to-babel/lib/set-class-private-property.js"(exports, module2) {
    "use strict";
    module2.exports = (path) => {
      path.node.type = "ClassPrivateProperty";
    };
  }
});

// node_modules/estree-to-babel/lib/set-class-private-name.js
var require_set_class_private_name = __commonJS({
  "node_modules/estree-to-babel/lib/set-class-private-name.js"(exports, module2) {
    "use strict";
    var { Identifier } = require_bundle().types;
    module2.exports = ({ node: node2 }) => {
      if (!node2.name)
        return;
      node2.id = Identifier(node2.name);
      node2.id.loc = {
        start: {
          line: node2.loc.start.line,
          column: node2.loc.start.column + 1
        },
        end: node2.loc.end
      };
      delete node2.name;
    };
  }
});

// node_modules/estree-to-babel/lib/set-directives.js
var require_set_directives = __commonJS({
  "node_modules/estree-to-babel/lib/set-directives.js"(exports, module2) {
    "use strict";
    var {
      Directive,
      DirectiveLiteral
    } = require_bundle().types;
    module2.exports = (path) => {
      const { node: node2 } = path;
      if (node2.directives)
        return;
      node2.directives = [];
      for (const statementPath of path.get("body")) {
        if (statementPath.type !== "ExpressionStatement")
          continue;
        const statement = statementPath.node;
        if (!("directive" in statement))
          continue;
        if (!statement.directive)
          continue;
        const directiveLiteral = DirectiveLiteral(statement.directive);
        const directive = Directive(directiveLiteral);
        node2.directives.push(directive);
        statementPath.remove();
      }
    };
  }
});

// node_modules/estree-to-babel/lib/convert-chain-expression.js
var require_convert_chain_expression = __commonJS({
  "node_modules/estree-to-babel/lib/convert-chain-expression.js"(exports, module2) {
    "use strict";
    module2.exports = (path) => {
      const expressionPath = path.get("expression");
      const { expression } = path.node;
      if (expressionPath.isCallExpression())
        expression.type = "OptionalCallExpression";
      else
        expression.type = "OptionalMemberExpression";
      path.replaceWith(expression);
    };
  }
});

// node_modules/estree-to-babel/lib/convert-import-declaration.js
var require_convert_import_declaration = __commonJS({
  "node_modules/estree-to-babel/lib/convert-import-declaration.js"(exports, module2) {
    "use strict";
    module2.exports = (path) => {
      const { attributes = [] } = path.node;
      path.node.attributes = attributes;
    };
  }
});

// node_modules/estree-to-babel/lib/convert-export-declaration.js
var require_convert_export_declaration = __commonJS({
  "node_modules/estree-to-babel/lib/convert-export-declaration.js"(exports, module2) {
    "use strict";
    var { assign } = Object;
    module2.exports = (path) => {
      const { attributes = [] } = path.node;
      assign(path.node, {
        attributes
      });
    };
  }
});

// node_modules/estree-to-babel/lib/ts.js
var require_ts = __commonJS({
  "node_modules/estree-to-babel/lib/ts.js"(exports, module2) {
    "use strict";
    module2.exports.convertTSClassImplements = (path) => {
      path.node.type = "TSExpressionWithTypeArguments";
    };
    module2.exports.convertPropertyDefinition = (path) => {
      const { node: node2 } = path;
      if (node2.key.type === "PrivateIdentifier") {
        const { key } = node2;
        node2.type = "ClassPrivateProperty";
        node2.key = createPrivateName(key);
        return;
      }
      path.node.type = "ClassProperty";
    };
    module2.exports.convertTSInterfaceHeritage = (path) => {
      path.node.type = "TSExpressionWithTypeArguments";
      let { expression } = path.node;
      while (expression.type === "MemberExpression") {
        const { object, property } = expression;
        expression.type = "TSQualifiedName";
        expression.left = object;
        expression.right = property;
        delete expression.object;
        delete expression.property;
        expression = object;
      }
    };
    module2.exports.convertPrivateIdentifier = (path) => {
      path.replaceWith(createPrivateName(path.node));
    };
    module2.exports.convertTSAbstractMethodDefinition = (path) => {
      const { node: node2 } = path;
      const {
        generator,
        async,
        params,
        id,
        returnType
      } = node2.value;
      const newNode = {
        ...node2,
        abstract: true,
        generator,
        async,
        params,
        id,
        returnType,
        type: "TSDeclareMethod"
      };
      delete newNode.value;
      path.replaceWith(newNode);
    };
    function createPrivateName(node2) {
      return {
        type: "PrivateName",
        id: {
          ...node2,
          type: "Identifier"
        },
        loc: node2.loc
      };
    }
  }
});

// node_modules/estree-to-babel/lib/comments.js
var require_comments = __commonJS({
  "node_modules/estree-to-babel/lib/comments.js"(exports, module2) {
    "use strict";
    module2.exports.convertNodeComments = (node2) => {
      const { comments } = node2;
      if (!comments)
        return;
      delete node2.comments;
      node2.leadingComments = void 0;
      node2.trailingComments = void 0;
      node2.innerComments = void 0;
      for (const comment2 of comments) {
        const group = getCommentGroup(comment2);
        if (!node2[group])
          node2[group] = [];
        delete comment2.leading;
        delete comment2.trailing;
        comment2.type = getCommentType(comment2);
        node2[group].push(comment2);
      }
    };
    module2.exports.convertProgramComments = (comments) => {
      for (const comment2 of comments) {
        comment2.type = getCommentType(comment2);
      }
      return comments;
    };
    function getCommentType({ type }) {
      return `Comment${type}`;
    }
    function getCommentGroup({ trailing, leading }) {
      if (trailing)
        return "trailingComments";
      if (leading)
        return "leadingComments";
      return "innerComments";
    }
  }
});

// node_modules/estree-to-babel/lib/set-literal.js
var require_set_literal = __commonJS({
  "node_modules/estree-to-babel/lib/set-literal.js"(exports, module2) {
    "use strict";
    var isString = (a) => typeof a === "string";
    var isNumber = (a) => typeof a === "number";
    var isNull = (a) => a === null;
    var isBool = (a) => typeof a === "boolean";
    module2.exports = (node2) => {
      const { type, value } = node2;
      if (type !== "Literal")
        return;
      if (isNull(value)) {
        node2.type = "NullLiteral";
        return;
      }
      if (isString(value)) {
        node2.type = "StringLiteral";
        return;
      }
      if (isNumber(value)) {
        node2.type = "NumericLiteral";
        return;
      }
      if (isBool(value)) {
        node2.type = "BooleanLiteral";
        return;
      }
      if (node2.regex) {
        transformRegExp(node2);
        return;
      }
    };
    function transformRegExp(node2) {
      node2.type = "RegExpLiteral";
      for (const key of Object.keys(node2.regex)) {
        node2[key] = node2.regex[key];
      }
      delete node2.regex;
    }
  }
});

// node_modules/estree-to-babel/lib/get-ast.js
var require_get_ast = __commonJS({
  "node_modules/estree-to-babel/lib/get-ast.js"(exports, module2) {
    "use strict";
    var { convertProgramComments } = require_comments();
    module2.exports = (node2) => {
      if (node2.type === "File")
        return node2;
      const {
        comments = [],
        tokens,
        ...program
      } = node2;
      const ast = {
        type: "File",
        program: {
          ...program,
          directives: []
        },
        comments: convertProgramComments(comments),
        tokens
      };
      return ast;
    };
  }
});

// node_modules/estree-to-babel/lib/estree-to-babel.js
var require_estree_to_babel = __commonJS({
  "node_modules/estree-to-babel/lib/estree-to-babel.js"(exports, module2) {
    "use strict";
    var { traverse, types: types2 } = require_bundle();
    var traverseObjectExpression = require_traverse_object_expression();
    var setClassMethod = require_set_class_method();
    var setClassPrivateProperty = require_set_class_private_property();
    var setClassPrivateName = require_set_class_private_name();
    var setDirectives = require_set_directives();
    var convertChainExpression = require_convert_chain_expression();
    var convertImportDeclaration = require_convert_import_declaration();
    var convertExportDeclaration = require_convert_export_declaration();
    var {
      convertTSClassImplements,
      convertTSInterfaceHeritage,
      convertTSAbstractMethodDefinition,
      convertPropertyDefinition,
      convertPrivateIdentifier
    } = require_ts();
    var { convertNodeComments } = require_comments();
    var setLiteral = require_set_literal();
    var getAST = require_get_ast();
    var {
      isObjectExpression,
      isExportDeclaration
    } = types2;
    module2.exports = (node2) => {
      const ast = getAST(node2);
      traverse(ast, {
        noScope: true,
        enter(path) {
          const { node: node3 } = path;
          const { type } = node3;
          if (type.endsWith("Literal")) {
            setLiteral(node3);
            return setEsprimaRaw(node3);
          }
          if (type === "BlockStatement" || type === "Program")
            return setDirectives(path);
          if (type === "Property")
            return setObjectProperty(node3);
          if (type === "MethodDefinition")
            return setClassMethod(path);
          if (type === "FieldDefinition")
            return setClassPrivateProperty(path);
          if (type === "PrivateName")
            return setClassPrivateName(path);
          if (type === "ImportDeclaration")
            return convertImportDeclaration(path);
          if (isExportDeclaration(path))
            return convertExportDeclaration(path);
          if (type === "ChainExpression")
            return convertChainExpression(path);
          if (type === "TSAbstractMethodDefinition")
            return convertTSAbstractMethodDefinition(path);
          if (type === "TSInterfaceHeritage")
            return convertTSInterfaceHeritage(path);
          if (type === "PropertyDefinition")
            return convertPropertyDefinition(path);
          if (type === "PrivateIdentifier")
            return convertPrivateIdentifier(path);
          if (type === "TSClassImplements")
            return convertTSClassImplements(path);
        },
        exit(path) {
          const { node: node3 } = path;
          convertNodeComments(node3);
          if (isObjectExpression(node3))
            return traverseObjectExpression(path.get("properties"));
        }
      });
      return ast;
    };
    function setObjectProperty(node2) {
      node2.type = "ObjectProperty";
    }
    function setEsprimaRaw(node2) {
      const { raw } = node2;
      node2.raw = raw || node2.extra?.raw;
      node2.extra = node2.extra || {
        raw
      };
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports.BindingIdentifier = ["Identifier"];
    var Statement = exports.Statement = ["Statement"];
    var Expression = exports.Expression = ["Expression"];
    var Scope4 = exports.Scope = ["Scopable", "Pattern"];
    var Referenced = exports.Referenced = null;
    var BlockScoped = exports.BlockScoped = null;
    var Var = exports.Var = ["VariableDeclaration"];
    var User = exports.User = null;
    var Generated = exports.Generated = null;
    var Pure = exports.Pure = null;
    var Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports.RestProperty = ["RestElement"];
    var SpreadProperty = exports.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isBindingIdentifier = isBindingIdentifier;
    exports.isBlockScoped = isBlockScoped;
    exports.isExpression = isExpression;
    exports.isFlow = isFlow;
    exports.isForAwaitStatement = isForAwaitStatement;
    exports.isGenerated = isGenerated;
    exports.isPure = isPure;
    exports.isReferenced = isReferenced;
    exports.isReferencedIdentifier = isReferencedIdentifier;
    exports.isReferencedMemberExpression = isReferencedMemberExpression;
    exports.isRestProperty = isRestProperty;
    exports.isScope = isScope;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStatement = isStatement;
    exports.isUser = isUser;
    exports.isVar = isVar;
    var _t = require_lib3();
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier: isIdentifier2,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier: isJSXIdentifier2,
      isJSXMemberExpression,
      isMemberExpression,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node: node2,
        parent
      } = this;
      if (!isIdentifier2(node2, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier2(node2, opts)) {
          if (isCompatTag(node2.name))
            return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node: node2,
        parent
      } = this;
      return isMemberExpression(node2) && nodeIsReferenced(node2, parent);
    }
    function isBindingIdentifier() {
      const {
        node: node2,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier2(node2) && isBinding(node2, parent, grandparent);
    }
    function isStatement() {
      const {
        node: node2,
        parent
      } = this;
      if (nodeIsStatement(node2)) {
        if (isVariableDeclaration(node2)) {
          if (isForXStatement(parent, {
            left: node2
          }))
            return false;
          if (isForStatement(parent, {
            init: node2
          }))
            return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node: node2
      } = this;
      if (nodeIsFlow(node2)) {
        return true;
      } else if (isImportDeclaration(node2)) {
        return node2.importKind === "type" || node2.importKind === "typeof";
      } else if (isExportDeclaration(node2)) {
        return node2.exportKind === "type";
      } else if (isImportSpecifier(node2)) {
        return node2.importKind === "type" || node2.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
    }
    function isSpreadProperty() {
      return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@babel/traverse/lib/visitors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.explode = explode;
    exports.isExplodedVisitor = isExplodedVisitor;
    exports.merge = merge2;
    exports.verify = verify;
    var virtualTypes = require_virtual_types();
    var virtualTypesValidators = require_virtual_types_validator();
    var _t = require_lib3();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode(visitor) {
      if (isExplodedVisitor(visitor))
        return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        const parts = nodeType.split("|");
        if (parts.length === 1)
          continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        if (!isVirtualType(nodeType))
          continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(nodeType, fns[type]);
        }
        delete visitor[nodeType];
        const types2 = virtualTypes[nodeType];
        if (types2 !== null) {
          for (const type of types2) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases)
          continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify(visitor) {
      if (visitor._verified)
        return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType))
          continue;
        if (TYPES.indexOf(nodeType) < 0) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
      }
    }
    function merge2(visitors, states = [], wrapper) {
      const mergedVisitor = {};
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
          if (shouldIgnoreKey(key))
            continue;
          let typeVisitor = visitor[key];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      ;
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        if (!Array.isArray(fns))
          continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path) {
              fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key))
          continue;
        const fns = obj[key];
        if (typeof fns === "function") {
          obj[key] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter))
        obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit))
        obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path) {
        if (validator.call(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_")
        return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip")
        return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys") {
        return true;
      }
      {
        if (key === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const phase of ["enter", "exit"]) {
        if (!src[phase])
          continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
  }
});

// node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@babel/traverse/lib/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clear = clear;
    exports.clearPath = clearPath;
    exports.clearScope = clearScope;
    exports.getCachedPaths = getCachedPaths;
    exports.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports.scope = exports.path = void 0;
    var pathsCache = exports.path = /* @__PURE__ */ new WeakMap();
    var scope = exports.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache$get, _hub;
      {
        hub = null;
      }
      return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      var _hub2, _hub3;
      {
        hub = null;
      }
      let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
      if (!parents)
        pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = /* @__PURE__ */ new WeakMap());
      let paths = parents.get(parent);
      if (!paths)
        parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend3;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend3(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position3 = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position3 !== -1 && (terminatorPosition === -1 || position3 < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@babel/helper-split-export-declaration/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/helper-split-export-declaration/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = splitExportDeclaration;
    var _t = require_lib3();
    var {
      cloneNode,
      exportNamedDeclaration,
      exportSpecifier,
      identifier,
      variableDeclaration,
      variableDeclarator
    } = _t;
    function splitExportDeclaration(exportDeclaration) {
      if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (exportDeclaration.isExportDefaultDeclaration()) {
        const declaration2 = exportDeclaration.get("declaration");
        const standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration();
        const exportExpr = declaration2.isFunctionExpression() || declaration2.isClassExpression();
        const scope = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
        let id = declaration2.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration2.node.id = cloneNode(id);
          }
        } else if (exportExpr && scope.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier(id.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration2.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
        exportDeclaration.insertAfter(updatedExportDeclaration);
        exportDeclaration.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(exportDeclaration);
        }
        return exportDeclaration;
      } else if (exportDeclaration.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = exportDeclaration.get("declaration");
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name2) => {
        return exportSpecifier(identifier(name2), identifier(name2));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      exportDeclaration.insertAfter(aliasDeclar);
      exportDeclaration.replaceWith(declaration.node);
      return exportDeclaration;
    }
  }
});

// node_modules/@babel/helper-environment-visitor/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/helper-environment-visitor/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    {
      exports.skipAllButComputedKey = function skipAllButComputedKey(path) {
        path.skip();
        if (path.node.computed) {
          path.context.maybeQueue(path.get("key"));
        }
      };
    }
    function requeueComputedKeyAndDecorators(path) {
      const {
        context,
        node: node2
      } = path;
      if (node2.computed) {
        context.maybeQueue(path.get("key"));
      }
      if (node2.decorators) {
        for (const decorator of path.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    var visitor = {
      FunctionParent(path) {
        if (path.isArrowFunctionExpression()) {
          return;
        } else {
          path.skip();
          if (path.isMethod()) {
            requeueComputedKeyAndDecorators(path);
          }
        }
      },
      Property(path) {
        if (path.isObjectProperty()) {
          return;
        }
        path.skip();
        requeueComputedKeyAndDecorators(path);
      }
    };
    var _default = visitor;
    exports.default = _default;
  }
});

// node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helperSplitExportDeclaration = require_lib4();
    var t2 = require_lib3();
    var _helperEnvironmentVisitor = require_lib5();
    var _traverseNode = require_traverse_node();
    var _visitors = require_visitors();
    var renameVisitor = {
      ReferencedIdentifier({
        node: node2
      }, state) {
        if (node2.name === state.oldName) {
          node2.name = state.newName;
        }
      },
      Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
          if (path.isMethod()) {
            (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path);
          }
        }
      },
      ObjectProperty({
        node: node2,
        scope
      }, state) {
        const {
          name: name2
        } = node2.key;
        if (node2.shorthand && (name2 === state.oldName || name2 === state.newName) && scope.getBindingIdentifier(name2) === state.binding.identifier) {
          var _node$extra;
          node2.shorthand = false;
          if ((_node$extra = node2.extra) != null && _node$extra.shorthand)
            node2.extra.shorthand = false;
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration())
          return;
        const ids = path.getOuterBindingIdentifiers();
        for (const name2 in ids) {
          if (name2 === state.oldName)
            ids[name2].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t2.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
      maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path
        } = binding;
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, {
          discriminant: true
        });
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path);
          this.maybeConvertFromClassFunctionExpression(path);
        }
      }
    };
    exports.default = Renamer;
  }
});

// node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/@babel/traverse/lib/scope/binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path)) {
          this.reassign(path);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue)
          return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path) {
        this.constant = false;
        if (this.constantViolations.indexOf(path) !== -1) {
          return;
        }
        this.constantViolations.push(path);
      }
      reference(path) {
        if (this.referencePaths.indexOf(path) !== -1) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports.default = Binding;
    function isDeclaredInLoop(path) {
      for (let {
        parentPath,
        key
      } = path; parentPath; {
        parentPath,
        key
      } = parentPath) {
        if (parentPath.isFunctionParent())
          return false;
        if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/globals/globals.json
var require_globals = __commonJS({
  "node_modules/globals/globals.json"(exports, module2) {
    module2.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// node_modules/globals/index.js
var require_globals2 = __commonJS({
  "node_modules/globals/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_globals();
  }
});

// node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/@babel/traverse/lib/scope/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib13();
    var _binding = require_binding();
    var _globals = require_globals2();
    var _t = require_lib3();
    var t2 = _t;
    var _cache = require_cache();
    var _visitors = require_visitors();
    var {
      NOT_LOCAL_BINDING,
      callExpression,
      cloneNode,
      getBindingIdentifiers,
      identifier,
      isArrayExpression: isArrayExpression2,
      isBinary,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier: isIdentifier2,
      isImportDeclaration,
      isLiteral,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration,
      matchesPattern,
      memberExpression,
      numericLiteral,
      toIdentifier: toIdentifier2,
      variableDeclaration,
      variableDeclarator,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode
    } = _t;
    function gatherNodeParts(node2, parts) {
      switch (node2 == null ? void 0 : node2.type) {
        default:
          if (isImportDeclaration(node2) || isExportDeclaration(node2)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node2) || isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && node2.source) {
              gatherNodeParts(node2.source, parts);
            } else if ((isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && (_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
              for (const e of node2.specifiers)
                gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration(node2) || isExportNamedDeclaration(node2)) && node2.declaration) {
              gatherNodeParts(node2.declaration, parts);
            }
          } else if (isModuleSpecifier(node2)) {
            gatherNodeParts(node2.local, parts);
          } else if (isLiteral(node2) && !isNullLiteral(node2) && !isRegExpLiteral(node2) && !isTemplateLiteral(node2)) {
            parts.push(node2.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node2.object, parts);
          gatherNodeParts(node2.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node2.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node2.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node2.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node2.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node2.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node2.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node2.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node2.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node2.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node2.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node2.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node2.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node2.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node2.meta, parts);
          gatherNodeParts(node2.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node2.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node2.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node2.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node2.namespace, parts);
          gatherNodeParts(node2.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      ForStatement(path) {
        const declar = path.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path) {
        if (path.isBlockScoped())
          return;
        if (path.isImportDeclaration())
          return;
        if (path.isExportDeclaration())
          return;
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        state.references.push(path);
      },
      ForXStatement(path, state) {
        const left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        } else if (left.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path) {
          const {
            node: node2,
            scope
          } = path;
          if (isExportAllDeclaration(node2))
            return;
          const declar = node2.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id)
              return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path);
          } else if (isVariableDeclaration(declar)) {
            for (const decl of declar.declarations) {
              for (const name2 of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name2);
                binding == null || binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path)
          scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name2 = id.name;
          path.scope.bindings[name2] = path.scope.parent.getBinding(name2);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        const params = path.get("params");
        for (const param of params) {
          path.scope.registerBinding("param", param);
        }
        if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      ClassExpression(path) {
        if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path);
        }
      }
    };
    var uid = 0;
    var Scope4 = class {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.labels = void 0;
        this.inited = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node: node2
        } = path;
        const cached = _cache.scope.get(node2);
        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }
        _cache.scope.set(node2, this);
        this.uid = uid++;
        this.block = node2;
        this.path = path;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          const shouldSkip2 = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip2 && path.isMethod())
            path = path.parentPath;
          if (path && path.isScope())
            parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      get parentBlock() {
        return this.path.parent;
      }
      get hub() {
        return this.path.hub;
      }
      traverse(node2, opts, state) {
        (0, _index.default)(node2, opts, this, state, this.path);
      }
      generateDeclaredUidIdentifier(name2) {
        const id = this.generateUidIdentifier(name2);
        this.push({
          id
        });
        return cloneNode(id);
      }
      generateUidIdentifier(name2) {
        return identifier(this.generateUid(name2));
      }
      generateUid(name2 = "temp") {
        name2 = toIdentifier2(name2).replace(/^_+/, "").replace(/[0-9]+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = this._generateUid(name2, i);
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program = this.getProgramParent();
        program.references[uid2] = true;
        program.uids[uid2] = true;
        return uid2;
      }
      _generateUid(name2, i) {
        let id = name2;
        if (i > 1)
          id += i;
        return `_${id}`;
      }
      generateUidBasedOnNode(node2, defaultName) {
        const parts = [];
        gatherNodeParts(node2, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node2, defaultName) {
        return identifier(this.generateUidBasedOnNode(node2, defaultName));
      }
      isStatic(node2) {
        if (isThisExpression(node2) || isSuper(node2) || isTopicReference(node2)) {
          return true;
        }
        if (isIdentifier2(node2)) {
          const binding = this.getBinding(node2.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node2.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node2, dontPush) {
        if (this.isStatic(node2)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node2);
          if (!dontPush) {
            this.push({
              id
            });
            return cloneNode(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name2, id) {
        if (kind === "param")
          return;
        if (local.kind === "local")
          return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.hub.buildError(id, `Duplicate declaration "${name2}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name2 of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name2];
            console.log(" -", name2, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      toArray(node2, i, arrayLikeIsIterable) {
        if (isIdentifier2(node2)) {
          const binding = this.getBinding(node2.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node2;
          }
        }
        if (isArrayExpression2(node2)) {
          return node2;
        }
        if (isIdentifier2(node2, {
          name: "arguments"
        })) {
          return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node2]);
        }
        let helperName;
        const args = [node2];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression(this.hub.addHelper(helperName), args);
      }
      hasLabel(name2) {
        return !!this.getLabel(name2);
      }
      getLabel(name2) {
        return this.labels.get(name2);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get("declarations");
          const {
            kind
          } = path.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          if (path.node.declare)
            return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
          const specifiers = path.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path) {
        const ids = path.getBindingIdentifiers();
        for (const name2 of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name2)) == null || _this$getBinding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind)
          throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          const declarators = path.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        for (const name2 of Object.keys(ids)) {
          parent.references[name2] = true;
          for (const id of ids[name2]) {
            const local = this.getOwnBinding(name2);
            if (local) {
              if (local.identifier === id)
                continue;
              this.checkBlockScopedCollisions(local, kind, name2, id);
            }
            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name2] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node2) {
        this.globals[node2.name] = node2;
      }
      hasUid(name2) {
        let scope = this;
        do {
          if (scope.uids[name2])
            return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name2) {
        let scope = this;
        do {
          if (scope.globals[name2])
            return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name2) {
        return !!this.getProgramParent().references[name2];
      }
      isPure(node2, constantsOnly) {
        if (isIdentifier2(node2)) {
          const binding = this.getBinding(node2.name);
          if (!binding)
            return false;
          if (constantsOnly)
            return binding.constant;
          return true;
        } else if (isThisExpression(node2) || isMetaProperty(node2) || isTopicReference(node2) || isPrivateName(node2)) {
          return true;
        } else if (isClass(node2)) {
          var _node$decorators;
          if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node2.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node2.body, constantsOnly);
        } else if (isClassBody(node2)) {
          for (const method of node2.body) {
            if (!this.isPure(method, constantsOnly))
              return false;
          }
          return true;
        } else if (isBinary(node2)) {
          return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly);
        } else if (isArrayExpression2(node2) || isTupleExpression(node2)) {
          for (const elem of node2.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly))
              return false;
          }
          return true;
        } else if (isObjectExpression(node2) || isRecordExpression(node2)) {
          for (const prop of node2.properties) {
            if (!this.isPure(prop, constantsOnly))
              return false;
          }
          return true;
        } else if (isMethod(node2)) {
          var _node$decorators2;
          if (node2.computed && !this.isPure(node2.key, constantsOnly))
            return false;
          if (((_node$decorators2 = node2.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node2)) {
          var _node$decorators3;
          if (node2.computed && !this.isPure(node2.key, constantsOnly))
            return false;
          if (((_node$decorators3 = node2.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node2) || node2.static) {
            if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node2)) {
          return this.isPure(node2.argument, constantsOnly);
        } else if (isTaggedTemplateExpression(node2)) {
          return matchesPattern(node2.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node2.quasi, constantsOnly);
        } else if (isTemplateLiteral(node2)) {
          for (const expression of node2.expressions) {
            if (!this.isPure(expression, constantsOnly))
              return false;
          }
          return true;
        } else {
          return isPureish(node2);
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          const data2 = scope.data[key];
          if (data2 != null)
            return data2;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do {
          const data2 = scope.data[key];
          if (data2 != null)
            scope.data[key] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path = this.path;
        this.references = /* @__PURE__ */ Object.create(null);
        this.bindings = /* @__PURE__ */ Object.create(null);
        this.globals = /* @__PURE__ */ Object.create(null);
        this.uids = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ Object.create(null);
        const programParent = this.getProgramParent();
        if (programParent.crawling)
          return;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
          for (const visit3 of collectorVisitor.enter) {
            visit3.call(state, path, state);
          }
          const typeVisitors = collectorVisitor[path.type];
          if (typeVisitors) {
            for (const visit3 of typeVisitors.enter) {
              visit3.call(state, path, state);
            }
          }
        }
        path.traverse(collectorVisitor, state);
        this.crawling = false;
        for (const path2 of state.assignments) {
          const ids = path2.getBindingIdentifiers();
          for (const name2 of Object.keys(ids)) {
            if (path2.scope.getBinding(name2))
              continue;
            programParent.addGlobal(ids[name2]);
          }
          path2.scope.registerConstantViolation(path2);
        }
        for (const ref2 of state.references) {
          const binding = ref2.scope.getBinding(ref2.node.name);
          if (binding) {
            binding.reference(ref2);
          } else {
            programParent.addGlobal(ref2.node);
          }
        }
        for (const path2 of state.constantViolations) {
          path2.scope.registerConstantViolation(path2);
        }
      }
      push(opts) {
        let path = this.path;
        if (path.isPattern()) {
          path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && t2.isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && t2.isIdentifier(id)) {
          path.pushContainer("params", id);
          path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer("body", [declar]);
          if (!unique)
            path.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator(id, init);
        const len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name2 of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name2];
              if (binding.kind === kind)
                ids[name2] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      }
      bindingIdentifierEquals(name2, node2) {
        return this.getBindingIdentifier(name2) === node2;
      }
      getBinding(name2) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name2);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name2 === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name2) {
        return this.bindings[name2];
      }
      getBindingIdentifier(name2) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name2)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name2) {
        const binding = this.bindings[name2];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name2) {
        return !!this.getOwnBinding(name2);
      }
      hasBinding(name2, opts) {
        var _opts, _opts2, _opts3;
        if (!name2)
          return false;
        if (this.hasOwnBinding(name2))
          return true;
        {
          if (typeof opts === "boolean")
            opts = {
              noGlobals: opts
            };
        }
        if (this.parentHasBinding(name2, opts))
          return true;
        if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name2))
          return true;
        if (!((_opts2 = opts) != null && _opts2.noGlobals) && Scope4.globals.includes(name2))
          return true;
        if (!((_opts3 = opts) != null && _opts3.noGlobals) && Scope4.contextVariables.includes(name2))
          return true;
        return false;
      }
      parentHasBinding(name2, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name2, opts);
      }
      moveBindingTo(name2, scope) {
        const info = this.getBinding(name2);
        if (info) {
          info.scope.removeOwnBinding(name2);
          info.scope = scope;
          scope.bindings[name2] = info;
        }
      }
      removeOwnBinding(name2) {
        delete this.bindings[name2];
      }
      removeBinding(name2) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name2)) == null || _this$getBinding3.scope.removeOwnBinding(name2);
        let scope = this;
        do {
          if (scope.uids[name2]) {
            scope.uids[name2] = false;
          }
        } while (scope = scope.parent);
      }
    };
    exports.default = Scope4;
    Scope4.globals = Object.keys(_globals.builtin);
    Scope4.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.get = void 0;
      exports2.put = void 0;
      exports2.pop = void 0;
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      (() => {
        exports2.get = (strarr, key) => strarr._indexes[key];
        exports2.put = (strarr, key) => {
          const index2 = exports2.get(strarr, key);
          if (index2 !== void 0)
            return index2;
          const { array, _indexes: indexes } = strarr;
          return indexes[key] = array.push(key) - 1;
        };
        exports2.pop = (strarr) => {
          const { array, _indexes: indexes } = strarr;
          if (array.length === 0)
            return;
          const last = array.pop();
          indexes[last] = void 0;
        };
      })();
      exports2.SetArray = SetArray;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode2(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index2 = 0;
        do {
          const semi = indexOf(mappings, index2);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index2; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index2 = semi + 1;
        } while (index2 <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index2) {
        const idx = mappings.indexOf(";", index2);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = mappings.charCodeAt(pos++);
          integer = charToInt[c];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        state[j] += value;
        return pos;
      }
      function hasMoreVlq(mappings, i, length) {
        if (i >= length)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports2.decode = decode2;
      exports2.encode = encode;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index2 = path.lastIndexOf("/");
        return path.slice(0, index2 + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index2 = path.lastIndexOf("/");
        return path.slice(0, index2 + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start2) {
        for (let i = start2; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index2) {
        for (let i = index2 + 1; i < haystack.length; index2 = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index2;
      }
      function lowerBound(haystack, needle, index2) {
        for (let i = index2 - 1; i >= 0; index2 = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index2;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex];
            const index2 = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert(originalLine, memo.lastIndex = index2 + 1, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index2, value) {
        for (let i = array.length; i > index2; i--) {
          array[i] = array[i - 1];
        }
        array[index2] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = typeof map === "string" ? JSON.parse(map) : map;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports2.presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset: offset2 } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset2.line, columnOffset + offset2.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        if ("sections" in input)
          return recurse(...arguments);
        const map = new TraceMap(input, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports2.decodedMappings(map);
        const { resolvedSources, sourcesContent: contents } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index2) {
        for (let i = arr.length; i <= index2; i++)
          arr[i] = [];
        return arr[index2];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports2.encodedMappings = void 0;
      exports2.decodedMappings = void 0;
      exports2.traceSegment = void 0;
      exports2.originalPositionFor = void 0;
      exports2.generatedPositionFor = void 0;
      exports2.allGeneratedPositionsFor = void 0;
      exports2.eachMapping = void 0;
      exports2.sourceContentFor = void 0;
      exports2.presortedDecodedMap = void 0;
      exports2.decodedMap = void 0;
      exports2.encodedMap = void 0;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      (() => {
        exports2.encodedMappings = (map) => {
          var _a;
          return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);
        };
        exports2.decodedMappings = (map) => {
          return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
        };
        exports2.traceSegment = (map, line, column) => {
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return null;
          const segments = decoded[line];
          const index2 = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
          return index2 === -1 ? null : segments[index2];
        };
        exports2.originalPositionFor = (map, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return OMapping(null, null, null, null);
          const segments = decoded[line];
          const index2 = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (index2 === -1)
            return OMapping(null, null, null, null);
          const segment = segments[index2];
          if (segment.length === 1)
            return OMapping(null, null, null, null);
          const { names, resolvedSources } = map;
          return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
        };
        exports2.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
        };
        exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
        };
        exports2.eachMapping = (map, cb) => {
          const decoded = exports2.decodedMappings(map);
          const { names, resolvedSources } = map;
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generatedLine = i + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name2 = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name2 = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name: name2
              });
            }
          }
        };
        exports2.sourceContentFor = (map, source) => {
          const { sources, resolvedSources, sourcesContent } = map;
          if (sourcesContent == null)
            return null;
          let index2 = sources.indexOf(source);
          if (index2 === -1)
            index2 = resolvedSources.indexOf(source);
          return index2 === -1 ? null : sourcesContent[index2];
        };
        exports2.presortedDecodedMap = (map, mapUrl) => {
          const tracer = new TraceMap(clone(map, []), mapUrl);
          tracer._decoded = map.mappings;
          return tracer;
        };
        exports2.decodedMap = (map) => {
          return clone(map, exports2.decodedMappings(map));
        };
        exports2.encodedMap = (map) => {
          return clone(map, exports2.encodedMappings(map));
        };
        function generatedPosition(map, source, line, column, bias, all3) {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return all3 ? [] : GMapping(null, null);
          const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return all3 ? [] : GMapping(null, null);
          const memo = map._bySourceMemos[sourceIndex];
          if (all3)
            return sliceGeneratedPositions(segments, memo, line, column, bias);
          const index2 = traceSegmentInternal(segments, memo, line, column, bias);
          if (index2 === -1)
            return GMapping(null, null);
          const segment = segments[index2];
          return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
        }
      })();
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings
        };
      }
      function OMapping(source, line, column, name2) {
        return { source, line, column, name: name2 };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index2 = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2);
        } else if (bias === LEAST_UPPER_BOUND)
          index2++;
        if (index2 === -1 || index2 === segments.length)
          return -1;
        return index2;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      exports2.addSegment = void 0;
      exports2.addMapping = void 0;
      exports2.maybeAddSegment = void 0;
      exports2.maybeAddMapping = void 0;
      exports2.setSourceContent = void 0;
      exports2.toDecodedMap = void 0;
      exports2.toEncodedMap = void 0;
      exports2.fromMap = void 0;
      exports2.allMappings = void 0;
      let addSegmentInternal;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
        }
      }
      (() => {
        exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) => {
          return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3);
        };
        exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) => {
          return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3);
        };
        exports2.addMapping = (map, mapping) => {
          return addMappingInternal(false, map, mapping);
        };
        exports2.maybeAddMapping = (map, mapping) => {
          return addMappingInternal(true, map, mapping);
        };
        exports2.setSourceContent = (map, source, content3) => {
          const { _sources: sources, _sourcesContent: sourcesContent } = map;
          sourcesContent[setArray.put(sources, source)] = content3;
        };
        exports2.toDecodedMap = (map) => {
          const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          removeEmptyFinalLines(mappings);
          return {
            version: 3,
            file: file || void 0,
            names: names.array,
            sourceRoot: sourceRoot || void 0,
            sources: sources.array,
            sourcesContent,
            mappings
          };
        };
        exports2.toEncodedMap = (map) => {
          const decoded = exports2.toDecodedMap(map);
          return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
        };
        exports2.allMappings = (map) => {
          const out = [];
          const { _mappings: mappings, _sources: sources, _names: names } = map;
          for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generated = { line: i + 1, column: seg[COLUMN] };
              let source = void 0;
              let original = void 0;
              let name2 = void 0;
              if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                if (seg.length === 5)
                  name2 = names.array[seg[NAMES_INDEX]];
              }
              out.push({ generated, source, original, name: name2 });
            }
          }
          return out;
        };
        exports2.fromMap = (input) => {
          const map = new traceMapping.TraceMap(input);
          const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
          putAll(gen._names, map.names);
          putAll(gen._sources, map.sources);
          gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
          gen._mappings = traceMapping.decodedMappings(map);
          return gen;
        };
        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content3) => {
          const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          const line = getLine(mappings, genLine);
          const index2 = getColumnIndex(line, genColumn);
          if (!source) {
            if (skipable && skipSourceless(line, index2))
              return;
            return insert(line, index2, [genColumn]);
          }
          const sourcesIndex = setArray.put(sources, source);
          const namesIndex = name2 ? setArray.put(names, name2) : NO_NAME;
          if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content3 !== null && content3 !== void 0 ? content3 : null;
          if (skipable && skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
          }
          return insert(line, index2, name2 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
        };
      })();
      function getLine(mappings, index2) {
        for (let i = mappings.length; i <= index2; i++) {
          mappings[i] = [];
        }
        return mappings[index2];
      }
      function getColumnIndex(line, genColumn) {
        let index2 = line.length;
        for (let i = index2 - 1; i >= 0; index2 = i--) {
          const current2 = line[i];
          if (genColumn >= current2[COLUMN])
            break;
        }
        return index2;
      }
      function insert(array, index2, value) {
        for (let i = array.length; i > index2; i--) {
          array[i] = array[i - 1];
        }
        array[index2] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(strarr, array) {
        for (let i = 0; i < array.length; i++)
          setArray.put(strarr, array[i]);
      }
      function skipSourceless(line, index2) {
        if (index2 === 0)
          return true;
        const prev = line[index2 - 1];
        return prev.length === 1;
      }
      function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index2 === 0)
          return false;
        const prev = line[index2 - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name: name2, content: content3 } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        const s = source;
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name2, content3);
      }
      exports2.GenMapping = GenMapping;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS({
  "node_modules/@babel/generator/lib/source-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap = class {
      constructor(opts, code2) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = void 0;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code2 === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code2);
        } else if (typeof code2 === "object") {
          for (const sourceFileName of Object.keys(code2)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code2[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line,
              column
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line,
              column
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports.default = SourceMap;
  }
});

// node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "node_modules/@babel/generator/lib/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue = this._queue;
        for (let i = 0; i < 16; i++) {
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value,
              writable: true
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0)
          return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position3 = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position3.column += len;
          return;
        }
        const {
          column,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position3.line++;
          position3.column = 0;
          last = i + 1;
          if (last < len && line !== void 0) {
            this._mark(++line, 0, null, null, filename);
          }
          i = str.indexOf("\n", last);
        }
        position3.column += len - last;
      }
      _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0)
          return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue[queueCursor - 1].char;
          if (lastCp !== 10)
            return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map)
          return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map)
          return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      withSource(prop, loc, cb) {
        if (this._map) {
          this.source(prop, loc);
        }
        cb();
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        if (pos) {
          target.line = pos.line;
          target.column = Math.max(pos.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports.default = Buffer2;
  }
});

// node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@babel/generator/lib/node/whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nodes = void 0;
    var _t = require_lib3();
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression: isArrayExpression2,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier: isIdentifier2,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral: isStringLiteral2
    } = _t;
    function crawlInternal(node2, state) {
      if (!node2)
        return state;
      if (isMemberExpression(node2) || isOptionalMemberExpression(node2)) {
        crawlInternal(node2.object, state);
        if (node2.computed)
          crawlInternal(node2.property, state);
      } else if (isBinary(node2) || isAssignmentExpression(node2)) {
        crawlInternal(node2.left, state);
        crawlInternal(node2.right, state);
      } else if (isCallExpression(node2) || isOptionalCallExpression(node2)) {
        state.hasCall = true;
        crawlInternal(node2.callee, state);
      } else if (isFunction(node2)) {
        state.hasFunction = true;
      } else if (isIdentifier2(node2)) {
        state.hasHelper = state.hasHelper || node2.callee && isHelper(node2.callee);
      }
      return state;
    }
    function crawl(node2) {
      return crawlInternal(node2, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node2) {
      if (!node2)
        return false;
      if (isMemberExpression(node2)) {
        return isHelper(node2.object) || isHelper(node2.property);
      } else if (isIdentifier2(node2)) {
        return node2.name === "require" || node2.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node2)) {
        return isHelper(node2.callee);
      } else if (isBinary(node2) || isAssignmentExpression(node2)) {
        return isIdentifier2(node2.left) && isHelper(node2.left) || isHelper(node2.right);
      } else {
        return false;
      }
    }
    function isType(node2) {
      return isLiteral(node2) || isObjectExpression(node2) || isArrayExpression2(node2) || isIdentifier2(node2) || isMemberExpression(node2);
    }
    var nodes = exports.nodes = {
      AssignmentExpression(node2) {
        const state = crawl(node2.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase(node2, parent) {
        return (!!node2.consequent.length || parent.cases[0] === node2 ? 1 : 0) | (!node2.consequent.length && parent.cases[parent.cases.length - 1] === node2 ? 2 : 0);
      },
      LogicalExpression(node2) {
        if (isFunction(node2.left) || isFunction(node2.right)) {
          return 2;
        }
      },
      Literal(node2) {
        if (isStringLiteral2(node2) && node2.value === "use strict") {
          return 2;
        }
      },
      CallExpression(node2) {
        if (isFunction(node2.callee) || isHelper(node2)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression(node2) {
        if (isFunction(node2.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration(node2) {
        for (let i = 0; i < node2.declarations.length; i++) {
          const declar = node2.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement(node2) {
        if (isBlockStatement(node2.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node2, parent) {
      if (parent.properties[0] === node2) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node2, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node2 && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node2, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node2 && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node2, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node2 && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "node_modules/@babel/generator/lib/node/parentheses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrowFunctionExpression = ArrowFunctionExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.Binary = Binary;
    exports.BinaryExpression = BinaryExpression2;
    exports.ClassExpression = ClassExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.DoExpression = DoExpression;
    exports.FunctionExpression = FunctionExpression;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.Identifier = Identifier;
    exports.LogicalExpression = LogicalExpression;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    exports.ObjectExpression = ObjectExpression;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
    exports.UnaryLike = UnaryLike;
    exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.UpdateExpression = UpdateExpression;
    exports.AwaitExpression = exports.YieldExpression = YieldExpression;
    var _t = require_lib3();
    var {
      isArrayTypeAnnotation,
      isArrowFunctionExpression,
      isBinaryExpression,
      isCallExpression,
      isExportDeclaration,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression,
      isObjectPattern,
      isOptionalMemberExpression,
      isYieldExpression
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node2, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node2;
    };
    var hasPostfixPart = (node2, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node2 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node2 || parentType === "TaggedTemplateExpression" && parent.tag === node2 || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node2, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node2, parent, printStack) {
      if (printStack.length < 3)
        return;
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || parentType === "TypeAnnotation" && isArrowFunctionExpression(printStack[printStack.length - 3]);
    }
    function UpdateExpression(node2, parent) {
      return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent);
    }
    function ObjectExpression(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 2);
    }
    function DoExpression(node2, parent, printStack) {
      return !node2.async && isFirstInContext(printStack, 1);
    }
    function Binary(node2, parent) {
      const parentType = parent.type;
      if (node2.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node2;
      }
      if (isClassExtendsClause(node2, parent)) {
        return true;
      }
      if (hasPostfixPart(node2, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      if (parentType === "BinaryExpression" || parentType === "LogicalExpression") {
        const parentPos = PRECEDENCE.get(parent.operator);
        const nodePos = PRECEDENCE.get(node2.operator);
        if (parentPos === nodePos && parent.right === node2 && parentType !== "LogicalExpression" || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation(node2, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node2, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node2;
    }
    function TSAsExpression() {
      return true;
    }
    function TSUnionType(node2, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSOptionalType" || parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSRestType";
    }
    function TSInferType(node2, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node2, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function BinaryExpression2(node2, parent) {
      if (node2.operator === "in") {
        const parentType = parent.type;
        return parentType === "VariableDeclarator" || parentType === "ForStatement" || parentType === "ForInStatement" || parentType === "ForOfStatement";
      }
      return false;
    }
    function SequenceExpression(node2, parent) {
      const parentType = parent.type;
      if (parentType === "ForStatement" || parentType === "ThrowStatement" || parentType === "ReturnStatement" || parentType === "IfStatement" && parent.test === node2 || parentType === "WhileStatement" && parent.test === node2 || parentType === "ForInStatement" && parent.right === node2 || parentType === "SwitchStatement" && parent.discriminant === node2 || parentType === "ExpressionStatement" && parent.expression === node2) {
        return false;
      }
      return true;
    }
    function YieldExpression(node2, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node2, parent) || parentType === "AwaitExpression" && isYieldExpression(node2) || parentType === "ConditionalExpression" && node2 === parent.test || isClassExtendsClause(node2, parent);
    }
    function ClassExpression(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 4);
    }
    function UnaryLike(node2, parent) {
      return hasPostfixPart(node2, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node2 || isClassExtendsClause(node2, parent);
    }
    function FunctionExpression(node2, parent, printStack) {
      return isFirstInContext(printStack, 1 | 4);
    }
    function ArrowFunctionExpression(node2, parent) {
      return isExportDeclaration(parent) || ConditionalExpression(node2, parent);
    }
    function ConditionalExpression(node2, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node2 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node2, parent);
    }
    function OptionalMemberExpression(node2, parent) {
      return isCallExpression(parent) && parent.callee === node2 || isMemberExpression(parent) && parent.object === node2;
    }
    function AssignmentExpression(node2, parent) {
      if (isObjectPattern(node2.left)) {
        return true;
      } else {
        return ConditionalExpression(node2, parent);
      }
    }
    function LogicalExpression(node2, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType))
        return true;
      if (parentType !== "LogicalExpression")
        return false;
      switch (node2.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier(node2, parent, printStack) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node2.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node2) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (node2.name === "let") {
        const isFollowedByBracket = isMemberExpression(parent, {
          object: node2,
          computed: true
        }) || isOptionalMemberExpression(parent, {
          object: node2,
          computed: true,
          optional: false
        });
        return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
      }
      return node2.name === "async" && isForOfStatement(parent) && node2 === parent.left;
    }
    function isFirstInContext(printStack, checkParam) {
      const expressionStatement = checkParam & 1;
      const arrowBody = checkParam & 2;
      const exportDefault = checkParam & 4;
      const forHead = checkParam & 8;
      const forInHead = checkParam & 16;
      const forOfHead = checkParam & 32;
      let i = printStack.length - 1;
      if (i <= 0)
        return;
      let node2 = printStack[i];
      i--;
      let parent = printStack[i];
      while (i >= 0) {
        const parentType = parent.type;
        if (expressionStatement && parentType === "ExpressionStatement" && parent.expression === node2 || exportDefault && parentType === "ExportDefaultDeclaration" && node2 === parent.declaration || arrowBody && parentType === "ArrowFunctionExpression" && parent.body === node2 || forHead && parentType === "ForStatement" && parent.init === node2 || forInHead && parentType === "ForInStatement" && parent.left === node2 || forOfHead && parentType === "ForOfStatement" && parent.left === node2) {
          return true;
        }
        if (i > 0 && (hasPostfixPart(node2, parent) && parentType !== "NewExpression" || parentType === "SequenceExpression" && parent.expressions[0] === node2 || parentType === "UpdateExpression" && !parent.prefix || parentType === "ConditionalExpression" && parent.test === node2 || (parentType === "BinaryExpression" || parentType === "LogicalExpression") && parent.left === node2 || parentType === "AssignmentExpression" && parent.left === node2)) {
          node2 = parent;
          i--;
          parent = printStack[i];
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/generator/lib/node/index.js
var require_node2 = __commonJS({
  "node_modules/@babel/generator/lib/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.needsParens = needsParens;
    exports.needsWhitespace = needsWhitespace;
    exports.needsWhitespaceAfter = needsWhitespaceAfter;
    exports.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace2 = require_whitespace();
    var parens = require_parentheses();
    var _t = require_lib3();
    var {
      FLIPPED_ALIAS_KEYS,
      isCallExpression,
      isExpressionStatement: isExpressionStatement2,
      isMemberExpression,
      isNewExpression
    } = _t;
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node2, parent, stack) {
          var _fn;
          return (_fn = fn(node2, parent, stack)) != null ? _fn : func(node2, parent, stack);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace2.nodes);
    function isOrHasCallExpression(node2) {
      if (isCallExpression(node2)) {
        return true;
      }
      return isMemberExpression(node2) && isOrHasCallExpression(node2.object);
    }
    function needsWhitespace(node2, parent, type) {
      var _expandedWhitespaceNo;
      if (!node2)
        return false;
      if (isExpressionStatement2(node2)) {
        node2 = node2.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node2.type)) == null ? void 0 : _expandedWhitespaceNo(node2, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node2, parent) {
      return needsWhitespace(node2, parent, 1);
    }
    function needsWhitespaceAfter(node2, parent) {
      return needsWhitespace(node2, parent, 2);
    }
    function needsParens(node2, parent, printStack) {
      var _expandedParens$get;
      if (!parent)
        return false;
      if (isNewExpression(parent) && parent.callee === node2) {
        if (isOrHasCallExpression(node2))
          return true;
      }
      return (_expandedParens$get = expandedParens.get(node2.type)) == null ? void 0 : _expandedParens$get(node2, parent, printStack);
    }
  }
});

// node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@babel/generator/lib/generators/template-literals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateElement = TemplateElement;
    exports.TemplateLiteral = TemplateLiteral;
    function TaggedTemplateExpression(node2) {
      this.print(node2.tag, node2);
      this.print(node2.typeParameters, node2);
      this.print(node2.quasi, node2);
    }
    function TemplateElement(node2, parent) {
      const isFirst = parent.quasis[0] === node2;
      const isLast = parent.quasis[parent.quasis.length - 1] === node2;
      const value = (isFirst ? "`" : "}") + node2.value.raw + (isLast ? "`" : "${");
      this.token(value, true);
    }
    function TemplateLiteral(node2) {
      const quasis = node2.quasis;
      for (let i = 0; i < quasis.length; i++) {
        this.print(quasis[i], node2);
        if (i + 1 < quasis.length) {
          this.print(node2.expressions[i], node2);
        }
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "node_modules/@babel/generator/lib/generators/expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
    exports.AssignmentPattern = AssignmentPattern;
    exports.AwaitExpression = AwaitExpression;
    exports.BindExpression = BindExpression;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.Decorator = Decorator;
    exports.DoExpression = DoExpression;
    exports.EmptyStatement = EmptyStatement;
    exports.ExpressionStatement = ExpressionStatement;
    exports.Import = Import;
    exports.MemberExpression = MemberExpression;
    exports.MetaProperty = MetaProperty;
    exports.ModuleExpression = ModuleExpression;
    exports.NewExpression = NewExpression;
    exports.OptionalCallExpression = OptionalCallExpression;
    exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.PrivateName = PrivateName;
    exports.SequenceExpression = SequenceExpression;
    exports.Super = Super;
    exports.ThisExpression = ThisExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports.YieldExpression = YieldExpression;
    exports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require_lib3();
    var n = require_node2();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression
    } = _t;
    function UnaryExpression(node2) {
      const {
        operator
      } = node2;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node2.argument, node2);
    }
    function DoExpression(node2) {
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node2.body, node2);
    }
    function ParenthesizedExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression, node2);
      this.rightParens(node2);
    }
    function UpdateExpression(node2) {
      if (node2.prefix) {
        this.token(node2.operator);
        this.print(node2.argument, node2);
      } else {
        this.printTerminatorless(node2.argument, node2, true);
        this.token(node2.operator);
      }
    }
    function ConditionalExpression(node2) {
      this.print(node2.test, node2);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node2.consequent, node2);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node2.alternate, node2);
    }
    function NewExpression(node2, parent) {
      this.word("new");
      this.space();
      this.print(node2.callee, node2);
      if (this.format.minified && node2.arguments.length === 0 && !node2.optional && !isCallExpression(parent, {
        callee: node2
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node2.typeArguments, node2);
      this.print(node2.typeParameters, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function SequenceExpression(node2) {
      this.printList(node2.expressions, node2);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function isDecoratorMemberExpression(node2) {
      switch (node2.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node2.computed && node2.property.type === "Identifier" && isDecoratorMemberExpression(node2.object);
        default:
          return false;
      }
    }
    function shouldParenthesizeDecoratorExpression(node2) {
      if (node2.type === "ParenthesizedExpression") {
        return false;
      }
      return !isDecoratorMemberExpression(node2.type === "CallExpression" ? node2.callee : node2);
    }
    function _shouldPrintDecoratorsBeforeExport(node2) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node2.start === "number" && node2.start === node2.declaration.start;
    }
    function Decorator(node2) {
      this.tokenChar(64);
      const {
        expression
      } = node2;
      if (shouldParenthesizeDecoratorExpression(expression)) {
        this.tokenChar(40);
        this.print(expression, node2);
        this.tokenChar(41);
      } else {
        this.print(expression, node2);
      }
      this.newline();
    }
    function OptionalMemberExpression(node2) {
      let {
        computed
      } = node2;
      const {
        optional,
        property
      } = node2;
      this.print(node2.object, node2);
      if (!computed && isMemberExpression(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property, node2);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property, node2);
      }
    }
    function OptionalCallExpression(node2) {
      this.print(node2.callee, node2);
      this.print(node2.typeParameters, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.print(node2.typeArguments, node2);
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function CallExpression(node2) {
      this.print(node2.callee, node2);
      this.print(node2.typeArguments, node2);
      this.print(node2.typeParameters, node2);
      this.tokenChar(40);
      this.printList(node2.arguments, node2);
      this.rightParens(node2);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node2) {
      this.word("await");
      if (node2.argument) {
        this.space();
        this.printTerminatorless(node2.argument, node2, false);
      }
    }
    function YieldExpression(node2) {
      this.word("yield", true);
      if (node2.delegate) {
        this.tokenChar(42);
        if (node2.argument) {
          this.space();
          this.print(node2.argument, node2);
        }
      } else {
        if (node2.argument) {
          this.space();
          this.printTerminatorless(node2.argument, node2, false);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node2) {
      this.print(node2.expression, node2);
      this.semicolon();
    }
    function AssignmentPattern(node2) {
      this.print(node2.left, node2);
      if (node2.left.optional)
        this.tokenChar(63);
      this.print(node2.left.typeAnnotation, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right, node2);
    }
    function AssignmentExpression(node2, parent) {
      const parens = this.inForStatementInitCounter && node2.operator === "in" && !n.needsParens(node2, parent);
      if (parens) {
        this.tokenChar(40);
      }
      this.print(node2.left, node2);
      this.space();
      if (node2.operator === "in" || node2.operator === "instanceof") {
        this.word(node2.operator);
      } else {
        this.token(node2.operator);
      }
      this.space();
      this.print(node2.right, node2);
      if (parens) {
        this.tokenChar(41);
      }
    }
    function BindExpression(node2) {
      this.print(node2.object, node2);
      this.token("::");
      this.print(node2.callee, node2);
    }
    function MemberExpression(node2) {
      this.print(node2.object, node2);
      if (!node2.computed && isMemberExpression(node2.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node2.computed;
      if (isLiteral(node2.property) && typeof node2.property.value === "number") {
        computed = true;
      }
      if (computed) {
        this.tokenChar(91);
        this.print(node2.property, node2);
        this.tokenChar(93);
      } else {
        this.tokenChar(46);
        this.print(node2.property, node2);
      }
    }
    function MetaProperty(node2) {
      this.print(node2.meta, node2);
      this.tokenChar(46);
      this.print(node2.property, node2);
    }
    function PrivateName(node2) {
      this.tokenChar(35);
      this.print(node2.id, node2);
    }
    function V8IntrinsicIdentifier(node2) {
      this.tokenChar(37);
      this.word(node2.name);
    }
    function ModuleExpression(node2) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node2;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body, node2);
      this.dedent();
      this.rightBrace(node2);
    }
  }
});

// node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "node_modules/@babel/generator/lib/generators/statements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BreakStatement = BreakStatement;
    exports.CatchClause = CatchClause;
    exports.ContinueStatement = ContinueStatement;
    exports.DebuggerStatement = DebuggerStatement;
    exports.DoWhileStatement = DoWhileStatement;
    exports.ForOfStatement = exports.ForInStatement = void 0;
    exports.ForStatement = ForStatement;
    exports.IfStatement = IfStatement;
    exports.LabeledStatement = LabeledStatement;
    exports.ReturnStatement = ReturnStatement;
    exports.SwitchCase = SwitchCase;
    exports.SwitchStatement = SwitchStatement;
    exports.ThrowStatement = ThrowStatement;
    exports.TryStatement = TryStatement;
    exports.VariableDeclaration = VariableDeclaration;
    exports.VariableDeclarator = VariableDeclarator;
    exports.WhileStatement = WhileStatement;
    exports.WithStatement = WithStatement;
    var _t = require_lib3();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = _t;
    function WithStatement(node2) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node2.object, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function IfStatement(node2) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.space();
      const needsBlock = node2.alternate && isIfStatement(getLastStatement(node2.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node2.consequent, node2);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node2.alternate) {
        if (this.endsWith(125))
          this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node2.alternate, node2);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node2) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      this.inForStatementInitCounter++;
      this.print(node2.init, node2);
      this.inForStatementInitCounter--;
      this.tokenChar(59);
      if (node2.test) {
        this.space();
        this.print(node2.test, node2);
      }
      this.tokenChar(59);
      if (node2.update) {
        this.space();
        this.print(node2.update, node2);
      }
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function WhileStatement(node2) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    function ForXStatement(node2) {
      this.word("for");
      this.space();
      const isForOf = node2.type === "ForOfStatement";
      if (isForOf && node2.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      this.print(node2.left, node2);
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node2.right, node2);
      this.tokenChar(41);
      this.printBlock(node2);
    }
    var ForInStatement2 = exports.ForInStatement = ForXStatement;
    var ForOfStatement = exports.ForOfStatement = ForXStatement;
    function DoWhileStatement(node2) {
      this.word("do");
      this.space();
      this.print(node2.body, node2);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node2.test, node2);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node2, parent, isLabel) {
      if (node2) {
        printer.space();
        printer.printTerminatorless(node2, parent, isLabel);
      }
      printer.semicolon();
    }
    function BreakStatement(node2) {
      this.word("break");
      printStatementAfterKeyword(this, node2.label, node2, true);
    }
    function ContinueStatement(node2) {
      this.word("continue");
      printStatementAfterKeyword(this, node2.label, node2, true);
    }
    function ReturnStatement(node2) {
      this.word("return");
      printStatementAfterKeyword(this, node2.argument, node2, false);
    }
    function ThrowStatement(node2) {
      this.word("throw");
      printStatementAfterKeyword(this, node2.argument, node2, false);
    }
    function LabeledStatement(node2) {
      this.print(node2.label, node2);
      this.tokenChar(58);
      this.space();
      this.print(node2.body, node2);
    }
    function TryStatement(node2) {
      this.word("try");
      this.space();
      this.print(node2.block, node2);
      this.space();
      if (node2.handlers) {
        this.print(node2.handlers[0], node2);
      } else {
        this.print(node2.handler, node2);
      }
      if (node2.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node2.finalizer, node2);
      }
    }
    function CatchClause(node2) {
      this.word("catch");
      this.space();
      if (node2.param) {
        this.tokenChar(40);
        this.print(node2.param, node2);
        this.print(node2.param.typeAnnotation, node2);
        this.tokenChar(41);
        this.space();
      }
      this.print(node2.body, node2);
    }
    function SwitchStatement(node2) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node2.discriminant, node2);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node2.cases, node2, {
        indent: true,
        addNewlines(leading, cas) {
          if (!leading && node2.cases[node2.cases.length - 1] === cas)
            return -1;
        }
      });
      this.rightBrace(node2);
    }
    function SwitchCase(node2) {
      if (node2.test) {
        this.word("case");
        this.space();
        this.print(node2.test, node2);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node2.consequent.length) {
        this.newline();
        this.printSequence(node2.consequent, node2, {
          indent: true
        });
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node2, parent) {
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node2;
      this.word(kind, kind === "using" || kind === "await using");
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node2.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node2.declarations, node2, {
        separator: hasInits ? function() {
          this.tokenChar(44);
          this.newline();
        } : void 0,
        indent: node2.declarations.length > 1 ? true : false
      });
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node2)
            return;
        } else {
          if (parent.left === node2)
            return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node2) {
      this.print(node2.id, node2);
      if (node2.definite)
        this.tokenChar(33);
      this.print(node2.id.typeAnnotation, node2);
      if (node2.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.init, node2);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "node_modules/@babel/generator/lib/generators/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ClassAccessorProperty = ClassAccessorProperty;
    exports.ClassBody = ClassBody;
    exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
    exports.ClassMethod = ClassMethod;
    exports.ClassPrivateMethod = ClassPrivateMethod;
    exports.ClassPrivateProperty = ClassPrivateProperty;
    exports.ClassProperty = ClassProperty;
    exports.StaticBlock = StaticBlock;
    exports._classMethodHead = _classMethodHead;
    var _t = require_lib3();
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node2, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node2.decorators, node2);
      }
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node2.id) {
        this.space();
        this.print(node2.id, node2);
      }
      this.print(node2.typeParameters, node2);
      if (node2.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node2.superClass, node2);
        this.print(node2.superTypeParameters, node2);
      }
      if (node2.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node2.implements, node2);
      }
      this.space();
      this.print(node2.body, node2);
    }
    function ClassBody(node2) {
      this.tokenChar(123);
      if (node2.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node2.body, node2, {
          indent: true
        });
        if (!this.endsWith(10))
          this.newline();
        this.rightBrace(node2);
      }
    }
    function ClassProperty(node2) {
      var _node$key$loc;
      this.printJoin(node2.decorators, node2);
      const endLine = (_node$key$loc = node2.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        this._variance(node2);
        this.print(node2.key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      if (node2.definite) {
        this.tokenChar(33);
      }
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node2) {
      var _node$key$loc2;
      this.printJoin(node2.decorators, node2);
      const endLine = (_node$key$loc2 = node2.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      this.word("accessor", true);
      this.space();
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        this._variance(node2);
        this.print(node2.key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      if (node2.definite) {
        this.tokenChar(33);
      }
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node2) {
      this.printJoin(node2.decorators, node2);
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.key, node2);
      this.print(node2.typeAnnotation, node2);
      if (node2.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.value, node2);
      }
      this.semicolon();
    }
    function ClassMethod(node2) {
      this._classMethodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function ClassPrivateMethod(node2) {
      this._classMethodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function _classMethodHead(node2) {
      var _node$key$loc3;
      this.printJoin(node2.decorators, node2);
      const endLine = (_node$key$loc3 = node2.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
      if (endLine)
        this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node2);
      this._methodHead(node2);
    }
    function StaticBlock(node2) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node2.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node2.body, node2, {
          indent: true
        });
        this.rightBrace(node2);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "node_modules/@babel/generator/lib/generators/methods.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrowFunctionExpression = ArrowFunctionExpression;
    exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
    exports._functionHead = _functionHead;
    exports._methodHead = _methodHead;
    exports._param = _param;
    exports._parameters = _parameters;
    exports._params = _params;
    exports._predicate = _predicate;
    var _t = require_lib3();
    var {
      isIdentifier: isIdentifier2
    } = _t;
    function _params(node2, idNode, parentNode) {
      this.print(node2.typeParameters, node2);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node2.params, node2);
      this.tokenChar(41);
      const noLineTerminator = node2.type === "ArrowFunctionExpression";
      this.print(node2.returnType, node2, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, parent) {
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i], parent);
        if (i < parameters.length - 1) {
          this.tokenChar(44);
          this.space();
        }
      }
    }
    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation, parameter);
    }
    function _methodHead(node2) {
      const kind = node2.kind;
      const key = node2.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node2.generator) {
          this.tokenChar(42);
        }
      }
      if (node2.computed) {
        this.tokenChar(91);
        this.print(key, node2);
        this.tokenChar(93);
      } else {
        this.print(key, node2);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
      this._params(node2, node2.computed && node2.key.type !== "StringLiteral" ? void 0 : node2.key, void 0);
    }
    function _predicate(node2, noLineTerminatorAfter) {
      if (node2.predicate) {
        if (!node2.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node2.predicate, node2, noLineTerminatorAfter);
      }
    }
    function _functionHead(node2, parent) {
      if (node2.async) {
        this.word("async");
        this._endsWithInnerRaw = false;
        this.space();
      }
      this.word("function");
      if (node2.generator) {
        this._endsWithInnerRaw = false;
        this.tokenChar(42);
      }
      this.space();
      if (node2.id) {
        this.print(node2.id, node2);
      }
      this._params(node2, node2.id, parent);
      if (node2.type !== "TSDeclareFunction") {
        this._predicate(node2);
      }
    }
    function FunctionExpression(node2, parent) {
      this._functionHead(node2, parent);
      this.space();
      this.print(node2.body, node2);
    }
    function ArrowFunctionExpression(node2, parent) {
      if (node2.async) {
        this.word("async", true);
        this.space();
      }
      let firstParam;
      if (!this.format.retainLines && node2.params.length === 1 && isIdentifier2(firstParam = node2.params[0]) && !hasTypesOrComments(node2, firstParam)) {
        this.print(firstParam, node2, true);
      } else {
        this._params(node2, void 0, parent);
      }
      this._predicate(node2, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.print(node2.body, node2);
    }
    function hasTypesOrComments(node2, param) {
      var _param$leadingComment, _param$trailingCommen;
      return !!(node2.typeParameters || node2.returnType || node2.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id)
        return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "node_modules/@babel/generator/lib/generators/modules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExportAllDeclaration = ExportAllDeclaration;
    exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports.ExportNamedDeclaration = ExportNamedDeclaration;
    exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports.ExportSpecifier = ExportSpecifier;
    exports.ImportAttribute = ImportAttribute;
    exports.ImportDeclaration = ImportDeclaration;
    exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports.ImportExpression = ImportExpression;
    exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports.ImportSpecifier = ImportSpecifier;
    exports._printAttributes = _printAttributes;
    var _t = require_lib3();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = _t;
    function ImportSpecifier(node2) {
      if (node2.importKind === "type" || node2.importKind === "typeof") {
        this.word(node2.importKind);
        this.space();
      }
      this.print(node2.imported, node2);
      if (node2.local && node2.local.name !== node2.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node2.local, node2);
      }
    }
    function ImportDefaultSpecifier(node2) {
      this.print(node2.local, node2);
    }
    function ExportDefaultSpecifier(node2) {
      this.print(node2.exported, node2);
    }
    function ExportSpecifier(node2) {
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node2.local, node2);
      if (node2.exported && node2.local.name !== node2.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node2.exported, node2);
      }
    }
    function ExportNamespaceSpecifier(node2) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node2.exported, node2);
    }
    var warningShown = false;
    function _printAttributes(node2) {
      const {
        importAttributesKeyword
      } = this.format;
      const {
        attributes,
        assertions
      } = node2;
      if (attributes && !importAttributesKeyword && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && importAttributesKeyword !== "with") {
        this.printList(attributes || assertions, node2);
        return;
      }
      this.tokenChar(123);
      this.space();
      this.printList(attributes || assertions, node2);
      this.space();
      this.tokenChar(125);
    }
    function ExportAllDeclaration(node2) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node2.attributes) != null && _node$attributes.length || (_node$assertions = node2.assertions) != null && _node$assertions.length) {
        this.print(node2.source, node2, true);
        this.space();
        this._printAttributes(node2);
      } else {
        this.print(node2.source, node2);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node2) {
      if (isClassDeclaration(node2.declaration) && printer._shouldPrintDecoratorsBeforeExport(node2)) {
        printer.printJoin(node2.declaration.decorators, node2);
      }
    }
    function ExportNamedDeclaration(node2) {
      maybePrintDecoratorsBeforeExport(this, node2);
      this.word("export");
      this.space();
      if (node2.declaration) {
        const declar = node2.declaration;
        this.print(declar, node2);
        if (!isStatement(declar))
          this.semicolon();
      } else {
        if (node2.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node2.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift(), node2);
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, node2);
            this.space();
          }
          this.tokenChar(125);
        }
        if (node2.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node2.attributes) != null && _node$attributes2.length || (_node$assertions2 = node2.assertions) != null && _node$assertions2.length) {
            this.print(node2.source, node2, true);
            this.space();
            this._printAttributes(node2);
          } else {
            this.print(node2.source, node2);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node2) {
      maybePrintDecoratorsBeforeExport(this, node2);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      const declar = node2.declaration;
      this.print(declar, node2);
      if (!isStatement(declar))
        this.semicolon();
    }
    function ImportDeclaration(node2) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node2.importKind === "type" || node2.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node2.importKind);
        this.space();
      } else if (node2.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node2.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node2.phase);
        this.space();
      }
      const specifiers = node2.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift(), node2);
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      if (specifiers.length) {
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, node2);
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node2.attributes) != null && _node$attributes3.length || (_node$assertions3 = node2.assertions) != null && _node$assertions3.length) {
        this.print(node2.source, node2, true);
        this.space();
        this._printAttributes(node2);
      } else {
        this.print(node2.source, node2);
      }
      this.semicolon();
    }
    function ImportAttribute(node2) {
      this.print(node2.key);
      this.tokenChar(58);
      this.space();
      this.print(node2.value);
    }
    function ImportNamespaceSpecifier(node2) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node2.local, node2);
    }
    function ImportExpression(node2) {
      this.word("import");
      if (node2.phase) {
        this.tokenChar(46);
        this.word(node2.phase);
      }
      this.tokenChar(40);
      this.print(node2.source, node2);
      if (node2.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node2.options, node2);
      }
      this.tokenChar(41);
    }
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty3 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty3.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend3 = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index2 = -1;
      while (++index2 < length) {
        callback(array[index2]);
      }
    };
    var toString4 = object.toString;
    var isArray2 = Array.isArray;
    var isBuffer = Buffer.isBuffer;
    var isObject = (value) => {
      return toString4.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString4.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString4.call(value) == "[object Number]";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString4.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString4.call(value) == "[object Set]";
    };
    var singleEscapes = {
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape = /["'\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent2;
        ++options.indentLevel;
        indent2 = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend3(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent2 = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray2(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent2) + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument)) {
          if (json) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }
            return "0x" + hexadecimal;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push(
              (compact ? "" : indent2) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const string3 = argument;
      let index2 = -1;
      const length = string3.length;
      result = "";
      while (++index2 < length) {
        const character = string3.charAt(index2);
        if (options.es6) {
          const first = string3.charCodeAt(index2);
          if (
            // check if its the start of a surrogate pair
            first >= 55296 && first <= 56319 && // high surrogate
            length > index2 + 1
          ) {
            const second = string3.charCodeAt(index2 + 1);
            if (second >= 56320 && second <= 57343) {
              const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
              let hexadecimal2 = codePoint.toString(16);
              if (!lowercaseHex) {
                hexadecimal2 = hexadecimal2.toUpperCase();
              }
              result += "\\u{" + hexadecimal2 + "}";
              ++index2;
              continue;
            }
          }
        }
        if (!options.escapeEverything) {
          if (regexWhitelist.test(character)) {
            result += character;
            continue;
          }
          if (character == '"') {
            result += quote == character ? '\\"' : character;
            continue;
          }
          if (character == "`") {
            result += quote == character ? "\\`" : character;
            continue;
          }
          if (character == "'") {
            result += quote == character ? "\\'" : character;
            continue;
          }
        }
        if (character == "\0" && !json && !regexDigit.test(string3.charAt(index2 + 1))) {
          result += "\\0";
          continue;
        }
        if (regexSingleEscape.test(character)) {
          result += singleEscapes[character];
          continue;
        }
        const charCode = character.charCodeAt(0);
        if (options.minimal && charCode != 8232 && charCode != 8233) {
          result += character;
          continue;
        }
        let hexadecimal = charCode.toString(16);
        if (!lowercaseHex) {
          hexadecimal = hexadecimal.toUpperCase();
        }
        const longhand = hexadecimal.length > 2 || json;
        const escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
        result += escaped;
        continue;
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        return result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      return result;
    };
    jsesc.version = "2.5.2";
    module2.exports = jsesc;
  }
});

// node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "node_modules/@babel/generator/lib/generators/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArgumentPlaceholder = ArgumentPlaceholder;
    exports.ArrayPattern = exports.ArrayExpression = ArrayExpression2;
    exports.BigIntLiteral = BigIntLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.DecimalLiteral = DecimalLiteral;
    exports.Identifier = Identifier;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
    exports.ObjectMethod = ObjectMethod;
    exports.ObjectProperty = ObjectProperty;
    exports.PipelineBareFunction = PipelineBareFunction;
    exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports.PipelineTopicExpression = PipelineTopicExpression;
    exports.RecordExpression = RecordExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.SpreadElement = exports.RestElement = RestElement2;
    exports.StringLiteral = StringLiteral;
    exports.TopicReference = TopicReference;
    exports.TupleExpression = TupleExpression;
    var _t = require_lib3();
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier: isIdentifier2
    } = _t;
    function Identifier(node2) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node2.loc) == null ? void 0 : _node$loc.identifierName) || node2.name);
      this.word(node2.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement2(node2) {
      this.token("...");
      this.print(node2.argument, node2);
    }
    function ObjectExpression(node2) {
      const props = node2.properties;
      this.tokenChar(123);
      if (props.length) {
        this.space();
        this.printList(props, node2, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod(node2) {
      this.printJoin(node2.decorators, node2);
      this._methodHead(node2);
      this.space();
      this.print(node2.body, node2);
    }
    function ObjectProperty(node2) {
      this.printJoin(node2.decorators, node2);
      if (node2.computed) {
        this.tokenChar(91);
        this.print(node2.key, node2);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node2.value) && isIdentifier2(node2.key) && node2.key.name === node2.value.left.name) {
          this.print(node2.value, node2);
          return;
        }
        this.print(node2.key, node2);
        if (node2.shorthand && isIdentifier2(node2.key) && isIdentifier2(node2.value) && node2.key.name === node2.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node2.value, node2);
    }
    function ArrayExpression2(node2) {
      const elems = node2.elements;
      const len = elems.length;
      this.tokenChar(91);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0)
            this.space();
          this.print(elem, node2);
          if (i < len - 1)
            this.tokenChar(44);
        } else {
          this.tokenChar(44);
        }
      }
      this.tokenChar(93);
    }
    function RecordExpression(node2) {
      const props = node2.properties;
      let startToken;
      let endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      } else {
        startToken = "#{";
        endToken = "}";
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, node2, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node2) {
      const elems = node2.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      }
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0)
            this.space();
          this.print(elem, node2);
          if (i < len - 1)
            this.tokenChar(44);
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node2) {
      this.word(`/${node2.pattern}/${node2.flags}`);
    }
    function BooleanLiteral(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node2) {
      const raw = this.getPossibleRaw(node2);
      const opts = this.format.jsescOption;
      const value = node2.value;
      const str = value + "";
      if (opts.numbers) {
        this.number(_jsesc(value, opts), value);
      } else if (raw == null) {
        this.number(str, value);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
      } else {
        this.number(raw, value);
      }
    }
    function StringLiteral(node2) {
      const raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node2.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node2) {
      const raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node2.value + "n");
    }
    function DecimalLiteral(node2) {
      const raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node2.value + "m");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node2) {
      this.print(node2.expression, node2);
    }
    function PipelineBareFunction(node2) {
      this.print(node2.callee, node2);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
  }
});

// node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnyTypeAnnotation = AnyTypeAnnotation;
    exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports.DeclareClass = DeclareClass;
    exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports.DeclareExportDeclaration = DeclareExportDeclaration;
    exports.DeclareFunction = DeclareFunction;
    exports.DeclareInterface = DeclareInterface;
    exports.DeclareModule = DeclareModule;
    exports.DeclareModuleExports = DeclareModuleExports;
    exports.DeclareOpaqueType = DeclareOpaqueType;
    exports.DeclareTypeAlias = DeclareTypeAlias;
    exports.DeclareVariable = DeclareVariable;
    exports.DeclaredPredicate = DeclaredPredicate;
    exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports.EnumBooleanBody = EnumBooleanBody;
    exports.EnumBooleanMember = EnumBooleanMember;
    exports.EnumDeclaration = EnumDeclaration;
    exports.EnumDefaultedMember = EnumDefaultedMember;
    exports.EnumNumberBody = EnumNumberBody;
    exports.EnumNumberMember = EnumNumberMember;
    exports.EnumStringBody = EnumStringBody;
    exports.EnumStringMember = EnumStringMember;
    exports.EnumSymbolBody = EnumSymbolBody;
    exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.FunctionTypeParam = FunctionTypeParam;
    exports.IndexedAccessType = IndexedAccessType;
    exports.InferredPredicate = InferredPredicate;
    exports.InterfaceDeclaration = InterfaceDeclaration;
    exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports.MixedTypeAnnotation = MixedTypeAnnotation;
    exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports.NumberTypeAnnotation = NumberTypeAnnotation;
    exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports.ObjectTypeIndexer = ObjectTypeIndexer;
    exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports.ObjectTypeProperty = ObjectTypeProperty;
    exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports.OpaqueType = OpaqueType;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports.StringTypeAnnotation = StringTypeAnnotation;
    exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports.ThisTypeAnnotation = ThisTypeAnnotation;
    exports.TupleTypeAnnotation = TupleTypeAnnotation;
    exports.TypeAlias = TypeAlias;
    exports.TypeAnnotation = TypeAnnotation;
    exports.TypeCastExpression = TypeCastExpression;
    exports.TypeParameter = TypeParameter;
    exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.Variance = Variance;
    exports.VoidTypeAnnotation = VoidTypeAnnotation;
    exports._interfaceish = _interfaceish;
    exports._variance = _variance;
    var _t = require_lib3();
    var _modules = require_modules();
    var _types2 = require_types();
    var {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node2) {
      this.print(node2.elementType, node2, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node2);
    }
    function DeclareFunction(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.id.typeAnnotation.typeAnnotation, node2);
      if (node2.predicate) {
        this.space();
        this.print(node2.predicate, node2);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node2) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node2.value, node2);
      this.tokenChar(41);
    }
    function DeclareInterface(node2) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node2);
    }
    function DeclareModule(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node2.id, node2);
      this.space();
      this.print(node2.body, node2);
    }
    function DeclareModuleExports(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node2.typeAnnotation, node2);
    }
    function DeclareTypeAlias(node2) {
      this.word("declare");
      this.space();
      this.TypeAlias(node2);
    }
    function DeclareOpaqueType(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node2);
    }
    function DeclareVariable(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.id.typeAnnotation, node2);
      this.semicolon();
    }
    function DeclareExportDeclaration(node2) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node2.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node2);
    }
    function DeclareExportAllDeclaration(node2) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node2);
    }
    function EnumDeclaration(node2) {
      const {
        id,
        body
      } = node2;
      this.word("enum");
      this.space();
      this.print(id, node2);
      this.print(body, node2);
    }
    function enumExplicitType(context, name2, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name2);
      }
      context.space();
    }
    function enumBody(context, node2) {
      const {
        members
      } = node2;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member, node2);
        context.newline();
      }
      if (node2.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node2);
    }
    function EnumNumberBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node2);
    }
    function EnumStringBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node2);
    }
    function EnumSymbolBody(node2) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node2);
    }
    function EnumDefaultedMember(node2) {
      const {
        id
      } = node2;
      this.print(id, node2);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node2) {
      const {
        id,
        init
      } = node2;
      context.print(id, node2);
      context.space();
      context.token("=");
      context.space();
      context.print(init, node2);
      context.token(",");
    }
    function EnumBooleanMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumNumberMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumStringMember(node2) {
      enumInitializedMember(this, node2);
    }
    function FlowExportDeclaration(node2) {
      if (node2.declaration) {
        const declar = node2.declaration;
        this.print(declar, node2);
        if (!isStatement(declar))
          this.semicolon();
      } else {
        this.tokenChar(123);
        if (node2.specifiers.length) {
          this.space();
          this.printList(node2.specifiers, node2);
          this.space();
        }
        this.tokenChar(125);
        if (node2.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node2.source, node2);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node2, parent) {
      this.print(node2.typeParameters, node2);
      this.tokenChar(40);
      if (node2.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node2.this.typeAnnotation, node2);
        if (node2.params.length || node2.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node2.params, node2);
      if (node2.rest) {
        if (node2.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node2.rest, node2);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node2.returnType, node2);
    }
    function FunctionTypeParam(node2) {
      this.print(node2.name, node2);
      if (node2.optional)
        this.tokenChar(63);
      if (node2.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.typeAnnotation, node2);
    }
    function InterfaceExtends(node2) {
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2, true);
    }
    function _interfaceish(node2) {
      var _node$extends;
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      if ((_node$extends = node2.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends, node2);
      }
      if (node2.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node2.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node2.mixins, node2);
        }
        if ((_node$implements = node2.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node2.implements, node2);
        }
      }
      this.space();
      this.print(node2.body, node2);
    }
    function _variance(node2) {
      var _node$variance;
      const kind = (_node$variance = node2.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node2) {
      this.word("interface");
      this.space();
      this._interfaceish(node2);
    }
    function andSeparator() {
      this.space();
      this.tokenChar(38);
      this.space();
    }
    function InterfaceTypeAnnotation(node2) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node2.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends, node2);
      }
      this.space();
      this.print(node2.body, node2);
    }
    function IntersectionTypeAnnotation(node2) {
      this.printJoin(node2.types, node2, {
        separator: andSeparator
      });
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node2) {
      this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node2) {
      this.tokenChar(91);
      this.printList(node2.types, node2);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.argument, node2);
    }
    function TypeAlias(node2) {
      this.word("type");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right, node2);
      this.semicolon();
    }
    function TypeAnnotation(node2) {
      this.tokenChar(58);
      this.space();
      if (node2.optional)
        this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function TypeParameterInstantiation(node2) {
      this.tokenChar(60);
      this.printList(node2.params, node2, {});
      this.tokenChar(62);
    }
    function TypeParameter(node2) {
      this._variance(node2);
      this.word(node2.name);
      if (node2.bound) {
        this.print(node2.bound, node2);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default, node2);
      }
    }
    function OpaqueType(node2) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node2.id, node2);
      this.print(node2.typeParameters, node2);
      if (node2.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node2.supertype, node2);
      }
      if (node2.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.impltype, node2);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node2) {
      if (node2.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node2.properties, ...node2.callProperties || [], ...node2.indexers || [], ...node2.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, node2, {
          addNewlines(leading) {
            if (leading && !props[0])
              return 1;
          },
          indent: true,
          statement: true,
          iterator: () => {
            if (props.length !== 1 || node2.inexact) {
              this.tokenChar(44);
              this.space();
            }
          }
        });
        this.space();
      }
      if (node2.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node2.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node2.id, node2);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node2.optional)
        this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeCallProperty(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeIndexer(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this._variance(node2);
      this.tokenChar(91);
      if (node2.id) {
        this.print(node2.id, node2);
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.key, node2);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node2.value, node2);
    }
    function ObjectTypeProperty(node2) {
      if (node2.proto) {
        this.word("proto");
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.kind === "get" || node2.kind === "set") {
        this.word(node2.kind);
        this.space();
      }
      this._variance(node2);
      this.print(node2.key, node2);
      if (node2.optional)
        this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value, node2);
    }
    function ObjectTypeSpreadProperty(node2) {
      this.token("...");
      this.print(node2.argument, node2);
    }
    function QualifiedTypeIdentifier(node2) {
      this.print(node2.qualification, node2);
      this.tokenChar(46);
      this.print(node2.id, node2);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator() {
      this.space();
      this.tokenChar(124);
      this.space();
    }
    function UnionTypeAnnotation(node2) {
      this.printJoin(node2.types, node2, {
        separator: orSeparator
      });
    }
    function TypeCastExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression, node2);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(41);
    }
    function Variance(node2) {
      if (node2.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node2) {
      this.print(node2.objectType, node2, true);
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node2) {
      this.print(node2.objectType, node2);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "node_modules/@babel/generator/lib/generators/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BlockStatement = BlockStatement2;
    exports.Directive = Directive;
    exports.DirectiveLiteral = DirectiveLiteral;
    exports.File = File;
    exports.InterpreterDirective = InterpreterDirective;
    exports.Placeholder = Placeholder;
    exports.Program = Program;
    function File(node2) {
      if (node2.program) {
        this.print(node2.program.interpreter, node2);
      }
      this.print(node2.program, node2);
    }
    function Program(node2) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node2.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline = node2.body.length ? 2 : 1;
        this.printSequence(node2.directives, node2, {
          trailingCommentsLineOffset: newline
        });
        if (!((_node$directives$trai = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node2.body, node2);
    }
    function BlockStatement2(node2) {
      var _node$directives2;
      this.tokenChar(123);
      const directivesLen = (_node$directives2 = node2.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline = node2.body.length ? 2 : 1;
        this.printSequence(node2.directives, node2, {
          indent: true,
          trailingCommentsLineOffset: newline
        });
        if (!((_node$directives$trai2 = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node2.body, node2, {
        indent: true
      });
      this.rightBrace(node2);
    }
    function Directive(node2) {
      this.print(node2.value, node2);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node2) {
      const raw = this.getPossibleRaw(node2);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node2;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node2) {
      this.token(`#!${node2.value}`);
      this.newline(1, true);
    }
    function Placeholder(node2) {
      this.token("%%");
      this.print(node2.name);
      this.token("%%");
      if (node2.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/jsx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSXAttribute = JSXAttribute;
    exports.JSXClosingElement = JSXClosingElement;
    exports.JSXClosingFragment = JSXClosingFragment;
    exports.JSXElement = JSXElement;
    exports.JSXEmptyExpression = JSXEmptyExpression;
    exports.JSXExpressionContainer = JSXExpressionContainer;
    exports.JSXFragment = JSXFragment;
    exports.JSXIdentifier = JSXIdentifier;
    exports.JSXMemberExpression = JSXMemberExpression;
    exports.JSXNamespacedName = JSXNamespacedName;
    exports.JSXOpeningElement = JSXOpeningElement;
    exports.JSXOpeningFragment = JSXOpeningFragment;
    exports.JSXSpreadAttribute = JSXSpreadAttribute;
    exports.JSXSpreadChild = JSXSpreadChild;
    exports.JSXText = JSXText;
    function JSXAttribute(node2) {
      this.print(node2.name, node2);
      if (node2.value) {
        this.tokenChar(61);
        this.print(node2.value, node2);
      }
    }
    function JSXIdentifier(node2) {
      this.word(node2.name);
    }
    function JSXNamespacedName(node2) {
      this.print(node2.namespace, node2);
      this.tokenChar(58);
      this.print(node2.name, node2);
    }
    function JSXMemberExpression(node2) {
      this.print(node2.object, node2);
      this.tokenChar(46);
      this.print(node2.property, node2);
    }
    function JSXSpreadAttribute(node2) {
      this.tokenChar(123);
      this.token("...");
      this.print(node2.argument, node2);
      this.tokenChar(125);
    }
    function JSXExpressionContainer(node2) {
      this.tokenChar(123);
      this.print(node2.expression, node2);
      this.tokenChar(125);
    }
    function JSXSpreadChild(node2) {
      this.tokenChar(123);
      this.token("...");
      this.print(node2.expression, node2);
      this.tokenChar(125);
    }
    function JSXText(node2) {
      const raw = this.getPossibleRaw(node2);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node2.value, true);
      }
    }
    function JSXElement(node2) {
      const open = node2.openingElement;
      this.print(open, node2);
      if (open.selfClosing)
        return;
      this.indent();
      for (const child of node2.children) {
        this.print(child, node2);
      }
      this.dedent();
      this.print(node2.closingElement, node2);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node2) {
      this.tokenChar(60);
      this.print(node2.name, node2);
      this.print(node2.typeParameters, node2);
      if (node2.attributes.length > 0) {
        this.space();
        this.printJoin(node2.attributes, node2, {
          separator: spaceSeparator
        });
      }
      if (node2.selfClosing) {
        this.space();
        this.token("/>");
      } else {
        this.tokenChar(62);
      }
    }
    function JSXClosingElement(node2) {
      this.token("</");
      this.print(node2.name, node2);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node2) {
      this.print(node2.openingFragment, node2);
      this.indent();
      for (const child of node2.children) {
        this.print(child, node2);
      }
      this.dedent();
      this.print(node2.closingFragment, node2);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TSAnyKeyword = TSAnyKeyword;
    exports.TSArrayType = TSArrayType;
    exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
    exports.TSBigIntKeyword = TSBigIntKeyword;
    exports.TSBooleanKeyword = TSBooleanKeyword;
    exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports.TSConditionalType = TSConditionalType;
    exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports.TSConstructorType = TSConstructorType;
    exports.TSDeclareFunction = TSDeclareFunction;
    exports.TSDeclareMethod = TSDeclareMethod;
    exports.TSEnumDeclaration = TSEnumDeclaration;
    exports.TSEnumMember = TSEnumMember;
    exports.TSExportAssignment = TSExportAssignment;
    exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
    exports.TSExternalModuleReference = TSExternalModuleReference;
    exports.TSFunctionType = TSFunctionType;
    exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports.TSImportType = TSImportType;
    exports.TSIndexSignature = TSIndexSignature;
    exports.TSIndexedAccessType = TSIndexedAccessType;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSInterfaceBody = TSInterfaceBody;
    exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports.TSIntersectionType = TSIntersectionType;
    exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports.TSLiteralType = TSLiteralType;
    exports.TSMappedType = TSMappedType;
    exports.TSMethodSignature = TSMethodSignature;
    exports.TSModuleBlock = TSModuleBlock;
    exports.TSModuleDeclaration = TSModuleDeclaration;
    exports.TSNamedTupleMember = TSNamedTupleMember;
    exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports.TSNeverKeyword = TSNeverKeyword;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TSNullKeyword = TSNullKeyword;
    exports.TSNumberKeyword = TSNumberKeyword;
    exports.TSObjectKeyword = TSObjectKeyword;
    exports.TSOptionalType = TSOptionalType;
    exports.TSParameterProperty = TSParameterProperty;
    exports.TSParenthesizedType = TSParenthesizedType;
    exports.TSPropertySignature = TSPropertySignature;
    exports.TSQualifiedName = TSQualifiedName;
    exports.TSRestType = TSRestType;
    exports.TSStringKeyword = TSStringKeyword;
    exports.TSSymbolKeyword = TSSymbolKeyword;
    exports.TSThisType = TSThisType;
    exports.TSTupleType = TSTupleType;
    exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports.TSTypeAnnotation = TSTypeAnnotation;
    exports.TSTypeAssertion = TSTypeAssertion;
    exports.TSTypeLiteral = TSTypeLiteral;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSTypeParameter = TSTypeParameter;
    exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports.TSTypePredicate = TSTypePredicate;
    exports.TSTypeQuery = TSTypeQuery;
    exports.TSTypeReference = TSTypeReference;
    exports.TSUndefinedKeyword = TSUndefinedKeyword;
    exports.TSUnionType = TSUnionType;
    exports.TSUnknownKeyword = TSUnknownKeyword;
    exports.TSVoidKeyword = TSVoidKeyword;
    exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
    function TSTypeAnnotation(node2) {
      this.tokenChar(58);
      this.space();
      if (node2.optional)
        this.tokenChar(63);
      this.print(node2.typeAnnotation, node2);
    }
    function TSTypeParameterInstantiation(node2, parent) {
      this.tokenChar(60);
      this.printList(node2.params, node2, {});
      if (parent.type === "ArrowFunctionExpression" && node2.params.length === 1) {
        this.tokenChar(44);
      }
      this.tokenChar(62);
    }
    function TSTypeParameter(node2) {
      if (node2.in) {
        this.word("in");
        this.space();
      }
      if (node2.out) {
        this.word("out");
        this.space();
      }
      this.word(node2.name);
      if (node2.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node2.constraint, node2);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default, node2);
      }
    }
    function TSParameterProperty(node2) {
      if (node2.accessibility) {
        this.word(node2.accessibility);
        this.space();
      }
      if (node2.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node2.parameter);
    }
    function TSDeclareFunction(node2, parent) {
      if (node2.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node2, parent);
      this.tokenChar(59);
    }
    function TSDeclareMethod(node2) {
      this._classMethodHead(node2);
      this.tokenChar(59);
    }
    function TSQualifiedName(node2) {
      this.print(node2.left, node2);
      this.tokenChar(46);
      this.print(node2.right, node2);
    }
    function TSCallSignatureDeclaration(node2) {
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSConstructSignatureDeclaration(node2) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSPropertySignature(node2) {
      const {
        readonly
      } = node2;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node2);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(59);
    }
    function tsPrintPropertyOrMethodName(node2) {
      if (node2.computed) {
        this.tokenChar(91);
      }
      this.print(node2.key, node2);
      if (node2.computed) {
        this.tokenChar(93);
      }
      if (node2.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node2) {
      const {
        kind
      } = node2;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node2);
      this.tsPrintSignatureDeclarationBase(node2);
      this.tokenChar(59);
    }
    function TSIndexSignature(node2) {
      const {
        readonly,
        static: isStatic
      } = node2;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node2.parameters, node2);
      this.tokenChar(93);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(59);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node2) {
      this.tsPrintFunctionOrConstructorType(node2);
    }
    function TSConstructorType(node2) {
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node2);
    }
    function tsPrintFunctionOrConstructorType(node2) {
      const {
        typeParameters
      } = node2;
      const parameters = node2.parameters;
      this.print(typeParameters, node2);
      this.tokenChar(40);
      this._parameters(parameters, node2);
      this.tokenChar(41);
      this.space();
      this.token("=>");
      this.space();
      const returnType = node2.typeAnnotation;
      this.print(returnType.typeAnnotation, node2);
    }
    function TSTypeReference(node2) {
      this.print(node2.typeName, node2, true);
      this.print(node2.typeParameters, node2, true);
    }
    function TSTypePredicate(node2) {
      if (node2.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node2.parameterName);
      if (node2.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node2.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.exprName);
      if (node2.typeParameters) {
        this.print(node2.typeParameters, node2);
      }
    }
    function TSTypeLiteral(node2) {
      this.tsPrintTypeLiteralOrInterfaceBody(node2.members, node2);
    }
    function tsPrintTypeLiteralOrInterfaceBody(members, node2) {
      tsPrintBraced(this, members, node2);
    }
    function tsPrintBraced(printer, members, node2) {
      printer.token("{");
      if (members.length) {
        printer.indent();
        printer.newline();
        for (const member of members) {
          printer.print(member, node2);
          printer.newline();
        }
        printer.dedent();
      }
      printer.rightBrace(node2);
    }
    function TSArrayType(node2) {
      this.print(node2.elementType, node2, true);
      this.token("[]");
    }
    function TSTupleType(node2) {
      this.tokenChar(91);
      this.printList(node2.elementTypes, node2);
      this.tokenChar(93);
    }
    function TSOptionalType(node2) {
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(63);
    }
    function TSRestType(node2) {
      this.token("...");
      this.print(node2.typeAnnotation, node2);
    }
    function TSNamedTupleMember(node2) {
      this.print(node2.label, node2);
      if (node2.optional)
        this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node2.elementType, node2);
    }
    function TSUnionType(node2) {
      tsPrintUnionOrIntersectionType(this, node2, "|");
    }
    function TSIntersectionType(node2) {
      tsPrintUnionOrIntersectionType(this, node2, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node2, sep) {
      printer.printJoin(node2.types, node2, {
        separator() {
          this.space();
          this.token(sep);
          this.space();
        }
      });
    }
    function TSConditionalType(node2) {
      this.print(node2.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node2.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node2.falseType);
    }
    function TSInferType(node2) {
      this.token("infer");
      this.space();
      this.print(node2.typeParameter);
    }
    function TSParenthesizedType(node2) {
      this.tokenChar(40);
      this.print(node2.typeAnnotation, node2);
      this.tokenChar(41);
    }
    function TSTypeOperator(node2) {
      this.word(node2.operator);
      this.space();
      this.print(node2.typeAnnotation, node2);
    }
    function TSIndexedAccessType(node2) {
      this.print(node2.objectType, node2, true);
      this.tokenChar(91);
      this.print(node2.indexType, node2);
      this.tokenChar(93);
    }
    function TSMappedType(node2) {
      const {
        nameType,
        optional,
        readonly,
        typeParameter
      } = node2;
      this.tokenChar(123);
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this.word(typeParameter.name);
      this.space();
      this.word("in");
      this.space();
      this.print(typeParameter.constraint, typeParameter);
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType, node2);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      this.tokenChar(58);
      this.space();
      this.print(node2.typeAnnotation, node2);
      this.space();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSLiteralType(node2) {
      this.print(node2.literal, node2);
    }
    function TSExpressionWithTypeArguments(node2) {
      this.print(node2.expression, node2);
      this.print(node2.typeParameters, node2);
    }
    function TSInterfaceDeclaration(node2) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node2;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id, node2);
      this.print(typeParameters, node2);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz, node2);
      }
      this.space();
      this.print(body, node2);
    }
    function TSInterfaceBody(node2) {
      this.tsPrintTypeLiteralOrInterfaceBody(node2.body, node2);
    }
    function TSTypeAliasDeclaration(node2) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation
      } = node2;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id, node2);
      this.print(typeParameters, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation, node2);
      this.tokenChar(59);
    }
    function TSTypeExpression(node2) {
      var _expression$trailingC;
      const {
        type,
        expression,
        typeAnnotation
      } = node2;
      const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);
      this.print(expression, node2, true, void 0, forceParens);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation, node2);
    }
    function TSTypeAssertion(node2) {
      const {
        typeAnnotation,
        expression
      } = node2;
      this.tokenChar(60);
      this.print(typeAnnotation, node2);
      this.tokenChar(62);
      this.space();
      this.print(expression, node2);
    }
    function TSInstantiationExpression(node2) {
      this.print(node2.expression, node2);
      this.print(node2.typeParameters, node2);
    }
    function TSEnumDeclaration(node2) {
      const {
        declare,
        const: isConst,
        id,
        members
      } = node2;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id, node2);
      this.space();
      tsPrintBraced(this, members, node2);
    }
    function TSEnumMember(node2) {
      const {
        id,
        initializer
      } = node2;
      this.print(id, node2);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer, node2);
      }
      this.tokenChar(44);
    }
    function TSModuleDeclaration(node2) {
      const {
        declare,
        id
      } = node2;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (!node2.global) {
        this.word(id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id, node2);
      if (!node2.body) {
        this.tokenChar(59);
        return;
      }
      let body = node2.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id, body);
        body = body.body;
      }
      this.space();
      this.print(body, node2);
    }
    function TSModuleBlock(node2) {
      tsPrintBraced(this, node2.body, node2);
    }
    function TSImportType(node2) {
      const {
        argument,
        qualifier,
        typeParameters
      } = node2;
      this.word("import");
      this.tokenChar(40);
      this.print(argument, node2);
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier, node2);
      }
      if (typeParameters) {
        this.print(typeParameters, node2);
      }
    }
    function TSImportEqualsDeclaration(node2) {
      const {
        isExport,
        id,
        moduleReference
      } = node2;
      if (isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id, node2);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference, node2);
      this.tokenChar(59);
    }
    function TSExternalModuleReference(node2) {
      this.token("require(");
      this.print(node2.expression, node2);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node2) {
      this.print(node2.expression, node2);
      this.tokenChar(33);
    }
    function TSExportAssignment(node2) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.expression, node2);
      this.tokenChar(59);
    }
    function TSNamespaceExportDeclaration(node2) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node2.id, node2);
    }
    function tsPrintSignatureDeclarationBase(node2) {
      const {
        typeParameters
      } = node2;
      const parameters = node2.parameters;
      this.print(typeParameters, node2);
      this.tokenChar(40);
      this._parameters(parameters, node2);
      this.tokenChar(41);
      const returnType = node2.typeAnnotation;
      this.print(returnType, node2);
    }
    function tsPrintClassMemberModifiers(node2) {
      const isField = node2.type === "ClassAccessorProperty" || node2.type === "ClassProperty";
      if (isField && node2.declare) {
        this.word("declare");
        this.space();
      }
      if (node2.accessibility) {
        this.word(node2.accessibility);
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.override) {
        this.word("override");
        this.space();
      }
      if (node2.abstract) {
        this.word("abstract");
        this.space();
      }
      if (isField && node2.readonly) {
        this.word("readonly");
        this.space();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "node_modules/@babel/generator/lib/generators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _templateLiterals[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _expressions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _statements[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _classes[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _methods[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _modules[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _flow[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _base[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _jsx[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _typescript[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "node_modules/@babel/generator/lib/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buffer = require_buffer();
    var n = require_node2();
    var _t = require_lib3();
    var generatorFunctions = require_generators();
    var {
      isFunction,
      isStatement,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumDeclaration
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    var {
      needsParens
    } = n;
    var Printer = class {
      constructor(format, map) {
        this.inForStatementInitCounter = 0;
        this._printStack = [];
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._parenPushNewlineState = null;
        this._noLineTerminator = false;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.format = format;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map == null ? void 0 : map._inputMap;
        this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      generate(ast) {
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        if (this.format.compact || this.format.concise)
          return;
        this._indent++;
      }
      dedent() {
        if (this.format.compact || this.format.concise)
          return;
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
        } else {
          this._queue(59);
        }
        this._noLineTerminator = false;
      }
      rightBrace(node2) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node2.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node2) {
        this.sourceWithOffset("end", node2.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        if (this.format.compact)
          return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = false) {
        this._maybePrintInnerComments();
        if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
          this._space();
        }
        this._maybeAddAuxComment();
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number2) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            const secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(number2) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = false) {
        this._maybePrintInnerComments();
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._maybeAddAuxComment();
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this._maybePrintInnerComments();
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._maybeAddAuxComment();
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0)
          return;
        if (!force) {
          if (this.format.retainLines || this.format.compact)
            return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2)
          i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc)
          return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc)
          return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      withSource(prop, loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp(prop, loc);
        this._buf.withSource(prop, loc, cb);
      }
      sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName)
          return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _append(str, maybeNewline) {
        this._maybeAddParen(str);
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _appendChar(char) {
        this._maybeAddParenChar(char);
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _queue(char) {
        this._maybeAddParenChar(char);
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      _maybeAddParenChar(char) {
        const parenPushNewlineState = this._parenPushNewlineState;
        if (!parenPushNewlineState)
          return;
        if (char === 32) {
          return;
        }
        if (char !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40);
        this.indent();
        parenPushNewlineState.printed = true;
      }
      _maybeAddParen(str) {
        const parenPushNewlineState = this._parenPushNewlineState;
        if (!parenPushNewlineState)
          return;
        const len = str.length;
        let i;
        for (i = 0; i < len && str.charCodeAt(i) === 32; i++)
          continue;
        if (i === len) {
          return;
        }
        const cha = str.charCodeAt(i);
        if (cha !== 10) {
          if (cha !== 47 || i + 1 === len) {
            this._parenPushNewlineState = null;
            return;
          }
          const chaPost = str.charCodeAt(i + 1);
          if (chaPost === 42) {
            return;
          } else if (chaPost !== 47) {
            this._parenPushNewlineState = null;
            return;
          }
        }
        this.tokenChar(40);
        this.indent();
        parenPushNewlineState.printed = true;
      }
      catchUp(line) {
        if (!this.format.retainLines)
          return;
        const count = line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        var _loc$prop;
        if (!this.format.retainLines)
          return;
        const line = loc == null || (_loc$prop = loc[prop]) == null ? void 0 : _loc$prop.line;
        if (line != null) {
          const count = line - this._buf.getCurrentLine();
          for (let i = 0; i < count; i++) {
            this._newline();
          }
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node2, parent, isLabel) {
        if (isLabel) {
          this._noLineTerminator = true;
          this.print(node2, parent);
        } else {
          const terminatorState = {
            printed: false
          };
          this._parenPushNewlineState = terminatorState;
          this.print(node2, parent);
          if (terminatorState.printed) {
            this.dedent();
            this.newline();
            this.tokenChar(41);
          }
        }
      }
      print(node2, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
        var _node$extra, _node$leadingComments;
        if (!node2)
          return;
        this._endsWithInnerRaw = false;
        const nodeType = node2.type;
        const format = this.format;
        const oldConcise = format.concise;
        if (node2._compact) {
          format.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node2.constructor.name)}`);
        }
        this._printStack.push(node2);
        const oldInAux = this._insideAux;
        this._insideAux = node2.loc == void 0;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node2.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = forceParens || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node2, parent, this._printStack);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node2.leadingComments) != null && _node$leadingComments.length && node2.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node2)
                break;
            default:
              shouldPrintParens = true;
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          this._endsWithInnerRaw = false;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node2, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node2.loc;
        this.exactSource(loc, printMethod.bind(this, node2, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node2, parent);
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node2, parent);
        } else {
          this._printTrailingComments(node2, parent, trailingCommentsLineOffset);
        }
        this._printStack.pop();
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode)
          this._printAuxBeforeComment();
        if (!this._insideAux)
          this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode)
          return;
        this._printAuxAfterOnNextUserNode = true;
        const comment2 = this.format.auxiliaryCommentBefore;
        if (comment2) {
          this._printComment({
            type: "CommentBlock",
            value: comment2
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode)
          return;
        this._printAuxAfterOnNextUserNode = false;
        const comment2 = this.format.auxiliaryCommentAfter;
        if (comment2) {
          this._printComment({
            type: "CommentBlock",
            value: comment2
          }, 0);
        }
      }
      getPossibleRaw(node2) {
        const extra = node2.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node2.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, parent, opts = {}) {
        if (!(nodes != null && nodes.length))
          return;
        let {
          indent: indent2
        } = opts;
        if (indent2 == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent2 = true;
          }
        }
        if (indent2)
          this.indent();
        const newlineOpts = {
          addNewlines: opts.addNewlines,
          nextNodeStartLine: 0
        };
        const separator = opts.separator ? opts.separator.bind(this) : null;
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node2 = nodes[i];
          if (!node2)
            continue;
          if (opts.statement)
            this._printNewline(i === 0, newlineOpts);
          this.print(node2, parent, void 0, opts.trailingCommentsLineOffset || 0);
          opts.iterator == null || opts.iterator(node2, i);
          if (i < len - 1)
            separator == null || separator();
          if (opts.statement) {
            var _node$trailingComment;
            if (!((_node$trailingComment = node2.trailingComments) != null && _node$trailingComment.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent2)
          this.dedent();
      }
      printAndIndentOnComments(node2, parent) {
        const indent2 = node2.leadingComments && node2.leadingComments.length > 0;
        if (indent2)
          this.indent();
        this.print(node2, parent);
        if (indent2)
          this.dedent();
      }
      printBlock(parent) {
        const node2 = parent.body;
        if (node2.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node2, parent);
      }
      _printTrailingComments(node2, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node2;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node2, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node2, parent, lineOffset);
        }
      }
      _printLeadingComments(node2, parent) {
        const comments = node2.leadingComments;
        if (!(comments != null && comments.length))
          return;
        this._printComments(0, comments, node2, parent);
      }
      _maybePrintInnerComments() {
        if (this._endsWithInnerRaw)
          this.printInnerComments();
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments() {
        const node2 = this._printStack[this._printStack.length - 1];
        const comments = node2.innerComments;
        if (!(comments != null && comments.length))
          return;
        const hasSpace = this.endsWith(32);
        const indent2 = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent2)
          this.indent();
        this._printComments(1, comments, node2);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent2)
          this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, parent, opts = {}) {
        var _opts$indent;
        opts.statement = true;
        (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;
        this.printJoin(nodes, parent, opts);
      }
      printList(items, parent, opts = {}) {
        if (opts.separator == null) {
          opts.separator = commaSeparator;
        }
        this.printJoin(items, parent, opts);
      }
      _printNewline(newLine, opts) {
        const format = this.format;
        if (format.retainLines || format.compact)
          return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset2 = startLine - lastCommentLine;
          if (offset2 >= 0) {
            this.newline(offset2 || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment2) {
        if (comment2.ignore)
          return 0;
        if (this._printedComments.has(comment2))
          return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment2.value)) {
          return 2;
        }
        this._printedComments.add(comment2);
        if (!this.format.shouldPrintComment(comment2.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment2, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment2.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          const {
            _parenPushNewlineState
          } = this;
          if ((_parenPushNewlineState == null ? void 0 : _parenPushNewlineState.printed) === false && HAS_NEWLINE.test(comment2.value)) {
            this.tokenChar(40);
            this.indent();
            _parenPushNewlineState.printed = true;
          }
          val = `/*${comment2.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset2 = (_comment$loc = comment2.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset2) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset2 + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment2.value}`;
        } else {
          val = `/*${comment2.value}*/`;
        }
        if (this.endsWith(47))
          this._space();
        this.source("start", comment2.loc);
        this._append(val, isBlockComment);
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node2, parent, lineOffset = 0) {
        const nodeLoc = node2.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment2 = comments[i];
          const shouldPrint = this._shouldPrintComment(comment2);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment2.loc && shouldPrint === 1) {
            const commentStartLine = comment2.loc.start.line;
            const commentEndLine = comment2.loc.end.line;
            if (type === 0) {
              let offset2 = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment2.type === "CommentLine" || commentStartLine != commentEndLine)) {
                  offset2 = leadingCommentNewline = 1;
                }
              } else {
                offset2 = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset2);
              this._printComment(comment2, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset2 = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset2);
              this._printComment(comment2, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset2 = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset2);
              this._printComment(comment2, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment2.loc ? comment2.loc.start.line === comment2.loc.end.line : !HAS_NEWLINE.test(comment2.value);
              const shouldSkipNewline = singleLine && !isStatement(node2) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
              if (type === 0) {
                this._printComment(comment2, shouldSkipNewline && node2.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node2
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment2, 1);
              } else {
                this._printComment(comment2, 0);
              }
            } else if (type === 1 && !(node2.type === "ObjectExpression" && node2.properties.length > 1) && node2.type !== "ClassBody" && node2.type !== "TSInterfaceBody") {
              this._printComment(comment2, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment2, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      Printer.prototype.Noop = function Noop() {
      };
    }
    var _default = exports.default = Printer;
    function commaSeparator() {
      this.tokenChar(44);
      this.space();
    }
  }
});

// node_modules/@babel/generator/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/generator/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = generate2;
    var _sourceMap = require_source_map();
    var _printer = require_printer();
    function normalizeOptions(code2, opts) {
      var _opts$recordAndTupleS;
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        recordAndTupleSyntaxType: (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash",
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
        format.jsescOption.json = opts.jsonCompatibleStrings;
      }
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
      }
      if (format.compact === "auto") {
        format.compact = typeof code2 === "string" && code2.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    {
      exports.CodeGenerator = class CodeGenerator {
        constructor(ast, opts = {}, code2) {
          this._ast = void 0;
          this._format = void 0;
          this._map = void 0;
          this._ast = ast;
          this._format = normalizeOptions(code2, opts);
          this._map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null;
        }
        generate() {
          const printer = new _printer.default(this._format, this._map);
          return printer.generate(this._ast);
        }
      };
    }
    function generate2(ast, opts = {}, code2) {
      const format = normalizeOptions(code2, opts);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null;
      const printer = new _printer.default(format, map);
      return printer.generate(ast);
    }
  }
});

// node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/@babel/traverse/lib/path/ancestry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.find = find2;
    exports.findParent = findParent;
    exports.getAncestry = getAncestry;
    exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports.getFunctionParent = getFunctionParent;
    exports.getStatementParent = getStatementParent;
    exports.inType = inType;
    exports.isAncestor = isAncestor;
    exports.isDescendant = isDescendant;
    var _t = require_lib3();
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path = this;
      while (path = path.parentPath) {
        if (callback(path))
          return path;
      }
      return null;
    }
    function find2(callback) {
      let path = this;
      do {
        if (callback(path))
          return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys2 = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          const earliestKeyIndex = keys2.indexOf(earliest.parentKey);
          const currentKeyIndex = keys2.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path) => {
        const ancestry = [];
        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop:
        for (let i = 0; i < minDepth; i++) {
          const shouldMatch = first[i];
          for (const ancestry of ancestries) {
            if (ancestry[i] !== shouldMatch) {
              break depthLoop;
            }
          }
          lastCommonIndex = i;
          lastCommon = shouldMatch;
        }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path = this;
      const paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      while (path) {
        for (const type of candidateTypes) {
          if (path.node.type === type)
            return true;
        }
        path = path.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createUnionType = createUnionType;
    var _t = require_lib3();
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType
    } = _t;
    function createUnionType(types2) {
      {
        if (isFlowType(types2[0])) {
          if (createFlowUnionType) {
            return createFlowUnionType(types2);
          }
          return createUnionTypeAnnotation(types2);
        } else {
          if (createTSUnionType) {
            return createTSUnionType(types2);
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    var _t = require_lib3();
    var _util = require_util();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node2) {
      if (!this.isReferenced())
        return;
      const binding = this.scope.getBinding(node2.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node2.name);
        }
      }
      if (node2.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node2.name === "NaN" || node2.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node2.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name2) {
      const types2 = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path, name2);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => testConstantViolations.indexOf(path2) < 0);
        types2.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types2.push(violation.getTypeAnnotation());
        }
      }
      if (!types2.length) {
        return;
      }
      return (0, _util.createUnionType)(types2);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown")
          functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name2, path) {
      const operator = path.node.operator;
      const right = path.get("right").resolve();
      const left = path.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name: name2
      })) {
        target = right;
      } else if (right.isIdentifier({
        name: name2
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==")
        return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath)
        return;
      if (!typeofPath.get("argument").isIdentifier({
        name: name2
      }))
        return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral())
        return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string")
        return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name2) {
      let parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name2) !== binding)
            return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name2) {
      const ifStatement = getParentConditionalPath(binding, path, name2);
      if (!ifStatement)
        return;
      const test = ifStatement.get("test");
      const paths = [test];
      const types2 = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name2, path2);
          if (type)
            types2.push(type);
        }
      }
      if (types2.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types2),
          ifStatement
        };
      }
      return getConditionalAnnotation(binding, ifStatement, name2);
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrayExpression = ArrayExpression2;
    exports.AssignmentExpression = AssignmentExpression;
    exports.BinaryExpression = BinaryExpression2;
    exports.BooleanLiteral = BooleanLiteral;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports.LogicalExpression = LogicalExpression;
    exports.NewExpression = NewExpression;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.RestElement = RestElement2;
    exports.SequenceExpression = SequenceExpression;
    exports.StringLiteral = StringLiteral;
    exports.TSAsExpression = TSAsExpression;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.TypeCastExpression = TypeCastExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.VariableDeclarator = VariableDeclarator;
    var _t = require_lib3();
    var _infererReference = require_inferer_reference();
    var _util = require_util();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier: isIdentifier2
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier())
        return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node2) {
      return node2.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node2) {
      return node2.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node2) {
      if (node2.callee.type === "Identifier") {
        return genericTypeAnnotation(node2.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node2) {
      const operator = node2.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression2(node2) {
      const operator = node2.operator;
      if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node2) {
      const operator = node2.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression2() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement2() {
      return ArrayExpression2();
    }
    RestElement2.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier2(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node: node2
        } = callee;
        if (node2.async) {
          if (node2.generator) {
            return genericTypeAnnotation(identifier("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier("Promise"));
          }
        } else {
          if (node2.generator) {
            return genericTypeAnnotation(identifier("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._getTypeAnnotation = _getTypeAnnotation;
    exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports.couldBeBaseType = couldBeBaseType;
    exports.getTypeAnnotation = getTypeAnnotation;
    exports.isBaseType = isBaseType;
    exports.isGenericType = isGenericType;
    var inferers = require_inferers();
    var _t = require_lib3();
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier: isIdentifier2,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = this._getTypeAnnotation() || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node2 = this.node;
      if (!node2) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node2.typeAnnotation) {
        return node2.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node2)) {
        return;
      }
      typeAnnotationInferringNodes.add(node2);
      try {
        var _inferer;
        let inferer = inferers[node2.type];
        if (inferer) {
          return inferer.call(this, node2);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node2);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name2) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type))
        return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name2, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name2, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier2(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier2(type.typeName, {
        name: genericName
      });
    }
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert2 = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert2) {
      if (convert2.hasOwnProperty(model)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert2[model].channels;
        labels = convert2[model].labels;
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert2.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert2.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert2.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      var xyz = convert2.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t2 = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t2, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t2];
        case 3:
          return [p, q, v];
        case 4:
          return [t2, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert2.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert2.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert2.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      var color3 = args % 10;
      if (color3 === 0 || color3 === 7) {
        if (args > 50) {
          color3 += 3.5;
        }
        color3 = color3 / 10.5 * 255;
        return [color3, color3, color3];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color3 & 1) * mult * 255;
      var g = (color3 >> 1 & 1) * mult * 255;
      var b = (color3 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert2.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert2.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = convert2.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert2.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current2 = queue.pop();
        var adjacents = Object.keys(conversions[current2]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current2].distance + 1;
            node2.parent = current2;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link2(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link2(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert2;
  }
});

// node_modules/chalk/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/chalk/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset2) => function() {
      const code2 = fn.apply(colorConvert, arguments);
      return `\x1B[${code2 + offset2}m`;
    };
    var wrapAnsi256 = (fn, offset2) => function() {
      const code2 = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset2};5;${code2}m`;
    };
    var wrapAnsi16m = (fn, offset2) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/chalk/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/chalk/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/chalk/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/chalk/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag2();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name2, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
        }
      }
      return results;
    }
    function parseStyle2(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name2 = matches[1];
        if (matches[2]) {
          const args = parseArguments(name2, matches[2]);
          results.push([name2].concat(args));
        } else {
          results.push([name2]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current2 = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current2)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current2 = current2[styleName].apply(current2, enabled[styleName]);
          } else {
            current2 = current2[styleName];
          }
        }
      }
      return current2;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle2(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color2().stdout;
    var template2 = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code2 of this._styles.slice().reverse()) {
        str = code2.open + str.replace(code2.closeRe, code2.open) + code2.close;
        str = str.replace(/\r?\n/g, `${code2.close}$&${code2.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template2(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib();
    var _chalk = _interopRequireWildcard(require_chalk(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t2 : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t2 = _getRequireWildcardCache(r);
      if (t2 && t2.has(e))
        return t2.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t2 && t2.set(e, n), n;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset2, text5) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text5[offset2 - 1] === "<" || text5.slice(offset2 - 2, offset2) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text5) {
        let match;
        while (match = _jsTokens.default.exec(text5)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text5),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text5) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text5)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return _chalk.default.level > 0 || options.forceColor;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({
          enabled: true,
          level: 1
        });
        return chalkWithForcedColor;
      }
      return _chalk.default;
    }
    {
      exports.getChalk = (options) => getChalk(options.forceColor);
    }
    function highlight(code2, options = {}) {
      if (code2 !== "" && shouldHighlight(options)) {
        const defs = getDefs(getChalk(options.forceColor));
        return highlightTokens(defs, code2);
      } else {
        return code2;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;
    var _highlight = require_lib7();
    var _chalk = _interopRequireWildcard(require_chalk(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t2 : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t2 = _getRequireWildcardCache(r);
      if (t2 && t2.has(e))
        return t2.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t2 && t2.set(e, n), n;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({
          enabled: true,
          level: 1
        });
        return chalkWithForcedColor;
      }
      return _chalk.default;
    }
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start2 = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start2 = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start: start2,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = getChalk(opts.forceColor);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string3) => {
        return highlighted ? chalkFn(string3) : string3;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start: start2,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start2, end).map((line, index2) => {
        const number2 = start2 + 1 + index2;
        const paddedNumber = ` ${number2}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number2];
        const lastMarkerLine = !markerLines[number2 + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/@babel/parser/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Position3 = class {
      constructor(line, col, index2) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index2;
      }
    };
    var SourceLocation3 = class {
      constructor(start2, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start2;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position3, columnOffset) {
      const {
        line,
        column,
        index: index2
      } = position3;
      return new Position3(line, column + columnOffset, index2 + columnOffset);
    }
    var code2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: code2
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: code2
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = ({
      type,
      prefix: prefix2
    }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: ({
        maxArgumentCount
      }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = {
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`,
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    };
    var _excluded$1 = ["toMessage"];
    var _excluded2$1 = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor(_ref) {
      let {
        toMessage
      } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
      return function constructor({
        loc,
        details
      }) {
        const error = new SyntaxError();
        Object.assign(error, properties, {
          loc,
          pos: loc.index
        });
        if ("missingPlugin" in details) {
          Object.assign(error, {
            missingPlugin: details.missingPlugin
          });
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index: index2
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor({
            loc: new Position3(line, column, index2),
            details: Object.assign({}, details, overrides.details)
          });
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template2 = argument[reasonCode];
        const _ref2 = typeof template2 === "string" ? {
          message: () => template2
        } : typeof template2 === "function" ? {
          message: template2
        } : template2, {
          message
        } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => defineProperty(object, key, {
      enumerable: false,
      value: object[key]
    });
    function toESTreeLocation(node2) {
      node2.loc.start && toUnenumerable(node2.loc.start, "index");
      node2.loc.end && toUnenumerable(node2.loc.end, "index");
      return node2;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.options.tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex2 = null;
        try {
          regex2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        const node2 = this.estreeParseLiteral(regex2);
        node2.regex = {
          pattern,
          flags
        };
        return node2;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node2 = this.estreeParseLiteral(bigInt);
        node2.bigint = String(node2.value || value);
        return node2;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node2 = this.estreeParseLiteral(decimal);
        node2.decimal = String(node2.value || value);
        return node2;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node2, isAsync) {
        super.initFunction(node2, isAsync);
        node2.expression = false;
      }
      checkDeclaration(node2) {
        if (node2 != null && this.isObjectProperty(node2)) {
          this.checkDeclaration(node2.value);
        } else {
          super.checkDeclaration(node2);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
        node2.body = directiveStatements.concat(node2.body);
        delete node2.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parsePrivateName() {
        const node2 = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node2;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node2);
      }
      convertPrivateNameToPrivateIdentifier(node2) {
        const name2 = super.getPrivateNameSV(node2);
        node2 = node2;
        delete node2.id;
        node2.name = name2;
        node2.type = "PrivateIdentifier";
        return node2;
      }
      isPrivateName(node2) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node2);
          }
        }
        return node2.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node2) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node2);
          }
        }
        return node2.name;
      }
      parseLiteral(value, type) {
        const node2 = super.parseLiteral(value, type);
        node2.raw = node2.extra.raw;
        delete node2.extra;
        return node2;
      }
      parseFunctionBody(node2, allowExpression, isMethod = false) {
        super.parseFunctionBody(node2, allowExpression, isMethod);
        node2.expression = node2.body.type !== "BlockStatement";
      }
      parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node2.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node2.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node2.computed = false;
        }
        return this.finishNode(node2, "MethodDefinition");
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node2 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node2) {
          node2.type = "Property";
          if (node2.kind === "method") {
            node2.kind = "init";
          }
          node2.shorthand = false;
        }
        return node2;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node2 = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node2) {
          node2.kind = "init";
          node2.type = "Property";
        }
        return node2;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node2, isBinding) {
        if (node2 != null && this.isObjectProperty(node2)) {
          return this.isAssignable(node2.value, isBinding);
        }
        return super.isAssignable(node2, isBinding);
      }
      toAssignable(node2, isLHS = false) {
        if (node2 != null && this.isObjectProperty(node2)) {
          const {
            key,
            value
          } = node2;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node2, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(Errors.PatternHasAccessor, {
            at: prop.key
          });
        } else if (prop.method) {
          this.raise(Errors.PatternHasMethod, {
            at: prop.key
          });
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node2 = super.finishCallExpression(unfinished, optional);
        if (node2.callee.type === "Import") {
          node2.type = "ImportExpression";
          node2.source = node2.arguments[0];
          if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
            var _node$arguments$, _node$arguments$2;
            node2.options = (_node$arguments$ = node2.arguments[1]) != null ? _node$arguments$ : null;
            node2.attributes = (_node$arguments$2 = node2.arguments[1]) != null ? _node$arguments$2 : null;
          }
          delete node2.arguments;
          delete node2.callee;
        }
        return node2;
      }
      toReferencedArguments(node2) {
        if (node2.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node2);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node2 = super.parseExport(unfinished, decorators);
        switch (node2.type) {
          case "ExportAllDeclaration":
            node2.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
              node2.type = "ExportAllDeclaration";
              node2.exported = node2.specifiers[0].exported;
              delete node2.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node2;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node2.start) {
                this.resetStartLocation(node2, exportStartLoc);
              }
            }
            break;
        }
        return node2;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node2 = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
            node2.type = node2.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node2);
            chain.expression = node2;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
          node2.optional = false;
        }
        return node2;
      }
      isOptionalMemberExpression(node2) {
        if (node2.type === "ChainExpression") {
          return node2.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node2);
      }
      hasPropertyAsPrivateName(node2) {
        if (node2.type === "ChainExpression") {
          node2 = node2.expression;
        }
        return super.hasPropertyAsPrivateName(node2);
      }
      isObjectProperty(node2) {
        return node2.type === "Property" && node2.kind === "init" && !node2.method;
      }
      isObjectMethod(node2) {
        return node2.method || node2.kind === "get" || node2.kind === "set";
      }
      finishNodeAt(node2, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node2, type, endLoc));
      }
      resetStartLocation(node2, startLoc) {
        super.resetStartLocation(node2, startLoc);
        toESTreeLocation(node2);
      }
      resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node2, endLoc);
        toESTreeLocation(node2);
      }
    };
    var TokContext3 = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types2 = {
      brace: new TokContext3("{"),
      j_oTag: new TokContext3("<tag"),
      j_cTag: new TokContext3("</tag"),
      j_expr: new TokContext3("<tag>...</tag>", true)
    };
    {
      types2.template = new TokContext3("`", true);
    }
    var beforeExpr2 = true;
    var startsExpr2 = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$12 = /* @__PURE__ */ new Map();
    function createKeyword(name2, options = {}) {
      options.keyword = name2;
      const token = createToken(name2, options);
      keywords$12.set(name2, token);
      return token;
    }
    function createBinop(name2, binop2) {
      return createToken(name2, {
        beforeExpr: beforeExpr2,
        binop: binop2
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name2, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name2);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name2, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name2, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$12.set(name2, tokenTypeCounter);
      tokenLabels.push(name2);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketHashL: createToken("#[", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketBarL: createToken("[|", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceBarL: createToken("{|", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceHashL: createToken("#{", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr: beforeExpr2
      }),
      semi: createToken(";", {
        beforeExpr: beforeExpr2
      }),
      colon: createToken(":", {
        beforeExpr: beforeExpr2
      }),
      doubleColon: createToken("::", {
        beforeExpr: beforeExpr2
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr: beforeExpr2
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr: beforeExpr2
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr: beforeExpr2
      }),
      backQuote: createToken("`", {
        startsExpr: startsExpr2
      }),
      dollarBraceL: createToken("${", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      templateTail: createToken("...`", {
        startsExpr: startsExpr2
      }),
      templateNonTail: createToken("...${", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr: startsExpr2
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr: beforeExpr2,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr: startsExpr2
      }),
      bang: createToken("!", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      tilde: createToken("~", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      doubleCaret: createToken("^^", {
        startsExpr: startsExpr2
      }),
      doubleAt: createToken("@@", {
        startsExpr: startsExpr2
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr: beforeExpr2,
        binop: 9,
        prefix,
        startsExpr: startsExpr2
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr: startsExpr2
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr: beforeExpr2,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr: beforeExpr2,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr: beforeExpr2,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr: beforeExpr2
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr: beforeExpr2
      }),
      _else: createKeyword("else", {
        beforeExpr: beforeExpr2
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr: startsExpr2
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr: beforeExpr2
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr: beforeExpr2,
        startsExpr: startsExpr2
      }),
      _this: createKeyword("this", {
        startsExpr: startsExpr2
      }),
      _super: createKeyword("super", {
        startsExpr: startsExpr2
      }),
      _class: createKeyword("class", {
        startsExpr: startsExpr2
      }),
      _extends: createKeyword("extends", {
        beforeExpr: beforeExpr2
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr: startsExpr2
      }),
      _null: createKeyword("null", {
        startsExpr: startsExpr2
      }),
      _true: createKeyword("true", {
        startsExpr: startsExpr2
      }),
      _false: createKeyword("false", {
        startsExpr: startsExpr2
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _void: createKeyword("void", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _delete: createKeyword("delete", {
        beforeExpr: beforeExpr2,
        prefix,
        startsExpr: startsExpr2
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr: beforeExpr2
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr: startsExpr2
      }),
      _assert: createKeywordLike("assert", {
        startsExpr: startsExpr2
      }),
      _async: createKeywordLike("async", {
        startsExpr: startsExpr2
      }),
      _await: createKeywordLike("await", {
        startsExpr: startsExpr2
      }),
      _defer: createKeywordLike("defer", {
        startsExpr: startsExpr2
      }),
      _from: createKeywordLike("from", {
        startsExpr: startsExpr2
      }),
      _get: createKeywordLike("get", {
        startsExpr: startsExpr2
      }),
      _let: createKeywordLike("let", {
        startsExpr: startsExpr2
      }),
      _meta: createKeywordLike("meta", {
        startsExpr: startsExpr2
      }),
      _of: createKeywordLike("of", {
        startsExpr: startsExpr2
      }),
      _sent: createKeywordLike("sent", {
        startsExpr: startsExpr2
      }),
      _set: createKeywordLike("set", {
        startsExpr: startsExpr2
      }),
      _source: createKeywordLike("source", {
        startsExpr: startsExpr2
      }),
      _static: createKeywordLike("static", {
        startsExpr: startsExpr2
      }),
      _using: createKeywordLike("using", {
        startsExpr: startsExpr2
      }),
      _yield: createKeywordLike("yield", {
        startsExpr: startsExpr2
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr: startsExpr2
      }),
      _checks: createKeywordLike("checks", {
        startsExpr: startsExpr2
      }),
      _exports: createKeywordLike("exports", {
        startsExpr: startsExpr2
      }),
      _global: createKeywordLike("global", {
        startsExpr: startsExpr2
      }),
      _implements: createKeywordLike("implements", {
        startsExpr: startsExpr2
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr: startsExpr2
      }),
      _infer: createKeywordLike("infer", {
        startsExpr: startsExpr2
      }),
      _is: createKeywordLike("is", {
        startsExpr: startsExpr2
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr: startsExpr2
      }),
      _proto: createKeywordLike("proto", {
        startsExpr: startsExpr2
      }),
      _require: createKeywordLike("require", {
        startsExpr: startsExpr2
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr: startsExpr2
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr: startsExpr2
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr: startsExpr2
      }),
      _unique: createKeywordLike("unique", {
        startsExpr: startsExpr2
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr: startsExpr2
      }),
      _declare: createKeywordLike("declare", {
        startsExpr: startsExpr2
      }),
      _enum: createKeywordLike("enum", {
        startsExpr: startsExpr2
      }),
      _module: createKeywordLike("module", {
        startsExpr: startsExpr2
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr: startsExpr2
      }),
      _interface: createKeywordLike("interface", {
        startsExpr: startsExpr2
      }),
      _type: createKeywordLike("type", {
        startsExpr: startsExpr2
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr: startsExpr2
      }),
      name: createToken("name", {
        startsExpr: startsExpr2
      }),
      string: createToken("string", {
        startsExpr: startsExpr2
      }),
      num: createToken("num", {
        startsExpr: startsExpr2
      }),
      bigint: createToken("bigint", {
        startsExpr: startsExpr2
      }),
      decimal: createToken("decimal", {
        startsExpr: startsExpr2
      }),
      regexp: createToken("regexp", {
        startsExpr: startsExpr2
      }),
      privateName: createToken("#name", {
        startsExpr: startsExpr2
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 132;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 132;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 136;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types2.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types2.template) {
          context.pop();
        } else {
          context.push(types2.template);
        }
      };
      tokenTypes[142].updateContext = (context) => {
        context.push(types2.j_expr, types2.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
    var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
    nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
    var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet2(code3, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code3)
          return false;
        pos += set[i + 1];
        if (pos >= code3)
          return true;
      }
      return false;
    }
    function isIdentifierStart2(code3) {
      if (code3 < 65)
        return code3 === 36;
      if (code3 <= 90)
        return true;
      if (code3 < 97)
        return code3 === 95;
      if (code3 <= 122)
        return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code3));
      }
      return isInAstralSet2(code3, astralIdentifierStartCodes2);
    }
    function isIdentifierChar2(code3) {
      if (code3 < 48)
        return code3 === 36;
      if (code3 < 58)
        return true;
      if (code3 < 65)
        return false;
      if (code3 <= 90)
        return true;
      if (code3 < 97)
        return code3 === 95;
      if (code3 <= 122)
        return true;
      if (code3 <= 65535) {
        return code3 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code3));
      }
      return isInAstralSet2(code3, astralIdentifierStartCodes2) || isInAstralSet2(code3, astralIdentifierCodes2);
    }
    var reservedWords2 = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords2.keyword);
    var reservedWordsStrictSet = new Set(reservedWords2.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords2.has(word);
    }
    function isIteratorStart(current2, next, next2) {
      return current2 === 64 && next === 64 && isIdentifierStart2(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope4 = class {
      constructor(flags) {
        this.var = /* @__PURE__ */ new Set();
        this.lexical = /* @__PURE__ */ new Set();
        this.functions = /* @__PURE__ */ new Set();
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope4(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name2, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name2, bindingType, loc);
          if (bindingType & 16) {
            scope.functions.add(name2);
          } else {
            scope.lexical.add(name2);
          }
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name2);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name2, bindingType, loc);
            scope.var.add(name2);
            this.maybeExportDefined(scope, name2);
            if (scope.flags & 387)
              break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name2);
        }
      }
      maybeExportDefined(scope, name2) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name2);
        }
      }
      checkRedeclarationInScope(scope, name2, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name2, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name2
          });
        }
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        if (!(bindingType & 1))
          return false;
        if (bindingType & 8) {
          return scope.lexical.has(name2) || scope.functions.has(name2) || scope.var.has(name2);
        }
        if (bindingType & 16) {
          return scope.lexical.has(name2) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name2);
        }
        return scope.lexical.has(name2) && !(scope.flags & 8 && scope.lexical.values().next().value === name2) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name2);
      }
      checkLocalExport(id) {
        const {
          name: name2
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name2) && !topLevelScope.var.has(name2) && !topLevelScope.functions.has(name2)) {
          this.undefinedExports.set(name2, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope4 {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name2, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name2, bindingType, loc);
          this.maybeExportDefined(scope, name2);
          scope.declareFunctions.add(name2);
          return;
        }
        super.declareName(name2, bindingType, loc);
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        if (super.isRedeclaredInScope(scope, name2, bindingType))
          return true;
        if (bindingType & 2048) {
          return !scope.declareFunctions.has(name2) && (scope.lexical.has(name2) || scope.functions.has(name2));
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin2, name2) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin2)) == null ? void 0 : _this$plugins$get[name2];
      }
    };
    function setTrailingComments(node2, comments) {
      if (node2.trailingComments === void 0) {
        node2.trailingComments = comments;
      } else {
        node2.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node2, comments) {
      if (node2.leadingComments === void 0) {
        node2.leadingComments = comments;
      } else {
        node2.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node2, comments) {
      if (node2.innerComments === void 0) {
        node2.innerComments = comments;
      } else {
        node2.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node2, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node2, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment2) {
        if (this.filename)
          comment2.loc.filename = this.filename;
        this.state.comments.push(comment2);
      }
      processComment(node2) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node2.end) {
          lastCommentWS.leadingNode = node2;
          i--;
        }
        const {
          start: nodeStart
        } = node2;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node2;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node2;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node2,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node2.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node2, node2.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node2, node2.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node2, node2.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node2, node2.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node2, node2.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node2, comments);
              }
            }
          } else {
            setInnerComments(node2, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node2) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node2) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node2) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        if (commentStack[length - 1].trailingNode === node2) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node2) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node2, start2, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node2;
          } else if (commentEnd === start2) {
            commentWS.trailingNode = node2;
          } else if (commentEnd < start2) {
            break;
          }
        }
      }
    };
    var lineBreak2 = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG2 = new RegExp(lineBreak2.source, "g");
    function isNewLine2(code3) {
      switch (code3) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(code3) {
      switch (code3) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State2 = class {
      constructor() {
        this.strict = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inDisallowConditionalTypesContext = false;
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.type = 139;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.context = [types2.brace];
        this.canStartJSXElement = true;
        this.containsEsc = false;
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      init({
        strictMode,
        sourceType,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position3(startLine, startColumn, 0);
      }
      curPosition() {
        return new Position3(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone(skipArrays) {
        const state = new State2();
        const keys2 = Object.keys(this);
        for (let i = 0, length = keys2.length; i < length; i++) {
          const key = keys2[i];
          let val = this[key];
          if (!skipArrays && Array.isArray(val)) {
            val = val.slice();
          }
          state[key] = val;
        }
        return state;
      }
    };
    var _isDigit = function isDigit(code3) {
      return code3 >= 48 && code3 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code3;
          ({
            code: code3,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCharCode(code3));
        }
        case 117: {
          let code3;
          ({
            code: code3,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code3 === null ? null : String.fromCodePoint(code3));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start2 = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid2 = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code3 = input.charCodeAt(pos);
        let val;
        if (code3 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code3 >= 97) {
          val = code3 - 97 + 10;
        } else if (code3 >= 65) {
          val = code3 - 65 + 10;
        } else if (_isDigit(code3)) {
          val = code3 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid2 = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start2 || len != null && pos - start2 !== len || invalid2) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code3;
      if (ch === 123) {
        ++pos;
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code3 !== null && code3 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code3,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code3,
        pos
      };
    }
    var _excluded = ["at"];
    var _excluded2 = ["at"];
    function buildPosition(pos, lineStart, curLine) {
      return new Position3(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token3 = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation3(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!this.options.errorRecovery)
              return false;
            this.raise(Errors.InvalidDigit, {
              at: buildPosition(pos, lineStart, curLine),
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, {
              at: buildPosition(pos, lineStart, curLine)
            });
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, {
              at: buildPosition(pos - 1, lineStart, curLine)
            });
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, {
              at: buildPosition(pos, lineStart, curLine)
            });
          }
        });
        this.state = new State2();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token3(this.state));
        }
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace2.lastIndex = pos;
        return skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at2]) => this.raise(toParseError, {
            at: at2
          }));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead)
          this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(139);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        const start2 = this.state.pos;
        const end = this.input.indexOf(commentEnd, start2 + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG2.lastIndex = start2 + 2;
        while (lineBreakG2.test(this.input) && lineBreakG2.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG2.lastIndex;
        }
        if (this.isLookahead)
          return;
        const comment2 = {
          type: "CommentBlock",
          value: this.input.slice(start2 + 2, end),
          start: start2,
          end: end + commentEnd.length,
          loc: new SourceLocation3(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment2);
        return comment2;
      }
      skipLineComment(startSkip) {
        const start2 = this.state.pos;
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine2(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead)
          return;
        const end = this.state.pos;
        const value = this.input.slice(start2 + startSkip, end);
        const comment2 = {
          type: "CommentLine",
          value,
          start: start2,
          end,
          loc: new SourceLocation3(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment2);
        return comment2;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop:
          while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment2 = this.skipBlockComment("*/");
                    if (comment2 !== void 0) {
                      this.addComment(comment2);
                      if (this.options.attachComment)
                        comments.push(comment2);
                    }
                    break;
                  }
                  case 47: {
                    const comment2 = this.skipLineComment(2);
                    if (comment2 !== void 0) {
                      this.addComment(comment2);
                      if (this.options.attachComment)
                        comments.push(comment2);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule && this.options.annexB) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment2 = this.skipLineComment(3);
                    if (comment2 !== void 0) {
                      this.addComment(comment2);
                      if (this.options.attachComment)
                        comments.push(comment2);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule && this.options.annexB) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment2 = this.skipLineComment(4);
                    if (comment2 !== void 0) {
                      this.addComment(comment2);
                      if (this.options.attachComment)
                        comments.push(comment2);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
        if (comments.length > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, {
            at: this.state.curPosition()
          });
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart2(next)) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
          return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33)
          return false;
        const start2 = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine2(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start2 + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code3) {
        let type = code3 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code3 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code3 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code3 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code3 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code3 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code3 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code3) {
        switch (code3) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code3);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code3);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code3);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code3);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code3);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart2(code3)) {
              this.readWord(code3);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: String.fromCodePoint(code3)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start2 = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine2(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content3 = this.input.slice(start2, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start2);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, {
                at: nextPos()
              });
            }
          } else if (isIdentifierChar2(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, {
              at: nextPos()
            });
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(137, {
          pattern: content3,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, {
            at: createPositionWithColumnOffset(startLoc, 2),
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, {
            at: startLoc
          });
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        if (isBigInt) {
          const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(135, str);
          return;
        }
        this.finishToken(134, val);
      }
      readNumber(startsWithDot) {
        const start2 = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal2 = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, {
            at: this.state.curPosition()
          });
        }
        const hasLeadingZero = this.state.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start2, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
            at: startLoc
          });
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, {
                at: createPositionWithColumnOffset(startLoc, underscorePos)
              });
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, {
              at: startLoc
            });
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isDecimal2 = true;
        }
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        const str = this.input.slice(start2, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(135, str);
          return;
        }
        if (isDecimal2) {
          this.finishToken(136, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(134, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code3,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code3;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(133, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position3(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, {
        at: at2
      }) {
        const index2 = at2.index;
        if (this.state.strict && !this.state.strictErrors.has(index2)) {
          this.raise(toParseError, {
            at: at2
          });
        } else {
          this.state.strictErrors.set(index2, [toParseError, at2]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start2 = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar2(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start2 ? isIdentifierStart2 : isIdentifierChar2;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, {
                at: this.state.curPosition()
              });
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, {
                  at: escStart
                });
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$12.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.startLoc,
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, raiseProperties) {
        const {
          at: at2
        } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
        const loc = at2 instanceof Position3 ? at2 : at2.loc.start;
        const error = toParseError({
          loc,
          details
        });
        if (!this.options.errorRecovery)
          throw error;
        if (!this.isLookahead)
          this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, raiseProperties) {
        const {
          at: at2
        } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
        const loc = at2 instanceof Position3 ? at2 : at2.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError({
              loc,
              details
            });
          }
          if (error.loc.index < pos)
            break;
        }
        return this.raise(toParseError, raiseProperties);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, {
          expected: type ? tokenLabelName(type) : null,
          at: loc != null ? loc : this.state.startLoc
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, {
          at: loc != null ? loc : this.state.startLoc,
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name2) => this.hasPlugin(name2))) {
          throw this.raise(Errors.MissingOneOfPlugins, {
            at: this.state.startLoc,
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, {
            at: buildPosition(pos, lineStart, curLine)
          });
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current2 = this.current();
        for (const [name2, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current2) {
            if (!current2.undefinedPrivateNames.has(name2)) {
              current2.undefinedPrivateNames.set(name2, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name2
            });
          }
        }
      }
      declarePrivateName(name2, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name2);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name2);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined)
              loneAccessors.delete(name2);
          } else if (!redefined) {
            loneAccessors.set(name2, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, {
            at: loc,
            identifierName: name2
          });
        }
        privateNames.add(name2);
        undefinedPrivateNames.delete(name2);
      }
      usePrivateName(name2, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name2))
            return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name2, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name2
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, {
        at: at2
      }) {
        const index2 = at2.index;
        this.declarationErrors.set(index2, [ParsingErrorClass, at2]);
      }
      clearDeclarationError(index2) {
        this.declarationErrors.delete(index2);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, {
        at: node2
      }) {
        const origin = {
          at: node2.loc.start
        };
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, {
        at: node2
      }) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = {
          at: node2.loc.start
        };
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError({
        at: at2
      }) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
              at: at2
            });
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration())
          return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, {
            at: loc
          });
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags2(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node2, key, value, enumerable = true) {
        if (!node2)
          return;
        const extra = node2.extra = node2.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name2) {
        const nameEnd = nameStart + name2.length;
        if (this.input.slice(nameStart, nameEnd) === name2) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar2(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name2) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name2);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, {
              at: this.state.startLoc
            });
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13))
          return;
        this.raise(Errors.MissingSemicolon, {
          at: this.state.lastTokEndLoc
        });
      }
      expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node2 = fn((node3 = null) => {
            abortSignal.node = node3;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node: node2,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node: node2,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
          return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          });
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, {
            at: doubleProtoLoc
          });
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, {
            at: privateKeyLoc
          });
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node2) {
        return node2.type === "PrivateName";
      }
      getPrivateNameSV(node2) {
        return node2.id.name;
      }
      hasPropertyAsPrivateName(node2) {
        return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
      }
      isObjectProperty(node2) {
        return node2.type === "ObjectProperty";
      }
      isObjectMethod(node2) {
        return node2.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node3 = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation3(loc);
        if (parser != null && parser.options.ranges)
          this.range = [pos, 0];
        if (parser != null && parser.filename)
          this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node3.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node3(void 0, this.start, this.loc.start);
        const keys2 = Object.keys(this);
        for (let i = 0, length = keys2.length; i < length; i++) {
          const key = keys2[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node2) {
      return cloneIdentifier(node2);
    }
    function cloneIdentifier(node2) {
      const {
        type,
        start: start2,
        end,
        loc,
        range,
        extra,
        name: name2
      } = node2;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start2;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name2;
      if (type === "Placeholder") {
        cloned.expectedNode = node2.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node2) {
      const {
        type,
        start: start2,
        end,
        loc,
        range,
        extra
      } = node2;
      if (type === "Placeholder") {
        return clonePlaceholder(node2);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start2;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node2.raw !== void 0) {
        cloned.raw = node2.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node2.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        return new Node3(this, this.state.start, this.state.startLoc);
      }
      startNodeAt(loc) {
        return new Node3(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node2, type) {
        return this.finishNodeAt(node2, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node2, type, endLoc) {
        node2.type = type;
        node2.end = endLoc.index;
        node2.loc.end = endLoc;
        if (this.options.ranges)
          node2.range[1] = endLoc.index;
        if (this.options.attachComment)
          this.processComment(node2);
        return node2;
      }
      resetStartLocation(node2, startLoc) {
        node2.start = startLoc.index;
        node2.loc.start = startLoc;
        if (this.options.ranges)
          node2.range[0] = startLoc.index;
      }
      resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
        node2.end = endLoc.index;
        node2.loc.end = endLoc;
        if (this.options.ranges)
          node2.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node2, locationNode) {
        this.resetStartLocation(node2, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node2) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list3, test) {
      const list1 = [];
      const list22 = [];
      for (let i = 0; i < list3.length; i++) {
        (test(list3[i], i, list3) ? list1 : list22).push(list3[i]);
      }
      return [list1, list22];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow3 = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== 133 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment2) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment2.value);
          if (!matches)
            ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment2);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node2 = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStart > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
            at: moduloLoc
          });
        }
        if (this.eat(10)) {
          node2.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node2, "DeclaredPredicate");
        } else {
          return this.finishNode(node2, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node2) {
        this.next();
        this.flowParseInterfaceish(node2, true);
        return this.finishNode(node2, "DeclareClass");
      }
      flowParseDeclareFunction(node2) {
        this.next();
        const id = node2.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node2.id.name, 2048, node2.id.loc.start);
        return this.finishNode(node2, "DeclareFunction");
      }
      flowParseDeclare(node2, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node2);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node2);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node2);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node2);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            return this.flowParseDeclareModule(node2);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node2);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node2);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node2);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node2, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node2) {
        this.next();
        node2.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node2.id.name, 5, node2.id.loc.start);
        this.semicolon();
        return this.finishNode(node2, "DeclareVariable");
      }
      flowParseDeclareModule(node2) {
        this.scope.enter(0);
        if (this.match(133)) {
          node2.id = super.parseExprAtom();
        } else {
          node2.id = this.parseIdentifier();
        }
        const bodyNode = node2.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              });
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                at: bodyElement
              });
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              });
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node2.kind = kind || "CommonJS";
        return this.finishNode(node2, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node2, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node2.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node2.declaration = this.flowParseType();
            this.semicolon();
          }
          node2.default = true;
          return this.finishNode(node2, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
              at: this.state.startLoc,
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node2.declaration = this.flowParseDeclare(this.startNode());
            node2.default = false;
            return this.finishNode(node2, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node2 = this.parseExport(node2, null);
            if (node2.type === "ExportNamedDeclaration") {
              node2.type = "ExportDeclaration";
              node2.default = false;
              delete node2.exportKind;
            }
            node2.type = "Declare" + node2.type;
            return node2;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node2) {
        this.next();
        this.expectContextual(111);
        node2.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node2, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node2) {
        this.next();
        const finished = this.flowParseTypeAlias(node2);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node2) {
        this.next();
        const finished = this.flowParseOpaqueType(node2, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node2) {
        this.next();
        this.flowParseInterfaceish(node2, false);
        return this.finishNode(node2, "DeclareInterface");
      }
      flowParseInterfaceish(node2, isClass) {
        node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node2.id.name, isClass ? 17 : 8201, node2.id.loc.start);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node2.typeParameters = null;
        }
        node2.extends = [];
        if (this.eat(81)) {
          do {
            node2.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node2.implements = [];
          node2.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node2.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node2.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node2.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node2 = this.startNode();
        node2.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node2.typeParameters = null;
        }
        return this.finishNode(node2, "InterfaceExtends");
      }
      flowParseInterface(node2) {
        this.flowParseInterfaceish(node2, false);
        return this.finishNode(node2, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, {
            at: this.state.startLoc
          });
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word))
          return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
          at: startLoc,
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node2) {
        node2.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node2.typeParameters = null;
        }
        node2.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node2, "TypeAlias");
      }
      flowParseOpaqueType(node2, declare) {
        this.expectContextual(130);
        node2.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node2.typeParameters = null;
        }
        node2.supertype = null;
        if (this.match(14)) {
          node2.supertype = this.flowParseTypeInitialiser(14);
        }
        node2.impltype = null;
        if (!declare) {
          node2.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node2, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node2 = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node2.name = ident.name;
        node2.variance = variance;
        node2.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node2.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, {
              at: nodeStartLoc
            });
          }
        }
        return this.finishNode(node2, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node2 = this.startNode();
        node2.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node2.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node2, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node2 = this.startNode();
        const oldInType = this.state.inType;
        node2.params = [];
        this.state.inType = true;
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node2.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node2, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node2 = this.startNode();
        const oldInType = this.state.inType;
        node2.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node2.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node2, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node2 = this.startNode();
        this.expectContextual(129);
        node2.extends = [];
        if (this.eat(81)) {
          do {
            node2.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node2.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node2, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node2, isStatic, variance) {
        node2.static = isStatic;
        if (this.lookahead().type === 14) {
          node2.id = this.flowParseObjectPropertyKey();
          node2.key = this.flowParseTypeInitialiser();
        } else {
          node2.id = null;
          node2.key = this.flowParseType();
        }
        this.expect(3);
        node2.value = this.flowParseTypeInitialiser();
        node2.variance = variance;
        return this.finishNode(node2, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node2, isStatic) {
        node2.static = isStatic;
        node2.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node2.method = true;
          node2.optional = false;
          node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
        } else {
          node2.method = false;
          if (this.eat(17)) {
            node2.optional = true;
          }
          node2.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node2, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node2) {
        node2.params = [];
        node2.rest = null;
        node2.typeParameters = null;
        node2.this = null;
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node2.this = this.flowParseFunctionTypeParam(true);
          node2.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node2.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node2.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node2.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node2, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node2, isStatic) {
        const valueNode = this.startNode();
        node2.static = isStatic;
        node2.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node2, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node2 = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead2 = this.lookahead();
            if (lookahead2.type !== 14 && lookahead2.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead2 = this.lookahead();
            if (lookahead2.type !== 14 && lookahead2.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead2 = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead2.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
              at: inexactStartLoc
            });
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, {
                at: this.state.lastTokStartLoc
              });
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, {
                at: this.state.lastTokStartLoc
              });
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, {
                at: variance
              });
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, {
              at: this.state.lastTokStartLoc
            });
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, {
              at: variance
            });
          }
          node2.argument = this.flowParseType();
          return this.finishNode(node2, "ObjectTypeSpreadProperty");
        } else {
          node2.key = this.flowParseObjectPropertyKey();
          node2.static = isStatic;
          node2.proto = protoStartLoc != null;
          node2.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node2.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node2);
            }
            if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: node2.value.this
              });
            }
          } else {
            if (kind !== "init")
              this.unexpected();
            node2.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node2.value = this.flowParseTypeInitialiser();
            node2.variance = variance;
          }
          node2.optional = optional;
          return this.finishNode(node2, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
            at: property.value.this
          });
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: property
          });
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, {
            at: property
          });
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node2 = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node22 = this.startNodeAt(startLoc);
          node22.qualification = node2;
          node22.id = this.flowParseRestrictedIdentifier(true);
          node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
        }
        return node2;
      }
      flowParseGenericType(startLoc, id) {
        const node2 = this.startNodeAt(startLoc);
        node2.typeParameters = null;
        node2.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node2, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node2 = this.startNode();
        this.expect(87);
        node2.argument = this.flowParsePrimaryType();
        return this.finishNode(node2, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node2 = this.startNode();
        node2.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node2.types.push(this.flowParseType());
          if (this.match(3))
            break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node2, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name2 = null;
        let optional = false;
        let typeAnnotation = null;
        const node2 = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              at: node2
            });
          }
          name2 = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: node2
              });
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node2.name = name2;
        node2.optional = optional;
        node2.typeAnnotation = typeAnnotation;
        return this.finishNode(node2, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node2 = this.startNodeAt(type.loc.start);
        node2.name = null;
        node2.optional = false;
        node2.typeAnnotation = type;
        return this.finishNode(node2, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node2, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node2, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node2, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node2, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node2, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node2, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node2, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node2, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node2 = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47:
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          case 10:
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          case 133:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node2.value = this.match(85);
            this.next();
            return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(134)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
              }
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                at: this.state.startLoc
              });
            }
            this.unexpected();
            return;
          case 134:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 135:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node2, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node2, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node2, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node2, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node2, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node2, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node2.elementType = type;
            this.next();
            type = this.finishNode(node2, "ArrayTypeAnnotation");
          } else {
            node2.objectType = type;
            node2.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node2.optional = optional;
              type = this.finishNode(node2, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node2, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node2 = this.startNode();
        if (this.eat(17)) {
          node2.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node2, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node2 = this.startNodeAt(param.loc.start);
          node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node2.rest = null;
          node2.this = null;
          node2.returnType = this.flowParseType();
          node2.typeParameters = null;
          return this.finishNode(node2, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node2 = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node2.types = [type];
        while (this.eat(45)) {
          node2.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node2.types.length === 1 ? type : this.finishNode(node2, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node2 = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node2.types = [type];
        while (this.eat(43)) {
          node2.types.push(this.flowParseIntersectionType());
        }
        return node2.types.length === 1 ? type : this.finishNode(node2, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node2 = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node2);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node2 = this.startNode();
        node2.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node2, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node2) {
        node2.expression.typeAnnotation = node2.typeAnnotation;
        this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
        return node2.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node2, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
          return;
        }
        super.parseFunctionBody(node2, false, isMethod);
      }
      parseFunctionBodyAndFinish(node2, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node2, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead2 = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead2.type)) {
            const node2 = this.startNode();
            this.next();
            return this.flowParseInterface(node2);
          }
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          const node2 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node2);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node2, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node2);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node2);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node2);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node2, false);
            }
          }
        }
        return super.parseExpressionStatement(node2, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(126)) {
          const node2 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node2);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17))
          return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node2 = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid2, invalid2] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid2.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid2.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid2.length; i++) {
              noArrowAt.push(invalid2[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid2, invalid2] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid2.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, {
              at: state.startLoc
            });
          }
          if (failed && valid2.length === 1) {
            this.state = state;
            noArrowAt.push(valid2[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node2.test = expr;
        node2.consequent = consequent;
        node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node2, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node2, disallowInvalid) {
        const stack = [node2];
        const arrows = [];
        while (stack.length !== 0) {
          const node3 = stack.pop();
          if (node3.type === "ArrowFunctionExpression") {
            if (node3.typeParameters || !node3.returnType) {
              this.finishArrowValidation(node3);
            } else {
              arrows.push(node3);
            }
            stack.push(node3.body);
          } else if (node3.type === "ConditionalExpression") {
            stack.push(node3.consequent);
            stack.push(node3.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node3) => this.finishArrowValidation(node3));
          return [arrows, []];
        }
        return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node2) {
        var _node$extra;
        this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node2, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node2, parse5) {
        let result;
        if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse5();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse5();
        }
        return result;
      }
      parseParenItem(node2, startLoc) {
        node2 = super.parseParenItem(node2, startLoc);
        if (this.eat(17)) {
          node2.optional = true;
          this.resetEndLocation(node2);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node2;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node2;
      }
      assertModuleNodeAllowed(node2) {
        if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node2);
      }
      parseExportDeclaration(node2) {
        if (this.isContextual(130)) {
          node2.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node2.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node2);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node2.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node2.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          node2.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node2);
        }
      }
      eatExportStar(node2) {
        if (super.eatExportStar(node2))
          return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node2.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node2) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
        if (hasNamespace && node2.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node2, isStatement, optionalId) {
        super.parseClassId(node2, isStatement, optionalId);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, {
              at: startLoc
            });
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, {
              at: member.value
            });
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, {
            at: this.state.curPosition(),
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code3 === 62 || code3 === 60)) {
          this.finishOp(code3 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code3 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code3, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code3);
        }
      }
      isAssignable(node2, isBinding) {
        if (node2.type === "TypeCastExpression") {
          return this.isAssignable(node2.expression, isBinding);
        } else {
          return super.isAssignable(node2, isBinding);
        }
      }
      toAssignable(node2, isLHS = false) {
        if (!isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression") {
          node2.left = this.typeCastToParameter(node2.left);
        }
        super.toAssignable(node2, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, {
              at: expr.typeAnnotation
            });
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node2.elements);
        }
        return node2;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node2) {
        if (this.match(14)) {
          node2.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node2);
      }
      parseClassPrivateProperty(node2) {
        if (this.match(14)) {
          node2.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node2);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: method
            });
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: method
            });
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node2) {
        super.parseClassSuper(node2);
        if (node2.superClass && this.match(47)) {
          node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node2.implements = [];
          do {
            const node3 = this.startNode();
            node3.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node3.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node3.typeParameters = null;
            }
            implemented.push(this.finishNode(node3, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, {
              at: param
            });
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, {
              at: param
            });
          }
        }
      }
      parsePropertyNamePrefixOperator(node2) {
        node2.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10))
            this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, {
              at: param
            });
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: param
            });
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, {
            at: param
          });
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, {
            at: param
          });
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node2 = super.parseMaybeDefault(startLoc, left);
        if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, {
            at: node2.typeAnnotation
          });
        }
        return node2;
      }
      checkImportReflection(node2) {
        super.checkImportReflection(node2);
        if (node2.module && node2.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, {
            at: node2.specifiers[0].loc.start
          });
        }
      }
      parseImportSpecifierLocal(node2, specifier, type) {
        specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node2.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
          return true;
        if (this.isContextual(130)) {
          if (!isExport)
            return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node2, isExport, phase, loc) {
        super.applyImportPhase(node2, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node2.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55))
            this.unexpected();
          node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
            at: specifier
          });
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node2, isConstructor) {
        const kind = node2.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node2, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node2, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node2.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node2, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx3;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx3.error)
            return jsx3.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx3) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
              abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression")
              abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                  at: typeParameters
                });
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx3) != null && _jsx2.node) {
            this.state = jsx3.failState;
            return jsx3.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx3) != null && _jsx3.thrown)
            throw jsx3.error;
          if (arrow.thrown)
            throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
            at: typeParameters
          });
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node2) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(19))
              this.unexpected();
            return typeNode;
          });
          if (result.thrown)
            return null;
          if (result.error)
            this.state = result.failState;
          node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node2);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node2, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
          node2.params = params;
        } else {
          super.setArrowFunctionParameters(node2, params);
        }
      }
      checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
          return;
        }
        for (let i = 0; i < node2.params.length; i++) {
          if (this.isThisParam(node2.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              at: node2.params[i]
            });
          }
        }
        super.checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
          this.next();
          const node2 = this.startNodeAt(startLoc);
          node2.callee = base;
          node2.arguments = super.parseCallExpressionArguments(11, false);
          base = this.finishNode(node2, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted)
            return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error)
            return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node2 = this.startNodeAt(startLoc);
          node2.callee = base;
          node2.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(10);
          node2.arguments = this.parseCallExpressionArguments(11, false);
          node2.optional = true;
          return this.finishCallExpression(node2, true);
        } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
          const node2 = this.startNodeAt(startLoc);
          node2.callee = base;
          const result = this.tryParse(() => {
            node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node2.arguments = super.parseCallExpressionArguments(11, false);
            if (subscriptState.optionalChainMember) {
              node2.optional = false;
            }
            return this.finishCallExpression(node2, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node2) {
        super.parseNewCallee(node2);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node2.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node2 = this.startNodeAt(startLoc);
        this.parseFunctionParams(node2, false);
        if (!this.parseArrow(node2))
          return;
        return super.parseArrowExpression(node2, void 0, true);
      }
      readToken_mult_modulo(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code3);
      }
      readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code3 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code3);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, {
            at: this.state.curPosition()
          });
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, {
              at: this.state.startLoc
            });
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
          at: loc,
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
          at: loc
        }, enumContext));
      }
      flowEnumErrorNumberMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
          at: loc,
          enumName,
          memberName
        });
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node2, {
        enumName
      }) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
          at: node2,
          enumName
        });
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 134: {
            const literal2 = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 133: {
            const literal2 = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal2 = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, {
              at: id,
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, {
              at: id,
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102))
          return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
            at: this.state.startLoc,
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, {
            at: this.state.startLoc,
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node2, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node2.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node2.explicitType = true;
            node2.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumBooleanBody");
          case "number":
            node2.explicitType = true;
            node2.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumNumberBody");
          case "string":
            node2.explicitType = true;
            node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node2, "EnumStringBody");
          case "symbol":
            node2.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumSymbolBody");
          default: {
            const empty5 = () => {
              node2.members = [];
              this.expect(8);
              return this.finishNode(node2, "EnumStringBody");
            };
            node2.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty5();
            } else if (!boolsLen && !numsLen) {
              node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node2, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node2.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node2, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node2.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node2, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, {
                at: nameLoc,
                enumName
              });
              return empty5();
            }
          }
        }
      }
      flowParseEnumDeclaration(node2) {
        const id = this.parseIdentifier();
        node2.id = id;
        node2.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node2, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node2) {
        return node2.type === "TypeCastExpression" ? node2.expression : node2;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx2 = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(142);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(141, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine2(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine2(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(133, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start2 = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar2(ch) || ch === 45);
        this.finishToken(140, this.input.slice(start2, this.state.pos));
      }
      jsxParseIdentifier() {
        const node2 = this.startNode();
        if (this.match(140)) {
          node2.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node2.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node2, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name2 = this.jsxParseIdentifier();
        if (!this.eat(14))
          return name2;
        const node2 = this.startNodeAt(startLoc);
        node2.namespace = name2;
        node2.name = this.jsxParseIdentifier();
        return this.finishNode(node2, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node2 = this.jsxParseNamespacedName();
        if (node2.type === "JSXNamespacedName") {
          return node2;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node2;
          newNode.property = this.jsxParseIdentifier();
          node2 = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node2;
      }
      jsxParseAttributeValue() {
        let node2;
        switch (this.state.type) {
          case 5:
            node2 = this.startNode();
            this.setContext(types2.brace);
            this.next();
            node2 = this.jsxParseExpressionContainer(node2, types2.j_oTag);
            if (node2.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, {
                at: node2
              });
            }
            return node2;
          case 142:
          case 133:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, {
              at: this.state.startLoc
            });
        }
      }
      jsxParseEmptyExpression() {
        const node2 = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node2) {
        this.next();
        node2.expression = this.parseExpression();
        this.setContext(types2.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node2, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node2, previousContext) {
        if (this.match(8)) {
          node2.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node2.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node2, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node2 = this.startNode();
        if (this.match(5)) {
          this.setContext(types2.brace);
          this.next();
          this.expect(21);
          node2.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types2.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node2, "JSXSpreadAttribute");
        }
        node2.name = this.jsxParseNamespacedName();
        node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node2, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node2 = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node2, "JSXOpeningFragment");
        }
        node2.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node2);
      }
      jsxParseOpeningElementAfterName(node2) {
        const attributes = [];
        while (!this.match(56) && !this.match(143)) {
          attributes.push(this.jsxParseAttribute());
        }
        node2.attributes = attributes;
        node2.selfClosing = this.eat(56);
        this.expect(143);
        return this.finishNode(node2, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node2 = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node2, "JSXClosingFragment");
        }
        node2.name = this.jsxParseElementName();
        this.expect(143);
        return this.finishNode(node2, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node2 = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.state.type) {
                case 142:
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startLoc);
                    break contents;
                  }
                  children.push(this.jsxParseElementAt(startLoc));
                  break;
                case 141:
                  children.push(this.parseExprAtom());
                  break;
                case 5: {
                  const node3 = this.startNode();
                  this.setContext(types2.brace);
                  this.next();
                  if (this.match(21)) {
                    children.push(this.jsxParseSpreadChild(node3));
                  } else {
                    children.push(this.jsxParseExpressionContainer(node3, types2.j_expr));
                  }
                  break;
                }
                default:
                  this.unexpected();
              }
            }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, {
              at: closingElement
            });
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, {
              at: closingElement,
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node2.openingFragment = openingElement;
          node2.closingFragment = closingElement;
        } else {
          node2.openingElement = openingElement;
          node2.closingElement = closingElement;
        }
        node2.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
            at: this.state.startLoc
          });
        }
        return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(141)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(142)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(142);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace)
          super.skipSpace();
      }
      getTokenFromCode(code3) {
        const context = this.curContext();
        if (context === types2.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types2.j_oTag || context === types2.j_cTag) {
          if (isIdentifierStart2(code3)) {
            this.jsxReadWord();
            return;
          }
          if (code3 === 62) {
            ++this.state.pos;
            this.finishToken(143);
            return;
          }
          if ((code3 === 34 || code3 === 39) && context === types2.j_oTag) {
            this.jsxReadString(code3);
            return;
          }
        }
        if (code3 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(142);
          return;
        }
        super.getTokenFromCode(code3);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 142) {
          context.splice(-2, 2, types2.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 142) {
          context.push(types2.j_oTag);
        } else if (type === 143) {
          const out = context[context.length - 1];
          if (out === types2.j_oTag && prevType === 56 || out === types2.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr;
          } else {
            this.setContext(types2.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope4 {
      constructor(...args) {
        super(...args);
        this.types = /* @__PURE__ */ new Set();
        this.enums = /* @__PURE__ */ new Set();
        this.constEnums = /* @__PURE__ */ new Set();
        this.classes = /* @__PURE__ */ new Set();
        this.exportOnlyBindings = /* @__PURE__ */ new Set();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags == 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags == 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name2, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name2)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name2))
              return true;
          }
        }
        return false;
      }
      declareName(name2, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name2, true)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name2
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name2);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name2);
          scope.exportOnlyBindings.add(name2);
          return;
        }
        super.declareName(name2, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name2, bindingType, loc);
            this.maybeExportDefined(scope, name2);
          }
          scope.types.add(name2);
        }
        if (bindingType & 256)
          scope.enums.add(name2);
        if (bindingType & 512) {
          scope.constEnums.add(name2);
        }
        if (bindingType & 128)
          scope.classes.add(name2);
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        if (scope.enums.has(name2)) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = scope.constEnums.has(name2);
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && scope.classes.has(name2)) {
          if (scope.lexical.has(name2)) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && scope.types.has(name2)) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name2, bindingType);
      }
      checkLocalExport(id) {
        const {
          name: name2
        } = id;
        if (this.hasImport(name2))
          return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          if (scope.types.has(name2) || scope.exportOnlyBindings.has(name2))
            return;
        }
        super.checkLocalExport(id);
      }
    };
    var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    var unwrapParenthesizedExpression = (node2) => {
      return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node2, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node2);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                at: node2
              });
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node2
              });
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, {
              at: node2
            });
          }
        }
        switch (node2.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            for (let i = 0, length = node2.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node2.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: node2.extra.trailingCommaLoc
                });
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node2;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, {
                at: node2.left.loc.end
              });
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
            at: prop.key
          });
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, {
              at: prop
            });
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt)
            continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, {
                at: elt
              });
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, {
                at: trailingCommaLoc
              });
            }
          }
        }
      }
      isAssignable(node2, isBinding) {
        switch (node2.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node2.properties.length - 1;
            return node2.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node2.value);
          case "SpreadElement":
            return this.isAssignable(node2.argument);
          case "ArrayExpression":
            return node2.elements.every((element2) => element2 === null || this.isAssignable(element2));
          case "AssignmentExpression":
            return node2.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node2.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node2, "SpreadElement");
      }
      parseRestBinding() {
        const node2 = this.startNode();
        this.next();
        node2.argument = this.parseBindingAtom();
        return this.finishNode(node2, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node2, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const prop = this.startNode();
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(prop);
        } else if (type === 138) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param, flags) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29))
          return left;
        const node2 = this.startNodeAt(startLoc);
        node2.left = left;
        node2.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node2, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn$1({
          AssignmentPattern: "left",
          RestElement: "argument",
          ObjectProperty: "value",
          ParenthesizedExpression: "expression",
          ArrayPattern: "elements",
          ObjectPattern: "properties"
        }, type);
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, {
        in: ancestor,
        binding = 64,
        checkClashes = false,
        strictModeChanged = false,
        hasParenthesizedAncestor = false
      }) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression))
          return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, {
                at: expression,
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, {
              at: expression
            });
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name: name2
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name2)) {
              this.raise(Errors.ParamDupe, {
                at: expression
              });
            } else {
              checkClashes.add(name2);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true)
          return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, {
            at: expression,
            ancestor
          });
          return;
        }
        const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        for (const child of [].concat(expression[key])) {
          if (child) {
            this.checkLVal(child, {
              in: nextAncestor,
              binding,
              checkClashes,
              strictModeChanged,
              hasParenthesizedAncestor: isParenthesizedExpression
            });
          }
        }
      }
      checkIdentifier(at2, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, {
              at: at2,
              referenceName: at2.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, {
              at: at2,
              bindingName: at2.name
            });
          }
        }
        if (bindingType & 8192 && at2.name === "let") {
          this.raise(Errors.LetInLexicalBinding, {
            at: at2
          });
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at2, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node2, allowPattern) {
        switch (node2.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node2.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern)
              break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, {
              at: node2
            });
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
          at: this.state.startLoc
        });
        return true;
      }
    };
    var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.indexOf(modifier) !== -1) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, {
              at: loc,
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, {
              at: loc,
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier)
            break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, {
                at: startLoc,
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, {
                at: startLoc,
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, {
                at: startLoc,
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, {
              at: startLoc,
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element2 = parseElement();
          if (element2 == null) {
            return void 0;
          }
          result.push(element2);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node2 = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(133)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, {
            at: this.state.startLoc
          });
        }
        node2.argument = super.parseExprAtom();
        this.expect(11);
        if (this.eat(16)) {
          node2.qualifier = this.tsParseEntityName();
        }
        if (this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node2, "TSImportType");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdentifier(allowReservedWords);
        while (this.eat(16)) {
          const node2 = this.startNodeAtNode(entity);
          node2.left = entity;
          node2.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node2, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node2 = this.startNode();
        node2.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node2, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node2 = this.startNodeAtNode(lhs);
        node2.parameterName = lhs;
        node2.typeAnnotation = this.tsParseTypeAnnotation(false);
        node2.asserts = false;
        return this.finishNode(node2, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "TSThisType");
      }
      tsParseTypeQuery() {
        const node2 = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node2.exprName = this.tsParseImportType();
        } else {
          node2.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node2, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node2 = this.startNode();
        parseModifiers(node2);
        node2.name = this.tsParseTypeParameterName();
        node2.constraint = this.tsEatThenParseType(81);
        node2.default = this.tsEatThenParseType(29);
        return this.finishNode(node2, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node2 = this.startNode();
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node2.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, {
            at: node2
          });
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node2, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node2, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list3 = super.parseBindingList(11, 41, 2);
        for (const pattern of list3) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, {
              at: pattern,
              type
            });
          }
        }
        return list3;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node2) {
        this.tsFillSignature(14, node2);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node2, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node2) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node2.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node2.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node2, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node2, readonly) {
        if (this.eat(17))
          node2.optional = true;
        const nodeAny = node2;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, {
              at: node2
            });
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
              at: this.state.curPosition()
            });
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, {
                at: this.state.curPosition()
              });
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, {
                at: this.state.curPosition()
              });
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                  at: this.state.curPosition()
                });
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                at: method[returnTypeKey]
              });
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly)
            property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node2 = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
          } else {
            node2.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node2, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node2);
        const idx = this.tsTryParseIndexSignature(node2);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node2);
        if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node2.kind = node2.key.name;
          super.parsePropertyName(node2);
        }
        return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
      }
      tsParseTypeLiteral() {
        const node2 = this.startNode();
        node2.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node2, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedTypeParameter() {
        const node2 = this.startNode();
        node2.name = this.tsParseTypeParameterName();
        node2.constraint = this.tsExpectThenParseType(58);
        return this.finishNode(node2, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node2 = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node2.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node2.readonly = true;
        }
        this.expect(0);
        node2.typeParameter = this.tsParseMappedTypeParameter();
        node2.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node2.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node2.optional = true;
        }
        node2.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node2, "TSMappedType");
      }
      tsParseTupleType() {
        const node2 = this.startNode();
        node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node2.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, {
              at: elementNode
            });
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node2, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          startLoc
        } = this.state;
        const rest = this.eat(21);
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const startLoc2 = this.state.startLoc;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAtNode(label);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, {
                at: this.state.lastTokStartLoc
              });
            }
          } else {
            labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, {
              at: type
            });
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node2 = this.startNode();
        this.expect(10);
        node2.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node2, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node2 = this.startNode();
        if (type === "TSConstructorType") {
          node2.abstract = !!abstract;
          if (abstract)
            this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2));
        return this.finishNode(node2, type);
      }
      tsParseLiteralTypeNode() {
        const node2 = this.startNode();
        switch (this.state.type) {
          case 134:
          case 135:
          case 133:
          case 85:
          case 86:
            node2.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node2, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node2 = this.startNode();
        node2.literal = super.parseTemplate(false);
        return this.finishNode(node2, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType)
          return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 133:
          case 134:
          case 135:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node2 = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 134 && nextToken.type !== 135) {
                this.unexpected();
              }
              node2.literal = this.parseMaybeUnary();
              return this.finishNode(node2, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node2 = this.startNode();
                this.next();
                return this.finishNode(node2, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node2 = this.startNodeAtNode(type);
            node2.elementType = type;
            this.expect(3);
            type = this.finishNode(node2, "TSArrayType");
          } else {
            const node2 = this.startNodeAtNode(type);
            node2.objectType = type;
            node2.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node2, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node2 = this.startNode();
        const operator = this.state.value;
        this.next();
        node2.operator = operator;
        node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node2);
        }
        return this.finishNode(node2, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node2) {
        switch (node2.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, {
              at: node2
            });
        }
      }
      tsParseInferType() {
        const node2 = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node2, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node2 = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types3 = [];
        do {
          types3.push(parseConstituentType());
        } while (this.eat(operator));
        if (types3.length === 1 && !hasLeadingOperator) {
          return types3[0];
        }
        node2.types = types3;
        return this.finishNode(node2, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t2 = this.startNode();
          this.expect(returnToken);
          const node2 = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node2.parameterName = thisTypePredicate;
              node2.asserts = true;
              node2.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node2);
              thisTypePredicate.asserts = true;
            }
            t2.typeAnnotation = thisTypePredicate;
            return this.finishNode(t2, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t2);
            }
            node2.parameterName = this.parseIdentifier();
            node2.asserts = asserts;
            node2.typeAnnotation = null;
            t2.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
            return this.finishNode(t2, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node2.parameterName = typePredicateVariable;
          node2.typeAnnotation = type;
          node2.asserts = asserts;
          t2.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
          return this.finishNode(t2, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.lastTokStartLoc,
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
        this.tsInType(() => {
          if (eatColon)
            this.expect(14);
          t2.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t2, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node2 = this.startNodeAtNode(type);
        node2.checkType = type;
        node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node2, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, {
            at: this.state.startLoc
          });
        }
        const node2 = this.startNode();
        node2.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node2.expression = this.parseMaybeUnary();
        return this.finishNode(node2, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node2 = this.startNode();
          node2.expression = this.tsParseEntityName();
          if (this.match(47)) {
            node2.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node2, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, {
            at: originalStartLoc,
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node2, properties = {}) {
        if (this.hasFollowingLineBreak())
          return null;
        this.expectContextual(129);
        if (properties.declare)
          node2.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node2.id = this.parseIdentifier();
          this.checkIdentifier(node2.id, 130);
        } else {
          node2.id = null;
          this.raise(TSErrors.MissingInterfaceName, {
            at: this.state.startLoc
          });
        }
        node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node2.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node2.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node2, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node2) {
        node2.id = this.parseIdentifier();
        this.checkIdentifier(node2.id, 2);
        node2.typeAnnotation = this.tsInType(() => {
          node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node3 = this.startNode();
            this.next();
            return this.finishNode(node3, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node2, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node2 = this.startNode();
        node2.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node2.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node2, "TSEnumMember");
      }
      tsParseEnumDeclaration(node2, properties = {}) {
        if (properties.const)
          node2.const = true;
        if (properties.declare)
          node2.declare = true;
        this.expectContextual(126);
        node2.id = this.parseIdentifier();
        this.checkIdentifier(node2.id, node2.const ? 8971 : 8459);
        this.expect(5);
        node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node2, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node2 = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node2.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node2, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
        node2.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node2.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node2.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node2.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node2, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node2) {
        if (this.isContextual(112)) {
          node2.global = true;
          node2.id = this.parseIdentifier();
        } else if (this.match(133)) {
          node2.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node2.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node2, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, isExport) {
        node2.isExport = isExport || false;
        node2.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node2.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, {
            at: moduleReference
          });
        }
        node2.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node2, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node2 = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(133)) {
          this.unexpected();
        }
        node2.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node2, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node)
          return;
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result)
                return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node2, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node2);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node2;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node2, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node2, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node2, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(133)) {
                return this.tsParseAmbientExternalModuleDeclaration(node2);
              } else if (tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node2);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node2);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node2);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak())
            return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47))
          return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node2 = this.startNodeAt(startLoc);
          node2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node2);
          node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node2;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res)
          return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47)
          return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node2 = this.startNode();
        node2.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node2.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, {
            at: node2
          });
        } else if (!this.state.inType && this.curContext() === types2.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node2, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
          return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, {
            at: startLoc
          });
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp2 = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp2.decorators = decorators;
          }
          if (accessibility)
            pp2.accessibility = accessibility;
          if (readonly)
            pp2.readonly = readonly;
          if (override)
            pp2.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, {
              at: pp2
            });
          }
          pp2.parameter = elt;
          return this.finishNode(pp2, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node2) {
        return node2.type === "TSParameterProperty" && super.isSimpleParameter(node2.parameter) || super.isSimpleParameter(node2);
      }
      tsDisallowOptionalPattern(node2) {
        for (const param of node2.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, {
              at: param
            });
          }
        }
      }
      setArrowFunctionParameters(node2, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node2, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node2);
      }
      parseFunctionBodyAndFinish(node2, type, isMethod = false) {
        if (this.match(14)) {
          node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node2, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, {
            at: node2
          });
          if (node2.declare) {
            return super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node2);
        return super.parseFunctionBodyAndFinish(node2, type, isMethod);
      }
      registerFunctionStatementId(node2) {
        if (!node2.body && node2.id) {
          this.checkIdentifier(node2.id, 1024);
        } else {
          super.registerFunctionStatementId(node2);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node2) => {
          if ((node2 == null ? void 0 : node2.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, {
              at: node2.typeAnnotation
            });
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node2.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node2.elements);
        }
        return node2;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments)
              return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node3 = this.startNodeAt(startLoc);
              node3.callee = base;
              node3.arguments = this.parseCallExpressionArguments(11, false);
              this.tsCheckForInvalidTypeCasts(node3.arguments);
              node3.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node3.optional = isOptionalCall;
              }
              return this.finishCallExpression(node3, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node2 = this.startNodeAt(startLoc);
            node2.expression = base;
            node2.typeParameters = typeArguments;
            return this.finishNode(node2, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                at: this.state.startLoc
              });
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node2) {
        var _callee$extra;
        super.parseNewCallee(node2);
        const {
          callee
        } = node2;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          node2.typeParameters = callee.typeParameters;
          node2.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node2 = this.startNodeAt(leftStartLoc);
          node2.expression = left;
          node2.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, {
                  at: this.state.startLoc,
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node2, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node2, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node2) {
        super.checkImportReflection(node2);
        if (node2.module && node2.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, {
            at: node2.specifiers[0].loc.start
          });
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
          return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node2, isExport, phase, loc) {
        super.applyImportPhase(node2, isExport, phase, loc);
        if (isExport) {
          node2.exportKind = phase === "type" ? "type" : "value";
        } else {
          node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node2) {
        if (this.match(133)) {
          node2.importKind = "value";
          return super.parseImport(node2);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node2.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node2);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node2);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
            at: importNode
          });
        }
        return importNode;
      }
      parseExport(node2, decorators) {
        if (this.match(83)) {
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
          } else {
            node2.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, true);
        } else if (this.eat(29)) {
          const assign = node2;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node2;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node2, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node2, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext)
          return declaration;
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init)
            continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
              at: init
            });
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
              at: init
            });
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node2 = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node2, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                at: this.state.curPosition()
              });
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, {
              at: member
            });
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, {
              at: member,
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, {
              at: member
            });
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, {
              at: member
            });
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
            at: member
          });
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, {
              at: member
            });
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional)
          methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, {
            at: methodOrProp
          });
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, {
            at: methodOrProp
          });
        }
      }
      parseExpressionStatement(node2, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node2, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
          return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      parseParenItem(node2, startLoc) {
        node2 = super.parseParenItem(node2, startLoc);
        if (this.eat(17)) {
          node2.optional = true;
          this.resetEndLocation(node2);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node2;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node2;
      }
      parseExportDeclaration(node2) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node2));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
            at: this.state.startLoc
          });
        }
        const isIdentifier2 = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier2 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node2);
        if (!declaration)
          return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node2.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node2, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node2, isStatement, optionalId, node2.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters)
          node2.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node2) {
        if (!node2.optional) {
          if (this.eat(35)) {
            node2.definite = true;
          } else if (this.eat(17)) {
            node2.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node2.typeAnnotation = type;
      }
      parseClassProperty(node2) {
        this.parseClassPropertyAnnotation(node2);
        if (this.state.isAmbientContext && !(node2.readonly && !node2.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, {
            at: this.state.startLoc
          });
        }
        if (node2.abstract && this.match(29)) {
          const {
            key
          } = node2;
          this.raise(TSErrors.AbstractPropertyHasInitializer, {
            at: this.state.startLoc,
            propertyName: key.type === "Identifier" && !node2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
        return super.parseClassProperty(node2);
      }
      parseClassPrivateProperty(node2) {
        if (node2.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, {
            at: node2
          });
        }
        if (node2.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, {
            at: node2,
            modifier: node2.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node2);
        return super.parseClassPrivateProperty(node2);
      }
      parseClassAccessorProperty(node2) {
        this.parseClassPropertyAnnotation(node2);
        if (node2.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, {
            at: node2
          });
        }
        return super.parseClassAccessorProperty(node2);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, {
            at: typeParameters
          });
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, {
            at: method,
            kind
          });
        }
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node2, kind) {
        if (node2.type === "TSDeclareMethod")
          return;
        if (node2.type === "MethodDefinition" && !node2.value.body)
          return;
        super.declareClassPrivateMethodInScope(node2, kind);
      }
      parseClassSuper(node2) {
        super.parseClassSuper(node2);
        if (node2.superClass && (this.match(47) || this.match(51))) {
          node2.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(113)) {
          node2.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node2, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          node2.typeParameters = typeParameters;
        super.parseFunctionParams(node2, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node2, call) {
        if (this.match(14)) {
          node2.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node2, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx3;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx3.error)
            return jsx3.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx3) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state)
          state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx3) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error)
            return typeCast.node;
        }
        if ((_jsx2 = jsx3) != null && _jsx2.node) {
          this.state = jsx3.failState;
          return jsx3.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx3) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node2) {
        var _node$extra;
        if (node2.params.length === 1 && !node2.params[0].constraint && !((_node$extra = node2.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, {
            at: node2
          });
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node2) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19))
              abort();
            return returnType;
          });
          if (result.aborted)
            return;
          if (!result.thrown) {
            if (result.error)
              this.state = result.failState;
            node2.returnType = result.node;
          }
        }
        return super.parseArrow(node2);
      }
      parseAssignableListItemTypes(param, flags) {
        if (!(flags & 2))
          return param;
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node2, isBinding) {
        switch (node2.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node2.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node2, isBinding);
        }
      }
      toAssignable(node2, isLHS = false) {
        switch (node2.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node2, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                at: node2
              });
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                at: node2
              });
            }
            this.toAssignable(node2.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node2.left.type === "TSTypeCastExpression") {
              node2.left = this.typeCastToParameter(node2.left);
            }
          default:
            super.toAssignable(node2, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node2, isLHS) {
        switch (node2.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isLHS);
            break;
          default:
            super.toAssignable(node2, isLHS);
        }
      }
      checkToRestConversion(node2, allowPattern) {
        switch (node2.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node2.expression, false);
            break;
          default:
            super.checkToRestConversion(node2, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn({
          TSTypeCastExpression: true,
          TSParameterProperty: "parameter",
          TSNonNullExpression: "expression",
          TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
        }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node2 = super.parseMaybeDefault(startLoc, left);
        if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, {
            at: node2.typeAnnotation
          });
        }
        return node2;
      }
      getTokenFromCode(code3) {
        if (this.state.inType) {
          if (code3 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code3 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code3);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node2) {
        node2.expression.typeAnnotation = node2.typeAnnotation;
        this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
        return node2.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node2) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments)
            node2.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node2);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      }
      parseClass(node2, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node2.abstract;
        try {
          return super.parseClass(node2, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node2, decorators) {
        if (this.match(80)) {
          node2.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node2, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node2.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
              at: node2
            });
            return this.tsParseInterfaceDeclaration(node2);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, {
              at: method,
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport);
          return this.finishNode(node2, "ExportSpecifier");
        }
        node2.exportKind = "value";
        return super.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node2, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node2[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
            at: loc
          });
        }
        node2[leftOfAsKey] = leftOfAs;
        node2[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node2[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node2[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node2[rightOfAsKey]) {
          node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node2[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression")
        return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier")
        return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(144)) {
          const node2 = this.startNode();
          this.next();
          this.assertNoSpace();
          node2.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(144);
          return this.finishPlaceholder(node2, expectedNode);
        }
      }
      finishPlaceholder(node2, expectedNode) {
        const isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
        node2.expectedNode = expectedNode;
        return isFinished ? node2 : this.finishNode(node2, "Placeholder");
      }
      getTokenFromCode(code3) {
        if (code3 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(144, 2);
        } else {
          super.getTokenFromCode(code3);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node2, isLHS) {
        if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
          node2.expectedNode = "Pattern";
        } else {
          super.toAssignable(node2, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 144) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node2, isBreak) {
        if (node2.label && node2.label.type === "Placeholder")
          return;
        super.verifyBreakContinue(node2, isBreak);
      }
      parseExpressionStatement(node2, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node2, expr);
        }
        if (this.match(14)) {
          const stmt = node2;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        node2.name = expr.name;
        return this.finishPlaceholder(node2, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node2, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(144) || this.match(5)) {
            node2.id = placeholder;
          } else if (optionalId || !isStatement) {
            node2.id = null;
            node2.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node2, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
              at: this.state.startLoc
            });
          }
        } else {
          this.parseClassId(node2, isStatement, optionalId);
        }
        super.parseClassSuper(node2);
        node2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node2.superClass, oldStrict);
        return this.finishNode(node2, type);
      }
      parseExport(node2, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseExport(node2, decorators);
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node2.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
      }
      checkExport(node2) {
        const {
          specifiers
        } = node2;
        if (specifiers != null && specifiers.length) {
          node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
        }
        super.checkExport(node2);
        node2.specifiers = specifiers;
      }
      parseImport(node2) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseImport(node2);
        node2.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node2, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node2.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node2);
          if (!hasStarImport)
            this.parseNamedImportSpecifiers(node2);
        }
        this.expectContextual(98);
        node2.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.state.lastTokEndLoc.index) {
          this.raise(PlaceholderErrors.UnexpectedSpace, {
            at: this.state.lastTokEndLoc
          });
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node2 = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name2 = this.parseIdentifierName();
            const identifier = this.createIdentifier(node2, name2);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    function hasPlugin(plugins, expectedConfig) {
      const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
      const expectedKeys = Object.keys(expectedOptions);
      const expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some((p) => {
        if (typeof p === "string") {
          return expectedOptionsIsEmpty && p === expectedName;
        } else {
          const [pluginName, pluginOptions] = p;
          if (pluginName !== expectedName) {
            return false;
          }
          for (const key of expectedKeys) {
            if (pluginOptions[key] !== expectedOptions[key]) {
              return false;
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name2, option) {
      const plugin2 = plugins.find((plugin3) => {
        if (Array.isArray(plugin3)) {
          return plugin3[0] === name2;
        } else {
          return plugin3 === name2;
        }
      });
      if (plugin2 && Array.isArray(plugin2) && plugin2.length > 1) {
        return plugin2[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
          syntaxType: "hash"
        }]);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
            throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
        throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      }
      if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx: jsx2,
      flow: flow3,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions2 = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createImportExpressions: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
    function getOptions2(opts) {
      if (opts == null) {
        return Object.assign({}, defaultOptions2);
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      const options = {};
      for (const key of Object.keys(defaultOptions2)) {
        var _opts$key;
        options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions2[key];
      }
      return options;
    }
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name2 = key.type === "Identifier" ? key.name : key.value;
        if (name2 === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, {
              at: key
            });
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, {
                at: key
              });
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(139)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node2 = this.startNodeAt(startLoc);
          node2.expressions = [expr];
          while (this.eat(12)) {
            node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node2.expressions);
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(108)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node2 = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node2.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node2.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node2.left = left;
          }
          this.next();
          node2.right = this.parseMaybeAssign();
          this.checkLVal(left, {
            in: this.finishNode(node2, "AssignmentExpression")
          });
          return node2;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node2 = this.startNodeAt(startLoc);
          node2.test = expr;
          node2.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node2.alternate = this.parseMaybeAssign();
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, {
              at: left,
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node2 = this.startNodeAt(leftStartLoc);
            node2.left = left;
            node2.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                  at: this.state.startLoc
                });
              }
            }
            node2.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, {
                at: this.state.startLoc
              });
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(108)) {
                    throw this.raise(Errors.PipeBodyIsTighter, {
                      at: this.state.startLoc
                    });
                  }
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, {
            at: startLoc,
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, {
            at: startLoc
          });
        }
        return body;
      }
      checkExponentialAfterUnary(node2) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
            at: node2.argument
          });
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary)
            this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node2 = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node2.operator = this.state.value;
          node2.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node2.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node2.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, {
                at: node2
              });
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, {
                at: node2
              });
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node2);
            }
            return this.finishNode(node2, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node2, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr3 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr3 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
              at: startLoc
            });
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node2, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node2;
          this.checkLVal(updateExpressionNode.argument, {
            in: this.finishNode(updateExpressionNode, "UpdateExpression")
          });
          return node2;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false))
          return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node3 = this.startNodeAt(startLoc);
          node3.operator = this.state.value;
          node3.prefix = false;
          node3.argument = expr;
          this.next();
          this.checkLVal(expr, {
            in: expr = this.finishNode(node3, "UpdateExpression")
          });
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node2 = this.startNodeAt(startLoc);
        node2.object = base;
        node2.computed = computed;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(138)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, {
              at: startLoc
            });
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node2.property = this.parsePrivateName();
        } else {
          node2.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node2.optional = optional;
          return this.finishNode(node2, "OptionalMemberExpression");
        } else {
          return this.finishNode(node2, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node2 = this.startNodeAt(startLoc);
        node2.object = base;
        this.next();
        node2.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node2.optional = optional;
        }
        if (optional) {
          node2.arguments = this.parseCallExpressionArguments(11);
        } else {
          node2.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node2, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node2, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node2, isParenthesizedExpr) {
        this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node2 = this.startNodeAt(startLoc);
        node2.tag = base;
        node2.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, {
            at: startLoc
          });
        }
        return this.finishNode(node2, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      expectImportAttributesPlugin() {
        if (!this.hasPlugin("importAssertions")) {
          this.expectPlugin("importAttributes");
        }
      }
      finishCallExpression(node2, optional) {
        if (node2.callee.type === "Import") {
          if (node2.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectImportAttributesPlugin();
              }
            }
          }
          if (node2.arguments.length === 0 || node2.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, {
              at: node2,
              maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
            });
          } else {
            for (const arg of node2.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, {
                  at: arg
                });
              }
            }
          }
        }
        return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(Errors.ImportCallArgumentTrailingComma, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node2, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node2, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node2, call.callee.trailingComments);
        }
        return node2;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node2;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node2 = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node2);
            }
            if (this.match(10)) {
              if (this.options.createImportExpressions) {
                return this.parseImportCall(node2);
              } else {
                return this.finishNode(node2, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, {
                at: this.state.lastTokStartLoc
              });
              return this.finishNode(node2, "Import");
            }
          case 78:
            node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 134:
            return this.parseNumericLiteral(this.state.value);
          case 135:
            return this.parseBigIntLiteral(this.state.value);
          case 136:
            return this.parseDecimalLiteral(this.state.value);
          case 133:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node2 = this.startNode();
            this.next();
            node2.object = null;
            const callee = node2.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node2, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, {
                at: callee
              });
            }
          }
          case 138: {
            this.raise(Errors.PrivateInExpectedIn, {
              at: this.state.startLoc,
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node2 = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
              at: startLoc
            });
          }
          this.registerTopicReference();
          return this.finishNode(node2, nodeType);
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, {
            at: startLoc,
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, {
              at: startLoc
            });
        }
      }
      parseAsyncArrowUnaryFunction(node2) {
        this.prodParam.enter(functionFlags2(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, {
            at: this.state.curPosition()
          });
        }
        this.expect(19);
        return this.parseArrowExpression(node2, params, true);
      }
      parseDo(node2, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node2.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node2.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node2.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node2, "DoExpression");
      }
      parseSuper() {
        const node2 = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.SuperNotAllowed, {
            at: node2
          });
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.UnexpectedSuper, {
            at: node2
          });
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, {
            at: node2
          });
        }
        return this.finishNode(node2, "Super");
      }
      parsePrivateName() {
        const node2 = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name2 = this.state.value;
        this.next();
        node2.id = this.createIdentifier(id, name2);
        return this.finishNode(node2, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node2 = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node2, meta, "sent");
        }
        return this.parseFunction(node2);
      }
      parseMetaProperty(node2, meta, propertyName) {
        node2.meta = meta;
        const containsEsc = this.state.containsEsc;
        node2.property = this.parseIdentifier(true);
        if (node2.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, {
            at: node2.property,
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node2, "MetaProperty");
      }
      parseImportMetaProperty(node2) {
        const id = this.createIdentifier(this.startNodeAtNode(node2), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, {
              at: id
            });
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          if (!isSource)
            this.unexpected();
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!this.options.createImportExpressions) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
              at: this.state.startLoc,
              phase: this.state.value
            });
          }
          this.next();
          node2.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node2);
        }
        return this.parseMetaProperty(node2, id, "meta");
      }
      parseLiteralAtNode(value, type, node2) {
        this.addExtra(node2, "rawValue", value);
        this.addExtra(node2, "raw", this.input.slice(node2.start, this.state.end));
        node2.value = value;
        this.next();
        return this.finishNode(node2, type);
      }
      parseLiteral(value, type) {
        const node2 = this.startNode();
        return this.parseLiteralAtNode(value, type, node2);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node2 = this.parseLiteral(value.value, "RegExpLiteral");
        node2.pattern = value.pattern;
        node2.flags = value.flags;
        return node2;
      }
      parseBooleanLiteral(value) {
        const node2 = this.startNode();
        node2.value = value;
        this.next();
        return this.finishNode(node2, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc)
          this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc)
          this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node2) {
        if (this.eat(19)) {
          return node2;
        }
      }
      parseParenItem(node2, startLoc) {
        return node2;
      }
      parseNewOrNewTarget() {
        const node2 = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node2, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
            this.raise(Errors.UnexpectedNewTarget, {
              at: metaProp
            });
          }
          return metaProp;
        }
        return this.parseNew(node2);
      }
      parseNew(node2) {
        this.parseNewCallee(node2);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node2.arguments = args;
        } else {
          node2.arguments = [];
        }
        return this.finishNode(node2, "NewExpression");
      }
      parseNewCallee(node2) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node2.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, {
            at: callee
          });
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start: start2,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start2 + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, {
              at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
            });
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node2 = this.startNode();
        node2.expressions = [];
        let curElt = this.parseTemplateElement(isTagged);
        node2.quasis = [curElt];
        while (!curElt.tail) {
          node2.expressions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        return this.finishNode(node2, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node2 = this.startNode();
        node2.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node2);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, {
              at: prop
            });
          }
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
          node2.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node2, type);
      }
      addTrailingCommaExtraToNode(node2) {
        this.addExtra(node2, "trailingComma", this.state.lastTokStart);
        this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, {
              at: this.state.startLoc
            });
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length)
            this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, {
                at: this.state.curPosition(),
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: method
          });
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, {
            at: method
          });
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern)
            this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, {
                at: shorthandAssignLoc
              });
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node2 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node2)
          this.unexpected();
        return node2;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 134:
                key = this.parseNumericLiteral(value);
                break;
              case 133:
                key = this.parseStringLiteral(value);
                break;
              case 135:
                key = this.parseBigIntLiteral(value);
                break;
              case 136:
                key = this.parseDecimalLiteral(value);
                break;
              case 138: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, {
                    at: privateKeyLoc
                  });
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 138) {
            prop.computed = false;
          }
        }
        return prop.key;
      }
      initFunction(node2, isAsync) {
        node2.id = null;
        node2.generator = false;
        node2.async = isAsync;
      }
      parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node2, isAsync);
        node2.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags2(isAsync, node2.generator));
        this.parseFunctionParams(node2, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node2, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node2 = this.startNode();
        this.next();
        node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags2(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node2, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node2, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node2, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node2, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node2, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node2.params = params;
      }
      parseFunctionBodyAndFinish(node2, type, isMethod = false) {
        this.parseFunctionBody(node2, false, isMethod);
        return this.finishNode(node2, type);
      }
      parseFunctionBody(node2, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node2.body = this.parseMaybeAssign();
          this.checkParams(node2, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node2.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, {
                at: (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.loc.end : node2
              });
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node2.id) {
              this.checkIdentifier(node2.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node2) {
        return node2.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i]))
            return false;
        }
        return true;
      }
      checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node2.params) {
          this.checkLVal(param, {
            in: formalParameters,
            binding: 5,
            checkClashes,
            strictModeChanged
          });
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, {
              at: this.state.curPosition(),
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, {
              at: this.state.startLoc
            });
          }
          const node2 = this.startNode();
          this.next();
          elt = this.finishNode(node2, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node2 = this.startNode();
        const name2 = this.parseIdentifierName(liberal);
        return this.createIdentifier(node2, name2);
      }
      createIdentifier(node2, name2) {
        node2.name = name2;
        node2.loc.identifierName = name2;
        return this.finishNode(node2, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name2;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name2 = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name2, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name2;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, {
            at: startLoc,
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, {
            at: startLoc,
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, {
              at: startLoc
            });
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, {
              at: startLoc
            });
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
              at: startLoc
            });
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError({
            at: startLoc
          });
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, {
              at: startLoc
            });
            return;
          }
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait)
          return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startLoc) {
        const node2 = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
          at: node2
        });
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, {
            at: node2
          });
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node2.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node2, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak())
          return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node2 = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
          at: node2
        });
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 139:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating)
                break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node2.delegate = delegating;
        node2.argument = argument;
        return this.finishNode(node2, "YieldExpression");
      }
      parseImportCall(node2) {
        this.next();
        node2.source = this.parseMaybeAssignAllowIn();
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          node2.options = null;
        }
        if (this.eat(12)) {
          this.expectImportAttributesPlugin();
          if (!this.match(11)) {
            node2.options = this.parseMaybeAssignAllowIn();
            this.eat(12);
          }
        }
        this.expect(11);
        return this.finishNode(node2, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, {
              at: leftStartLoc
            });
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, {
            at: this.state.startLoc
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, {
            at: startLoc
          });
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node2 = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node2.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node2, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel2 = {
      kind: "loop"
    };
    var switchLabel2 = {
      kind: "switch"
    };
    var loneSurrogate2 = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator2 = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 138) {
              const {
                loc,
                start: start2,
                value,
                end
              } = token;
              const hashEndPos = start2 + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token3({
                type: getExportedToken(27),
                value: "#",
                start: start2,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token3({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start: start2,
                value,
                end
              } = token;
              const backquoteEnd = start2 + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start2) === 96) {
                startToken = new Token3({
                  type: getExportedToken(22),
                  value: "`",
                  start: start2,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token3({
                  type: getExportedToken(8),
                  value: "}",
                  start: start2,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token3({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token3({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token3({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.state.comments;
        if (this.options.tokens) {
          file.tokens = babel7CompatTokens(this.tokens, this.input);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 139, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [localName, at2] of Array.from(this.scope.undefinedExports)) {
            this.raise(Errors.ModuleExportUndefined, {
              at: at2,
              localName
            });
          }
        }
        let finishedProgram;
        if (end === 139) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node2 = this.startNode();
        node2.value = this.state.value;
        this.next();
        return this.finishNode(node2, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart2(ch)) {
          keywordRelationalOperator2.lastIndex = pos;
          if (keywordRelationalOperator2.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator2.lastIndex);
            if (!isIdentifierChar2(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifier() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const starttype = this.state.type;
        const node2 = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (starttype) {
          case 60:
            return this.parseBreakContinueStatement(node2, true);
          case 63:
            return this.parseBreakContinueStatement(node2, false);
          case 64:
            return this.parseDebuggerStatement(node2);
          case 90:
            return this.parseDoWhileStatement(node2);
          case 91:
            return this.parseForStatement(node2);
          case 68:
            if (this.lookaheadCharCode() === 46)
              break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
                at: this.state.startLoc
              });
            }
            return this.parseFunctionStatement(node2, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration)
              this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node2), true);
          case 69:
            return this.parseIfStatement(node2);
          case 70:
            return this.parseReturnStatement(node2);
          case 71:
            return this.parseSwitchStatement(node2);
          case 72:
            return this.parseThrowStatement(node2);
          case 73:
            return this.parseTryStatement(node2);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, {
                  at: node2
                });
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: node2
                });
              }
              this.next();
              return this.parseVarStatement(node2, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, {
                at: this.state.startLoc
              });
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, {
                at: this.state.startLoc
              });
            }
            return this.parseVarStatement(node2, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak())
                break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, {
                at: this.state.startLoc
              });
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node2, kind);
          }
          case 92:
            return this.parseWhileStatement(node2);
          case 76:
            return this.parseWithStatement(node2);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node2);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, {
                at: this.state.startLoc
              });
            }
            this.next();
            let result;
            if (starttype === 83) {
              result = this.parseImport(node2);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node2, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                  at: this.state.startLoc
                });
              }
              this.next();
              return this.parseFunctionStatement(node2, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node2, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node2, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node2) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, {
            at: node2
          });
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy"))
          return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          if (classNode.decorators && classNode.decorators.length > 0) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, {
                at: classNode.decorators[0]
              });
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode)
            this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, {
              at: this.state.startLoc
            });
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, {
            at: this.state.startLoc
          });
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node2 = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node2.expression = this.parseMaybeDecoratorArguments(expr);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node2.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                at: paramsStartLoc
              });
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node3 = this.startNodeAt(startLoc);
              node3.object = expr;
              if (this.match(138)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node3.property = this.parsePrivateName();
              } else {
                node3.property = this.parseIdentifier(true);
              }
              node3.computed = false;
              expr = this.finishNode(node3, "MemberExpression");
            }
            node2.expression = this.parseMaybeDecoratorArguments(expr);
          }
        } else {
          node2.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node2, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
          const node2 = this.startNodeAtNode(expr);
          node2.callee = expr;
          node2.arguments = this.parseCallExpressionArguments(11, false);
          this.toReferencedList(node2.arguments);
          return this.finishNode(node2, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node2, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node2.label = null;
        } else {
          node2.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node2, isBreak);
        return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node2, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node2.label == null || lab.name === node2.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop"))
              break;
            if (node2.label && isBreak)
              break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, {
            at: node2,
            type
          });
        }
      }
      parseDebuggerStatement(node2) {
        this.next();
        this.semicolon();
        return this.finishNode(node2, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node2) {
        this.next();
        this.state.labels.push(loopLabel2);
        node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node2.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node2, "DoWhileStatement");
      }
      parseForStatement(node2) {
        this.next();
        this.state.labels.push(loopLabel2);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) {
          awaitAt = this.state.lastTokStartLoc;
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, {
                  at: this.state.startLoc
                });
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, {
                at: init2
              });
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node2, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node2, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, {
              at: init
            });
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, {
              at: init
            });
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            in: {
              type
            }
          });
          return this.parseForIn(node2, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init);
      }
      parseFunctionStatement(node2, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node2, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node2) {
        this.next();
        node2.test = this.parseHeaderExpression();
        node2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node2, "IfStatement");
      }
      parseReturnStatement(node2) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(Errors.IllegalReturn, {
            at: this.state.startLoc
          });
        }
        this.next();
        if (this.isLineTerminator()) {
          node2.argument = null;
        } else {
          node2.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node2, "ReturnStatement");
      }
      parseSwitchStatement(node2) {
        this.next();
        node2.discriminant = this.parseHeaderExpression();
        const cases = node2.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel2);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur)
              this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, {
                  at: this.state.lastTokStartLoc
                });
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur)
          this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node2, "SwitchStatement");
      }
      parseThrowStatement(node2) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, {
            at: this.state.lastTokEndLoc
          });
        }
        node2.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node2, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          in: {
            type: "CatchClause"
          },
          binding: 9
        });
        return param;
      }
      parseTryStatement(node2) {
        this.next();
        node2.block = this.parseBlock();
        node2.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node2.handler = this.finishNode(clause, "CatchClause");
        }
        node2.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node2.handler && !node2.finalizer) {
          this.raise(Errors.NoCatchOrFinally, {
     